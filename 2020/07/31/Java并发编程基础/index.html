<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dslztx.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、线程基本含义1.1、Java线程与操作系统线程Java线程由Java语言模型提供并确保在不同操作系统环境上的语义一致性，JDK负责具体实现和屏蔽操作系统环境差异，比如在现代Linux操作系统中，Java线程会被映射到Linux原生线程。 1.2、线程对应的数据结构和属性进程和线程具有承载其数据的相应数据结构实体：  Linux进程如是，由Linux内核提供 Linux线程如是，由Linux内核">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程基础">
<meta property="og:url" content="https://dslztx.github.io/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="dslztx">
<meta property="og:description" content="一、线程基本含义1.1、Java线程与操作系统线程Java线程由Java语言模型提供并确保在不同操作系统环境上的语义一致性，JDK负责具体实现和屏蔽操作系统环境差异，比如在现代Linux操作系统中，Java线程会被映射到Linux原生线程。 1.2、线程对应的数据结构和属性进程和线程具有承载其数据的相应数据结构实体：  Linux进程如是，由Linux内核提供 Linux线程如是，由Linux内核">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.dslztx.top/imgs/20200731-0-0.svg">
<meta property="article:published_time" content="2020-07-31T09:48:33.000Z">
<meta property="article:modified_time" content="2024-10-23T15:15:49.611Z">
<meta property="article:author" content="dslztx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.dslztx.top/imgs/20200731-0-0.svg">

<link rel="canonical" href="https://dslztx.github.io/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发编程基础 | dslztx</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?49fef4ace861beab604aeacea5240e39";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dslztx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>专题</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dslztx.github.io/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/head.png">
      <meta itemprop="name" content="dslztx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dslztx">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-31 17:48:33" itemprop="dateCreated datePublished" datetime="2020-07-31T17:48:33+08:00">2020-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-23 23:15:49" itemprop="dateModified" datetime="2024-10-23T23:15:49+08:00">2024-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">专题于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AF%AD%E8%A8%80/Java/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/07/31/Java并发编程基础/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、线程基本含义"><a href="#一、线程基本含义" class="headerlink" title="一、线程基本含义"></a><strong>一、线程基本含义</strong></h2><h3 id="1-1、Java线程与操作系统线程"><a href="#1-1、Java线程与操作系统线程" class="headerlink" title="1.1、Java线程与操作系统线程"></a><strong>1.1、Java线程与操作系统线程</strong></h3><p>Java线程由Java语言模型提供并确保在不同操作系统环境上的语义一致性，JDK负责具体实现和屏蔽操作系统环境差异，比如在现代Linux操作系统中，Java线程会被映射到Linux原生线程。</p>
<h3 id="1-2、线程对应的数据结构和属性"><a href="#1-2、线程对应的数据结构和属性" class="headerlink" title="1.2、线程对应的数据结构和属性"></a><strong>1.2、线程对应的数据结构和属性</strong></h3><p>进程和线程具有承载其数据的相应数据结构实体：</p>
<ul>
<li>Linux进程如是，由Linux内核提供</li>
<li>Linux线程如是，由Linux内核提供</li>
<li>Java进程如是，由JDK提供，比如“对应Unix操作系统环境的类java.lang.UNIXProcess”</li>
<li>Java线程如是，由JDK提供，具体且唯一（即不同操作系统环境对应同一个类）的类java.lang.Thread</li>
</ul>
<p>接下来介绍Java线程常见的几个属性（在相应的java.lang.Thread实例对象中设置），具体有：线程组，线程优先级，是否为后台线程，线程名字和target。</p>
<h4 id="1-2-1、线程组"><a href="#1-2-1、线程组" class="headerlink" title="1.2.1、线程组"></a><strong>1.2.1、线程组</strong></h4><p>通过线程组同时管理一批线程，所有线程默认属于“默认线程组”。<br>在实际使用场景中，几乎不被使用。</p>
<h4 id="1-2-2、线程优先级"><a href="#1-2-2、线程优先级" class="headerlink" title="1.2.2、线程优先级"></a><strong>1.2.2、线程优先级</strong></h4><p>线程优先级越高，被分配到CPU时间片的概率越大。</p>
<p>线程可设置优先级，线程调度器倾向于优先调用优先级高的线程。但仅是“倾向于”，不可依赖。<br>在实际使用场景中，几乎不被使用。因为：</p>
<ul>
<li>对于Java线程的线程优先级，JDK不确保在不同操作系统环境的语义一致性，因此：1）线程优先级设定在有些操作系统中可能完全无效；2）在线程优先级设定有效的前提下，相同优先级设定，在A操作系统和B操作系统的展现行为可能不同</li>
<li>在线程调度中，线程优先级只是一个维度的因素，还有其他维度的因素，因此，只能说“线程优先级越高，被分配到CPU时间片的概率越大”，而不是必然的</li>
</ul>
<h4 id="1-2-3、是否为后台线程"><a href="#1-2-3、是否为后台线程" class="headerlink" title="1.2.3、是否为后台线程"></a><strong>1.2.3、是否为后台线程</strong></h4><p>基于“是否为后台线程”的角度，Java线程分为：后台线程和非后台线程。<br>关于两者的描述有以下几点：</p>
<ul>
<li>常见的是非后台线程；后台线程不是Java进程中不可或缺的线程，一般只用来提供通用服务，比如“Finalizer线程”</li>
<li>非后台线程创建的线程默认为非后台线程；后台线程创建的线程默认为后台线程。或者可以且必须在线程启动之前，通过方法<code>setDaemon(boolean on)</code>手动设置是否为后台线程</li>
<li>当Java进程中不存在非后台线程，进程立即退出（会杀死所有后台线程），效果等价于执行<code>System.exit(int status)</code>方法。这里有一个引申点：我们知道“try-catch-finally”语句结构中的“finally”语句一般都会执行完成，但是当由于执行<code>System.exit(int status)</code>方法立即退出Java进程时，“finally”语句并不保证会被执行，现在新增一种“finally”语句并不保证会被执行的情形，即“不存在非后台线程，Java进程立即退出”，当然此时不保证会被执行的“finally”语句必在后台线程中</li>
</ul>
<h4 id="1-2-4、线程名字"><a href="#1-2-4、线程名字" class="headerlink" title="1.2.4、线程名字"></a><strong>1.2.4、线程名字</strong></h4><p>线程具有默认名字，<font color='red'>但是为了后续排查时的可读性，建议取一个可读性好的名字</font>。</p>
<h4 id="1-2-5、target"><a href="#1-2-5、target" class="headerlink" title="1.2.5、target"></a><strong>1.2.5、target</strong></h4><p>调用Thread实例的<code>start()</code>方法，开启一个Java线程，最终会去执行该Thread实例的<code>run()</code>方法，其源代码如下，其中的<code>target</code>是一个Runnable实例对象，其<code>run()</code>方法包含具体的工作逻辑。</p>
<p>Thread类的<code>run()</code>方法源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、线程常见动作方法"><a href="#二、线程常见动作方法" class="headerlink" title="二、线程常见动作方法"></a><strong>二、线程常见动作方法</strong></h2><p>线程常见动作方法（<code>java.lang.Thread</code>类中方法）如下：</p>
<ul>
<li><code>suspend</code>方法：已废弃</li>
<li><code>resume</code>方法：已废弃</li>
<li><code>stop</code>方法：已废弃</li>
<li><code>yield</code>方法：执行<code>yield</code>方法，表明当前线程愿意放弃剩下的时间片，“建议”线程调度器可以调度运行其他的线程。但仅是“建议”，不可依赖</li>
<li><code>start</code>方法：构造完Thread实例后，调用其上的<code>start()</code>方法，线程状态从<code>NEW</code>转到<code>RUNNABLE</code>，详见“三、线程状态与转移”小节。需要注意的是，在线程A中创建线程B对应的“java.lang.Thread”类实例，然后调用其上的<code>start()</code>方法，它会立即返回，并不会阻塞线程A的运行，此后线程B和线程A处于平等的地位由线程调度器统一调度</li>
<li><code>join</code>方法：在线程A中调用执行线程B对应的Thread实例上的<code>join</code>方法，表示挂起线程A直到线程B执行完成转到<code>TERMINATED</code>状态，详见“三、线程状态与转移”小节</li>
<li><code>interrupt</code>方法：中断线程，详见“四、中断”小节</li>
</ul>
<h2 id="三、线程状态与转移"><a href="#三、线程状态与转移" class="headerlink" title="三、线程状态与转移"></a><strong>三、线程状态与转移</strong></h2><p>Java线程的状态转移示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20200731-0-0.svg"></p>
<h3 id="3-1、Java线程状态"><a href="#3-1、Java线程状态" class="headerlink" title="3.1、Java线程状态"></a><strong>3.1、Java线程状态</strong></h3><p>Java线程状态如表1所示。</p>
<p>表1[1]</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，“java.lang.Thread”实例被构建，但是还未调用其上<code>start()</code>方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，实际上包括“RUNNING（运行）”，“READY（等待CPU）”和“IO_WAIT（等待IO）”3种情形</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程申请synchronized锁而不得</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或者中断）才能退出等待状态</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>超时等待状态，退出条件在<code>WAITING</code>状态的基础之上加了“到达指定的超时时间也可退出等待状态”</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<br/>

<p><strong>几点说明</strong>：</p>
<ul>
<li>参见<code>java.lang.Thread</code>类中<code>State</code>枚举类</li>
<li>Java线程状态由Java语言自定义，与Linux线程的状态（Linux线程的状态跟Linux进程的状态一致，参见[2]）非一一映射，比如“Java线程的<code>RUNNABLE</code>对应Linux线程的<code>R</code>和<code>S</code>”，“Java线程的<code>BLOCKED</code>，<code>WAITING</code>和<code>TIMED_WAITING</code>都对应Linux线程的<code>S</code>”。实验代码1证明当Java线程处于“IO_WAIT（等待IO）”情形时，其Java线程状态为<code>RUNNABLE</code>，对应的Linux线程状态为<code>S</code></li>
<li><code>挂起</code>虚状态包括<code>BLOCKED</code>，<code>WAITING</code>和<code>TIMED_WAITING</code></li>
<li>Java线程的存活期意指：从调用其对应的Thread实例的<code>start()</code>方法开始，到其执行完成进入<code>TERMINATED</code>状态之前。在Java线程存活期内，调用其对应Thread实例的<code>isAlive()</code>方法，返回<code>true</code>，否则返回<code>false</code>，实验代码2是一个实验验证。本文的很多讨论都建立在“Java线程处于存活期”的前提下，否则失去实际意义，比如“讨论<code>Thread.interrupt()</code>，<code>Thread.isInterrupted()</code>，<code>Thread.interrupted()</code>和<code>LockSupport.unpark(Thread thread)</code>这4个方法的调用，只有目标Java线程存活才有实际意义”</li>
</ul>
<p><strong>实验代码1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>ps</code>命令知上述Java进程的ID为18141，通过<code>jstack 18141</code>命令打印线程栈日志，并在其内找到对应的main线程记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007fe0b000a800 nid=0x46de runnable [0x00007fe0b6d86000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">        at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">        at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)</span><br><span class="line">        at java.io.BufferedInputStream.read(BufferedInputStream.java:265)</span><br><span class="line">        - locked &lt;0x000000078661b698&gt; (a java.io.BufferedInputStream)</span><br><span class="line">        at Main.main(Main.java:10)</span><br></pre></td></tr></table></figure>
<p>根据nid字段值“0x46de”知道对应的Linux线程ID为18142，再使用<code>view /proc/18141/task/18142/status</code>命令查看该Linux线程的状态[4]，部分结果如下，可知该Linux线程的状态为<code>S</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name:   java</span><br><span class="line">Umask:  0002</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   18141</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    18142</span><br></pre></td></tr></table></figure>

<p><strong>实验代码2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(a.isAlive());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">finish</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="3-2、挂起-RUNNABLE的转移条件"><a href="#3-2、挂起-RUNNABLE的转移条件" class="headerlink" title="3.2、挂起 &lt;-&gt; RUNNABLE的转移条件"></a><strong>3.2、<code>挂起 &lt;-&gt; RUNNABLE</code>的转移条件</strong></h3><h4 id="3-2-1、Thread-sleep方法"><a href="#3-2-1、Thread-sleep方法" class="headerlink" title="3.2.1、Thread.sleep方法"></a><strong>3.2.1、<code>Thread.sleep</code>方法</strong></h4><p>有两个重载方法：<code>sleep(long millis)</code>和<code>sleep(long millis, int nanos)</code>，两者的区别只在于等待时间的设定精度。<br>线程A中执行<code>sleep</code>方法，线程A进入<code>TIMED_WAITING</code>状态，等待设定的时间到期后返回<code>RUNNABLE</code>状态。</p>
<p><strong>实验代码3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在100s睡眠时间到达前打印线程栈，线程栈中main线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f574c00a800 nid=0x1f36 waiting on condition [0x00007f5752474000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main.main(Main.java:3)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、synchronized方法-语句块"><a href="#3-2-2、synchronized方法-语句块" class="headerlink" title="3.2.2、synchronized方法&#x2F;语句块"></a><strong>3.2.2、synchronized方法&#x2F;语句块</strong></h4><p>线程A在执行synchronized方法&#x2F;语句块之前，需要申请相应的synchronized锁，如果申请不到，线程A被放入锁对象关联的<code>cxq</code>或者<code>EntryList</code>队列，并进入<code>BLOCKED</code>状态，待后续申请到synchronized锁时，从<code>cxq</code>或者<code>EntryList</code>队列移除，再返回到<code>RUNNABLE</code>状态。</p>
<p><strong>实验代码4</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让threadA去申请到obj对象对应的synchronized锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前，线程栈中threadA和threadB线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f9c440ef800 nid=0x2133 waiting for monitor entry [0x00007f9c2c67f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$2.run(Main.java:31)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b0c0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f9c440ee000 nid=0x212f waiting on condition [0x00007f9c2c780000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:13)</span><br><span class="line">        - locked &lt;0x000000078665b0c0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3、Object类的wait-notify-notifyAll实例方法"><a href="#3-2-3、Object类的wait-notify-notifyAll实例方法" class="headerlink" title="3.2.3、Object类的wait/notify/notifyAll实例方法"></a><strong>3.2.3、Object类的<code>wait/notify/notifyAll</code>实例方法</strong></h4><p>方法含义：</p>
<ul>
<li><code>wait</code>方法<ul>
<li>在调用对象obj的<code>wait</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，然后在调用<code>wait</code>方法之后会首先释放掉已获得的obj对应synchronized锁（<font color='red'>需要注意的是，不会释放其他已获得的synchronized锁</font>）</li>
<li>线程A调用执行对象obj的<code>wait</code>方法进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，线程A加入到obj对象关联的<code>WaitSet</code>队列，待后续尝试唤醒时，线程A移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列，即“等待再次申请获取相应的synchronized锁”，此时A处于<code>BLOCKED</code>状态，待最终获取到相应的synchronized锁，线程A从<code>cxq队列</code>或者<code>EntryList</code>队列移除，线程A被成功唤醒，进入<code>RUNNABLE</code>状态</li>
</ul>
</li>
<li><code>notify</code>方法<ul>
<li>在调用对象obj的<code>notify</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，跟<code>wait</code>方法不同，调用<code>notify</code>方法之后不会释放掉已获得的obj对应synchronized锁，而是需要等到相应的synchronized方法&#x2F;语句块执行完成退出</li>
<li>线程B调用执行对象obj的<code>notify</code>方法随机选中obj对象关联的<code>WaitSet队列</code>中的一个线程C尝试唤醒，即将其移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列</li>
</ul>
</li>
<li><code>notifyAll</code>方法<ul>
<li>在调用对象obj的<code>notifyAll</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，跟<code>wait</code>方法不同，调用<code>notifyAll</code>方法之后不会释放掉已获得的obj对应synchronized锁，而是需要等到相应的synchronized方法&#x2F;语句块执行完成退出</li>
<li>线程B调用执行对象obj的<code>notifyAll</code>方法尝试唤醒obj对象关联的<code>WaitSet队列</code>中的所有线程，即将他们所有都移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列</li>
</ul>
</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>对于<code>notify/notifyAll</code>方法和<code>wait</code>方法之间的调用顺序关系，默认是“后序”，即“<code>notify/notifyAll</code>方法在<code>wait</code>方法之后调用”，经过实验可发现，如果是“先序”，则<code>notify/notifyAll</code>方法调用发出的唤醒信号直接丢失。接下来在本文中称这类唤醒信号为“<font color='red'>一次性唤醒信号</font>”</li>
</ul>
<br/>

<p><code>wait</code>方法有3个重载方法：<code>wait()</code>，<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>。调用<code>wait()</code>方法进入<code>WAITING</code>状态；调用<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态。</p>
<h5 id="3-2-3-1、wait-方法"><a href="#3-2-3-1、wait-方法" class="headerlink" title="3.2.3.1、wait()方法"></a><strong>3.2.3.1、<code>wait()</code>方法</strong></h5><p>线程A调用执行对象obj的<code>wait()</code>方法进入<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行对象obj的<code>notify()</code>方法</li>
<li>线程B调用执行对象obj的<code>notifyAll()</code>方法</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup.</code>）</li>
</ul>
<p>成功唤醒：</p>
<ul>
<li><font color='red'>再次强调下，假定线程A调用对象obj的<code>wait()</code>方法进入<code>WAITING</code>状态，后续发生上述任一唤醒条件，且线程A被选中尝试唤醒，只有当线程A再次申请到obj对应synchronized锁时才被成功唤醒</font></li>
</ul>
<p><strong>实验代码5</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程栈中threadA线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f62e00f6000 nid=0x29f8 in Object.wait() [0x00007f62ca2a7000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果：threadA线程挂起不被唤醒。</p>
<p><strong>实验代码6</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：在threadB开始运行大约60秒后打印“hello world”，因为threadA被成功唤醒既需要调用<code>notify()</code>方法发出的唤醒信号，也需要threadB释放掉obj对应的synchronized锁。</p>
<p>在threadB执行完<code>obj.notify()</code>语句睡眠60s期间，查看线程栈状态，可发现此时threadA的线程状态为<code>BLOCKED</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f55400ff800 nid=0x592e waiting on condition [0x00007f5529398000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - locked &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f55400fd800 nid=0x592a in Object.wait() [0x00007f5529499000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码7</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;world hello&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notifyAll();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：在threadC开始运行大约60秒后打印如下内容，因为threadA和threadB被成功唤醒既需要调用<code>notifyAll()</code>方法发出的唤醒信号，也需要threadC释放掉obj对应的synchronized锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">world hello</span><br></pre></td></tr></table></figure>

<p><strong>实验代码8</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先让threadA获取synchronized锁，执行wait()方法，释放掉synchronized锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下，因为只有当threadB执行完成释放掉obj对应的synchronized锁，threadA获得上述synchronized锁后，threadA才能被成功唤醒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-2、wait-long-timeout-和wait-long-timeout-int-nanos-方法"><a href="#3-2-3-2、wait-long-timeout-和wait-long-timeout-int-nanos-方法" class="headerlink" title="3.2.3.2、wait(long timeout)和wait(long timeout, int nanos)方法"></a><strong>3.2.3.2、<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法</strong></h5><p>线程A调用执行对象obj的<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态。<font color='red'>需要注意的是</font>，线程A调用执行对象obj的<code>wait(0)</code>和<code>wait(0,0)</code>方法进入的是<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行对象obj的<code>notify()</code>方法</li>
<li>线程B调用执行对象obj的<code>notifyAll()</code>方法</li>
<li>设定的超时时间到期</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup.</code>）</li>
</ul>
<p>成功唤醒：</p>
<ul>
<li><font color='red'>再次强调下，假定线程A调用对象obj的<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态，后续发生上述任一唤醒条件，且线程A被选中尝试唤醒，只有当线程A再次申请到obj对应synchronized锁时才被成功唤醒</font></li>
</ul>
<p><strong>实验代码9</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait(<span class="number">60000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在60s时间挂起时间到达前打印线程栈，线程栈中threadA线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007fb2340f6000 nid=0x2cb5 in Object.wait() [0x00007fb21e9ae000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果：大约60秒后打印“hello world”，因为60秒后设定的超时时间到期尝试唤醒，在获得obj对应的synchronized锁后被成功唤醒。</p>
<h4 id="3-2-4、Thread类的join实例方法"><a href="#3-2-4、Thread类的join实例方法" class="headerlink" title="3.2.4、Thread类的join实例方法"></a><strong>3.2.4、Thread类的<code>join</code>实例方法</strong></h4><p><code>join</code>方法有3个重载方法：<code>join()</code>，<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>，后两者的区别只在于等待时间的设定精度。<br>现有线程B，其对应的Thread实例对象引用为threadB，在线程A中执行<code>threadB.join()/threadB.join(long millis)/join(long millis, int nanos)</code>方法，其含义是：线程A进入<code>WAITING</code>&#x2F;<code>TIMED_WAITING</code>状态，直到线程B执行完成进入<code>TERMINATED</code>状态或者设定的超时时间到期。<br>查看如下<code>join()</code>方法核心实现，可知其核心逻辑通过调用<code>wait(long timeout)</code>方法实现，当线程B执行完成进入<code>TERMINATED</code>状态后，会触发调用下<code>threadB.notifyAll()</code>方法（[1]中P190页对此有作阐明）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实验代码10</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前打印线程栈，线程栈信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadC&quot; #11 prio=5 os_prio=0 tid=0x00007f79cc0f9800 nid=0x42e4 in Object.wait() [0x00007f7996c1a000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1252)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1326)</span><br><span class="line">        at Main$3.run(Main.java:40)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f79cc0f7800 nid=0x42e3 in Object.wait() [0x00007f7996d1b000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1252)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1326)</span><br><span class="line">        at Main$2.run(Main.java:25)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f79cc0f5800 nid=0x42e2 waiting on condition [0x00007f7996e1c000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:8)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thu Dec 17 17:13:53 CST 2020:1</span><br><span class="line">Thu Dec 17 17:13:53 CST 2020:hello</span><br><span class="line">Thu Dec 17 17:15:28 CST 2020:2</span><br><span class="line">Thu Dec 17 17:15:28 CST 2020:world</span><br></pre></td></tr></table></figure>

<p><strong>实验代码11</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join(<span class="number">200000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join(<span class="number">200000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前（此时threadB和threadC的睡眠时间更加没有可能到达）打印线程栈，线程栈信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadC&quot; #11 prio=5 os_prio=0 tid=0x00007f11fc0e9800 nid=0x60c2 in Object.wait() [0x00007f11e5da2000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1260)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at Main$3.run(Main.java:41)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f11fc0e8000 nid=0x60c1 in Object.wait() [0x00007f11e5ea3000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1260)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at Main$2.run(Main.java:26)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f11fc0e6000 nid=0x60b1 waiting on condition [0x00007f11e5fa4000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:10)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sat Jan 02 20:35:20 CST 2021:hello</span><br><span class="line">Sat Jan 02 20:35:20 CST 2021:1</span><br><span class="line">Sat Jan 02 20:36:55 CST 2021:2</span><br><span class="line">Sat Jan 02 20:36:55 CST 2021:world</span><br></pre></td></tr></table></figure>

<br/>

<p>有一个疑惑点，既然核心逻辑是通过调用<code>wait</code>方法实现，那么在调用<code>threadB.join</code>方法后，是否可以不等待threadB执行完成，而是人为手动执行<code>threadB.notify()/notifyAll()</code>方法从而唤醒线程A呢？答案既是肯定的也是否定的，因为在人为唤醒线程A后会由于<code>while(isAlive())</code>语句而再次进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，参见实验代码12。</p>
<p><strong>实验代码12</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (threadA) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:notifyAll the wait on threadA&quot;</span>);</span><br><span class="line">                    threadA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:notifyAll the wait on threadA finished&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadD.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thu Dec 17 17:20:50 CST 2020:1</span><br><span class="line">Thu Dec 17 17:20:50 CST 2020:hello</span><br><span class="line">Thu Dec 17 17:20:55 CST 2020:notifyAll the wait on threadA</span><br><span class="line">Thu Dec 17 17:20:55 CST 2020:notifyAll the wait on threadA finished</span><br><span class="line">//这里需要等待threadA的100s睡眠时间到达</span><br><span class="line">Thu Dec 17 17:22:25 CST 2020:2</span><br><span class="line">Thu Dec 17 17:22:25 CST 2020:world</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5、LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-unpark-Thread-thread-类方法"><a href="#3-2-5、LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-unpark-Thread-thread-类方法" class="headerlink" title="3.2.5、LockSupport类的park()/parkNanos(long nanos)/parkUtil(long deadline)/unpark(Thread thread)类方法"></a><strong>3.2.5、LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)/unpark(Thread thread)</code>类方法</strong></h4><p>方法含义：</p>
<ul>
<li><code>park()</code>方法。线程A执行<code>park()</code>方法进入<code>WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>parkNanos(long nanos)</code>方法。线程A执行<code>parkNanos(long nanos)</code>方法进入<code>TIMED_WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>parkUtil(long deadline)</code>方法。线程A执行<code>parkUtil(long deadline)</code>方法进入<code>TIMED_WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>unpark(Thread thread)</code>方法。线程B执行<code>unpark(Thread thread)</code>方法唤醒Java线程实例thread对应的线程</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>本文对<code>park()</code>，<code>parkNanos(long nanos)</code>和<code>parkUtil(long deadline)</code>这3个方法的相应重载方法<code>park(Object blocker)</code>，<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>不作讨论，因为核心语义一致</li>
<li>对于<code>unpark(Thread thread)</code>方法和<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法之间的调用顺序关系，默认是“后序”，即“<code>unpark(Thread thread)</code>方法在<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法之后调用”，经过实验可发现，如果是“先序”，<code>unpark(Thread thread)</code>方法调用发出的唤醒信号并不会直接丢失（可与<code>notify/notifyAll</code>方法调用发出的唤醒信号进行对比）。根据<code>unpark(Thread thread)</code>方法的实现原理，可知调用其发出的唤醒信号的特点是：设置一个0-1标志位，如果是“后序”调用，则经历“设置1标志位 -&gt; 唤醒先前的相应的<code>park/parkNanos/parkUtil</code>方法调用 -&gt; 复位0标志位”过程；如果是“先序”调用，则经历“设置1标志位 -&gt; 唤醒后续的相应的<code>park/parkNanos/parkUtil</code>方法调用 -&gt; 复位0标志位”过程。<font color='red'>需要注意的是，由于是一个0-1标志位，故在“先序”调用情形中，提前多次<code>unpark(Thread thread)</code>方法调用与提前1次<code>unpark(Thread thread)</code>方法调用等价</font>。接下来在本文中称这类唤醒信号为“<font color='red'>标志位唤醒信号</font>”</li>
</ul>
<h5 id="3-2-5-1、park-方法"><a href="#3-2-5-1、park-方法" class="headerlink" title="3.2.5.1、park()方法"></a><strong>3.2.5.1、<code>park()</code>方法</strong></h5><p>线程A执行<code>park()</code>方法进入<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行<code>unpark(Thread thread)</code>方法，thread代表线程A对应的Thread实例</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>The call spuriously (that is, for no reason) returns</code>）</li>
</ul>
<p><strong>实验代码13</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：threadA线程挂起不被唤醒。</p>
<p>线程栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f14400f6000 nid=0x4aa8 waiting on condition [0x00007f1429499000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">        at Main$1.run(Main.java:9)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码14</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p><strong>实验代码15</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;again&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是一个0-1标志位，在“先序”调用情形中，提前多次unpark方法调用与提前1次unpark方法调用等价</span></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">//挂起不被唤醒</span><br></pre></td></tr></table></figure>

<h5 id="3-2-5-2、parkNanos-long-nanos-和parkUntil-long-deadline"><a href="#3-2-5-2、parkNanos-long-nanos-和parkUntil-long-deadline" class="headerlink" title="3.2.5.2、parkNanos(long nanos)和parkUntil(long deadline)"></a><strong>3.2.5.2、<code>parkNanos(long nanos)</code>和<code>parkUntil(long deadline)</code></strong></h5><p>线程A执行<code>parkNanos(long nanos)</code>和<code>parkUntil(long deadline)</code>方法进入<code>TIMED_WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行<code>unpark(Thread thread)</code>方法，thread代表线程A对应的Thread实例</li>
<li>设定的超时时间到期</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>The call spuriously (that is, for no reason) returns</code>）</li>
</ul>
<p><strong>实验代码16</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">10L</span> * <span class="number">1000000000</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA的挂起时间10s到达前打印线程栈，线程栈记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007fed1c0ed800 nid=0x4d5e waiting on condition [0x00007fed04315000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338)</span><br><span class="line">        at Main$1.run(Main.java:9)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码17</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.parkUntil(System.currentTimeMillis() + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="3-2-6、Condition接口的await-awaitUninterruptibly-await-long-time-TimeUnit-unit-awaitNano-long-nanosTimeout-awaitUntil-Date-deadline-signal-signalAll-实例方法"><a href="#3-2-6、Condition接口的await-awaitUninterruptibly-await-long-time-TimeUnit-unit-awaitNano-long-nanosTimeout-awaitUntil-Date-deadline-signal-signalAll-实例方法" class="headerlink" title="3.2.6、Condition接口的await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)/signal()/signalAll()实例方法"></a><strong>3.2.6、Condition接口的<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)/signal()/signalAll()</code>实例方法</strong></h4><p>对于Condition接口，在Java并发包中已存在两个实现，分别是<code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject</code>和<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject</code>，查看两者实现，发现都通过调用LockSupport类的<code>park/parkNanos/parkUtil</code>方法实现<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>方法的核心逻辑，通过调用LockSupport类的<code>unpark</code>方法实现<code>signal()/signalAll()</code>方法的核心逻辑。</p>
<p>仅限于基于上述两个已存在类，可以有结论：</p>
<ul>
<li>调用<code>await()/awaitUninterruptibly()</code>会进入<code>WAITING</code>状态</li>
<li>调用<code>await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>会进入<code>TIMED_WAITING</code>状态</li>
</ul>
<p>另外值得叙述的是<code>awaitUninterruptibly()</code>方法（源码如下），它针对中断操作的处理步骤是：在被中断信号唤醒后，立即无条件复位中断标志位，然后判断while退出条件是否得到满足，如果满足则退出，否则继续挂起；而<code>await()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>方法针对中断操作的处理步骤是：在被中断信号唤醒后，立即无条件复位中断标志位，然后直接退出while循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a><strong>四、中断</strong></h2><p>中断的本质十分简单：“发出唤醒信号”和“设置中断标志位”。如何处理“唤醒信号”和“中断标志位”由后续具体逻辑具体负责。<br>发出的唤醒信号分为3类：</p>
<ul>
<li>针对<code>Thread.sleep</code>的唤醒信号</li>
<li>针对<code>Object.wait</code>的唤醒信号，等价于<code>Object.notify</code></li>
<li>针对<code>LockSupport.park</code>的唤醒信号，等价于<code>LockSupport.unpark</code></li>
</ul>
<p>在Thread类中跟中断有关的方法有3个：</p>
<ul>
<li><code>interrupt()</code>：在线程存活期调用，否则无实际意义</li>
<li><code>interrupted()</code>：如果设置了中断标志位则返回true，复位中断标志位；否则返回false</li>
<li><code>isInterrupted()</code>：如果设置了中断标志位则返回true，否则返回false。需要注意的是：<font color='red'>并不会复位中断标志位</font></li>
</ul>
<h3 id="4-1、针对Thread类的sleep方法"><a href="#4-1、针对Thread类的sleep方法" class="headerlink" title="4.1、针对Thread类的sleep方法"></a><strong>4.1、针对Thread类的<code>sleep</code>方法</strong></h3><p>一次性唤醒信号。</p>
<h4 id="4-1-1、后序"><a href="#4-1-1、后序" class="headerlink" title="4.1.1、后序"></a><strong>4.1.1、后序</strong></h4><p>一次性唤醒信号生效消失，线程被唤醒后检测到设置了中断标志位，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码18</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                        .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1609836534638</span><br><span class="line">1609836534639:[false]</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2、先序"><a href="#4-1-2、先序" class="headerlink" title="4.1.2、先序"></a><strong>4.1.2、先序</strong></h4><p>一次性唤醒信号丢失消失，后续线程调用<code>Thread.sleep</code>方法时发现设置了中断标志位，直接唤醒，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码19</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">aSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                        .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">hello world</span><br><span class="line">1609836587473:[false]</span><br></pre></td></tr></table></figure>

<h3 id="4-2、针对Object类的wait方法"><a href="#4-2、针对Object类的wait方法" class="headerlink" title="4.2、针对Object类的wait方法"></a><strong>4.2、针对Object类的<code>wait</code>方法</strong></h3><p>一次性唤醒信号。</p>
<p><strong>再次强调下</strong>：如上所述，我们知道，线程A调用对象obj的<code>wait</code>方法进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，后续尝试唤醒时（线程B调用执行对象obj的<code>notify/notifyAll</code>方法；设定的超时时间到期；虚假唤醒），只有当线程A再次申请到obj对应的synchronized锁才被成功唤醒，<font color='red'>中断唤醒情形也不例外</font>。</p>
<h4 id="4-2-1、后序"><a href="#4-2-1、后序" class="headerlink" title="4.2.1、后序"></a><strong>4.2.1、后序</strong></h4><p>一次性唤醒信号生效消失，线程被唤醒后（<font color='red'>需要再次获取到synchronized锁</font>）检测到设置了中断标志位，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码20</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[thread sleep finished]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[interrupt send]&quot;</span>);</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1609753806368:[interrupt send]</span><br><span class="line">1609753861368:[thread sleep finished]</span><br><span class="line">1609753861369:[false]</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2、先序"><a href="#4-2-2、先序" class="headerlink" title="4.2.2、先序"></a><strong>4.2.2、先序</strong></h4><p>一次性唤醒信号丢失消失，后续线程调用<code>wait</code>方法发现设置了中断标志位，直接唤醒（<font color='red'>需要再次获取到synchronized锁，不过笔者不是很确定——在该种情形中，是“先释放锁，再获取锁”，还是“发现设置了中断标志位直接不释放锁”</font>），抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码21</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">aSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objA.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">hello world</span><br><span class="line">1609838232636:[false]</span><br></pre></td></tr></table></figure>

<h3 id="4-3、针对LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-方法"><a href="#4-3、针对LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-方法" class="headerlink" title="4.3、针对LockSupport类的park()/parkNanos(long nanos)/parkUtil(long deadline)方法"></a><strong>4.3、针对LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法</strong></h3><p>标志位唤醒信号。</p>
<h4 id="4-3-1、后序"><a href="#4-3-1、后序" class="headerlink" title="4.3.1、后序"></a><strong>4.3.1、后序</strong></h4><p>标志位唤醒信号生效消失，线程被唤醒后虽然检测到设置了中断标志位，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。</p>
<p><strong>实验代码22</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1609805900180</span><br><span class="line">true</span><br><span class="line">1609805900180:[true]</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2、先序"><a href="#4-3-2、先序" class="headerlink" title="4.3.2、先序"></a><strong>4.3.2、先序</strong></h4><p>标志位唤醒信号不会丢失，后续线程调用LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>发现存在唤醒信号，标志位唤醒信号生效消失，线程被唤醒后虽然检测到设置了中断标志位，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。<br>在没有标志位唤醒信号的情形下，后续线程调用LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法发现设置了中断标志位，直接唤醒，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。</p>
<p><strong>实验代码23</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Switch aSwitch = new Switch();</span><br><span class="line"></span><br><span class="line">        Object obj = new Object();</span><br><span class="line"></span><br><span class="line">        Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        LockSupport.park();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + &quot;:[&quot; + Thread.currentThread().isInterrupted() + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;world&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello world again&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;threadA&quot;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Switch &#123;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world again</span><br></pre></td></tr></table></figure>

<h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a><strong>五、死锁</strong></h2><h3 id="5-1、狭义"><a href="#5-1、狭义" class="headerlink" title="5.1、狭义"></a><strong>5.1、狭义</strong></h3><p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>Java死锁产生的四个必要条件：</p>
<ul>
<li>互斥使用，即当资源被一个线程占有使用时，别的线程不能使用</li>
<li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li>
<li>请求和保持，即当资源请求者在请求其他资源的同时保持对原有资源的占有</li>
<li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源，这样就形成了一个等待环路</li>
</ul>
<p>当上述四个条件都成立的时候，便形成死锁，在死锁的情况下如果打破上述任何一个条件，便可让死锁消失。</p>
<p>以上引用自[11]。</p>
<p>根据以上定义，可使用synchronized锁或者Lock显式锁构造死锁案例，接下来根据synchronized锁构造一个死锁案例。</p>
<p><strong>实验代码24</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程栈信息如下所示，发现jstack能够直接侦测到该种死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f39bc0e0000 nid=0x5774 waiting for monitor entry [0x00007f39a67ac000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f39bc0de000 nid=0x5773 waiting for monitor entry [0x00007f39a68ad000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$1.run(Main.java:18)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">//这里省略</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f398c003a18 (object 0x000000078665b048, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadA&quot;</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f398c006568 (object 0x000000078665b058, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadB&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">        at Main$1.run(Main.java:18)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h3 id="5-2、广义"><a href="#5-2、广义" class="headerlink" title="5.2、广义"></a><strong>5.2、广义</strong></h3><p>死锁是这样一种情形：多个线程同时被阻塞，它们互相循环依赖对方的动作才能被唤醒。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>实验代码25</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objA.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    objB.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objB.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objC) &#123;</span><br><span class="line">                    objC.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objC) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objC.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    objA.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h2><h3 id="6-1、挂起线程T0被线程T1唤醒的跨线程内存可见性"><a href="#6-1、挂起线程T0被线程T1唤醒的跨线程内存可见性" class="headerlink" title="6.1、挂起线程T0被线程T1唤醒的跨线程内存可见性"></a><strong>6.1、挂起线程T0被线程T1唤醒的跨线程内存可见性</strong></h3><p>这里讨论挂起线程T0被线程T1唤醒时的跨线程内存可见性问题，具体是：T1中的唤醒前动作集T1AS与T0中的被唤醒后动作集T0AS之间的happens-before规则（<font color='red'>需要注意的是，讨论对象从“内存可见性”到“happens-before规则”是因为：在内存可见性范畴，“happens-before规则”虽然只是其中一类规则，还有很多其他规则，比如“final关键词提供的内存可见语义规则”，但是“happens-before规则”相对来说最具有应用价值</font>）。</p>
<p>根据“3.2、<code>挂起 &lt;-&gt; RUNNABLE</code>的转移条件”小节内容，可知挂起线程T0的方法有6个：</p>
<ul>
<li>Thread类的<code>sleep</code>方法，唤醒方式有：超时自唤醒，T1调用T0的<code>interrupt()</code>方法</li>
<li>synchronized方法&#x2F;语句块，唤醒方式有：T1释放synchronized锁</li>
<li>Object类的<code>wait</code>方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用Object类的<code>notify()/notifyAll()</code>方法或者调用T0的<code>interrupt()</code>方法</li>
<li>Thread类的<code>join</code>实例方法，唤醒方式有：超时自唤醒，T1线程（T1就是T0所等待的线程，即T0线程调用<code>T1.join()</code>挂起）执行完成进入<code>TERMINATED</code>状态，T1（T1可以是T0所等待的线程，也可以不是，一般是后者）调用T0的<code>interrupt()</code>方法</li>
<li>LockSupport类的<code>park/parkNano/parkUntil</code>方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用LockSupport类的<code>unpark(T0)</code>方法或者调用T0的<code>interrupt()</code>方法</li>
<li>Condition接口的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>实例方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用Condition接口的<code>signal()/signalAll()</code>方法或者调用T0的<code>interrupt()</code>方法（需要注意的是，<code>awaitUninterruptibly</code>方法不响应中断）</li>
</ul>
<p><strong>在继续讨论之前，先作几点说明</strong>：</p>
<ul>
<li>接下来，以“hb”简指“happens-before”</li>
<li>下表中的<code>NO</code>意指：T1中的中断唤醒前动作集T1AS与T0中的被唤醒后动作集T0AS没有必然的内存可见性关系，自然也没有必然的hb规则</li>
<li>Condition实例对象关联的锁一般是指ReentrantLock锁，这里也基于此进行说明。跟synchronized锁一样，ReentrantLock锁的使用也遵循“监视器锁”hb规则，具体证明可参见<a href="/blog/2021/04/02/Lock%E6%8E%A5%E5%8F%A3/" title="Lock接口">《Lock接口》</a></li>
<li>对于<code>wait-notify/notifyAll</code>和<code>await/awaitUninterruptibly/awaitNano/awaitUntil-signal/signalAll</code>过程的hb规则，须具体情况具体分析，核心基于“监视器锁”hb规则，再次提醒下：在调用<code>wait</code>和<code>await/awaitNano/awaitUntil</code>方法后立即中断的情形中，锁的申请和释放过程是有点特殊的</li>
</ul>
<table>
<thead>
<tr>
<th>T0挂起方法</th>
<th>T0自唤醒</th>
<th>T1非中断唤醒</th>
<th>T1中断唤醒</th>
</tr>
</thead>
<tbody><tr>
<td>Thread类的<code>sleep</code>方法</td>
<td>NO</td>
<td>不存在T1非中断唤醒情形</td>
<td>NO</td>
</tr>
<tr>
<td>synchronized方法&#x2F;语句块</td>
<td>不可能情形</td>
<td>T1释放相应的synchronized锁，关于内存可见性，遵循<code>监视器锁hb规则</code></td>
<td>NO</td>
</tr>
<tr>
<td>Object类的<code>wait</code>方法</td>
<td>NO</td>
<td>见“论述1”</td>
<td>NO</td>
</tr>
<tr>
<td>Thread类的<code>join</code>方法</td>
<td>NO</td>
<td>T0线程调用<code>T1.join()</code>挂起，T1执行完成进入<code>TERMINATED</code>状态唤醒T0，关于内存可见性，遵循<code>join() hb规则</code>。<br/><br/>根据“3.2.4、Thread类的<code>join</code>实例方法”可知，<code>join() hb规则</code>可简单由“论述1”中的<code>wait/notify/notifyAll hb规则</code>推得，因此，<code>join() hb规则</code>本质也是来源于<code>监视器锁hb规则</code></td>
<td>NO</td>
</tr>
<tr>
<td>LockSupport类的<code>park/parkNano/parkUntil</code>方法</td>
<td>NO</td>
<td>T1调用LockSupport类的<code>unpark(T0)</code>方法，关于内存可见性，T1中的<code>unpark()</code>方法前动作集T1AS与T0中的被唤醒后动作集T0AS没有必然的内存可见性关系[8]</td>
<td>NO</td>
</tr>
<tr>
<td>Condition的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法</td>
<td>NO</td>
<td>见“论述2”</td>
<td>NO</td>
</tr>
</tbody></table>
<p><strong>论述1</strong>：<br>T0调用<code>wait</code>方法挂起，T1调用<code>notify()/notifyAll()</code>方法尝试唤醒，</p>
<ul>
<li>未成功唤醒：不可能出现的情形。因为“根据已知前提，唤醒信号必定发送，调用<code>notify()/notifyAll()</code>方法后最终必定会自动隐式释放掉synchronized锁，成功唤醒的条件得到满足”</li>
<li>成功唤醒：调用<code>notify()/notifyAll()</code>方法后最终必定会自动隐式释放掉synchronized锁，该锁被T0获取而成功唤醒（实际可能是形如“T1释放锁 Tm获取锁 Tm释放锁 Tn获取锁 Tn释放锁 … T0获取锁”过程，但是根据“传递性”hb规则，不影响证明），基于“程序顺序”，“监视器锁”和“传递性”这3个hb规则，可推导得：T1调用<code>notify()/notifyAll()</code>方法之前的操作（更准确的说，T1在调用<code>notify()/notifyAll()</code>后最终隐式释放掉synchronized锁之前的操作） happens-before 于T0调用<code>wait</code>方法被成功唤醒之后的操作。据此，在实验代码26中，有“&#x2F;&#x2F;1 -hb-&gt; &#x2F;&#x2F;2 -hb-&gt; &#x2F;&#x2F;3 -hb-&gt; &#x2F;&#x2F;4 -hb-&gt; &#x2F;&#x2F;5 -hb-&gt; &#x2F;&#x2F;6 -hb-&gt; &#x2F;&#x2F;7”</li>
</ul>
<p><strong>论述2</strong>：<br>T0调用Condition的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法挂起，T1调用<code>signal()/signalAll()</code>方法尝试唤醒，</p>
<ul>
<li>未成功唤醒：根据已知前提，唤醒信号必定发送，故未成功唤醒只能是因为T1中最后未释放对应的ReentrantLock锁，此时无谓谈论happens-before关系。但是根据如下“ReentrantLock锁使用的惯用法”，该种情形理论上不会出现</li>
<li>成功唤醒：调用<code>signal()/signalAll()</code>方法后最终在finally语句中显式释放掉ReentrantLock锁，该锁被T0获取而成功唤醒（实际可能是形如“T1释放锁 Tm获取锁 Tm释放锁 Tn获取锁 Tn释放锁 … T0获取锁”过程，但是根据“传递性”hb规则，不影响证明），基于“程序顺序”，“监视器锁”和“传递性”这3个hb规则，可推导得：T1调用<code>signal()/signalAll()</code>方法之前的操作（更准确的说，T1在调用<code>signal()/signalAll()</code>后最终显式释放掉ReentrantLock锁之前的操作） happens-before 于T0调用<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法被成功唤醒之后的操作</li>
</ul>
<p>ReentrantLock锁使用的惯用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockUseExample</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>实验代码26</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 被唤醒，这里重新获得synchronized锁</span></span><br><span class="line">                        obj.wait();              <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;5&quot;</span>); <span class="comment">// 5</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;6&quot;</span>); <span class="comment">// 6</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;7&quot;</span>); <span class="comment">// 7</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">                &#125;                            <span class="comment">// 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、惯用法"><a href="#6-2、惯用法" class="headerlink" title="6.2、惯用法"></a><strong>6.2、惯用法</strong></h3><p>Object类的<code>wait</code>和LockSupport类的<code>park</code>方法使用的惯用形式为：在一个while语句块中调用<code>wait</code>方法和<code>park</code>方法，被唤醒后如果不满足while循环退出条件继续挂起。可参见实验代码27。<br>以上惯用形式的合理和必要之处在于：调用<code>wait</code>和<code>park</code>方法的原始意图本就在于等待某个条件的达成，如果被非法唤醒而条件未达成则会导致违背这种原始意图，通过while语句块可以避免这种情形。<br>非法唤醒的情形包括两种：</p>
<ul>
<li>代码实现Bug，误调用Object类的<code>notify/notifyAll</code>方法&#x2F;LockSupport类的<code>unpark</code>方法、设定的唤醒超时时间到期、误调用Thread类的<code>interrupt()</code>方法。从这个角度来看，如果不用惯用法，代码健壮性差</li>
<li><code>wait</code>和<code>park</code>方法都有一个“虚假唤醒”的唤醒情形。从这个角度来看，如果不用惯用法，代码存在漏洞</li>
</ul>
<p><strong>实验代码27</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只是示例，没有考虑代码健壮性（包括线程安全性）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> Thread parkThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            obj.notify();</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parkMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            parkThread = Thread.currentThread();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unparkMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        LockSupport.unpark(parkThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、垃圾回收"><a href="#6-3、垃圾回收" class="headerlink" title="6.3、垃圾回收"></a><strong>6.3、垃圾回收</strong></h3><p>创建Thread实例对象，并开启对应线程后，它会被注册到“<font color='red'>某处</font>”，因此在线程存活期内是引用可达的，并不会被垃圾回收；线程结束后相应的Thread实例对象才会被解除注册，此时可被垃圾回收。</p>
<h3 id="6-4、main主线程与普通线程的异同"><a href="#6-4、main主线程与普通线程的异同" class="headerlink" title="6.4、main主线程与普通线程的异同"></a><strong>6.4、main主线程与普通线程的异同</strong></h3><p>main主线程与普通线程相比，除了是入口线程外，并无二致。</p>
<h3 id="6-5、线程内异常处理"><a href="#6-5、线程内异常处理" class="headerlink" title="6.5、线程内异常处理"></a><strong>6.5、线程内异常处理</strong></h3><p>Java线程内抛出异常（包括“错误”，接下来未作特别声明，“异常”都包括“错误”）时，有两条运行路径。</p>
<h4 id="6-5-1、异常在线程内被catch住"><a href="#6-5-1、异常在线程内被catch住" class="headerlink" title="6.5.1、异常在线程内被catch住"></a><strong>6.5.1、异常在线程内被catch住</strong></h4><p>正确合理的应对方式。</p>
<h4 id="6-5-2、异常未在线程内被catch住"><a href="#6-5-2、异常未在线程内被catch住" class="headerlink" title="6.5.2、异常未在线程内被catch住"></a><strong>6.5.2、异常未在线程内被catch住</strong></h4><p>线程内异常未在线程内被catch住，即逃逸到线程外，这会导致该线程死亡，但不会影响所在Java进程。不过在线程死亡之前，会去执行Thread类的“private void dispatchUncaughtException(Throwable e)”方法（“e”指代未被处理异常）。<br>默认会调用ThreadGroup类下<code>uncaughtException()</code>方法，可通过<code>setUncaughtExceptionHandler()</code>方法自定义设置“UncaughtExceptionHandler”实例对象，从而自定义对未处理异常的处理逻辑。</p>
<p><font color='red'>特别需要注意的是</font>：Java线程运行在独立的线程空间，内部未处理的异常不能被其它线程处理，示例见以下两个示例代码。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionNotCatch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 以下抛出异常内部未能处理，执行Thread类的“private void dispatchUncaughtException(Throwable e)”方法，该异常作为参数传入</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;hello world exception&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                            <span class="comment">// 没有抓住RuntimeException异常</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;can not run to here&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 线程内部异常不能被其它线程处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有抓住异常，线程直接结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread is alive ? &quot;</span> + thread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionUncaughtExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;hello world exception&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                            <span class="comment">// 没有抓住RuntimeException异常</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;can not run to here&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;dslztx-thread-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">UncaughtExceptionHandler</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常catch了,当前线程为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，异常线程为：&quot;</span> + t.getName()</span><br><span class="line">                        + <span class="string">&quot;，异常信息为：&quot;</span> + e.getStackTrace());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 线程内部异常不能被其它线程处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有抓住异常，线程直接结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread is alive ? &quot;</span> + thread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6、调用Object-wait或者Thread-join方法挂起查看所打印jstack命令结果的一个注意点"><a href="#6-6、调用Object-wait或者Thread-join方法挂起查看所打印jstack命令结果的一个注意点" class="headerlink" title="6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点"></a><strong>6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点</strong></h3><p>调用Object.wait或者Thread.join（本质通过调用Object.wait实现）方法挂起查看所打印jstack命令结果的一个注意点：虽然显示某个synchronized锁被获取，但实际上调用wait方法挂起后是释放掉该锁的，比如在如下jstack命令结果中，“threadA”在挂起时已经释放掉“0x000000078665afb8”指代的synchronized锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f62e00f6000 nid=0x29f8 in Object.wait() [0x00007f62ca2a7000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<br/>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]《Java并发编程的艺术》<br>[2]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/YDDMAX/p/5208561.html">https://www.cnblogs.com/YDDMAX/p/5208561.html</a><br>[3]<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38244610/article/details/106106276">https://blog.csdn.net/qq_38244610/article/details/106106276</a><br>[4]<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9577231/how-to-check-the-state-of-linux-threads">https://stackoverflow.com/questions/9577231/how-to-check-the-state-of-linux-threads</a><br>[5]<a target="_blank" rel="noopener" href="https://cgiirw.github.io/2018/05/27/Interrupt_Ques/">https://cgiirw.github.io/2018/05/27/Interrupt_Ques/</a><br>[6]<a target="_blank" rel="noopener" href="https://cgiirw.github.io/2018/05/17/Thread01/">https://cgiirw.github.io/2018/05/17/Thread01/</a><br>[7]<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.2.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.2.1</a><br>[8]<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2475067/java-locksupport-memory-consistency">https://stackoverflow.com/questions/2475067/java-locksupport-memory-consistency</a><br>[9]<a target="_blank" rel="noopener" href="https://blogs.oracle.com/dave/a-race-in-locksupport-park-arising-from-weak-memory-models">https://blogs.oracle.com/dave/a-race-in-locksupport-park-arising-from-weak-memory-models</a><br>[10]<a target="_blank" rel="noopener" href="https://cgiirw.github.io/2018/10/17/Blocked03/">https://cgiirw.github.io/2018/10/17/Blocked03/</a><br>[11]<a target="_blank" rel="noopener" href="https://www.runoob.com/java/thread-deadlock.html">https://www.runoob.com/java/thread-deadlock.html</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>您的支持将鼓励我继续分享！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/blog/images/wechatpay.jpg" alt="dslztx 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>dslztx
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dslztx.github.io/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">https://dslztx.github.io/blog/2020/07/31/Java并发编程基础/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/07/30/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/" rel="prev" title="原子操作类">
      <i class="fa fa-chevron-left"></i> 原子操作类
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/08/28/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AF%BC%E8%AE%BA/" rel="next" title="性能调优导论">
      性能调优导论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89"><span class="nav-text">一、线程基本含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.1、Java线程与操作系统线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-text">1.2、线程对应的数据结构和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-text">1.2.1、线程组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">1.2.2、线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3%E3%80%81%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.2.3、是否为后台线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8D%E5%AD%97"><span class="nav-text">1.2.4、线程名字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5%E3%80%81target"><span class="nav-text">1.2.5、target</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E5%8A%A8%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">二、线程常见动作方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E7%A7%BB"><span class="nav-text">三、线程状态与转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">3.1、Java线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E6%8C%82%E8%B5%B7-RUNNABLE%E7%9A%84%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.2、挂起 &lt;-&gt; RUNNABLE的转移条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1%E3%80%81Thread-sleep%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.1、Thread.sleep方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2%E3%80%81synchronized%E6%96%B9%E6%B3%95-%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-text">3.2.2、synchronized方法&#x2F;语句块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3%E3%80%81Object%E7%B1%BB%E7%9A%84wait-notify-notifyAll%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.3、Object类的wait&#x2F;notify&#x2F;notifyAll实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-1%E3%80%81wait-%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.3.1、wait()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-2%E3%80%81wait-long-timeout-%E5%92%8Cwait-long-timeout-int-nanos-%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.3.2、wait(long timeout)和wait(long timeout, int nanos)方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4%E3%80%81Thread%E7%B1%BB%E7%9A%84join%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.4、Thread类的join实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5%E3%80%81LockSupport%E7%B1%BB%E7%9A%84park-parkNanos-long-nanos-parkUtil-long-deadline-unpark-Thread-thread-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.5、LockSupport类的park()&#x2F;parkNanos(long nanos)&#x2F;parkUtil(long deadline)&#x2F;unpark(Thread thread)类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-1%E3%80%81park-%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.5.1、park()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-5-2%E3%80%81parkNanos-long-nanos-%E5%92%8CparkUntil-long-deadline"><span class="nav-text">3.2.5.2、parkNanos(long nanos)和parkUntil(long deadline)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6%E3%80%81Condition%E6%8E%A5%E5%8F%A3%E7%9A%84await-awaitUninterruptibly-await-long-time-TimeUnit-unit-awaitNano-long-nanosTimeout-awaitUntil-Date-deadline-signal-signalAll-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.6、Condition接口的await()&#x2F;awaitUninterruptibly()&#x2F;await(long time, TimeUnit unit)&#x2F;awaitNano(long nanosTimeout)&#x2F;awaitUntil(Date deadline)&#x2F;signal()&#x2F;signalAll()实例方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD"><span class="nav-text">四、中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E9%92%88%E5%AF%B9Thread%E7%B1%BB%E7%9A%84sleep%E6%96%B9%E6%B3%95"><span class="nav-text">4.1、针对Thread类的sleep方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1%E3%80%81%E5%90%8E%E5%BA%8F"><span class="nav-text">4.1.1、后序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2%E3%80%81%E5%85%88%E5%BA%8F"><span class="nav-text">4.1.2、先序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E9%92%88%E5%AF%B9Object%E7%B1%BB%E7%9A%84wait%E6%96%B9%E6%B3%95"><span class="nav-text">4.2、针对Object类的wait方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E3%80%81%E5%90%8E%E5%BA%8F"><span class="nav-text">4.2.1、后序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2%E3%80%81%E5%85%88%E5%BA%8F"><span class="nav-text">4.2.2、先序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E3%80%81%E9%92%88%E5%AF%B9LockSupport%E7%B1%BB%E7%9A%84park-parkNanos-long-nanos-parkUtil-long-deadline-%E6%96%B9%E6%B3%95"><span class="nav-text">4.3、针对LockSupport类的park()&#x2F;parkNanos(long nanos)&#x2F;parkUtil(long deadline)方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E3%80%81%E5%90%8E%E5%BA%8F"><span class="nav-text">4.3.1、后序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2%E3%80%81%E5%85%88%E5%BA%8F"><span class="nav-text">4.3.2、先序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81"><span class="nav-text">五、死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E7%8B%AD%E4%B9%89"><span class="nav-text">5.1、狭义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E5%B9%BF%E4%B9%89"><span class="nav-text">5.2、广义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-text">六、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E3%80%81%E6%8C%82%E8%B5%B7%E7%BA%BF%E7%A8%8BT0%E8%A2%AB%E7%BA%BF%E7%A8%8BT1%E5%94%A4%E9%86%92%E7%9A%84%E8%B7%A8%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">6.1、挂起线程T0被线程T1唤醒的跨线程内存可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E3%80%81%E6%83%AF%E7%94%A8%E6%B3%95"><span class="nav-text">6.2、惯用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">6.3、垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4%E3%80%81main%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-text">6.4、main主线程与普通线程的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5%E3%80%81%E7%BA%BF%E7%A8%8B%E5%86%85%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">6.5、线程内异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1%E3%80%81%E5%BC%82%E5%B8%B8%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%86%85%E8%A2%ABcatch%E4%BD%8F"><span class="nav-text">6.5.1、异常在线程内被catch住</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2%E3%80%81%E5%BC%82%E5%B8%B8%E6%9C%AA%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%86%85%E8%A2%ABcatch%E4%BD%8F"><span class="nav-text">6.5.2、异常未在线程内被catch住</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6%E3%80%81%E8%B0%83%E7%94%A8Object-wait%E6%88%96%E8%80%85Thread-join%E6%96%B9%E6%B3%95%E6%8C%82%E8%B5%B7%E6%9F%A5%E7%9C%8B%E6%89%80%E6%89%93%E5%8D%B0jstack%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dslztx"
      src="/blog/images/head.png">
  <p class="site-author-name" itemprop="name">dslztx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">327</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">专题</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dslztx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://httpsdslztxgithubioblog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://dslztx.github.io/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/";
    this.page.identifier = "2020/07/31/Java并发编程基础/";
    this.page.title = "Java并发编程基础";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://httpsdslztxgithubioblog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
