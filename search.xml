<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>12种基础死活棋形</title>
    <url>/blog/2023/11/19/12%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%AD%BB%E6%B4%BB%E6%A3%8B%E5%BD%A2/</url>
    <content><![CDATA[<p>棋形，是棋子在棋盘上组合成的各种形状。<br>本文介绍12种基础死活棋形，包括：两种死形，四种活形，六种半死不活形。</p>
<br/>

<p>在介绍之前先作两点说明：</p>
<ol>
<li>双方都按照最强落子原则进行探讨，否则毫无实际意义</li>
<li>本文案例讨论中以黑棋为守方，白棋为攻方。故：<ul>
<li>黑子的目标是：尽量能做活</li>
<li>白子的目标是：尽量能阻止黑棋做活</li>
</ul>
</li>
</ol>
<h2 id="一、死活棋形"><a href="#一、死活棋形" class="headerlink" title="一、死活棋形"></a><strong>一、死活棋形</strong></h2><h3 id="1-1、死形"><a href="#1-1、死形" class="headerlink" title="1.1、死形"></a><strong>1.1、死形</strong></h3><p>守方必不能做活，故“攻守双方都无需落子”。</p>
<h4 id="1-1-1、直二"><a href="#1-1-1、直二" class="headerlink" title="1.1.1、直二"></a><strong>1.1.1、直二</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-1.svg width=30% height=30% />


<p>具体分析过程分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必不能做活。</p>
<p><strong>2、白先</strong><br>黑必不能做活。</p>
<h4 id="1-1-2、方四"><a href="#1-1-2、方四" class="headerlink" title="1.1.2、方四"></a><strong>1.1.2、方四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-2.svg width=30% height=30% />


<p>具体分析过程（中心对称，基于A点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必不能做活：</p>
<ol>
<li><del>黑A -&gt; 白D：黑做活失败</del></li>
<li><del>[与1对称]黑B -&gt; 白C：黑做活失败</del></li>
<li><del>[与1对称]黑C -&gt; 白B：黑做活失败</del></li>
<li><del>[与1对称]黑D -&gt; 白A：黑做活失败</del></li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活：无需先落子，黑落子后必能按照“1、黑先”小节阻止黑做活。</p>
<h3 id="1-2、活形"><a href="#1-2、活形" class="headerlink" title="1.2、活形"></a><strong>1.2、活形</strong></h3><p>守方必能做活，故“攻守双方都无需落子”。</p>
<h4 id="1-2-1、直四"><a href="#1-2-1、直四" class="headerlink" title="1.2.1、直四"></a><strong>1.2.1、直四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-3.svg width=30% height=30% />


<p>具体分析过程（轴对称，基于A和B点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 直三且白先：黑做活失败</del></li>
<li><del>[与1对称]黑D -&gt; 直三且白先：黑做活失败</del></li>
<li>黑B：黑做活成功</li>
<li>[与3对称]黑C：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必能做活（没有一种下法能够成功阻止做活）：</p>
<ol>
<li><del>白A -&gt; 黑B&#x2F;C：阻止黑做活失败</del></li>
<li><del>[与1对称]白D -&gt; 黑B&#x2F;C：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与3对称]白C -&gt; 黑B：阻止黑做活失败</del></li>
</ol>
<h4 id="1-2-2、曲四"><a href="#1-2-2、曲四" class="headerlink" title="1.2.2、曲四"></a><strong>1.2.2、曲四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-5.svg width=30% height=30% />


<p>具体分析过程分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 直三且白先：黑做活失败</del></li>
<li>黑B -&gt; 白C&#x2F;D：黑做活成功</li>
<li>黑C -&gt; 白A&#x2F;B：黑做活成功</li>
<li><del>黑D -&gt; 弯三且白先：黑做活失败</del></li>
</ol>
<p><strong>2、白先</strong><br>黑必能做活（没有一种下法能够成功阻止做活）：</p>
<ol>
<li><del>白A -&gt; 黑B：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>白C -&gt; 黑B：阻止黑做活失败</del></li>
<li><del>白D -&gt; 黑C：阻止黑做活失败</del></li>
</ol>
<h4 id="1-2-3、闪电四"><a href="#1-2-3、闪电四" class="headerlink" title="1.2.3、闪电四"></a><strong>1.2.3、闪电四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-4.svg width=30% height=30% />


<p>具体分析过程（中心对称，基于A和B点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 弯三棋形且白先：黑做活失败</del></li>
<li><del>[与1对称]黑D -&gt; 弯三棋形且白先：黑做活失败</del></li>
<li>黑B：黑做活成功</li>
<li>[与3对称]黑C：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必能做活（没有一种下法能够成功阻止做活）：</p>
<ol>
<li><del>白A -&gt; 黑B&#x2F;C：阻止黑做活失败</del></li>
<li><del>[与1对称]白D -&gt; 黑C&#x2F;B：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与3对称]白C -&gt; 黑B：阻止黑做活失败</del></li>
</ol>
<h4 id="1-2-4、板六"><a href="#1-2-4、板六" class="headerlink" title="1.2.4、板六"></a><strong>1.2.4、板六</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-6.svg width=30% height=30% />


<p>具体分析过程（中心对称，基于A和B点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 刀把五且白先：黑做活失败</del></li>
<li><del>[与1对称]黑C -&gt; 刀把五且白先：黑做活失败</del></li>
<li><del>[与1对称]黑D -&gt; 刀把五且白先：黑做活失败</del></li>
<li><del>[与1对称]黑F -&gt; 刀把五且白先：黑做活失败</del></li>
<li>黑B：黑做活成功</li>
<li>[与5对称]黑E：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必能做活（没有一种下法能够成功阻止做活）：</p>
<ol>
<li><del>白A -&gt; 黑B&#x2F;E：阻止黑做活失败</del></li>
<li><del>[与1对称]白C -&gt; 黑B&#x2F;E：阻止黑做活失败</del></li>
<li><del>[与1对称]白D -&gt; 黑B&#x2F;E：阻止黑做活失败</del></li>
<li><del>[与1对称]白F -&gt; 黑B&#x2F;E：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑E：阻止黑做活失败</del></li>
<li><del>[与5对称]白E -&gt; 黑B：阻止黑做活失败</del></li>
</ol>
<h3 id="1-3、半死不活形"><a href="#1-3、半死不活形" class="headerlink" title="1.3、半死不活形"></a><strong>1.3、半死不活形</strong></h3><p>守方先落子，存在一种下法能成功做活；攻方先落子，存在一种下法能够成功阻止做活。</p>
<h4 id="1-3-1、直三"><a href="#1-3-1、直三" class="headerlink" title="1.3.1、直三"></a><strong>1.3.1、直三</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-7.svg width=30% height=30% />

<p>结论：抢B点——守方抢到B，成功做活；攻方抢到B，成功阻止做活。</p>
<p>具体分析过程（轴对称，基于A和B点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A：黑做活失败</del></li>
<li><del>[与1对称]黑C：黑做活失败</del></li>
<li>黑B：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A -&gt; 黑B：阻止黑做活失败</del></li>
<li><del>[与1对称]白C -&gt; 黑B：阻止黑做活失败</del></li>
<li>白B：阻止黑做活成功</li>
</ol>
<h4 id="1-3-2、弯三"><a href="#1-3-2、弯三" class="headerlink" title="1.3.2、弯三"></a><strong>1.3.2、弯三</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-8.svg width=30% height=30% />

<p>结论：抢B点——守方抢到B，成功做活；攻方抢到B，成功阻止做活。</p>
<p>具体分析过程（轴对称，基于A和B点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A：黑做活失败</del></li>
<li><del>[与1对称]黑C：黑做活失败</del></li>
<li>黑B：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A -&gt; 黑B：阻止黑做活失败</del></li>
<li><del>[与1对称]白C -&gt; 黑B：阻止黑做活失败</del></li>
<li>白B：阻止黑做活成功</li>
</ol>
<h4 id="1-3-3、丁四"><a href="#1-3-3、丁四" class="headerlink" title="1.3.3、丁四"></a><strong>1.3.3、丁四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-9.svg width=30% height=30% />

<p>结论：抢C点——守方抢到C，成功做活；攻方抢到C，成功阻止做活。</p>
<p>具体分析过程（轴对称，基于A、B和C点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 直三且白先：黑做活失败</del></li>
<li><del>黑B -&gt; 弯三且白先：黑做活失败</del></li>
<li><del>[与2对称]黑D -&gt; 弯三且白先：黑做活失败</del></li>
<li>黑C：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与2对称]白D -&gt; 黑C：阻止黑做活失败</del></li>
<li>白C：阻止黑做活成功</li>
</ol>
<h4 id="1-3-4、刀把五"><a href="#1-3-4、刀把五" class="headerlink" title="1.3.4、刀把五"></a><strong>1.3.4、刀把五</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-10.svg width=30% height=30% />

<p>结论：攻方先，抢到B点（刀把），成功阻止做活；守方先，抢到A、B和E点，成功做活。<font color='red'>为了减少记忆成本，把关键点统一记为B</font>。</p>
<p>具体分析过程分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li>黑A -&gt; 闪电四活形：黑做活成功</li>
<li>黑B：黑做活成功</li>
<li><del>黑C -&gt; 方四：黑做活失败</del></li>
<li><del>黑D -&gt; 丁四且白先：黑做活失败</del></li>
<li>黑E -&gt; 曲四活形：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A&#x2F;D&#x2F;E&#x2F;C -&gt; 黑B：阻止黑做活失败</del></li>
<li>白B：阻止黑做活成功</li>
</ol>
<h4 id="1-3-5、梅花五"><a href="#1-3-5、梅花五" class="headerlink" title="1.3.5、梅花五"></a><strong>1.3.5、梅花五</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-11.svg width=30% height=30% />

<p>结论：攻方先，抢到C点，成功阻止做活；守方先，抢到C点，成功做活。</p>
<p>具体分析过程（轴对称，基于A和C点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li><del>黑A -&gt; 白C：黑做活失败</del></li>
<li><del>[与1对称]黑B -&gt; 白C：黑做活失败</del></li>
<li><del>[与1对称]黑D -&gt; 白C：黑做活失败</del></li>
<li><del>[与1对称]黑E -&gt; 白C：黑做活失败</del></li>
<li>黑C：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与1对称]白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与1对称]白D -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>[与1对称]白E -&gt; 黑C：阻止黑做活失败</del></li>
<li>白C：阻止黑做活成功</li>
</ol>
<h4 id="1-3-6、葡萄六"><a href="#1-3-6、葡萄六" class="headerlink" title="1.3.6、葡萄六"></a><strong>1.3.6、葡萄六</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-12.svg width=30% height=30% />

<p>结论：攻方先，抢到D点，成功阻止做活；守方先，抢到A、D和E点，成功做活。<font color='red'>为了减少记忆成本，把关键点统一记为D</font>。</p>
<p>具体分析过程（轴对称，基于A、B、C和D点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li>黑A：黑做活成功</li>
<li>[与1对称]黑E：黑做活成功</li>
<li><del>黑B -&gt; 梅花五且白先：黑做活失败</del></li>
<li><del>黑C -&gt; 刀把五且白先：黑做活失败</del></li>
<li><del>[与4对称]黑F -&gt; 刀把五且白先：黑做活失败</del></li>
<li>黑D：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li><del>白A&#x2F;B&#x2F;C&#x2F;E&#x2F;F -&gt; 黑D：阻止黑做活失败</del></li>
<li>白D：阻止黑做活成功</li>
</ol>
<h2 id="二、死活棋形之劫材"><a href="#二、死活棋形之劫材" class="headerlink" title="二、死活棋形之劫材"></a><strong>二、死活棋形之劫材</strong></h2><p>劫材再回顾下是“彼之弱点，我之劫材”。</p>
<h3 id="2-1、死形"><a href="#2-1、死形" class="headerlink" title="2.1、死形"></a><strong>2.1、死形</strong></h3><p>死形的劫材如果存在必属于守方：<code>守方落子 -&gt; 攻方必须应劫，否则守方做活成功</code>。</p>
<h4 id="2-1-1、直二"><a href="#2-1-1、直二" class="headerlink" title="2.1.1、直二"></a><strong>2.1.1、直二</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-1.svg width=30% height=30% />

<p>结论：守方无劫材。</p>
<h4 id="2-1-2、方四"><a href="#2-1-2、方四" class="headerlink" title="2.1.2、方四"></a><strong>2.1.2、方四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-2.svg width=30% height=30% />

<p>结论：A、B、C和D四个点都是守方的劫材。</p>
<p>具体分析过程：</p>
<ol>
<li>黑A -&gt; 白必须应劫落子D，否则黑做活成功</li>
<li>黑B -&gt; 白必须应劫落子C，否则黑做活成功</li>
<li>黑C -&gt; 白必须应劫落子B，否则黑做活成功</li>
<li>黑D -&gt; 白必须应劫落子A，否则黑做活成功</li>
</ol>
<h3 id="2-2、活形"><a href="#2-2、活形" class="headerlink" title="2.2、活形"></a><strong>2.2、活形</strong></h3><p>活形的劫材如果存在必属于攻方：<code>攻方落子 -&gt; 守方必须应劫，否则攻方阻止做活成功</code>。</p>
<h4 id="2-2-1、直四"><a href="#2-2-1、直四" class="headerlink" title="2.2.1、直四"></a><strong>2.2.1、直四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-3.svg width=30% height=30% />

<p>结论：B和C两个点是攻方的劫材。</p>
<p>具体分析：</p>
<ol>
<li><del>白A -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与1对称]白D -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li>白B -&gt; 黑须立即落子C应对：是白的劫材</li>
<li>[与3对称]白C -&gt; 黑须立即落子B应对：是白的劫材</li>
</ol>
<h4 id="2-2-2、曲四"><a href="#2-2-2、曲四" class="headerlink" title="2.2.2、曲四"></a><strong>2.2.2、曲四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-4.svg width=30% height=30% />

<p>结论：B和C两个点是攻方的劫材。</p>
<p>具体分析：</p>
<ol>
<li><del>白A -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li>白B -&gt; 黑须立即落子C应对：是白的劫材</li>
<li>[与2对称]白C -&gt; 黑须立即落子B应对：是白的劫材</li>
<li><del>[与1对称]白D -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
</ol>
<h4 id="2-2-3、闪电四"><a href="#2-2-3、闪电四" class="headerlink" title="2.2.3、闪电四"></a><strong>2.2.3、闪电四</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-5.svg width=30% height=30% />

<p>结论：B和C两个点是攻方的劫材。</p>
<p>具体分析：</p>
<ol>
<li><del>白A -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li>白B -&gt; 黑须立即落子C应对：是白的劫材</li>
<li>白C -&gt; 黑须立即落子B应对：是白的劫材</li>
<li><del>白D -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
</ol>
<h4 id="2-2-4、板六"><a href="#2-2-4、板六" class="headerlink" title="2.2.4、板六"></a><strong>2.2.4、板六</strong></h4><img src=https://blog.dslztx.top/imgs/20231119-0-6.svg width=30% height=30% />

<p>结论：B和E两个点是攻方的劫材。</p>
<p>具体分析：</p>
<ol>
<li><del>白A -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与1对称]白C -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与1对称]白D -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与1对称]白F -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li>白B -&gt; 黑须立即落子C应对：是白的劫材</li>
<li>[与5对称]白E -&gt; 黑须立即落子B应对：是白的劫材</li>
</ol>
<h3 id="2-3、半死不活形"><a href="#2-3、半死不活形" class="headerlink" title="2.3、半死不活形"></a><strong>2.3、半死不活形</strong></h3><p>按照劫材定义——“逼迫对方应对”，半死不活形没有劫材，因为：</p>
<ol>
<li>守方先<ul>
<li>如果抢占做活关键点成功做活，无法逼迫对方应对</li>
<li>如果不下做活关键点只能引诱（而不是逼迫）攻方抢占关键点阻止做活</li>
</ul>
</li>
<li>攻方先<ul>
<li>如果抢占做活关键点成功阻止做活，无法逼迫对方应对</li>
<li>如果不下做活关键点引诱（而不是逼迫）守方抢占关键点成功做活</li>
</ul>
</li>
</ol>
<p>但是也可将劫材定义广义化，将以上引诱作为劫材情形。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h2><table>
<thead>
<tr>
<th>棋形</th>
<th>死活类型</th>
<th>守方</th>
<th>攻方</th>
<th>劫材</th>
</tr>
</thead>
<tbody><tr>
<td>直二</td>
<td>死形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>不存在属于守方的劫材点</td>
</tr>
<tr>
<td>方四</td>
<td>死形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>4个点都是守方的劫材点</td>
</tr>
<tr>
<td>直四</td>
<td>活形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>中间两个点是攻方的劫材点</td>
</tr>
<tr>
<td>曲四</td>
<td>活形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>中间两个点是攻方的劫材点</td>
</tr>
<tr>
<td>闪电四</td>
<td>活形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>中间两个点是攻方的劫材点</td>
</tr>
<tr>
<td>板六</td>
<td>活形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>中间两个点是攻方的劫材点</td>
</tr>
<tr>
<td>直三</td>
<td>半死不活形</td>
<td>立即做活，关键点是中央点位</td>
<td>立即阻止做活，关键点是中央点位</td>
<td>关键点是广义的劫材点</td>
</tr>
<tr>
<td>弯三</td>
<td>半死不活形</td>
<td>立即做活，关键点是中央点位</td>
<td>立即阻止做活，关键点是中央点位</td>
<td>关键点是广义的劫材点</td>
</tr>
<tr>
<td>丁四</td>
<td>半死不活形</td>
<td>立即做活，关键点是中央点位</td>
<td>立即阻止做活，关键点是中央点位</td>
<td>关键点是广义的劫材点</td>
</tr>
<tr>
<td>刀把五</td>
<td>半死不活形</td>
<td>立即做活，关键点是刀把点位</td>
<td>立即阻止做活，关键点是刀把点位</td>
<td>关键点是广义的劫材点</td>
</tr>
<tr>
<td>梅花五</td>
<td>半死不活形</td>
<td>立即做活，关键点是中央点位</td>
<td>立即阻止做活，关键点是中央点位</td>
<td>关键点是广义的劫材点</td>
</tr>
<tr>
<td>葡萄六</td>
<td>半死不活形</td>
<td>立即做活，关键点是中央点位</td>
<td>立即阻止做活，关键点是中央点位</td>
<td>关键点是广义的劫材点</td>
</tr>
</tbody></table>
<p>一句助记口头禅</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直二方四立即死</span><br><span class="line">直四曲四闪电四，还有板六也是活</span><br><span class="line">刀五花五葡萄六，直三弯三丁四半</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://mp.weixin.qq.com/s/Ee87tmop4fto1IN28Rom-Q">https://mp.weixin.qq.com/s/Ee87tmop4fto1IN28Rom-Q</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>3个JDK最好一致</title>
    <url>/blog/2019/05/20/3%E4%B8%AAJDK%E6%9C%80%E5%A5%BD%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p>3个JDK（源码所使用JDK，目标运行平台JDK，编译所使用JDK）最好一致，以避免一些奇怪的异常或者错误。</p>
<h2 id="一、3个JDK不一致导致抛出NoClassDefFoundError异常的一种情形"><a href="#一、3个JDK不一致导致抛出NoClassDefFoundError异常的一种情形" class="headerlink" title="一、3个JDK不一致导致抛出NoClassDefFoundError异常的一种情形"></a><strong>一、3个JDK不一致导致抛出NoClassDefFoundError异常的一种情形</strong></h2><p>实验代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;String, AtomicInteger&gt; domainCounts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        main.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> domainCounts.keySet().iterator(); ((Iterator)iterator).hasNext();) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> (String)iterator.next();</span><br><span class="line"></span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令为<code>~/jdk1.8/bin/javac -source 1.6 -target 1.6 Main.java</code>，运行命令为<code>~/jdk1.6/bin/java Main</code>，抛出异常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</span><br><span class="line">        at Main.f(Main.java:15)</span><br><span class="line">        at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure>
<p>执行<code>javap -v Main</code>命令，发现<code>f()</code>方法对应的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void f();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #4                  // Field domainCounts:Ljava/util/concurrent/ConcurrentHashMap;</span><br><span class="line">         4: invokevirtual #8                  // Method java/util/concurrent/ConcurrentHashMap.keySet:()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</span><br><span class="line">         7: invokevirtual #9                  // Method java/util/concurrent/ConcurrentHashMap$KeySetView.iterator:()Ljava/util/Iterator;</span><br><span class="line">        10: astore_1</span><br><span class="line">        11: aload_1</span><br><span class="line">        12: invokeinterface #10,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z</span><br><span class="line">        17: ifeq          40</span><br><span class="line">        20: aload_1</span><br><span class="line">        21: invokeinterface #11,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">        26: checkcast     #12                 // class java/lang/String</span><br><span class="line">        29: astore_2</span><br><span class="line">        30: getstatic     #13                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        33: aload_2</span><br><span class="line">        34: invokevirtual #14                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        37: goto          11</span><br><span class="line">        40: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">        line 16: 20</span><br><span class="line">        line 18: 30</span><br><span class="line">        line 19: 37</span><br><span class="line">        line 20: 40</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 252 /* append */</span><br><span class="line">          offset_delta = 11</span><br><span class="line">          locals = [ class java/util/Iterator ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 28</span><br></pre></td></tr></table></figure>
<p>查看上述内容，可发现绑定到了属于JDK1.8的<code>java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView</code>，从而可知在使用JDK1.8编译的时候，一些特定于JDK1.8的依赖信息被写入到了CLASS文件中（<font color='red'>笔者认为这是JDK1.8中javac命令实现的bug，因为我们指定了<code>-target 1.6</code>，自然期待的结果应该是特定于JDK1.6的依赖信息被写入到CLASS文件中</font>），这最终导致了当运行于JDK1.6目标平台时会抛出<code>java.lang.NoClassDefFoundError</code>异常。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>7zr命令</title>
    <url>/blog/2017/08/24/7zr%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、安装工具"><a href="#一、安装工具" class="headerlink" title="一、安装工具"></a><strong>一、安装工具</strong></h2><p>Ubuntu下使用如下命令安装7zr命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install p7zip</span><br></pre></td></tr></table></figure>
<h2 id="二、使用工具"><a href="#二、使用工具" class="headerlink" title="二、使用工具"></a><strong>二、使用工具</strong></h2><h3 id="2-1、创建7z压缩包"><a href="#2-1、创建7z压缩包" class="headerlink" title="2.1、创建7z压缩包"></a><strong>2.1、创建7z压缩包</strong></h3><p>命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7zr a 压缩包名称.7z 待压缩文件/目录</span><br></pre></td></tr></table></figure>
<h3 id="2-2、解压7z压缩包"><a href="#2-2、解压7z压缩包" class="headerlink" title="2.2、解压7z压缩包"></a><strong>2.2、解压7z压缩包</strong></h3><p>命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7zr x 压缩包名称.7z</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man 7zr
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/blog/2021/04/02/AQS/</url>
    <content><![CDATA[<h2 id="一、基本含义"><a href="#一、基本含义" class="headerlink" title="一、基本含义"></a><strong>一、基本含义</strong></h2><p>AQS，指代<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>类，中文名为“队列同步器”，它是实现J.U.C包中几个高级组件（比如“ReentrantLock”，“ReentrantReadWriteLock”，“CountDownLatch”，“Semaphore”等）的核心辅助类。</p>
<p>设计AQS面向的问题是：多线程竞争临界资源（即<code>private volatile int state</code>），竞争失败的线程进入队列排队。</p>
<p>另外有一个类<code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</code>，它与<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>相比，核心差异在于：其临界资源是<code>private volatile long state</code>。</p>
<h2 id="二、源码阅读"><a href="#二、源码阅读" class="headerlink" title="二、源码阅读"></a><strong>二、源码阅读</strong></h2><p>笔者对于AQS源码的理解程度只是概貌程度，远没有到细节，关于这点有以下几点说明：</p>
<ul>
<li>看源码时，以看懂大致内容为主，学习其设计的思路，不要陷入所有条件的处理细节中。尤其是在多线程环境中，对与错有时候并不是那么容易看出来的</li>
<li>AQS中的临界资源获取方法，比如“acquire(int arg)”，其本质其实就是“乐观锁实现悲观锁”，而“乐观锁”的实现本就较难理解</li>
<li>内存可见性语义确保是通过“volatile变量”，“Unsafe类的CAS操作”，“final变量”等机制获得的</li>
</ul>
<h3 id="2-1、state"><a href="#2-1、state" class="headerlink" title="2.1、state"></a><strong>2.1、state</strong></h3><p>表征临界资源。</p>
<h3 id="2-2、队列"><a href="#2-2、队列" class="headerlink" title="2.2、队列"></a><strong>2.2、队列</strong></h3><h4 id="2-2-1、队列节点"><a href="#2-2-1、队列节点" class="headerlink" title="2.2.1、队列节点"></a><strong>2.2.1、队列节点</strong></h4><p>队列节点定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AbstractQueuedSynchronizer.<span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractQueuedSynchronizer</span>.Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AbstractQueuedSynchronizer.<span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> AbstractQueuedSynchronizer.Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> AbstractQueuedSynchronizer.Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    AbstractQueuedSynchronizer.Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    Node() &#123; <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, AbstractQueuedSynchronizer.Node mode) &#123; <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AbstractQueuedSynchronizer.Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        AbstractQueuedSynchronizer.<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、3种类型队列</strong><br>3种类型队列共用以上队列节点定义。</p>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>waitStatus</th>
<th>prev</th>
<th>next</th>
<th>thread</th>
<th>nextWaiter</th>
</tr>
</thead>
<tbody><tr>
<td>排他锁申请等待队列</td>
<td>!&#x3D;Node.CONDITION</td>
<td>前导节点</td>
<td>后导节点</td>
<td>关联的线程实例对象</td>
<td>Node.EXCLUSIVE</td>
</tr>
<tr>
<td>共享锁申请等待队列</td>
<td>!&#x3D;Node.CONDITION</td>
<td>前导节点</td>
<td>后导节点</td>
<td>关联的线程实例对象</td>
<td>Node.SHARED</td>
</tr>
<tr>
<td>AWAIT调用等待队列</td>
<td>&#x3D;&#x3D;Node.CONDITION</td>
<td>空</td>
<td>空</td>
<td>关联的线程实例对象</td>
<td>后导节点</td>
</tr>
</tbody></table>
<p><strong>2、prev和next</strong><br>用于表征队列节点之间的关系（除了AWAIT调用等待队列），prev指针是准确的，next指针不一定准确，但是next不准确时只可能是以下两种不准确值：</p>
<ul>
<li>NULL。<code>cancelAcquire</code>方法和<code>enq</code>方法可能出现一种并发执行情形：<code>cancelAcquire</code>方法中语句<code>node == tail &amp;&amp; compareAndSetTail(node, pred)</code>和<code>enq</code>方法中的<code>compareAndSetTail(t, node)</code>语句执行结果都为<code>true</code>，然后<code>compareAndSetNext(pred, predNext, null);</code>又后于<code>t.next = node;</code>执行，导致次尾节点的<code>next</code>字段值被错误地置为<code>NULL</code></li>
<li>指向的<code>Node.waitStatus &gt; 0</code>，即处于<code>CANCELLED</code>状态。在<code>cancelAcquire</code>方法中，可能不进入<code>unparkSuccessor(node);</code>分支，此时<code>pred</code>节点的<code>next</code>字段值未得到更新，可能指向<code>waitStatus &gt; 0</code>的节点</li>
</ul>
<p><strong>3、thread</strong><br>关联的线程实例对象。</p>
<h4 id="2-2-2、head和tail"><a href="#2-2-2、head和tail" class="headerlink" title="2.2.2、head和tail"></a><strong>2.2.2、head和tail</strong></h4><p>head和tail分别表示排他锁申请等待队列&#x2F;共享锁申请等待队列的队列头节点和尾节点（AWAIT调用等待队列的队列头和尾节点不由head&#x2F;tail表示，而是由AbstractQueuedSynchronizer.ConditionObject类中的<code>firstWaiter/lastWaiter</code>表示）：</p>
<ul>
<li>初始化时，head和tail都为NULL，只有产生线程竞争需要加入队列节点时才进行队列初始化，即惰性生成，此时<code>head=tail=new Node()</code></li>
<li>当head&#x3D;tail时（值可以是NULL，也可以是非NULL），表示队列为空</li>
<li>当线程T1持有锁时，<code>head或者为空；或者不为空，此时该head节点即表征T1，虽然thread和prev字段会被置为NULL</code>；反过来，<code>当head为空或者不为空，是否有线程持有锁都是不确定的</code></li>
</ul>
<h3 id="2-3、方法"><a href="#2-3、方法" class="headerlink" title="2.3、方法"></a><strong>2.3、方法</strong></h3><p>方法分为3类：</p>
<ul>
<li>辅助方法</li>
<li>核心方法</li>
<li>核心方法变种</li>
</ul>
<h4 id="2-3-1、核心方法"><a href="#2-3-1、核心方法" class="headerlink" title="2.3.1、核心方法"></a><strong>2.3.1、核心方法</strong></h4><p>核心方法涵盖“获取”和“释放”两部分，又根据“排他竞争临界资源&#x2F;共享竞争临界资源”可分为两类。<br><strong>1、“排他竞争临界资源”核心方法</strong><br><strong>获取</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>释放</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码理解</strong>：</p>
<ul>
<li>在这里，<code>tryAcquire(int arg)</code>和<code>tryRelease(int arg)</code>方法直接抛出异常，真正的逻辑在子类实现，故本质上采用模板方法设计模式</li>
<li>获取逻辑流程可描述为：<ol start="0">
<li>调用tryAcquire方法进行尝试，成功即退出；否则添加一个对应的队列节点，进入下述循环</li>
<li>循环：调用tryAcquire方法进行尝试，成功退出；否则，如果满足挂起条件则挂起等待被唤醒（唤醒后仍然回到循环开头），不满足挂起条件则回退到循环开头</li>
</ol>
</li>
<li>释放逻辑流程可描述为：如果释放成功，并且当前线程有对应的队列节点且节点的<code>waitStatus!=0</code>，则尝试唤醒队列的下一个节点</li>
<li>Node节点中<code>waitStatus</code>字段存在<code>SIGNAL</code>值的必要性在于：用于协调“获取方法中的线程挂起”和“释放方法中的线程唤醒”操作，确保挂起会被唤醒</li>
</ul>
<p><strong>2、“共享竞争临界资源”核心方法</strong><br>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码理解</strong>：</p>
<ul>
<li>在这里，<code>tryAcquireShared(int arg)</code>和<code>tryReleaseShared(int arg)</code>方法直接抛出异常，真正的逻辑在子类实现，故本质上采用模板方法设计模式</li>
<li>获取逻辑流程可描述为：<ol start="0">
<li>调用tryAcquireShared方法进行尝试，成功即退出；否则添加一个对应的队列节点，进入下述循环</li>
<li>循环：调用tryAcquireShared方法进行尝试，成功（这里跟<code>1、“排他竞争临界资源”核心方法</code>小节不一样的是，在以共享模式竞争到临界资源后，会尝试唤醒队列中所有等待进行共享竞争的节点，即调用<code>setHeadAndPropagate</code>方法，这是一个贪心优化）退出；否则，如果满足挂起条件则挂起等待被唤醒（唤醒后仍然回到循环开头），不满足挂起条件则回退到循环开头</li>
</ol>
</li>
<li>释放逻辑流程可描述为：如果释放成功，尝试唤醒队列中后续节点</li>
<li>Node节点中<code>waitStatus</code>字段存在<code>SIGNAL</code>值的必要性在于：用于协调“获取方法中的线程挂起”和“释放方法中的线程唤醒”操作，确保挂起会被唤醒</li>
</ul>
<h4 id="2-3-2、核心方法变种"><a href="#2-3-2、核心方法变种" class="headerlink" title="2.3.2、核心方法变种"></a><strong>2.3.2、核心方法变种</strong></h4><p>根据以上内容知，核心方法涵盖“获取”和“释放”两部分，变种存在于“获取”部分。</p>
<p><strong>1、“排他竞争临界资源”核心方法变种</strong><br><strong>原获取核心方法</strong>：<code>acquire -&gt; tryAcquire,acquireQueued</code>。在获取锁等待挂起过程中，遇到中断信号，不抛出<code>InterruptedException</code>异常，在获取到锁之后，再自调用中断方法。</p>
<p><strong>获取核心方法变种1</strong>：<code>acquireInterruptibly -&gt; tryAcquire,doAcquireInterruptibly</code>。在获取锁等待挂起过程中，遇到中断信号，直接抛出<code>InterruptedException</code>异常。</p>
<p><strong>获取核心方法变种2</strong>：<code>tryAcquireNanos -&gt; tryAcquire,doAcquireNanos</code>。在至多指定时间内尝试获取锁，如果时间超期仍然未成功则直接失败；在整个过程中，遇到中断信号，直接抛出<code>InterruptedException</code>异常。另外，<code>tryAcquireNanos</code>方法的名字取的易混淆。</p>
<p><strong>2、“共享竞争临界资源”核心方法变种</strong><br><strong>原获取核心方法</strong>：<code>acquireShared -&gt; tryAcquireShared,doAcquireShared</code>。在获取锁等待挂起过程中，遇到中断信号，不抛出<code>InterruptedException</code>异常，在获取到锁之后，再自调用中断方法。</p>
<p><strong>获取核心方法变种1</strong>：<code>acquireSharedInterruptibly -&gt; tryAcquireShared,doAcquireSharedInterruptibly</code>。在获取锁等待挂起过程中，遇到中断信号，直接抛出<code>InterruptedException</code>异常。</p>
<p><strong>获取核心方法变种2</strong>：<code>tryAcquireSharedNanos -&gt; tryAcquireShared,doAcquireSharedNanos</code>。在至多指定时间内尝试获取锁，如果时间超期仍然未成功则直接失败；在整个过程中，遇到中断信号，直接抛出<code>InterruptedException</code>异常。另外，<code>tryAcquireSharedNanos</code>方法的名字取的易混淆。</p>
<h3 id="2-4、“排他竞争临界资源”语境下的ConditionObject"><a href="#2-4、“排他竞争临界资源”语境下的ConditionObject" class="headerlink" title="2.4、“排他竞争临界资源”语境下的ConditionObject"></a><strong>2.4、“排他竞争临界资源”语境下的ConditionObject</strong></h3><p>AQS的内部类ConditionObject针对“排他竞争临界资源”语境设计，在“共享竞争临界资源”语境讨论无意义，其父接口为<code>java.util.concurrent.locks.Condition</code>。</p>
<h4 id="2-4-1、设计用途"><a href="#2-4-1、设计用途" class="headerlink" title="2.4.1、设计用途"></a><strong>2.4.1、设计用途</strong></h4><p>为提供线程协同机制：</p>
<ul>
<li>与synchronized锁（排他锁）配套的是，Object类提供<code>wait()/wait(long timeout)/wait(long timeout, int nanos)</code>等待方法和<code>notify()/notifyAll()</code>唤醒等待方法</li>
<li>与基于此处AQS实现的高级排他锁（比如“JDK中的ReentrantLock类表征的锁”）配套的是，ConditionObject类提供<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>等待方法和<code>signal()/signalAll()</code>唤醒等待方法</li>
</ul>
<h4 id="2-4-2、等待方法和唤醒等待方法"><a href="#2-4-2、等待方法和唤醒等待方法" class="headerlink" title="2.4.2、等待方法和唤醒等待方法"></a><strong>2.4.2、等待方法和唤醒等待方法</strong></h4><p><strong>1、“synchronized锁”情形</strong><br>等待方法有：<code>wait()/wait(long timeout)/wait(long timeout, int nanos)</code>；唤醒等待方法有：<code>notify()/notifyAll()</code>，是“<font color='red'>一次性唤醒信号</font>”。</p>
<p>假定有线程A和线程B，锁对象lock，线程A调用执行对象lock的等待方法进入等待，该等待被唤醒的条件有[1]：</p>
<ul>
<li>线程B调用执行对象lock的<code>notify()</code>方法</li>
<li>线程B调用执行对象lock的<code>notifyAll()</code>方法</li>
<li>设定的超时时间到期</li>
<li>虚假唤醒，即“无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup.</code>）”</li>
<li>中断</li>
</ul>
<p><strong>2、“基于此处AQS实现的高级排他锁”情形</strong><br>等待方法有：<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>；唤醒等待方法有：<code>signal()/signalAll()</code>，是“<font color='red'>一次性唤醒信号</font>”。</p>
<p>假定有线程A和线程B，锁对象lock，调用lock.newConditionObject()生成的ConditionObject对象为obj，线程A调用执行对象obj的等待方法进入等待，该等待被唤醒的条件有：</p>
<ul>
<li>线程B调用执行对象obj的<code>signal()</code>方法</li>
<li>线程B调用执行对象obj的<code>signalAll()</code>方法</li>
<li>设定的超时时间到期</li>
<li>设定的截止时间到期</li>
<li>不存在虚假唤醒。<font color='red'>但是需要注意的是Condition接口的JavaDoc中声明允许虚假唤醒存在，这里的ConditionObject实现杜绝了这种可能而已</font></li>
<li>中断（需要注意的是，调用执行<code>obj.awaitUninterruptibly()</code>等待方法进入的等待不会被中断唤醒）</li>
</ul>
<h4 id="2-4-3、使用形式"><a href="#2-4-3、使用形式" class="headerlink" title="2.4.3、使用形式"></a><strong>2.4.3、使用形式</strong></h4><p>两者的使用形式皆为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用等待方法：</span><br><span class="line">    获取排他锁</span><br><span class="line">    调用等待惯用法：在一个循环中调用等待</span><br><span class="line">    释放排他锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">唤醒等待方法：</span><br><span class="line">    获取排他锁</span><br><span class="line">    唤醒等待</span><br><span class="line">    释放排他锁</span><br></pre></td></tr></table></figure>

<p>synchronized锁示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitF</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                obj.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock锁示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitF</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalF</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：</p>
<ul>
<li>“synchronized锁机制类”还有synchronized方法使用形式</li>
<li>基于此处AQS实现的高级排他锁，除了这里的ReentrantLock，还可以自定义实现</li>
<li>synchronized锁类型只有一个“WAIT调用等待队列”；而基于此处AQS实现的高级排他锁可能就有多个“AWAIT调用等待队列”，因为可以多次调用<code>newCondition()</code>方法，生成多个ConditionObject对象，也即对应着多个“AWAIT调用等待队列”</li>
</ul>
<h4 id="2-4-4、实现细节"><a href="#2-4-4、实现细节" class="headerlink" title="2.4.4、实现细节"></a><strong>2.4.4、实现细节</strong></h4><p>基于ConditionObject实现的等待&#x2F;唤醒流程图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210402-0-0.svg"></p>
<p><strong>几点说明</strong>：</p>
<ul>
<li>跟调用<code>wait()/wait(long timeout)/wait(long timeout, int nanos)</code>方法<font color='red'>公平</font>加入对应的“WAIT调用等待队列”一样，调用<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>方法也是<font color='red'>公平</font>加入对应的“AWAIT调用等待队列”</li>
<li>关于“释放锁-获取锁-抛出InterruptedException异常”三者关系：<ul>
<li>在这里我们可查看<code>await()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>这4个方法的源代码，从而可知：对于await&#x2F;awaitNano&#x2F;awaitUntil等待，不管是后序还是前序中断，“释放锁-获取锁-抛出InterruptedException异常”三者关系都较为明确</li>
<li>而我们在<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a>中有提到过一个困惑——<code>对于wait等待，后序中断时，“释放锁-获取锁-抛出InterruptedException异常”三者关系较为明确；前序中断时，“释放锁-获取锁-抛出InterruptedException异常”三者关系不能确定</code>。wait等待的实现可能类似于await&#x2F;awaitNano&#x2F;awaitUntil，也可能不是的</li>
<li><font color='red'>特别需要注意的是，上述“前序中断”和“后序中断”是通常范畴的理解，不要较真，比如“极端的后序中断产生前序中断的效果”</font></li>
</ul>
</li>
</ul>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>接下来介绍基于AQS实现高级锁，常见形式为：在高级锁类中继承实现一个AQS的子类Sync，在该高级锁中定义一个该子类的实例成员变量<code>Sync sync</code>，该高级锁的核心方法实现都借助于<code>sync</code>。</p>
<p>根据<a href="/blog/2020/07/21/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%94%81/" title="原子操作与锁">《原子操作与锁》</a>我们知道，常见的锁分类有：</p>
<ul>
<li>悲观锁 vs 乐观锁</li>
<li>阻塞锁 vs 非阻塞锁</li>
<li>公平锁 vs 非公平锁</li>
<li>可重入锁 vs 非可重入锁</li>
<li>共享锁 vs 排他锁</li>
</ul>
<p>结合上述锁分类，关于基于AQS实现高级锁有以下几点：</p>
<ul>
<li>根据AQS中的临界资源获取方法，比如“acquire(int arg)”，其本质其实就是“乐观锁实现悲观锁”，且获取不到时需要排队阻塞，故基于AQS实现的高级锁必为“悲观锁”和“阻塞锁”</li>
<li>根据Sync具体实现，决定是“公平锁”还是“非公平锁”：<ul>
<li>“公平锁”例子：<code>sync</code>实例成员变量指向ReentrantLock.FairSync实例的ReentrantLock锁，<code>sync</code>实例成员变量指向ReentrantReadWriteLock.FairSync实例的ReentrantReadWriteLock.WriteLock锁，<code>sync</code>实例成员变量指向ReentrantReadWriteLock.FairSync实例的ReentrantReadWriteLock.ReadLock锁</li>
<li>“非公平锁”例子：<code>sync</code>实例成员变量指向ReentrantLock.NonfairSync实例的ReentrantLock锁，<code>sync</code>实例成员变量指向ReentrantReadWriteLock.NonfairSync实例的ReentrantReadWriteLock.WriteLock锁，<code>sync</code>实例成员变量指向ReentrantReadWriteLock.NonfairSync实例的ReentrantReadWriteLock.ReadLock锁</li>
</ul>
</li>
<li>根据Sync具体实现，决定是“可重入锁”还是“非可重入锁”：<ul>
<li>“可重入锁”例子：ReentrantLock锁，ReentrantReadWriteLock.WriteLock锁，ReentrantReadWriteLock.ReadLock锁</li>
<li>“非可重入锁”例子：如下源码中的NonReentrantMutex锁</li>
</ul>
</li>
<li>根据Sync具体实现，决定是“共享锁”还是“排他锁”：<ul>
<li>“共享锁”例子：ReentrantReadWriteLock.ReadLock锁</li>
<li>“排他锁”例子：ReentrantLock锁，ReentrantReadWriteLock.WriteLock锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantMutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// Report whether in locked state</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquire the lock if state is zero</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Release the lock by setting state to zero</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Provide a Condition</span></span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize properly</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">                <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>                &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>          &#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>              &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span>   &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span>         &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a><br>[2]<a href="http://www.docjar.com/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer$Node.html">http://www.docjar.com/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer$Node.html</a><br>[3]<a href="https://mp.weixin.qq.com/s/ut4hRJSDOls6UTUdlpu9_g">https://mp.weixin.qq.com/s/ut4hRJSDOls6UTUdlpu9_g</a><br>[4]<a href="https://javadoop.com/post/AbstractQueuedSynchronizer">https://javadoop.com/post/AbstractQueuedSynchronizer</a><br>[5]<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>ASCII编码</title>
    <url>/blog/2018/04/20/ASCII%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>ASCII，英文全称为“American Standard Code for Information Interchange”，即美国信息交换标准代码，是基于拉丁字母的一套编码方案，现在正逐渐被Unicode所替换。<br>ASCII中一共有128个字符，包括95个可打印字符和33个不可打印字符，其中不可打印字符分为控制字符和通讯专用字符。</p>
<h2 id="二、不可打印字符"><a href="#二、不可打印字符" class="headerlink" title="二、不可打印字符"></a><strong>二、不可打印字符</strong></h2><p>十进制的0-31和127对应的ASCII字符为不可打印字符。</p>
<h2 id="三、可打印字符"><a href="#三、可打印字符" class="headerlink" title="三、可打印字符"></a><strong>三、可打印字符</strong></h2><p>除了不可打印字符外都是可打印字符，即十进制的32-126对应的ASCII字符为可打印字符。</p>
<h2 id="四、ASCII码表"><a href="#四、ASCII码表" class="headerlink" title="四、ASCII码表"></a><strong>四、ASCII码表</strong></h2><p>见图1[3]。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20161101-0-0.gif"></p>
<br/>
参考文献：
[1]https://zh.wikipedia.org/wiki/ASCII
[2]http://baike.baidu.com/view/1112575.htm
[3]http://www.asciitable.com/
]]></content>
      <categories>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64编码</title>
    <url>/blog/2018/04/21/Base64%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>编码时，6位比特编码成1个字符；解码时，1个字符解码成6位比特。6位比特对应<code>2^6</code>种可能取值，故而被称为“Base64编码”。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a><strong>二、原理</strong></h2><p>首先给出一个映射表，表示的含义是：编码时，给定一个“6位比特”，其相应的十进制值对应的映射字符即为被编码成字符；解码时，逆向化过程。实际上除了以下64个字符外，还有一个填充字符“&#x3D;”，对应“比特全属于填充字节的6位比特”。</p>
<table>
<thead>
<tr>
<th>十进制值</th>
<th>映射字符</th>
<th>十进制值</th>
<th>映射字符</th>
<th>十进制值</th>
<th>映射字符</th>
<th>十进制值</th>
<th>映射字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<h3 id="2-1、编码"><a href="#2-1、编码" class="headerlink" title="2.1、编码"></a><strong>2.1、编码</strong></h3><p>给定一个字节流，进行Base64编码的过程如下：将字节流表示成比特流，如果比特流总个数不为24的倍数，则在尾部添加填充字节（填充字节为0字节，8位比特全为0），使得最终比特流总个数为24的倍数。接着，以“6位比特”为单元，根据上述映射表进行编码，比特全属于填充字节的“6位比特”被编码成字符“&#x3D;”，而不是字符“A”。<br>实验如下：</p>
<table>
<thead>
<tr>
<th>原比特流</th>
<th>填充比特流</th>
<th>被编码成字符串</th>
</tr>
</thead>
<tbody><tr>
<td>010101011010101000001111</td>
<td>无</td>
<td>VaoP</td>
</tr>
<tr>
<td>010110100110000000000000</td>
<td>无</td>
<td>WmAA</td>
</tr>
<tr>
<td>0101101001100000</td>
<td>00000000</td>
<td>WmA&#x3D;</td>
</tr>
<tr>
<td>01101100</td>
<td>0000000000000000</td>
<td>bA&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h3 id="2-2、解码"><a href="#2-2、解码" class="headerlink" title="2.2、解码"></a><strong>2.2、解码</strong></h3><p>编码过程的逆向化过程。</p>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a><strong>三、使用</strong></h2><p>使用“commons-codec”包的“org.apache.commons.codec.binary.Base64”类。</p>
<h3 id="3-1、编码"><a href="#3-1、编码" class="headerlink" title="3.1、编码"></a><strong>3.1、编码</strong></h3><p>实验代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] a = new byte[3];</span><br><span class="line">        // 010101011010101000001111</span><br><span class="line">        a[0] = 85;</span><br><span class="line">        a[1] = -86;</span><br><span class="line">        a[2] = 15;</span><br><span class="line"></span><br><span class="line">        System.out.println(Base64.encodeBase64String(a));</span><br><span class="line"></span><br><span class="line">        byte[] b = new byte[3];</span><br><span class="line">        // 010110100110000000000000</span><br><span class="line">        b[0] = 90;</span><br><span class="line">        b[1] = 96;</span><br><span class="line">        b[2] = 0;</span><br><span class="line">        System.out.println(Base64.encodeBase64String(b));</span><br><span class="line"></span><br><span class="line">        byte[] c = new byte[2];</span><br><span class="line">        // 0101101001100000</span><br><span class="line">        c[0] = 90;</span><br><span class="line">        c[1] = 96;</span><br><span class="line">        System.out.println(Base64.encodeBase64String(c));</span><br><span class="line"></span><br><span class="line">        byte[] d = new byte[1];</span><br><span class="line">        // 01101100</span><br><span class="line">        d[0] = 108;</span><br><span class="line">        System.out.println(Base64.encodeBase64String(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VaoP</span><br><span class="line">WmAA</span><br><span class="line">WmA=</span><br><span class="line">bA==</span><br></pre></td></tr></table></figure>
<h3 id="3-2、解码"><a href="#3-2、解码" class="headerlink" title="3.2、解码"></a><strong>3.2、解码</strong></h3><p>实验代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = &quot;VaoP&quot;;</span><br><span class="line">        System.out.println(Arrays.toString(Base64.decodeBase64(a)));</span><br><span class="line"></span><br><span class="line">        String b = &quot;WmAA&quot;;</span><br><span class="line">        System.out.println(Arrays.toString(Base64.decodeBase64(b)));</span><br><span class="line"></span><br><span class="line">        String c = &quot;WmA=&quot;;</span><br><span class="line">        System.out.println(Arrays.toString(Base64.decodeBase64(c)));</span><br><span class="line"></span><br><span class="line">        String d = &quot;bA==&quot;;</span><br><span class="line">        System.out.println(Arrays.toString(Base64.decodeBase64(d)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[85, -86, 15]</span><br><span class="line">[90, 96, 0]</span><br><span class="line">[90, 96]</span><br><span class="line">[108]</span><br></pre></td></tr></table></figure>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>以上只是核心原理介绍，实际中有很多变种，上述“commons-codec”包中的Base64编码实现也只是其中的一种变种实现。</p>
<br/>
参考文献：
[1]http://blog.csdn.net/xuefeng0707/article/details/19845111
[2]http://www.rfc-editor.org/rfc/rfc2045.txt
[3]https://en.wikipedia.org/wiki/Base64
]]></content>
      <categories>
        <category>协议规范</category>
        <category>邮件解析</category>
      </categories>
  </entry>
  <entry>
    <title>5种创建型设计模式</title>
    <url>/blog/2024/08/12/5%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、Factory-Method-Pattern"><a href="#一、Factory-Method-Pattern" class="headerlink" title="一、Factory Method Pattern"></a><strong>一、Factory Method Pattern</strong></h2><p>中文名：工厂方法设计模式。</p>
<h3 id="1-1、痛点"><a href="#1-1、痛点" class="headerlink" title="1.1、痛点"></a><strong>1.1、痛点</strong></h3><p>不使用<code>new</code>等直接方法创建目标类的实例对象，而是使用工厂方法创建，针对痛点：</p>
<ol>
<li>便于使用</li>
<li>便于扩展</li>
</ol>
<h3 id="1-2、实现"><a href="#1-2、实现" class="headerlink" title="1.2、实现"></a><strong>1.2、实现</strong></h3><p>有两种实现形式：</p>
<ul>
<li>实例工厂方法</li>
<li>静态工厂方法</li>
</ul>
<h4 id="1-2-1、实例工厂方法实现形式"><a href="#1-2-1、实例工厂方法实现形式" class="headerlink" title="1.2.1、实例工厂方法实现形式"></a><strong>1.2.1、实例工厂方法实现形式</strong></h4><p>分“目标类只有1个”和“目标类不只1个，且具有共同父类”两种情况进行介绍。</p>
<h5 id="1-2-1-1、目标类只有1个"><a href="#1-2-1-1、目标类只有1个" class="headerlink" title="1.2.1.1、目标类只有1个"></a><strong>1.2.1.1、目标类只有1个</strong></h5><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = <span class="string">&quot;dslztx&quot;</span>;</span><br><span class="line">        user.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserFactory</span> <span class="variable">userFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFactory</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userFactory.createUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-2、目标类不只1个，且具有共同父类"><a href="#1-2-1-2、目标类不只1个，且具有共同父类" class="headerlink" title="1.2.1.2、目标类不只1个，且具有共同父类"></a><strong>1.2.1.2、目标类不只1个，且具有共同父类</strong></h5><p><font color='red'>讲解设计模式的教材&#x2F;材料在介绍工厂方法设计模式时常基于该场景。</font></p>
<p>示例代码如下[1]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，我们需要定义一个图形接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，我们实现两个具体的图形类，分别是 Circle（圆形）和 Rectangle（矩形）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，我们创建一个抽象工厂类 ShapeFactory</span></span><br><span class="line"><span class="comment">// 它定义了一个抽象的工厂方法 createShape，子类将实现这个方法来创建具体的图形对象</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Shape <span class="title function_">createShape</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，我们创建两个具体的工厂类，分别是 CircleFactory 和 RectangleFactory</span></span><br><span class="line"><span class="comment">// 它们分别实现了 ShapeFactory 并重写了 createShape 方法来返回相应的图形对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">extends</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span> <span class="keyword">extends</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以使用这些工厂类来创建图形对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShapeFactory</span> <span class="variable">circleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> circleFactory.createShape();</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="type">ShapeFactory</span> <span class="variable">rectangleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> rectangleFactory.createShape();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2、静态工厂方法实现形式"><a href="#1-2-2、静态工厂方法实现形式" class="headerlink" title="1.2.2、静态工厂方法实现形式"></a><strong>1.2.2、静态工厂方法实现形式</strong></h4><p>分“目标类只有1个”和“目标类不只1个，且具有共同父类”两种情况进行介绍。</p>
<h5 id="1-2-2-1、目标类只有1个"><a href="#1-2-2-1、目标类只有1个" class="headerlink" title="1.2.2.1、目标类只有1个"></a><strong>1.2.2.1、目标类只有1个</strong></h5><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactoryStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> User <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = <span class="string">&quot;dslztx&quot;</span>;</span><br><span class="line">        user.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserFactoryStatic.createUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-2、目标类不只1个，且具有共同父类"><a href="#1-2-2-2、目标类不只1个，且具有共同父类" class="headerlink" title="1.2.2.2、目标类不只1个，且具有共同父类"></a><strong>1.2.2.2、目标类不只1个，且具有共同父类</strong></h5><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，我们需要定义一个图形接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，我们实现两个具体的图形类，分别是 Circle（圆形）和 Rectangle（矩形）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactoryStatic</span> &#123;</span><br><span class="line">    <span class="comment">// 利用类型参数来创建具体图形子类对象</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Shape</span>&gt; T <span class="title function_">createShape</span><span class="params">(Class&lt;T&gt; tClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tClass == Circle.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tClass == Rectangle.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> ShapeFactoryStatic.createShape(Circle.class);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> ShapeFactoryStatic.createShape(Rectangle.class);</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3、JDK中的例子"><a href="#1-3、JDK中的例子" class="headerlink" title="1.3、JDK中的例子"></a><strong>1.3、JDK中的例子</strong></h3><p>JDK中的例子：</p>
<ol>
<li><code>Integer.valueOf(int i)</code>：方便扩展成缓存<code>[-128,127]</code>值范围内的Integer对象进行复用</li>
<li><code>Object.toString()</code></li>
<li><code>Calendar getInstance()</code></li>
</ol>
<h2 id="二、Abstract-Factory-Pattern"><a href="#二、Abstract-Factory-Pattern" class="headerlink" title="二、Abstract Factory Pattern"></a><strong>二、Abstract Factory Pattern</strong></h2><p>中文名：抽象工厂设计模式。<br>另外一个名字为：Kit Pattern，工具箱设计模式。</p>
<h3 id="2-1、痛点"><a href="#2-1、痛点" class="headerlink" title="2.1、痛点"></a><strong>2.1、痛点</strong></h3><p>实现需求：需要创建一系列相关或相互依赖的对象，这些对象属于一组相关的产品族，同时，系统需要保证这些产品族之间的一致性。</p>
<h3 id="2-2、实现"><a href="#2-2、实现" class="headerlink" title="2.2、实现"></a><strong>2.2、实现</strong></h3><p>实现必存在工厂类父类，且该工厂类父类中必存在抽象工厂方法。</p>
<p>注意与“工厂方法设计模式”实现的区分：对于<code>实现必存在工厂类父类，且该工厂类父类中必存在抽象工厂方法</code>，其属于“工厂方法设计模式”中的<code>实例工厂方法</code>实现形式；反之，“工厂方法设计模式”中还有<code>静态工厂方法</code>实现形式，也有非<code>实现必存在工厂类父类，且该工厂类父类中必存在抽象工厂方法</code>的<code>实例工厂方法</code>实现形式。<font color='red'>故“抽象工厂设计模式”属于“工厂方法设计模式”的子集</font>。</p>
<p>示例代码如下[1]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品接口：操作系统</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品接口：应用程序</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SoftwareFactory</span> &#123;</span><br><span class="line">    OperatingSystem <span class="title function_">createOperatingSystem</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Application <span class="title function_">createApplication</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows操作系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsOS</span> <span class="keyword">implements</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Windows OS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Linux操作系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxOS</span> <span class="keyword">implements</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Linux OS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Word应用程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordApplication</span> <span class="keyword">implements</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Opening Word Application&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Excel应用程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExcelApplication</span> <span class="keyword">implements</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Opening Excel Application&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：Windows工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> <span class="keyword">implements</span> <span class="title class_">SoftwareFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OperatingSystem <span class="title function_">createOperatingSystem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsOS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Application <span class="title function_">createApplication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExcelApplication</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：Linux工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxFactory</span> <span class="keyword">implements</span> <span class="title class_">SoftwareFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OperatingSystem <span class="title function_">createOperatingSystem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinuxOS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Application <span class="title function_">createApplication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WordApplication</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个示例中，抽象工厂模式通过SoftwareFactory接口和其实现类来创建不同类型的操作系统和应用程序。</span></span><br><span class="line"><span class="comment">// 客户端代码可以根据需要选择不同的工厂实例来创建不同的产品组合。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SoftwareFactory</span> <span class="variable">windowsFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsFactory</span>();</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">windowsOS</span> <span class="operator">=</span> windowsFactory.createOperatingSystem();</span><br><span class="line">        <span class="type">Application</span> <span class="variable">windowsApp</span> <span class="operator">=</span> windowsFactory.createApplication();</span><br><span class="line"></span><br><span class="line">        windowsOS.run();</span><br><span class="line">        windowsApp.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">SoftwareFactory</span> <span class="variable">linuxFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinuxFactory</span>();</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">linuxOS</span> <span class="operator">=</span> linuxFactory.createOperatingSystem();</span><br><span class="line">        <span class="type">Application</span> <span class="variable">linuxApp</span> <span class="operator">=</span> linuxFactory.createApplication();</span><br><span class="line"></span><br><span class="line">        linuxOS.run();</span><br><span class="line">        linuxApp.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、JDK中的例子"><a href="#2-3、JDK中的例子" class="headerlink" title="2.3、JDK中的例子"></a><strong>2.3、JDK中的例子</strong></h3><h4 id="2-3-1、java-awt-Toolkit"><a href="#2-3-1、java-awt-Toolkit" class="headerlink" title="2.3.1、java.awt.Toolkit"></a><strong>2.3.1、<code>java.awt.Toolkit</code></strong></h4><p>工厂类父类<code>java.awt.Toolkit</code>和其中3个抽象工厂方法（实际不只3个，这里只罗列3个进行举例说明）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Toolkit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ButtonPeer <span class="title function_">createButton</span><span class="params">(Button target)</span> <span class="keyword">throws</span> HeadlessException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> TextFieldPeer <span class="title function_">createTextField</span><span class="params">(TextField target)</span> <span class="keyword">throws</span> HeadlessException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> LabelPeer <span class="title function_">createLabel</span><span class="params">(Label target)</span> <span class="keyword">throws</span> HeadlessException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button产品的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ButtonPeer</span> <span class="keyword">extends</span> <span class="title class_">ComponentPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextField产品的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextFieldPeer</span> <span class="keyword">extends</span> <span class="title class_">TextComponentPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Label产品的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LabelPeer</span> <span class="keyword">extends</span> <span class="title class_">ComponentPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-1、Windows-JDK"><a href="#2-3-1-1、Windows-JDK" class="headerlink" title="2.3.1.1、Windows JDK"></a><strong>2.3.1.1、Windows JDK</strong></h5><p><code>java.awt.Toolkit</code>的具体子类<code>sun.awt.windows.WToolkit</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WToolkit</span> <span class="keyword">extends</span> <span class="title class_">SunToolkit</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button产品的具体子类<code>sun.awt.windows.WButtonPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WButtonPeer</span> <span class="keyword">extends</span> <span class="title class_">WComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">ButtonPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextField产品的具体子类<code>sun.awt.windows.WTextFieldPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WTextFieldPeer</span> <span class="keyword">extends</span> <span class="title class_">WTextComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">TextFieldPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Label产品的具体子类<code>sun.awt.windows.WLabelPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WLabelPeer</span> <span class="keyword">extends</span> <span class="title class_">WComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">LabelPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-2、Linux-JDK"><a href="#2-3-1-2、Linux-JDK" class="headerlink" title="2.3.1.2、Linux JDK"></a><strong>2.3.1.2、Linux JDK</strong></h5><p><code>java.awt.Toolkit</code>的具体子类<code>sun.awt.X11.XToolkit</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">XToolkit</span> <span class="keyword">extends</span> <span class="title class_">UNIXToolkit</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button产品的具体子类<code>sun.awt.X11.XButtonPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XButtonPeer</span> <span class="keyword">extends</span> <span class="title class_">XComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">ButtonPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextField产品的具体子类<code>sun.awt.X11.XTextFieldPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">XTextFieldPeer</span> <span class="keyword">extends</span> <span class="title class_">XComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">TextFieldPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Label产品的具体子类<code>sun.awt.X11.XLabelPeer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XLabelPeer</span> <span class="keyword">extends</span> <span class="title class_">XComponentPeer</span> <span class="keyword">implements</span> <span class="title class_">LabelPeer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Builder-Pattern"><a href="#三、Builder-Pattern" class="headerlink" title="三、Builder Pattern"></a><strong>三、Builder Pattern</strong></h2><p>中文名：构建者设计模式。</p>
<h3 id="3-1、痛点"><a href="#3-1、痛点" class="headerlink" title="3.1、痛点"></a><strong>3.1、痛点</strong></h3><p>适用场景：对于一个实例对象，很难一次性构建完成或者一次性构建完成代价很大。它的本质是将构建实例对象所需的信息从“一次性输入”改为“非一次性输入”。</p>
<h3 id="3-2、实现"><a href="#3-2、实现" class="headerlink" title="3.2、实现"></a><strong>3.2、实现</strong></h3><p>有两种实现形式：</p>
<ul>
<li>二角色——Client和Builder，实际经常使用的实现形式</li>
<li>三角色——Client，Director和Builder，很多设计模式书籍建议的实现形式，引入Director的本意是将Client和Builder解耦，但也引入了额外的维护成本，故权衡下来，在引入构建者设计模式时经常使用“二角色”实现形式</li>
</ul>
<p><strong>备注</strong>：多见“Builder实例的构建方法返回Builder实例本身”以进行链式调用</p>
<h4 id="3-2-1、“二角色”实现形式"><a href="#3-2-1、“二角色”实现形式" class="headerlink" title="3.2.1、“二角色”实现形式"></a><strong>3.2.1、“二角色”实现形式</strong></h4><p>包含Client和Builder两种角色，Builder角色负责构建实例对象，Client角色（即业务代码）直接与Builder角色进行交互。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line"></span><br><span class="line">    String foundation;</span><br><span class="line">    String structure;</span><br><span class="line">    String roof;</span><br><span class="line">    String interior;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        house = <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">(String foundation)</span> &#123;</span><br><span class="line">        house.foundation = foundation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">(String structure)</span> &#123;</span><br><span class="line">        house.structure = structure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">(String roof)</span> &#123;</span><br><span class="line">        house.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildInterior</span><span class="params">(String interior)</span> &#123;</span><br><span class="line">        house.interior = interior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">getHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得foundation变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">foundation</span> <span class="operator">=</span> <span class="string">&quot;FakeFoundation&quot;</span>;</span><br><span class="line">        houseBuilder.buildFoundation(foundation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得structure变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">structure</span> <span class="operator">=</span> <span class="string">&quot;FakeStructure&quot;</span>;</span><br><span class="line">        houseBuilder.buildStructure(structure);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得roof变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">roof</span> <span class="operator">=</span> <span class="string">&quot;FakeRoof&quot;</span>;</span><br><span class="line">        houseBuilder.buildRoof(roof);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得interior变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">interior</span> <span class="operator">=</span> <span class="string">&quot;FakeInterior&quot;</span>;</span><br><span class="line">        houseBuilder.buildInterior(interior);</span><br><span class="line"></span><br><span class="line">        System.out.println(houseBuilder.getHouse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例子所描述的场景中，很难一次性获得构建House实例对象所需的信息，构建者设计模式很好地解决这个问题</span></span><br><span class="line">        <span class="comment">// Client直接与Builder进行交互</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、“三角色”实现形式"><a href="#3-2-2、“三角色”实现形式" class="headerlink" title="3.2.2、“三角色”实现形式"></a><strong>3.2.2、“三角色”实现形式</strong></h4><p>包含Client、Director和Builder三种角色，Builder角色负责构建实例对象，Client角色（即业务代码）通过Director角色与Builder角色进行交互。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line"></span><br><span class="line">    String foundation;</span><br><span class="line">    String structure;</span><br><span class="line">    String roof;</span><br><span class="line">    String interior;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        house = <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">(String foundation)</span> &#123;</span><br><span class="line">        house.foundation = foundation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">(String structure)</span> &#123;</span><br><span class="line">        house.structure = structure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">(String roof)</span> &#123;</span><br><span class="line">        house.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildInterior</span><span class="params">(String interior)</span> &#123;</span><br><span class="line">        house.interior = interior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">getHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HouseBuilder houseBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(HouseBuilder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">constructHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得foundation变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">foundation</span> <span class="operator">=</span> <span class="string">&quot;FakeFoundation&quot;</span>;</span><br><span class="line">        houseBuilder.buildFoundation(foundation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得structure变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">structure</span> <span class="operator">=</span> <span class="string">&quot;FakeStructure&quot;</span>;</span><br><span class="line">        houseBuilder.buildStructure(structure);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得roof变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">roof</span> <span class="operator">=</span> <span class="string">&quot;FakeRoof&quot;</span>;</span><br><span class="line">        houseBuilder.buildRoof(roof);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始获取不到，经过很复杂的计算才获得interior变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">interior</span> <span class="operator">=</span> <span class="string">&quot;FakeInterior&quot;</span>;</span><br><span class="line">        houseBuilder.buildInterior(interior);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> houseBuilder.getHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HouseBuilder</span> <span class="variable">concreteBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(concreteBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="type">House</span> <span class="variable">concreteHouse</span> <span class="operator">=</span> director.constructHouse();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete House: &quot;</span> + concreteHouse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例子所描述的场景中，很难一次性获得构建House实例对象所需的信息，构建者设计模式很好地解决这个问题</span></span><br><span class="line">        <span class="comment">// Client通过Director与Builder进行交互</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、JDK中的例子"><a href="#3-3、JDK中的例子" class="headerlink" title="3.3、JDK中的例子"></a><strong>3.3、JDK中的例子</strong></h3><h4 id="3-3-1、StringBuilder"><a href="#3-3-1、StringBuilder" class="headerlink" title="3.3.1、StringBuilder"></a><strong>3.3.1、StringBuilder</strong></h4><p>构建一个String实例对象不能一次性输入所有信息，须多次输入，适合使用StringBuilder。</p>
<p>采用“二角色”实现形式的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">&quot;Subject&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">&quot;Content&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">&quot;Footer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="四、Prototype-Pattern"><a href="#四、Prototype-Pattern" class="headerlink" title="四、Prototype Pattern"></a><strong>四、Prototype Pattern</strong></h2><p>中文名：原型设计模式。</p>
<h3 id="4-1、痛点"><a href="#4-1、痛点" class="headerlink" title="4.1、痛点"></a><strong>4.1、痛点</strong></h3><p>实现业务需求：根据已存在实例对象克隆“具有一模一样值”的实例对象。</p>
<p>克隆具有克隆深浅的属性，关于克隆深浅有两点说明：</p>
<ol>
<li>越浅的克隆，克隆对象与原对象共享内存越多，两者互相独立性越差；越深的克隆，克隆对象与原对象共享内存越少，两者互相独立性越好</li>
<li><font color='red'>经常简单将克隆分为“浅度克隆”和“深度克隆”，其实是错误的，因为“浅度克隆”和“深度克隆”之间没有明确的界限</font></li>
</ol>
<p>在以下示例代码中，呈现了对于<code>shallowClone -&gt; deepClone -&gt; deepMoreClone</code>，克隆越来越深（佐证了难以简单划分“浅度克隆”和“深度克隆”），克隆对象与原对象共享内存越来越少，两者互相独立性越来越好。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">shallowClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = name;</span><br><span class="line">        user.age = age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepo</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserRepo <span class="title function_">shallowClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserRepo</span> <span class="variable">userRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRepo</span>();</span><br><span class="line">        userRepo.userList = userList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserRepo <span class="title function_">deepClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserRepo</span> <span class="variable">userRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRepo</span>();</span><br><span class="line">        userRepo.userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(userList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserRepo <span class="title function_">deepMoreClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserRepo</span> <span class="variable">userRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRepo</span>();</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; tmpUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            tmpUserList.add(user.shallowClone());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userRepo.userList = tmpUserList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、实现"><a href="#4-2、实现" class="headerlink" title="4.2、实现"></a><strong>4.2、实现</strong></h3><p>有3种实现形式</p>
<ul>
<li>自实现复制方法</li>
<li>JDK的<code>Object.clone()</code>原生机制</li>
<li>第三方复制框架</li>
</ul>
<h4 id="4-2-1、自实现复制方法"><a href="#4-2-1、自实现复制方法" class="headerlink" title="4.2.1、自实现复制方法"></a><strong>4.2.1、自实现复制方法</strong></h4><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = <span class="string">&quot;dslztx&quot;</span>;</span><br><span class="line">        user.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">copiedUser</span> <span class="operator">=</span> copy(user);</span><br><span class="line">        System.out.println(copiedUser.name);</span><br><span class="line">        System.out.println(copiedUser.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">copy</span><span class="params">(User a)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = a.name;</span><br><span class="line">        user.age = a.age;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2、JDK的Object-clone-原生机制"><a href="#4-2-2、JDK的Object-clone-原生机制" class="headerlink" title="4.2.2、JDK的Object.clone()原生机制"></a><strong>4.2.2、JDK的<code>Object.clone()</code>原生机制</strong></h4><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.name = <span class="string">&quot;dslztx&quot;</span>;</span><br><span class="line">        user.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">copiedUser</span> <span class="operator">=</span> user.clone();</span><br><span class="line">        System.out.println(copiedUser.name);</span><br><span class="line">        System.out.println(copiedUser.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3、第三方复制框架"><a href="#4-2-3、第三方复制框架" class="headerlink" title="4.2.3、第三方复制框架"></a><strong>4.2.3、第三方复制框架</strong></h4><p>使用第三方复制框架，比如“Apache commons-beanutils包中的BeanUtils.copyProperties工具方法”。</p>
<h3 id="4-3、JDK中的例子"><a href="#4-3、JDK中的例子" class="headerlink" title="4.3、JDK中的例子"></a><strong>4.3、JDK中的例子</strong></h3><h4 id="4-3-1、ArrayList的clone-方法"><a href="#4-3-1、ArrayList的clone-方法" class="headerlink" title="4.3.1、ArrayList的clone()方法"></a><strong>4.3.1、ArrayList的<code>clone()</code>方法</strong></h4><p>重写覆盖<code>Object.clone()</code>方法实现ArrayList自己的<code>clone()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Singleton"><a href="#五、Singleton" class="headerlink" title="五、Singleton"></a><strong>五、Singleton</strong></h2><p>中文名：单例设计模式。</p>
<h3 id="5-1、痛点"><a href="#5-1、痛点" class="headerlink" title="5.1、痛点"></a><strong>5.1、痛点</strong></h3><p>实现业务需求：全局具有唯一实例。</p>
<h3 id="5-2、实现"><a href="#5-2、实现" class="headerlink" title="5.2、实现"></a><strong>5.2、实现</strong></h3><p>单例有多种实现形式，参见<a href="/blog/2020/07/26/%E5%8D%95%E4%BE%8B/" title="单例">《单例》</a>。</p>
<h3 id="5-3、JDK中的例子"><a href="#5-3、JDK中的例子" class="headerlink" title="5.3、JDK中的例子"></a><strong>5.3、JDK中的例子</strong></h3><h4 id="5-3-1、java-lang-Runtime实例对象"><a href="#5-3-1、java-lang-Runtime实例对象" class="headerlink" title="5.3.1、java.lang.Runtime实例对象"></a><strong>5.3.1、<code>java.lang.Runtime</code>实例对象</strong></h4><p><code>java.lang.Runtime</code>实例对象是单例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://mp.weixin.qq.com/s/H16g_yZwRMIKagPb8oNIYQ">https://mp.weixin.qq.com/s/H16g_yZwRMIKagPb8oNIYQ</a><br>[2]<a href="https://www.bilibili.com/read/cv18266097">https://www.bilibili.com/read/cv18266097</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Bash Shell快捷键</title>
    <url>/blog/2018/05/31/Bash-Shell%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="一、移动"><a href="#一、移动" class="headerlink" title="一、移动"></a><strong>一、移动</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+b</td>
<td>向后（左）移动一个字符，助记：backward</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向前（右）移动一个字符，助记：forward</td>
</tr>
<tr>
<td>Alt+b</td>
<td>向后（左）移动一个单词，助记：backward</td>
</tr>
<tr>
<td>Alt+f</td>
<td>向前（右）移动一个单词，助记：forward</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>跳到行首</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>跳到行尾</td>
</tr>
</tbody></table>
<h2 id="二、编辑"><a href="#二、编辑" class="headerlink" title="二、编辑"></a><strong>二、编辑</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+h</td>
<td>向左删除一个字符，等价于“Backspace”按键</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>向右删除一个字符，等价于“Delete”按键</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>向左删除直到行首</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>向右删除直到行尾</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>向左删除直到单词首</td>
</tr>
<tr>
<td>Alt+d</td>
<td>向右删除直到单词尾</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清屏</td>
</tr>
</tbody></table>
<p>备注：<br><font color='red'>向左删除，从光标所在位置左边一个字符开始；向右删除，从光标所在位置字符开始</font></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+n</td>
<td>历史命令记录中的下一条命令，助记：next</td>
</tr>
<tr>
<td>Ctrl+p</td>
<td>历史命令记录中的上一条命令，助记：previous</td>
</tr>
<tr>
<td>Shift+PageUp</td>
<td>向上翻页</td>
</tr>
<tr>
<td>Shift+PageDown</td>
<td>向下翻页</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>进入“历史命令记录查找”模式，输入关键词进行查找。在“历史命令记录查找”模式中：再次按下“Ctrl+r”快捷键，可在匹配项之间切换；按下“Enter”键立即执行所选历史命令；按下“向左方向键&#x2F;向右方向键”可编辑所选历史命令再执行</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]https://github.com/hokein/Wiki/wiki/Bash-Shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE
[2]https://help.gnome.org/users/gnome-terminal/stable/adv-keyboard-shortcuts.html.en
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/blog/2020/01/14/CAS/</url>
    <content><![CDATA[<h2 id="一、CAS原子操作含义"><a href="#一、CAS原子操作含义" class="headerlink" title="一、CAS原子操作含义"></a><strong>一、CAS原子操作含义</strong></h2><p>CAS原子操作：“CAS”表示“Compare And Swap”，即“比较并替换”，具体是<code>欲更新一个内存区域A值，输入两个参数——“待比较值”和“待更新值”，先将A当前值与“待比较值”比较，如果比较结果相等，则将A值更新为“待更新值”，否则失败返回</code>。</p>
<h2 id="二、CAS原子操作存在的问题"><a href="#二、CAS原子操作存在的问题" class="headerlink" title="二、CAS原子操作存在的问题"></a><strong>二、CAS原子操作存在的问题</strong></h2><h3 id="2-1、ABA问题"><a href="#2-1、ABA问题" class="headerlink" title="2.1、ABA问题"></a><strong>2.1、ABA问题</strong></h3><p>有一个内存区域A，它的当前值为a，后来经历了“a-b”和“b-a”的值更新过程，此时如果对A执行CAS原子操作，“待比较值”为a，“待更新值”为d，则能够顺利执行，但是与预期并不一致，预期的内存区域A的值的迁移关系应该是<code>a-d</code>，而不是<code>a-b-a-d</code>。<br>解决方案是：另外再加一个版本号，在进行值更新的同时升版本号。</p>
<p><font color='red'>特别需要注意的是</font>，“ABA问题”的描述只是一个统称，本质上来说，“ABA问题”包括两类：</p>
<ul>
<li>偶数ABA问题，比如“A-A”，“A-B-C-A”，“A-B-C-D-E-A”，…</li>
<li>奇数ABA问题，比如“A-B-A”，“A-B-C-D-A”，“A-B-C-D-E-F-A”，…</li>
</ul>
<h3 id="2-2、只能保证替换一个内存区域值的操作的原子性"><a href="#2-2、只能保证替换一个内存区域值的操作的原子性" class="headerlink" title="2.2、只能保证替换一个内存区域值的操作的原子性"></a><strong>2.2、只能保证替换一个内存区域值的操作的原子性</strong></h3><p>只能保证替换一个内存区域值的操作的原子性，而并不能保证替换大于1个内存区域值的操作的原子性。</p>
<h2 id="三、指令集中的CAS原子操作指令"><a href="#三、指令集中的CAS原子操作指令" class="headerlink" title="三、指令集中的CAS原子操作指令"></a><strong>三、指令集中的CAS原子操作指令</strong></h2><p>不同的指令集具有不同的CAS原子操作指令或者其等价。比如“在X86指令体系中，<code>CMPXCHG</code>就是一个常见的CAS操作指令，需要注意的是，在多CPU或者CPU核环境中，需要给<code>CMPXCHG</code>指令加上<code>LOCK指令前缀</code>才能确保原子性”，“天生原子机器指令CAS”。</p>
<br/>

<p><strong>备注：</strong></p>
<ul>
<li>后续可知，加上<code>LOCK指令前缀</code>，不仅使得“原子化”，也使得“禁止重排序”，“刷新缓存到内存”和“使缓存失效”，这里给<code>CMPXCHG</code>指令加上<code>LOCK指令前缀</code>，只是为了“原子化”，后三者效果只是顺带，另外，CAS原子操作指令并不只有<code>LOCK CMPXCHG</code>这种形式，因此，在通用使用CAS原子操作指令时并不能作具有“禁止重排序”，“刷新缓存到内存”和“使缓存失效”效果的假定</li>
</ul>
<h2 id="四、JDK中提供的CAS原子方法"><a href="#四、JDK中提供的CAS原子方法" class="headerlink" title="四、JDK中提供的CAS原子方法"></a><strong>四、JDK中提供的CAS原子方法</strong></h2><p>JDK中提供的CAS原子方法是“sun.misc.Unsafe”类下的<code>compareAndSwapObject()</code>，<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>方法。</p>
<p>查看这3个方法的本地实现（C&#x2F;C++语言源代码），可知核心就是直接调用<code>LOCK CMPXCHAG</code>指令（在X86指令体系中）。</p>
<p>以<code>compareAndSwapInt()</code>方法为例，跟踪其本地实现源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">	<span class="comment">/* 省略一堆代码... */</span></span><br><span class="line">	&#123; CC <span class="string">&quot;compareAndSwapInt&quot;</span>,  CC <span class="string">&quot;(&quot;</span>OBJ <span class="string">&quot;J&quot;</span> <span class="string">&quot;I&quot;</span> <span class="string">&quot;I&quot;</span> <span class="string">&quot;)Z&quot;</span>, <span class="built_in">FN_PTR</span>( Unsafe_CompareAndSwapInt )  &#125;,</span><br><span class="line">	&#123; CC <span class="string">&quot;compareAndSwapLong&quot;</span>, CC <span class="string">&quot;(&quot;</span>OBJ <span class="string">&quot;J&quot;</span> <span class="string">&quot;J&quot;</span> <span class="string">&quot;J&quot;</span> <span class="string">&quot;)Z&quot;</span>, <span class="built_in">FN_PTR</span>( Unsafe_CompareAndSwapLong ) &#125;,</span><br><span class="line">	<span class="comment">/* 省略一堆代码... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Unsafe_CompareAndSwapInt</span>( JNIEnv * env, jobject unsafe, jobject obj, jlong offset, jint e, jint x ) ) &#123;</span><br><span class="line">	<span class="built_in">UnsafeWrapper</span>( <span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span> );</span><br><span class="line">	oop	p	= JNIHandles::<span class="built_in">resolve</span>( obj );</span><br><span class="line">	jint	* addr	= (jint *) <span class="built_in">index_oop_from_field_offset_long</span>( p, offset );</span><br><span class="line">	<span class="keyword">return</span>( (jint) (Atomic::<span class="built_in">cmpxchg</span>( x, addr, e ) ) == e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span><span class="params">( jint exchange_value, <span class="keyword">volatile</span> jint*     dest, jint compare_value )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">	<span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP( % <span class="number">4</span> ) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">			  : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">			  : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">			  : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span>(exchange_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知在执行<code>compareAndSwapInt()</code>方法时，最后会执行到<code>LOCK_IF_MP( % 4 ) &quot;cmpxchgl %1,(%3)&quot;</code>语句，其中<code>LOCK_IF_MP( % 4 )</code>表示在单CPU且单核的环境中，可以优化不加<code>LOCK指令前缀</code>，否则就需要加<code>LOCK指令前缀</code>以确保<code>cmpxchgl</code>的原子性，而<code>cmpxchgl</code>表示一个属于<code>CMPXCHG</code>家族的CAS操作指令，它的末尾<code>l</code>表示操作数长度为4。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://juejin.im/post/5a73cbbff265da4e807783f5">https://juejin.im/post/5a73cbbff265da4e807783f5</a><br>[2]<a href="https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock">https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>CPU</title>
    <url>/blog/2019/06/03/CPU/</url>
    <content><![CDATA[<h2 id="一、CPU基本概念"><a href="#一、CPU基本概念" class="headerlink" title="一、CPU基本概念"></a><strong>一、CPU基本概念</strong></h2><p>CPU（Central Processing Unit）：中央处理器，简称“处理器”，是一块超大规模的集成电路，是一台计算机的控制和运算中心。</p>
<h2 id="二、CPU架构"><a href="#二、CPU架构" class="headerlink" title="二、CPU架构"></a><strong>二、CPU架构</strong></h2><p>基本概念：</p>
<ul>
<li>CPU：处理器</li>
<li>CPU Core：处理器核心</li>
<li>CU（Control Unit）：控制单元</li>
<li>FPU（Floating Point Unit）：浮点运算单元</li>
<li>ALU（Arithmetic Logic Unit）：算术逻辑单元</li>
<li>Register：寄存器</li>
<li>CPU Cache：高速缓存，包括L1 Cache，L2 Cache和L3 Cache</li>
<li>SMT（Simultaneous multithreading）：同步多线程技术</li>
<li>HT（Hyper-Threading）：超线程技术，Intel的SMT落地方案</li>
</ul>
<p>CPU架构跟制作厂商、具体系列、具体型号等因素有关：</p>
<ul>
<li>AMD CPU架构跟Intel CPU架构一般不同</li>
<li>Intel的较老CPU架构是“单CPU，单CPU Core”；较现代CPU架构是“多CPU，多CPU Core”</li>
<li>较老的CPU不含有FPU，而是通过“ALU+软件”实现浮点运算</li>
<li>较老CPU架构中是“多CPU Core共享所在CPU的L2 Cache”；较现代CPU架构中是“多CPU Core共享所在CPU的L3 Cache”</li>
</ul>
<h3 id="2-1、最经典的CPU架构"><a href="#2-1、最经典的CPU架构" class="headerlink" title="2.1、最经典的CPU架构"></a><strong>2.1、最经典的CPU架构</strong></h3><p>CPU上只有一个CPU Core，该CPU（CPU Core）有：</p>
<ul>
<li>一个CU</li>
<li>一个ALU  </li>
<li>一个FPU</li>
<li>一整套Register</li>
<li>L1、L2、L3 Cache</li>
</ul>
<h3 id="2-2、现代CPU架构"><a href="#2-2、现代CPU架构" class="headerlink" title="2.2、现代CPU架构"></a><strong>2.2、现代CPU架构</strong></h3><p>首先介绍并行和并发概念，基于线程（当然也可基于CPU指令，线程所执行程序最终会被编译&#x2F;解释成CPU指令，两者完全等价）进行叙述：</p>
<ul>
<li>并行：线程A和B逻辑和物理上都同时执行，一般认为调度在不同CPU或者CPU Core上的两个线程逻辑和物理上同时执行，但是须知，并没有纯粹意义上的物理同时执行，比如“不同CPU共享总线等资源”，“同一CPU上不同CPU Core共享所在CPU的CU、L3 Cache、总线等资源”</li>
<li>并发：线程A和B逻辑上同时执行，物理上可同时执行，也可轮流执行（常见的是CPU时间分片方案）</li>
</ul>
<p>后续如无特别说明，基于并发进行说明。</p>
<p>为提升CPU架构并发性，现代CPU架构演进方向为“多CPU，单CPU上多CPU Core，CPU Core引入SMT技术”，代价是须引入复杂的硬件设计应对随之而来的调度问题，故需要综合权衡考量。<br>理论上，当其他条件相近时，共享物理资源越少，并发能力越强，故对于以下3种方案，并发能力排序为：<code>多CPU &gt; 多CPU Core &gt; CPU Core引入SMT技术</code>：</p>
<ul>
<li>多CPU：共享物理资源最少，有“总线”等</li>
<li>多CPU Core：共享物理资源次少，有“CU”，“L3 Cache”，“总线”等</li>
<li>CPU Core引入SMT技术：共享物理资源最多，几乎可以认为是全部，有“CU”，“ALU”，“FPU”，“一整套Register”，“L1、L2、L3 Cache”，“总线”等</li>
</ul>
<h4 id="2-2-1、多CPU和多CPU-Core"><a href="#2-2-1、多CPU和多CPU-Core" class="headerlink" title="2.2.1、多CPU和多CPU Core"></a><strong>2.2.1、多CPU和多CPU Core</strong></h4><p>有M（M&gt;1）个CPU，单CPU上有N个（N&gt;1）CPU Core。</p>
<p>CPU Core有：</p>
<ul>
<li>一个ALU  </li>
<li>一个FPU</li>
<li>一整套Register</li>
<li>L1、L2 Cache</li>
</ul>
<p>CPU有：</p>
<ul>
<li>N个CPU Core</li>
<li>一个CU（被其上的N个CPU Core共享。<font color='red'>准确来说，此时的CU是一个层次结构，CPU Core中是子CU，CPU中是主CU</font>）</li>
<li>L3 Cache（被其上的N个CPU Core共享）</li>
</ul>
<h4 id="2-2-2、同步多线程技术"><a href="#2-2-2、同步多线程技术" class="headerlink" title="2.2.2、同步多线程技术"></a><strong>2.2.2、同步多线程技术</strong></h4><p>同步多线程技术：英文名为“Simultaneous multithreading”，简称“SMT”，其具体描述如下：</p>
<blockquote>
<blockquote>
<p>一个线程A，分配到CPU Core C0的时间分片，在该时间分片的某个时钟周期，C0正在执行A所执行程序对应指令序列中的指令I0，此时C0内物理资源很大可能未被充分利用（比如“正在使用ALU，未使用FPU”，“正在使用CU，未使用ALU”），为充分榨干C0硬件性能，设计引入特殊硬件机制，使得在该时间分片内可同时加载P个线程所执行程序的指令序列，即相当于虚拟出了P个逻辑CPU Core，称之为P路SMT（Intel的实现方案称为“Hyper-Threading”，简称“HT”，默认都是2路SMT）。</p>
</blockquote>
</blockquote>
<p>以上提及的“特殊硬件机制”，存在多种方案：</p>
<ul>
<li>ILP（Instruction-Level Parallelism）技术。如果两条指令既不互相依赖，又支持同时执行，那么可并行执行，在一个CPU时间分片内，同时加载P个线程所执行程序的指令序列，最大程度并行执行可同时执行的指令对，相当于虚拟出了P个逻辑CPU Core</li>
<li>Intel使用自己的硬件方案（具体的硬件方案描述，笔者不甚清晰），默认是将一个CPU Core虚拟成2个逻辑CPU Core，即2路SMT</li>
</ul>
<p><strong>[备注]</strong> 相较于“P个CPU”和“P个CPU Core”，P路SMT中的P最名不符实，因为其共享最多物理资源，因竞争资源而导致其余P-1个线程等待的概率最大。</p>
<h2 id="三、CPU核心参数"><a href="#三、CPU核心参数" class="headerlink" title="三、CPU核心参数"></a><strong>三、CPU核心参数</strong></h2><p>在“二、CPU架构”中，我们知道，现代CPU架构下存在“物理CPU -&gt; 物理CPU Core -&gt; 逻辑CPU Core”3个CPU相关概念层次，相应的，<code>CPU</code>的含义也得到了泛化，可能指代“处理器这个广义的概念客体”或者“物理CPU”或者“物理CPU Core”或者“逻辑CPU Core”。</p>
<p>故理清概念如下，后续如无特别说明，基于此进行叙述。</p>
<ul>
<li>物理CPU</li>
<li>物理CPU Core</li>
<li>逻辑CPU Core</li>
</ul>
<p>另外特别值得说明的是，对应于“物理CPU -&gt; 物理CPU Core -&gt; 逻辑CPU Core”层级关系，存在CPU参数层级关系，具体是：</p>
<ol>
<li>某层的CPU参数，或者来自于继承，或者只属于本层，比如“逻辑CPU Core的逻辑编号只属于本层”，“逻辑CPU Core的主频继承自所在物理CPU Core”，“逻辑CPU Core的L1和L2 Cache继承自所在物理CPU Core，L3 Cache继承自所在物理CPU”</li>
<li>有时候难以明确逻辑CPU Core的某个参数是继承自所在物理CPU Core还是所在物理CPU，因为这跟具体的CPU架构有关</li>
</ol>
<h3 id="3-1、CPU相关数量"><a href="#3-1、CPU相关数量" class="headerlink" title="3.1、CPU相关数量"></a><strong>3.1、CPU相关数量</strong></h3><p>CPU相关数量有：</p>
<ul>
<li>物理CPU数量</li>
<li>物理CPU Core数量 &#x3D; ∑ 物理CPU<sub>i</sub>上物理CPU Core数量</li>
<li>逻辑CPU Core数量 &#x3D; ∑ 物理CPU<sub>i</sub>上逻辑CPU Core数量</li>
<li>CPU数量，一般说CPU数量指的就是逻辑CPU Core数量</li>
</ul>
<p><strong>1、一个例子</strong><br>一个示例CPU架构描述如下表。</p>
<table>
<thead>
<tr>
<th>物理CPU编号</th>
<th>物理CPU上物理CPU Core数量</th>
<th>是否开启SMT</th>
</tr>
</thead>
<tbody><tr>
<td>CPU<sub>1</sub></td>
<td>2</td>
<td>是，开启2-SMT</td>
</tr>
<tr>
<td>CPU<sub>2</sub></td>
<td>4</td>
<td>否</td>
</tr>
<tr>
<td>CPU<sub>3</sub></td>
<td>2</td>
<td>否</td>
</tr>
</tbody></table>
<p>物理CPU数量 &#x3D; 3<br>物理CPU Core数量 &#x3D; 2 + 4 + 2<br>逻辑CPU Core数量 &#x3D; 2 * 2 + 4 + 2</p>
<p><strong>[备注]</strong> 一般情况下，在一个“多物理CPU，物理CPU上多物理CPU Core”的CPU架构中，物理CPU上的物理CPU Core数量全局一致，是否开启SMT也是全局一致。</p>
<h3 id="3-2、主频"><a href="#3-2、主频" class="headerlink" title="3.2、主频"></a><strong>3.2、主频</strong></h3><p>主频是指CPU运算时的工作频率，其倒数指的是时钟周期。通常CPU完成一条指令的执行需要多个操作——“取指、译码、执行”。每个操作可能需要若干个时钟周期。故指令完成执行的时间 &#x3D; <code>时钟周期个数 * 时钟周期</code>，而时钟周期是工作频率的倒数，那么在其他条件相同的情况下有：工作频率越高，指令完成执行的时间越少。</p>
<p>须注意的是：评价CPU不能仅看主频维度参数，还需关注其他维度的参数，比如“核心数”，“工艺”，“CPU高速缓存”，“指令版本”等。比如“两代CPU（CPU A和CPU B），其他条件都相同，CPU A的主频是CPU B的两倍，但是CPU A的指令平均时钟周期个数是CPU B的3倍，那么总的来说，CPU A的平均指令时间是CPU B的1.5倍”。</p>
<p>主频可分为两类——额定主频和工作实际主频：</p>
<ul>
<li>从额定主频视角，一般情况下，所有CPU的额定主频一致，除非有特殊需求</li>
<li>从工作实际主频的视角，不同CPU的工作实际主频可以不同</li>
</ul>
<h4 id="3-2-1、额定主频"><a href="#3-2-1、额定主频" class="headerlink" title="3.2.1、额定主频"></a><strong>3.2.1、额定主频</strong></h4><h5 id="3-2-1-1、额定主频与外频的关系"><a href="#3-2-1-1、额定主频与外频的关系" class="headerlink" title="3.2.1.1、额定主频与外频的关系"></a><strong>3.2.1.1、额定主频与外频的关系</strong></h5><p>外频是CPU与主板之间同步工作的频率，一般作为整个计算机的基准频率（BCLK基频）。计算机系统中其他部件的频率都是在外频的基础上，乘以一定的倍数（通过倍频器硬件）来实现，这个倍数可以是大于1（升频）的，也可以是小于1（降频）的。比如“PCI设备的额定频率是33MHz，当外频是100MHz时，倍数就是1&#x2F;3”。</p>
<p>CPU的额定主频与外频的倍数有个专有称呼，即“倍频”，故有<code>额定主频 = 外频 * 倍频</code>。</p>
<h5 id="3-2-1-2、超频"><a href="#3-2-1-2、超频" class="headerlink" title="3.2.1.2、超频"></a><strong>3.2.1.2、超频</strong></h5><p>超频就是通过BIOS或者控制软件设置提升CPU额定主频，以获得更好的运算性能，代价是更大的散热和一定的不稳定风险。超频是该特殊升频的专有称呼。<br><font color='red'>超频的操作粒度是物理CPU Core。</font></p>
<p>根据<code>额定主频 = 外频 * 倍频</code>可知，超频的实现途径有两种：</p>
<ol>
<li>倍频不变，提升外频。但是外频作为基准频率，一旦改变，整个计算机运转就存在巨大的不稳定风险，故一般不选取这种途径</li>
<li>外频不变，倍频提升。一般选取这种方案。但有些CPU厂商会锁住倍频选项，此时就不能超频</li>
</ol>
<h4 id="3-2-2、工作实际主频"><a href="#3-2-2、工作实际主频" class="headerlink" title="3.2.2、工作实际主频"></a><strong>3.2.2、工作实际主频</strong></h4><p>一般情况下，工作实际主频跟额定主频一致，但现在很多CPU厂商提供动态调节主频的功能，使得工作实际主频跟额定主频不一致。</p>
<p><strong>1、动态升频</strong><br>以Intel CPU为例进行说明，Intel较为现代的CPU提供睿频加速技术，使得CPU的主频可以在某一范围内根据处理数据需要动态上调处理器电压和内核频率，以达成更高运算性能目的。</p>
<p><strong>2、动态降频</strong><br>以Intel CPU为例进行说明，Intel较为现代的CPU提供SpeedStep®动态节能技术，它允许系统动态下调处理器电压和内核频率，以达到降低产热和节能目的。</p>
<h3 id="3-3、高速缓存"><a href="#3-3、高速缓存" class="headerlink" title="3.3、高速缓存"></a><strong>3.3、高速缓存</strong></h3><p>现代CPU中有三级高速缓存：L1 Cache，L2 Cache和L3 Cache。</p>
<h3 id="3-4、字长"><a href="#3-4、字长" class="headerlink" title="3.4、字长"></a><strong>3.4、字长</strong></h3><p>现在常见的都是64位。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://chinalhr.github.io/post/os-heart-multicpu/">https://chinalhr.github.io/post/os-heart-multicpu/</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/352676442">https://zhuanlan.zhihu.com/p/352676442</a><br>[3]<a href="https://www.intel.cn/content/www/cn/zh/gaming/resources/how-to-overclock.html">https://www.intel.cn/content/www/cn/zh/gaming/resources/how-to-overclock.html</a><br>[4]<a href="https://zhuanlan.zhihu.com/p/52112475">https://zhuanlan.zhihu.com/p/52112475</a><br>[5]<a href="https://zhuanlan.zhihu.com/p/30582175">https://zhuanlan.zhihu.com/p/30582175</a><br>[6]<a href="https://superuser.com/questions/1222372/why-do-we-have-cpus-with-all-the-cores-at-the-same-speeds-and-not-combinations-o">https://superuser.com/questions/1222372/why-do-we-have-cpus-with-all-the-cores-at-the-same-speeds-and-not-combinations-o</a><br>[7]<a href="https://stackoverflow.com/questions/2619745/mutli-core-processors-does-each-core-run-at-the-full-clock-speed-or-some-frac">https://stackoverflow.com/questions/2619745/mutli-core-processors-does-each-core-run-at-the-full-clock-speed-or-some-frac</a><br>[8]<a href="https://www.quora.com/Is-it-normal-for-CPU-cores-to-have-different-speeds">https://www.quora.com/Is-it-normal-for-CPU-cores-to-have-different-speeds</a><br>[9]<a href="https://blog.csdn.net/yhb1206/article/details/120363093">https://blog.csdn.net/yhb1206/article/details/120363093</a><br>[10]<a href="https://juejin.cn/post/7023987432680849438">https://juejin.cn/post/7023987432680849438</a><br>[11]<a href="https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html">https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html</a><br>[12]<a href="https://www.tomshardware.com/how-to/how-to-overclock-a-cpu">https://www.tomshardware.com/how-to/how-to-overclock-a-cpu</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>Chrome键盘快捷键</title>
    <url>/blog/2018/05/30/Chrome%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>本文所描述Chrome键盘快捷键针对Windows和Linux操作系统下的Chrome浏览器。</p>
<h2 id="一、标签页和窗口快捷键"><a href="#一、标签页和窗口快捷键" class="headerlink" title="一、标签页和窗口快捷键"></a><strong>一、标签页和窗口快捷键</strong></h2><table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>打开新窗口</td>
<td>Ctrl+n</td>
</tr>
<tr>
<td>在隐身模式下打开新窗口</td>
<td>Ctrl+Shift+n</td>
</tr>
<tr>
<td>打开新标签页，并跳转到该标签页</td>
<td>Ctrl+t</td>
</tr>
<tr>
<td>重新打开最后关闭的标签页，并跳转到该标签页</td>
<td>Ctrl+Shift+t</td>
</tr>
<tr>
<td>跳转到下一个&#x2F;上一个打开的标签页</td>
<td>Ctrl+PgDn&#x2F;PgUp</td>
</tr>
<tr>
<td>跳转到打开的特定标签页</td>
<td>Ctrl+1-8</td>
</tr>
<tr>
<td>跳转到最后一个打开的标签页</td>
<td>Ctrl+9</td>
</tr>
<tr>
<td>当前标签页浏览记录回退&#x2F;前进</td>
<td>Alt+向左箭头键&#x2F;向右箭头键</td>
</tr>
<tr>
<td>关闭当前标签页</td>
<td>Ctrl+w</td>
</tr>
<tr>
<td>关闭所有打开的标签页，并退出浏览器</td>
<td>Ctrl+Shift+w</td>
</tr>
</tbody></table>
<h2 id="二、功能快捷键"><a href="#二、功能快捷键" class="headerlink" title="二、功能快捷键"></a><strong>二、功能快捷键</strong></h2><table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>在新标签页中打开“历史记录”页</td>
<td>Ctrl+h</td>
</tr>
<tr>
<td>在新标签页中打开“下载内容”页</td>
<td>Ctrl+j</td>
</tr>
<tr>
<td>打开Chrome任务管理器</td>
<td>Shift+Esc</td>
</tr>
<tr>
<td>打开查找栏搜索当前网页</td>
<td>Ctrl+f</td>
</tr>
<tr>
<td>在查找时，跳转到下一个匹配内容</td>
<td>Ctrl+g</td>
</tr>
<tr>
<td>在查找时，跳转到上一个匹配内容</td>
<td>Ctrl+Shift+g</td>
</tr>
</tbody></table>
<h2 id="三、地址栏快捷键"><a href="#三、地址栏快捷键" class="headerlink" title="三、地址栏快捷键"></a><strong>三、地址栏快捷键</strong></h2><table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>跳转到地址栏</td>
<td>Ctrl+l</td>
</tr>
<tr>
<td>跳转到地址栏，并进入搜索模式</td>
<td>Ctrl+e</td>
</tr>
</tbody></table>
<h2 id="四、网页快捷键"><a href="#四、网页快捷键" class="headerlink" title="四、网页快捷键"></a><strong>四、网页快捷键</strong></h2><table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>重新加载当前网页</td>
<td>Ctrl+r</td>
</tr>
<tr>
<td>停止加载网页</td>
<td>Esc</td>
</tr>
<tr>
<td>显示当前网页的HTML源代码</td>
<td>Ctrl+u</td>
</tr>
<tr>
<td>将当前网页保存为书签</td>
<td>Ctrl+d</td>
</tr>
<tr>
<td>将所有打开的标签页保存到书签文件夹</td>
<td>Ctrl+Shift+d</td>
</tr>
<tr>
<td>向上&#x2F;下滚动网页，一次一个屏幕</td>
<td>PgUp&#x2F;PgDn</td>
</tr>
<tr>
<td>网页顶部&#x2F;底部</td>
<td>Home&#x2F;End</td>
</tr>
<tr>
<td>网页上水平滚动</td>
<td>Shift+鼠标滚轮</td>
</tr>
</tbody></table>
<h2 id="五、鼠标快捷键"><a href="#五、鼠标快捷键" class="headerlink" title="五、鼠标快捷键"></a><strong>五、鼠标快捷键</strong></h2><table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>在当前标签页中打开链接</td>
<td>鼠标单击</td>
</tr>
<tr>
<td>在新的标签页中打开链接</td>
<td>Ctrl+鼠标单击</td>
</tr>
<tr>
<td>在新的标签页中打开链接，并跳转到该新标签页</td>
<td>Ctrl+Shift+鼠标单击</td>
</tr>
<tr>
<td>在新的窗口中打开链接</td>
<td>Shift+鼠标单击</td>
</tr>
</tbody></table>
<p>备注：<br>在URL链接中设置属性，可使得不需要“Ctrl”，“Shift”等功能辅助键。</p>
<br/>
参考文献：
[1]https://support.google.com/chrome/answer/157179?hl=zh-Hans
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Command-Line Mysql Client使用教程</title>
    <url>/blog/2016/07/31/Command-Line-Mysql-Client%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、进入Mysql-Client交互模式"><a href="#一、进入Mysql-Client交互模式" class="headerlink" title="一、进入Mysql Client交互模式"></a><strong>一、进入Mysql Client交互模式</strong></h2><h3 id="1-1、命令"><a href="#1-1、命令" class="headerlink" title="1.1、命令"></a><strong>1.1、命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h HostName/Ip -P PortNumber -u User -pPassword [--vertical]</span><br></pre></td></tr></table></figure>
<h3 id="1-2、命令选项含义"><a href="#1-2、命令选项含义" class="headerlink" title="1.2、命令选项含义"></a><strong>1.2、命令选项含义</strong></h3><h4 id="1-2-1、“-h-HostName-Ip”"><a href="#1-2-1、“-h-HostName-Ip”" class="headerlink" title="1.2.1、“-h HostName&#x2F;Ip”"></a><strong>1.2.1、“-h HostName&#x2F;Ip”</strong></h4><p>指定Mysql Server地址。</p>
<h4 id="1-2-2、“-P-PortNumber”"><a href="#1-2-2、“-P-PortNumber”" class="headerlink" title="1.2.2、“-P PortNumber”"></a><strong>1.2.2、“-P PortNumber”</strong></h4><p>指定Mysql Server监听端口。</p>
<h4 id="1-2-3、“-u-User”"><a href="#1-2-3、“-u-User”" class="headerlink" title="1.2.3、“-u User”"></a><strong>1.2.3、“-u User”</strong></h4><p>指定登录Mysql Server的用户。</p>
<h4 id="1-2-4、“-pPassword”"><a href="#1-2-4、“-pPassword”" class="headerlink" title="1.2.4、“-pPassword”"></a><strong>1.2.4、“-pPassword”</strong></h4><p>指定相应用户登录Mysql Server所使用密码。</p>
<h4 id="1-2-5、“–vertical”"><a href="#1-2-5、“–vertical”" class="headerlink" title="1.2.5、“–vertical”"></a><strong>1.2.5、“–vertical”</strong></h4><p>SQL查询结果以垂直形式展示。作者认为，垂直形式比水平形式更清晰。<br><font color='red'>SQL查询以“\G”结尾，也可使得SQL查询结果以垂直形式展示。</font></p>
<h2 id="二、进入Mysql-Client交互模式后，常用命令"><a href="#二、进入Mysql-Client交互模式后，常用命令" class="headerlink" title="二、进入Mysql Client交互模式后，常用命令"></a><strong>二、进入Mysql Client交互模式后，常用命令</strong></h2><p>进入Mysql交互模式后，可执行两类命令：“SQL查询语句”和“Mysql Client功能命令”。接下来介绍几个常用命令，其中既有属于“SQL查询语句”类别的，也有属于“Mysql Client功能命令”类别的。</p>
<h3 id="2-1、exit-quit命令"><a href="#2-1、exit-quit命令" class="headerlink" title="2.1、exit&#x2F;quit命令"></a><strong>2.1、exit&#x2F;quit命令</strong></h3><p>退出Mysql Client交互模式。比如<code>exit;</code>。</p>
<h3 id="2-2、source命令"><a href="#2-2、source命令" class="headerlink" title="2.2、source命令"></a><strong>2.2、source命令</strong></h3><p>以一个文件路径作为参数，解析执行文件中内容。比如<code>source /home/dsl/a.sql;</code>。</p>
<h3 id="2-3、status命令"><a href="#2-3、status命令" class="headerlink" title="2.3、status命令"></a><strong>2.3、status命令</strong></h3><p>查询Mysql Server状态信息。比如<code>status;</code>。</p>
<h3 id="2-4、tee命令"><a href="#2-4、tee命令" class="headerlink" title="2.4、tee命令"></a><strong>2.4、tee命令</strong></h3><p>以一个文件路径作为参数，将所有终端模拟器（比如Gnome Terminal）所打印信息同步打印到该文件，便于我们分析和处理SQL查询结果。比如<code>tee /home/dsl/mysql.out;</code>。</p>
<h3 id="2-5、use命令"><a href="#2-5、use命令" class="headerlink" title="2.5、use命令"></a><strong>2.5、use命令</strong></h3><p>以一个Database名称作为参数，将该Database设为默认Database。比如<code>use dslztx;</code>。</p>
<h3 id="2-6、charset命令"><a href="#2-6、charset命令" class="headerlink" title="2.6、charset命令"></a><strong>2.6、charset命令</strong></h3><p>以一个字符集名称作为参数，指定Mysql Client使用的字符集。注意跟图1中的字符集配置结合使用。比如<code>charset gbk;</code>。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20160731-0-0.png"></p>
<br/>
参考文献：
[1]mysql --help
[2]Mysql Client交互模式内执行`help`命令
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Confluence Wiki标记语言</title>
    <url>/blog/2017/02/07/Confluence-Wiki%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a><strong>一、标题</strong></h2><h3 id="1-1、语法"><a href="#1-1、语法" class="headerlink" title="1.1、语法"></a><strong>1.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1.一级标题</span><br><span class="line">h2.二级标题</span><br><span class="line">h3.三级标题</span><br><span class="line">h4.四级标题</span><br><span class="line">h5.五级标题</span><br><span class="line">h6.六级标题</span><br></pre></td></tr></table></figure>
<h3 id="1-2、效果"><a href="#1-2、效果" class="headerlink" title="1.2、效果"></a><strong>1.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-1.png"></p>
<h2 id="二、文本效果"><a href="#二、文本效果" class="headerlink" title="二、文本效果"></a><strong>二、文本效果</strong></h2><h3 id="2-1、语法"><a href="#2-1、语法" class="headerlink" title="2.1、语法"></a><strong>2.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*加粗*</span><br><span class="line">_强调_</span><br><span class="line">??引用??</span><br><span class="line">-删除线-</span><br><span class="line">+下划线+</span><br><span class="line">对象（接下来有个空格） ^上标^</span><br><span class="line">对象（接下来有个空格） ~下标~</span><br><span class="line">bq.文字引用</span><br><span class="line">&#123;quote&#125;</span><br><span class="line">段落引用</span><br><span class="line">第一段</span><br><span class="line">第二段</span><br><span class="line">&#123;quote&#125;</span><br><span class="line">&#123;color:red&#125;设置文字颜色&#123;color&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、效果"><a href="#2-2、效果" class="headerlink" title="2.2、效果"></a><strong>2.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-2.png"></p>
<h2 id="三、短线组合"><a href="#三、短线组合" class="headerlink" title="三、短线组合"></a><strong>三、短线组合</strong></h2><h3 id="3-1、语法"><a href="#3-1、语法" class="headerlink" title="3.1、语法"></a><strong>3.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下划线</span><br><span class="line">----</span><br><span class="line">如图符号</span><br><span class="line">---</span><br><span class="line">如图符号</span><br><span class="line">--</span><br></pre></td></tr></table></figure>
<h3 id="3-2、效果"><a href="#3-2、效果" class="headerlink" title="3.2、效果"></a><strong>3.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-3.png"></p>
<h2 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a><strong>四、链接</strong></h2><h3 id="4-1、语法"><a href="#4-1、语法" class="headerlink" title="4.1、语法"></a><strong>4.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[链接别名|http://www.google.com]</span><br><span class="line">[附件链接别名|^attachment.txt]</span><br></pre></td></tr></table></figure>
<h3 id="4-2、效果"><a href="#4-2、效果" class="headerlink" title="4.2、效果"></a><strong>4.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-4.png"></p>
<h2 id="五、列表"><a href="#五、列表" class="headerlink" title="五、列表"></a><strong>五、列表</strong></h2><h3 id="5-1、语法"><a href="#5-1、语法" class="headerlink" title="5.1、语法"></a><strong>5.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 无序条目1</span><br><span class="line">** 第二层级无序条目1</span><br><span class="line">*** 第三层级无序条目1</span><br><span class="line">*** 第三层级无序条目2</span><br><span class="line">*** 第三层级无序条目3</span><br><span class="line">** 第二层级无序条目2</span><br><span class="line">** 第二层级无序条目3</span><br><span class="line">* 无序条目2</span><br><span class="line">* 无序条目3</span><br><span class="line"></span><br><span class="line"># 有序条目1</span><br><span class="line">## 第二层级有序条目1</span><br><span class="line">### 第三层级有序条目1</span><br><span class="line">### 第三层级有序条目2</span><br><span class="line">### 第三层级有序条目3</span><br><span class="line">## 第二层级有序条目2</span><br><span class="line">## 第二层级有序条目3</span><br><span class="line"># 有序条目２</span><br><span class="line"># 有序条目3</span><br><span class="line"></span><br><span class="line"># 混合有序条目1</span><br><span class="line">#* 混合无序条目1</span><br><span class="line">#* 混合无序条目2</span><br><span class="line">#* 混合无序条目3</span><br><span class="line"># 混合有序条目2</span><br><span class="line"># 混合有序条目3</span><br></pre></td></tr></table></figure>
<h3 id="5-2、效果"><a href="#5-2、效果" class="headerlink" title="5.2、效果"></a><strong>5.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-5.png"></p>
<h2 id="六、图像"><a href="#六、图像" class="headerlink" title="六、图像"></a><strong>六、图像</strong></h2><h3 id="6-1、语法"><a href="#6-1、语法" class="headerlink" title="6.1、语法"></a><strong>6.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图像上文</span><br><span class="line">!http://imgsrc.baidu.com/forum/w%3D580/sign=c8f895faba0e7bec23da03e91f2cb9fa/60257b9759ee3d6da402063e41166d224e4ade1c.jpg|border=5,align=center!</span><br><span class="line">图像下文</span><br></pre></td></tr></table></figure>
<p>备注：可引用附件中的图像。</p>
<h3 id="6-2、效果"><a href="#6-2、效果" class="headerlink" title="6.2、效果"></a><strong>6.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-6.png"></p>
<h2 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a><strong>七、表格</strong></h2><h3 id="7-1、语法"><a href="#7-1、语法" class="headerlink" title="7.1、语法"></a><strong>7.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">||heading 1||heading 2||heading 3|| </span><br><span class="line">|col A1|col A2|col A3| </span><br><span class="line">|col B1|col B2|col B3|</span><br></pre></td></tr></table></figure>
<h3 id="7-2、效果"><a href="#7-2、效果" class="headerlink" title="7.2、效果"></a><strong>7.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-7.png"></p>
<h2 id="八、代码片段"><a href="#八、代码片段" class="headerlink" title="八、代码片段"></a><strong>八、代码片段</strong></h2><h3 id="8-1、语法"><a href="#8-1、语法" class="headerlink" title="8.1、语法"></a><strong>8.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;code:title=Bar.java|borderStyle=solid&#125;</span><br><span class="line">// Some comments here</span><br><span class="line">public String getFoo()</span><br><span class="line">&#123;</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">&#123;code&#125; </span><br><span class="line"></span><br><span class="line">&#123;code:xml&#125; </span><br><span class="line">&lt;test&gt; </span><br><span class="line">  &lt;another tag=&quot;attribute&quot;/&gt; </span><br><span class="line">&lt;/test&gt; </span><br><span class="line">&#123;code&#125; </span><br></pre></td></tr></table></figure>
<h3 id="8-2、效果"><a href="#8-2、效果" class="headerlink" title="8.2、效果"></a><strong>8.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-8.png"></p>
<h2 id="九、转义符号"><a href="#九、转义符号" class="headerlink" title="九、转义符号"></a><strong>九、转义符号</strong></h2><h3 id="9-1、语法"><a href="#9-1、语法" class="headerlink" title="9.1、语法"></a><strong>9.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\*</span><br><span class="line">\&#123;</span><br><span class="line">\&#125;</span><br><span class="line">\#</span><br></pre></td></tr></table></figure>
<h3 id="9-2、效果"><a href="#9-2、效果" class="headerlink" title="9.2、效果"></a><strong>9.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20170207-0-9.png"></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian开启邮件MTA</title>
    <url>/blog/2019/01/17/Debian%E5%BC%80%E5%90%AF%E9%82%AE%E4%BB%B6MTA/</url>
    <content><![CDATA[<p>Debian上默认安装的邮件MTA是“Exim4”，开启“Exim4”的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/exim4 start</span><br></pre></td></tr></table></figure>

<p>备注：<br>“Exim4”这个邮件MTA可作为SMTP Server</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Executors</title>
    <url>/blog/2021/05/15/Executors/</url>
    <content><![CDATA[<p>一个跟线程池相关的工厂方法类，主要用来生成几类“ThreadPoolExecutor”和“ScheduledThreadPoolExecutor”。</p>
<p>在继续介绍之前，根据阿里巴巴的《Java开发手册》，首先须知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line"> </span><br><span class="line">说明：Executors返回的线程池对象的弊端如下：</span><br><span class="line">1）FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</span><br><span class="line">2）CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</span><br></pre></td></tr></table></figure>

<p>同理可推及不应该用Executors去创建ScheduledThreadPoolExecutor，而是显式创建。</p>
<h2 id="一、生成ThreadPoolExecutor"><a href="#一、生成ThreadPoolExecutor" class="headerlink" title="一、生成ThreadPoolExecutor"></a><strong>一、生成ThreadPoolExecutor</strong></h2><p>常见的有3个方法，这里不列出增加一个“ThreadFactory threadFactory”的重载方法：</p>
<ul>
<li><code>public static ExecutorService newCachedThreadPool()</code>：方法主体为<code>new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;())</code>，根据以上构造参数构造的ThreadPoolExecutor实例语义可见[1]，“SynchronousQueue”的语义可见[3]</li>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：方法主体为<code>new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())</code>，根据以上构造参数构造的ThreadPoolExecutor实例语义可见[1]，“LinkedBlockingQueue”的语义可见[3]</li>
<li><code>public static ExecutorService newSingleThreadExecutor()</code>：方法主体为<code>new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()))</code>，根据以上构造参数构造的ThreadPoolExecutor实例语义可见[1]，“LinkedBlockingQueue”的语义可见[3]，查看FinalizableDelegatedExecutorService类的定义，它采用了“代理设计模式”，内部核心对象是上面构造的ThreadPoolExecutor实例，向外只暴露ExecutorService接口定义的方法。<font color='red'>与之对应的是上面两个方法返回的实际对象是ThreadPoolExecutor，向下转型成ThreadPoolExecutor实例后除了可调用ExecutorService接口中定义的方法，还可调用ThreadPoolExecutor类中新增的方法</font></li>
</ul>
<h2 id="二、生成ScheduledThreadPoolExecutor"><a href="#二、生成ScheduledThreadPoolExecutor" class="headerlink" title="二、生成ScheduledThreadPoolExecutor"></a><strong>二、生成ScheduledThreadPoolExecutor</strong></h2><p>常见的有2个方法，这里不列出增加一个“ThreadFactory threadFactory”的重载方法：</p>
<ul>
<li><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>：方法主体为<code>new ScheduledThreadPoolExecutor(corePoolSize)</code>，根据以上构造参数构造的ScheduledThreadPoolExecutor实例语义可见[2]</li>
<li><code>public static ScheduledExecutorService newSingleThreadScheduledExecutor()</code>：方法主体为<code>new DelegatedScheduledExecutorService(new ScheduledThreadPoolExecutor(1))</code>，根据以上构造参数构造的ScheduledThreadPoolExecutor实例语义可见[2]，查看DelegatedScheduledExecutorService类的定义，它采用了“代理设计模式”，内部核心对象是上面构造的ScheduledThreadPoolExecutor实例，向外只暴露ScheduledExecutorService接口定义的方法。<font color='red'>与之对应的是上面一个方法返回的实际对象是ScheduledThreadPoolExecutor，向下转型成ScheduledThreadPoolExecutor实例后除了可调用ScheduledExecutorService接口中定义的方法，还可调用ScheduledThreadPoolExecutor类中新增的方法</font></li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/05/13/ThreadPoolExecutor/" title="ThreadPoolExecutor">《ThreadPoolExecutor》</a><br>[2]<a href="/blog/2021/05/14/ScheduledThreadPoolExecutor/" title="ScheduledThreadPoolExecutor">《ScheduledThreadPoolExecutor》</a><br>[3]<a href="/blog/2021/08/11/%E5%B9%B6%E5%8F%91Queue/" title="并发Queue">《并发Queue》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Ext文件系统中，文件的“占用大小”和“使用大小”</title>
    <url>/blog/2016/10/18/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E2%80%9C%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D%E5%92%8C%E2%80%9C%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>Ext文件系统中，采用“inode&#x2F;block”结构来存储目录文件和一般文件。即目录文件有1个inode节点和1到多个block节点，block节点中存储“&lt;子文件文件名，子文件inode节点序号&gt;”记录；一般文件有1个inode节点和0到多个block节点，block节点中存储一般文件的具体内容。</p>
<h2 id="二、占用大小和使用大小"><a href="#二、占用大小和使用大小" class="headerlink" title="二、占用大小和使用大小"></a><strong>二、占用大小和使用大小</strong></h2><p>由于采用block节点机制，关于文件的“大小”，就有两个概念：占用大小和使用大小。根据以下两者的定义，可知一般情况下，“文件的使用大小”&lt;&#x3D;“文件的占用大小”。</p>
<h3 id="2-1、占用大小"><a href="#2-1、占用大小" class="headerlink" title="2.1、占用大小"></a><strong>2.1、占用大小</strong></h3><p>占用大小&#x3D;文件对应的block节点个数*单个block节点大小。</p>
<h3 id="2-2、使用大小"><a href="#2-2、使用大小" class="headerlink" title="2.2、使用大小"></a><strong>2.2、使用大小</strong></h3><p>使用大小&#x3D;block节点1使用大小（有些空间被空置）+block节点2使用大小（有些空间被空置）+…+block节点N使用大小（有些空间被空置）[假定文件对应N个block节点]。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>显示文件大小的命令（比如“stat命令”，“ls命令”，“du命令”等）显示“占用大小”，还是“使用大小”，由命令具体实现决定。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>GFW原理</title>
    <url>/blog/2024/02/06/GFW%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、防火墙原理"><a href="#一、防火墙原理" class="headerlink" title="一、防火墙原理"></a><strong>一、防火墙原理</strong></h2><p>防火墙屏蔽主要有以下这3种形式：</p>
<ol>
<li>DNS污染，进行域名解析的时候，它返回给你错误的IP</li>
<li>封杀IP地址</li>
<li>关键词过滤</li>
</ol>
<h2 id="二、穿越防火墙原理"><a href="#二、穿越防火墙原理" class="headerlink" title="二、穿越防火墙原理"></a><strong>二、穿越防火墙原理</strong></h2><p>针对以上屏蔽方式，解决方案分别如下：</p>
<ol>
<li>针对1，我们可以通过Hosts文件，在本地进行域名解析</li>
<li>针对2和3，只能通过加密代理等方式进行，比如使用GoAgent（Google服务器作为代理服务器），VPN，ShadowSocks，Skype等程序和机制</li>
</ol>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>GNU ERE正则表达式</title>
    <url>/blog/2017/06/05/GNU-ERE%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>GNU ERE正则表达式的正则表达式匹配引擎采用的匹配模型见<a href="/blog/2017/06/02/%E4%B8%80%E7%A7%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B/" title="一种正则表达式匹配模型">《一种正则表达式匹配模型》</a>。<br>由于GNU grep命令的“-E”模式使用GNU ERE正则表达式，因此本文接下来使用它进行实验。<br>特别需要强调的是，由于“locale设置”不同，操作系统环境不同等因素，同一个正则表达式可能具有不同的表达含义。比如在“locale&#x3D;C”设置下，“[a-d]”等价于“[abcd]”，而在有些locale设置下，“[a-d]”等价于“[aBbCcDd]”。又比如只在有些locale设置中，“\w”等价于“[a-zA-Z_0-9]”，“\W”等价于“[^a-zA-Z_0-9]”才成立。<br><font color='red'>接下来的语法介绍只针对“一般情形”，而不针对“特殊情形”，为了确保在你的“具体情形”下，正则表达式能够如你所期望地进行表达，最好能够提前进行一些测试。</font><br>正则表达式中不同语法单元具有不同的优先级顺序，无需记忆，使用“匹配组（即<code>()</code>对）”方式更加清晰明了。</p>
<h2 id="一、字符类"><a href="#一、字符类" class="headerlink" title="一、字符类"></a><strong>一、字符类</strong></h2><h3 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a><strong>1.1、定义</strong></h3><table>
<thead>
<tr>
<th>字符类</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>匹配“a，b，c”3个字符之一</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配除了“a，b，c”3个字符之外的任意一个字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>匹配26个小写英文字符和26个大写英文字符中的任意一个</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>匹配除了26个小写英文字符之外的任意一个字符</td>
</tr>
</tbody></table>
<h3 id="1-2、实验"><a href="#1-2、实验" class="headerlink" title="1.2、实验"></a><strong>1.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;[old]&#39; a.txt</code></td>
<td>hello world</td>
</tr>
<tr>
<td><code>grep -E &#39;[^old]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;[x-z]&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
</tbody></table>
<h2 id="二、预定义字符类"><a href="#二、预定义字符类" class="headerlink" title="二、预定义字符类"></a><strong>二、预定义字符类</strong></h2><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a><strong>2.1、定义</strong></h3><table>
<thead>
<tr>
<th>预定义字符类</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符，除了行终止符</td>
</tr>
<tr>
<td>\w</td>
<td>等价于[a-zA-Z_0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>等价于[^\w]</td>
</tr>
</tbody></table>
<h3 id="2-2、实验"><a href="#2-2、实验" class="headerlink" title="2.2、实验"></a><strong>2.2、实验</strong></h3><p>有文件“a.txt”，内容如下（第5行是个“TAB”字符）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a$</span><br><span class="line">A$</span><br><span class="line">9$</span><br><span class="line">_$</span><br><span class="line">	</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;.&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$<br/>	<br/>$$</td>
</tr>
<tr>
<td><code>grep -E &#39;\w&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$</td>
</tr>
<tr>
<td><code>grep -E &#39;\W&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$<br/>	<br/>$$</td>
</tr>
</tbody></table>
<h2 id="三、量词修饰符"><a href="#三、量词修饰符" class="headerlink" title="三、量词修饰符"></a><strong>三、量词修饰符</strong></h2><h3 id="3-1、定义"><a href="#3-1、定义" class="headerlink" title="3.1、定义"></a><strong>3.1、定义</strong></h3><table>
<thead>
<tr>
<th>量词修饰符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>匹配0次或者1次</td>
</tr>
<tr>
<td>X*</td>
<td>匹配0次或者0次以上</td>
</tr>
<tr>
<td>X+</td>
<td>匹配1次或者1次以上</td>
</tr>
<tr>
<td>X{n}</td>
<td>匹配n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>匹配至少n次</td>
</tr>
<tr>
<td>X{,m}</td>
<td>匹配至多m次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>匹配至少n次，至多m次</td>
</tr>
</tbody></table>
<h3 id="3-2、实验"><a href="#3-2、实验" class="headerlink" title="3.2、实验"></a><strong>3.2、实验</strong></h3><p>有文件“a.txt”，内容如下（第1行是空行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;a?&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep -E &#39;a*&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep -E &#39;b+&#39; a.txt</code></td>
<td>bb</td>
</tr>
<tr>
<td><code>grep -E &#39;.&#123;2&#125;&#39; a.txt</code></td>
<td>bb<br/>ccc</td>
</tr>
<tr>
<td><code>grep -E &#39;.&#123;1,&#125;&#39; a.txt</code></td>
<td>a<br/>bb<br/>ccc</td>
</tr>
<tr>
<td><code>grep -E &#39;.&#123;,2&#125;&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep -E &#39;.&#123;2,3&#125;&#39; a.txt</code></td>
<td>bb<br/>ccc</td>
</tr>
</tbody></table>
<h2 id="四、匹配组"><a href="#四、匹配组" class="headerlink" title="四、匹配组"></a><strong>四、匹配组</strong></h2><h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a><strong>4.1、定义</strong></h3><p>正则表达式中由“()”对括起来的子表达式被称为“匹配组”，它作为独立的匹配单元参与匹配。在正则表达式中，“匹配组”的数量就是“()”对的数量，“匹配组”的标号按照“(”符号出现的先后顺序进行确定：从“1标号-匹配组”开始。<font color='red'>也存在“0标号-匹配组”，它是特殊的“匹配组”，它代表整个正则表达式。</font>比如有<code>((A)(B(C)))</code>，其中“匹配组”数量为“4”，“1标号-匹配组”是“((A)(B(C)))”，“2标号-匹配组”是“(A)”，“3标号-匹配组”是“(B(C))”，“4标号-匹配组”是“(C)”，“0标号-匹配组”是“((A)(B(C)))”；又有<code>(A)(B(C))</code>，其中“匹配组”数量为“3”，“1标号-匹配组”是“(A)”，“2标号-匹配组”是“(B(C))”，“3标号-匹配组”是“(C)”，“0标号-匹配组”是“(A)(B(C))”。<br>可通过“\匹配组标号”形式在正则表达式引用相应“匹配组”在目标字符串中的匹配字符串内容，需要注意的是，不能使用“\0”，因为这是“语义非法的”。证明如下：现有一个正则表达式“abc\0”（a，b，c分别表示3个部分），为使该正则表达式有意义，“abc”3部分至少有一个不为空，假定该正则表达式存在对应的匹配字符串T，由于“T”与“\0”匹配，而“abc”至少有一个不为空，得到一个矛盾，因此假定不成立，即该正则表达式无对应的匹配字符串。</p>
<h3 id="4-2、实验"><a href="#4-2、实验" class="headerlink" title="4.2、实验"></a><strong>4.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcabc</span><br><span class="line">abcabd</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;([a-z]&#123;3&#125;)\1&#39; a.txt</code></td>
<td>abcabc</td>
</tr>
<tr>
<td><code>grep -E &#39;([a-z]&#123;2&#125;)c\1&#39; a.txt</code></td>
<td>abcabc<br/>abcabd</td>
</tr>
</tbody></table>
<h2 id="五、边界匹配符"><a href="#五、边界匹配符" class="headerlink" title="五、边界匹配符"></a><strong>五、边界匹配符</strong></h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a><strong>5.1、定义</strong></h3><table>
<thead>
<tr>
<th>边界匹配符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>索引位置为“行首位置”，跟行终止符无关</td>
</tr>
<tr>
<td>$</td>
<td>索引位置为“行尾位置”，行终止符为“\n”</td>
</tr>
<tr>
<td>&lt;</td>
<td>索引位置为“行首位置”，跟行终止符无关，跟“^”等价</td>
</tr>
<tr>
<td>\&gt;</td>
<td>索引位置为“行尾位置”，行终止符为“\r”或者“\n”</td>
</tr>
<tr>
<td>\b</td>
<td>索引位置为“单词边界位置”</td>
</tr>
<tr>
<td>\B</td>
<td>索引位置为“非单词边界位置”</td>
</tr>
</tbody></table>
<h3 id="5-2、实验"><a href="#5-2、实验" class="headerlink" title="5.2、实验"></a><strong>5.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>
<p>执行<code>od -A d -t x1cz -v -w10 a.txt</code>命令，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000  68  65  6c  6c  6f  20  77  6f  72  6c</span><br><span class="line">          h   e   l   l   o       w   o   r   l  &gt;hello worl&lt;</span><br><span class="line">0000010  64  0a  74  68  69  73  20  69  73  20</span><br><span class="line">          d  \n   t   h   i   s       i   s      &gt;d.this is &lt;</span><br><span class="line">0000020  61  6e  20  65  78  70  65  72  69  6d</span><br><span class="line">          a   n       e   x   p   e   r   i   m  &gt;an experim&lt;</span><br><span class="line">0000030  65  6e  74  0a</span><br><span class="line">          e   n   t  \n                          &gt;ent.&lt;</span><br><span class="line">0000034</span><br></pre></td></tr></table></figure>
<p>有文件“b.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>
<p>执行<code>od -A d -t x1cz -v -w10 b.txt</code>命令，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000  68  65  6c  6c  6f  20  77  6f  72  6c</span><br><span class="line">          h   e   l   l   o       w   o   r   l  &gt;hello worl&lt;</span><br><span class="line">0000010  64  0d  0a  74  68  69  73  20  69  73</span><br><span class="line">          d  \r  \n   t   h   i   s       i   s  &gt;d..this is&lt;</span><br><span class="line">0000020  20  61  6e  20  65  78  70  65  72  69</span><br><span class="line">              a   n       e   x   p   e   r   i  &gt; an experi&lt;</span><br><span class="line">0000030  6d  65  6e  74  0d  0a</span><br><span class="line">          m   e   n   t  \r  \n                  &gt;ment..&lt;</span><br><span class="line">0000036</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;\be&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;\Bh\B&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;^[ht]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;^[ht]&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;\&lt;[ht]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;\&lt;[ht]&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;[dt]$&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;[dt]$&#39; b.txt</code></td>
<td></td>
</tr>
<tr>
<td><code>grep -E &#39;[dt]\&gt;&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep -E &#39;[dt]\&gt;&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
</tbody></table>
<h2 id="六、转义"><a href="#六、转义" class="headerlink" title="六、转义"></a><strong>六、转义</strong></h2><h3 id="6-1、定义"><a href="#6-1、定义" class="headerlink" title="6.1、定义"></a><strong>6.1、定义</strong></h3><p>在正则表达式中，使用前导“\”字符来转义元字符。元字符有<code>+&#123;&#125;|()?[].^$*-</code>等。</p>
<h3 id="6-2、实验"><a href="#6-2、实验" class="headerlink" title="6.2、实验"></a><strong>6.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;.&#39; a.txt</code></td>
<td>a<br/>.</td>
</tr>
<tr>
<td><code>grep -E &#39;\.&#39; a.txt</code></td>
<td>.</td>
</tr>
</tbody></table>
<h2 id="七、操作符"><a href="#七、操作符" class="headerlink" title="七、操作符"></a><strong>七、操作符</strong></h2><h3 id="7-1、定义"><a href="#7-1、定义" class="headerlink" title="7.1、定义"></a><strong>7.1、定义</strong></h3><table>
<thead>
<tr>
<th>操作符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td>“或”操作符</td>
</tr>
</tbody></table>
<h3 id="7-2、实验"><a href="#7-2、实验" class="headerlink" title="7.2、实验"></a><strong>7.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab</span><br><span class="line">dc</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep -E &#39;ab&#124;dc&#39; a.txt</code></td>
<td>ab<br/>dc</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]man grep
[2]http://www.regular-expressions.info/gnu.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>FutureTask和ScheduledFutureTask</title>
    <url>/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/</url>
    <content><![CDATA[<p>在阅读和过程中，会碰到以下几个互相之间具有联系的类和接口：</p>
<ul>
<li>Runnable</li>
<li>Future</li>
<li>RunnableFuture</li>
<li>FutureTask</li>
<li>Callable</li>
<li>ScheduledFuture</li>
<li>RunnableScheduledFuture</li>
<li>ScheduledFutureTask</li>
</ul>
<p>相关继承类图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210516-0-0.svg"></p>
<p>本文接下来基于具体实现类“FutureTask”和“ScheduledFutureTask”梳理上述类和接口的脉络关系，以便于理解。</p>
<h2 id="一、FutureTask"><a href="#一、FutureTask" class="headerlink" title="一、FutureTask"></a><strong>一、FutureTask</strong></h2><h3 id="1-1、演进"><a href="#1-1、演进" class="headerlink" title="1.1、演进"></a><strong>1.1、演进</strong></h3><p>需求：向线程池提交一个任务后，能够控制过程和获取结果。</p>
<p>演进：</p>
<ol start="0">
<li>设计Future接口作为向线程池提交任务后的返回对象，通过它控制过程和获取结果</li>
<li>线程池中执行任务，任务的最终载体必然是Runnable接口，其与返回的Future结果属于跨线程关系，因此两者产生关联的唯一途径是共享内存，自然而然设计RunnableFuture接口</li>
<li>执行RunnableFuture接口的<code>run()</code>方法，然后将执行结果赋值到RunnableFuture实例的某个成员变量</li>
<li>FutureTask是RunnableFuture接口的实现类，引入一个<code>Callable callable</code>成员变量，在<code>run()</code>方法中执行该Callable接口的<code>call()</code>方法，然后<code>call()</code>方法的返回结果被赋值到<code>Object outcome</code>成员变量</li>
<li>由以上点可知，FutureTask的<code>run()</code>方法中调度执行Callable接口的<code>call()</code>方法：如果在调度任务时直接传入Callable接口，自然没啥问题；但是如果传入的是Runnable接口，则需要进行适配，具体是通过Executors.RunnableAdapter类，它实现了Callable接口，查看Executors.RunnableAdapter类的唯一构造方法，须传入两个参数，一个是<code>Runnable task</code>，另外一个是<code>T result</code>，后者表示预设的<code>call()</code>方法返回结果，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
</ol>
<p>Future接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunnableFuture接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunnableAdapter类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、源码阅读"><a href="#1-2、源码阅读" class="headerlink" title="1.2、源码阅读"></a><strong>1.2、源码阅读</strong></h3><p>带有笔者注释的FutureTask源码版本见<a href="https://github.com/dslztx/jdk8_study/blob/master/src/main/java/java/util/concurrent/FutureTask.java">链接</a>。</p>
<h4 id="1-2-1、内部状态"><a href="#1-2-1、内部状态" class="headerlink" title="1.2.1、内部状态"></a><strong>1.2.1、内部状态</strong></h4><p>有成员变量<code>volatile int state</code>，表征内部状态。</p>
<p>其内部状态列表如下：</p>
<ul>
<li><code>NEW=0</code>，初始状态</li>
<li><code>COMPLETING=1</code>，转向<code>NORMAL</code>或者<code>EXCEPTIONAL</code>时的临时中间状态</li>
<li><code>NORMAL=2</code>，<code>run()</code>方法内调用<code>call()</code>方法未抛异常，调用正常退出</li>
<li><code>EXCEPTIONAL=3</code>，<code>run()</code>方法内调用<code>call()</code>方法抛异常，调用非正常退出</li>
<li><code>CANCELLED=4</code>，调用<code>cancel()</code>方法时，如果传入参数<code>mayInterruptIfRunning=false</code>，内部状态从<code>NEW</code>转为<code>CANCELLED</code></li>
<li><code>INTERRUPTING=5</code>，调用<code>cancel()</code>方法时，如果传入参数<code>mayInterruptIfRunning=true</code>，内部状态从<code>NEW</code>转为<code>INTERRUPTING</code></li>
<li><code>INTERRUPTED=6</code>，调用<code>cancel()</code>方法时，如果传入参数<code>mayInterruptIfRunning=true</code>，内部状态从<code>NEW</code>转为<code>INTERRUPTING</code>，等发出中断信号后，内部状态再转为<code>INTERRUPTED</code></li>
</ul>
<h4 id="1-2-2、核心方法"><a href="#1-2-2、核心方法" class="headerlink" title="1.2.2、核心方法"></a><strong>1.2.2、核心方法</strong></h4><p><strong>1、run()</strong><br>执行任务，具体逻辑是：</p>
<ol start="0">
<li>调用成员变量<code>callable</code>的<code>call()</code>方法</li>
<li>根据<code>call()</code>方法的调用是否抛出异常分为两种情况：<ul>
<li>不抛出异常：1）内部状态经历<code>NEW -&gt; COMPLETING -&gt; NORMAL</code>；2）<code>call()</code>方法的返回结果赋值给成员变量<code>outcome</code></li>
<li>抛出异常：1）内部状态经历<code>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</code>；2）抛出的Throwable对象赋值给成员变量<code>outcome</code></li>
</ul>
</li>
</ol>
<p><strong>2、runAndReset()</strong><br>STPE中提交的“周期性任务”调度执行时执行本方法，它的具体逻辑是：</p>
<ol start="0">
<li>调用成员变量<code>callable</code>的<code>call()</code>方法</li>
<li>根据<code>call()</code>方法的调用是否抛出异常分为两种情况：<ul>
<li>不抛出异常：1）<font color='red'>内部状态仍为<code>NEW</code>，否则下一个周期不能执行</font>；2）<font color='red'><code>call()</code>方法的返回结果不赋值给成员变量<code>outcome</code></font>，即使赋值了，在<code>NEW</code>内部状态下，调用<code>get()</code>方法获取结果恒挂起，调用<code>get(long timeout, TimeUnit unit)</code>方法获取结果超时后抛出<code>TimeoutException</code>异常；3）<code>runAndReset()</code>方法返回<code>true</code>值，<font color='red'>表征该周期性任务会再被加入到workQueue队列进行后续调度</font>[1]</li>
<li>抛出异常：1）内部状态经历<code>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</code>；2）抛出的Throwable对象赋值给成员变量<code>outcome</code>；3）<code>runAndReset()</code>方法返回<code>false</code>值，<font color='red'>表征该周期性任务不会再被加入到workQueue队列进行后续调度</font>[1]</li>
</ul>
</li>
</ol>
<p><strong>3、cancel(boolean mayInterruptIfRunning)</strong><br>调用<code>cancel(boolean mayInterruptIfRunning)</code>方法尝试取消<code>run()</code>或者<code>runAndReset()</code>方法的运行。</p>
<p>其核心逻辑是：</p>
<ul>
<li>如果当前内部状态不为<code>NEW</code>，表明已经执行完成，不能再取消</li>
<li>如果当前内部状态为<code>NEW</code>，表明未执行完成，尝试取消：<ul>
<li>如果传入参数<code>mayInterruptIfRunning=false</code>，则经历<code>内部状态从NEW转为CANCELLED</code>过程</li>
<li>如果传入参数<code>mayInterruptIfRunning=true</code>，则经历<code>内部状态从NEW转为INTERRUPTING -&gt; 给正在执行当前任务的线程发中断信号 -&gt; 内部状态转为INTERRUPTED</code>过程</li>
</ul>
</li>
</ul>
<p><strong>4、isCancelled()</strong><br>当内部状态是<code>CANCELLED</code>、<code>INTERRUPTING</code>或者<code>INTERRUPTED</code>时（即成功调用<code>cancel(boolean mayInterruptIfRunning)</code>方法的可能结果），返回true，否则返回false。</p>
<p><strong>5、isDone()</strong><br>当内部状态不是<code>NEW</code>时，返回true，否则返回false。</p>
<p><strong>6、get()</strong><br>获取<code>run()</code>或者<code>runAndReset()</code>方法的执行结果：</p>
<ul>
<li>当内部状态&lt;&#x3D;<code>COMPLETING</code>时，恒挂起</li>
<li>当内部状态&gt;<code>COMPLETING</code>时，分为3种情况：<ul>
<li>内部状态为<code>NORMAL</code>，表示成员变量<code>callable</code>的<code>call()</code>方法执行未抛出异常，成功退出，这里返回成员变量<code>outcome</code>值（即<code>call()</code>方法的返回结果）</li>
<li>内部状态为<code>EXCEPTIONAL</code>，表示成员变量<code>callable</code>的<code>call()</code>方法执行抛出异常，这里抛出<code>ExecutionException</code>异常</li>
<li>内部状态&gt;&#x3D;<code>CANCELLED</code>，即为<code>CANCELLED</code>、<code>INTERRUPTING</code>或者<code>INTERRUPTED</code>，表示被取消执行，这里抛出<code>CancellationException</code>异常</li>
</ul>
</li>
</ul>
<p><strong>7、get(long timeout, TimeUnit unit)</strong><br>获取<code>run()</code>或者<code>runAndReset()</code>方法的执行结果：</p>
<ul>
<li>当内部状态&lt;&#x3D;<code>COMPLETING</code>时，挂起指定时间，如果到期仍是&lt;&#x3D;<code>COMPLETING</code>，则抛出<code>TimeoutException</code>异常</li>
<li>当内部状态&gt;<code>COMPLETING</code>时，分为3种情况：<ul>
<li>内部状态为<code>NORMAL</code>，表示成员变量<code>callable</code>的<code>call()</code>方法执行未抛出异常，成功退出，这里返回成员变量<code>outcome</code>值（即<code>call()</code>方法的返回结果）</li>
<li>内部状态为<code>EXCEPTIONAL</code>，表示成员变量<code>callable</code>的<code>call()</code>方法执行抛出异常，这里抛出<code>ExecutionException</code>异常</li>
<li>内部状态&gt;&#x3D;<code>CANCELLED</code>，即为<code>CANCELLED</code>、<code>INTERRUPTING</code>或者<code>INTERRUPTED</code>，表示被取消执行，这里抛出<code>CancellationException</code>异常</li>
</ul>
</li>
</ul>
<h2 id="二、ScheduledFutureTask"><a href="#二、ScheduledFutureTask" class="headerlink" title="二、ScheduledFutureTask"></a><strong>二、ScheduledFutureTask</strong></h2><p>相较于FutureTask，ScheduledFutureTask额外继承实现了3个接口的方法：</p>
<ul>
<li>Comparable接口的<code>public int compareTo(T o)</code>方法，ScheduledFutureTask被加入到STPE中属于DelayedWorkQueue类型的workQueue，DelayedWorkQueue是一个优先级队列，需要其中的元素实现Comparable接口的上述方法</li>
<li>Delay接口的<code>long getDelay(TimeUnit unit)</code>方法，获取任务计划执行时间与当前时间的时间差值，时间差值的单位由“TimeUnit unit”指定</li>
<li>RunnableScheduledFuture接口的<code>boolean isPeriodic()</code>方法，判断当前任务是否是周期性任务</li>
</ul>
<h2 id="三、关于源码的两个困惑"><a href="#三、关于源码的两个困惑" class="headerlink" title="三、关于源码的两个困惑"></a><strong>三、关于源码的两个困惑</strong></h2><h3 id="3-1、困惑1"><a href="#3-1、困惑1" class="headerlink" title="3.1、困惑1"></a><strong>3.1、困惑1</strong></h3><p>困惑1描述：调用<code>get()/get(long timeout, TimeUnit unit)</code>方法获取<code>set(V v)/setException(Throwable t)</code>方法中设置的变量<code>outcome</code>结果时，如何证明设置的值对其是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;                                                            <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面有介绍，取巧的做法，不会影响结果</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL); <span class="comment">// final state         //2</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;                                                             <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面有介绍，取巧的做法，不会影响结果</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state     //4</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">                                                                                 <span class="comment">//5，表示这里必有state&gt;COMPLETING</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;                                                          <span class="comment">//6</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>get()</code>方法为例进行说明（<code>get(long timeout, TimeUnit unit)</code>方法的说明是类似的），相关源代码已贴在上面。</p>
<p><strong>具体证明如下</strong>：根据<code>get()</code>方法的实现逻辑可知，在调用<code>report()</code>方法之前必有<code>state&gt;COMPLETING</code>，本讨论中只关心两个状态<code>NORMAL</code>和<code>EXCEPTIONAL</code>，<code>NORMAL</code>状态通过<code>set()</code>方法中的<code>UNSAFE.putOrderedInt(this, stateOffset, NORMAL)</code>语句设置&#x2F;<code>EXCEPTIONAL</code>状态通过<code>setException(Throwable t)</code>方法中的<code>UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL)</code>语句设置，<code>state</code>是volatile变量，在<code>get()</code>方法或者<code>awaitDone(boolean timed, long nanos)</code>方法中以“一般直白”形式读取故具有volatile变量读语义，根据<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>中的“广义的volatile变量happens-before规则”，再结合happens-before规则——“程序顺序规则”和“传递性规则”，有“&#x2F;&#x2F;1 -hb-&gt; &#x2F;&#x2F;2 -hb-&gt; &#x2F;&#x2F;5 -hb-&gt; &#x2F;&#x2F;6”或者“&#x2F;&#x2F;3 -hb-&gt; &#x2F;&#x2F;4 -hb-&gt; &#x2F;&#x2F;5 -hb&gt; &#x2F;&#x2F;6”，因此&#x2F;&#x2F;1处或者&#x2F;&#x2F;3处对<code>outcome</code>的设置对&#x2F;&#x2F;6处可见。</p>
<h3 id="3-2、困惑2"><a href="#3-2、困惑2" class="headerlink" title="3.2、困惑2"></a><strong>3.2、困惑2</strong></h3><p>困惑2描述：调用<code>cancel(true)</code>方法发送的中断信号可能会泄漏而递延到下一个任务的执行过程，而导致影响其执行吗？<font color='red'>答案是否定的。</font></p>
<p>根据具体执行方法是<code>run()</code>还是<code>runAndReset()（STPE中提交的“周期性任务”调度执行时执行该方法）</code>分为两种情形进行讨论证明。</p>
<h4 id="3-2-1、run"><a href="#3-2-1、run" class="headerlink" title="3.2.1、run()"></a><strong>3.2.1、run()</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))       <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    t.interrupt();                                      <span class="comment">//2</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">//上面有介绍，取巧的做法，不会影响结果</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);   <span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run() 见最开始的判断语句</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;                                                  <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)   </span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let&#x27;s spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">    <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">    <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">    <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">    <span class="comment">// cancellation interrupt.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Thread.interrupted();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就是有可能c.call()中有发出有用的中断信号，不能区分cancel()方法发出的还是c.call()发出的，故不能复位中断信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对的是构造时的`setState(-1)`语句，后续可以调用`interruptIfStarted()`方法了，否则是没有效果的</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//就是只有处于STOP状态，已经产生的interrupt信号才传递给任务，否则都清理掉；处于STOP状态，如果没有传递的interrupt信号，则自中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())                                        <span class="comment">//5</span></span><br><span class="line">                wt.interrupt();                                             </span><br><span class="line">    ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       </span><br><span class="line">        ... </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、前导</strong></p>
<ol>
<li>在<code>cancel(boolean mayInterruptIfRunning)</code>方法中，<code>Thread t = runner</code>语句内隐含的加载<code>runner</code>操作不能被重排序到<code>UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</code>语句之前，因为结合<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>和<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>可知，后者隐式带有StoreLoad绑定型内存屏障，故后续的Load操作不能被重排序到该Store操作之前</li>
<li>同理，在<code>run()</code>方法中，<code>int s = state</code>语句内隐含的加载<code>state</code>操作不能被重排序到会调用的<code>set(V v)</code>或者<code>setException(Throwable t)</code>方法内的<code>UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)</code>语句之前</li>
<li>同理，在<code>run()</code>方法中，<code>int s = state</code>语句内隐含的加载<code>state</code>操作不能被重排序到<code>runner = null</code>语句之前，因为后者是一个volatile变量写入，隐式带有StoreLoad内存屏障</li>
</ol>
<p><strong>2、具体证明</strong><br>根据以上贴出的源码，进行具体证明，以“&#x2F;&#x2F;4处加载到最新state时机”为讨论基点S，根据在S点时&#x2F;&#x2F;1处CAS操作的执行情况分为3类完备情况（如果不是CAS操作，考虑到可见性问题，则有不只3类完备情况）：</p>
<ol>
<li>在S点时，&#x2F;&#x2F;1处操作已执行且返回true<ul>
<li>如果此时S点的<code>state=CANCELLED</code>，则不发出中断信号</li>
<li>如果此时S点的<code>state=INTERRUPTING | INTERRUPTED</code>，需要注意的是，<code>INTERRUPTED</code>状态通过<code>UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED)</code>语句设置，并不立即可见。查看&#x2F;&#x2F;4处后<code>handlePossibleCancellationInterrupt(s)</code>方法，存在一个确保逻辑：如果当前<code>state=INTERRUPTING</code>，则进入一个循环，直到<code>state!=INTERRUPTING</code>，根据可能的state状态转移，此时必有<code>state=INTERRUPTED</code>。根据<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>中的“广义的volatile变量happens-before规则”，再结合happens-before规则——“程序顺序规则”和“传递性规则”，有<code>//2 -hb-&gt; //3 -hb-&gt; TPE类中runWorker()方法内的下一轮getTask()语句执行 -hb-&gt; TPE类中runWorker()方法内的下一轮//5语句执行</code>，如果&#x2F;&#x2F;2处实际上未执行到，自然不发出中断信号；如果&#x2F;&#x2F;2处实际执行到了，且出现中断信号泄漏（如果该中断信号在真实任务执行逻辑内部被复位掉，即<code>c.call();</code>内部，则没有泄漏），根据分析可知，此时该泄漏的中断信号必然会在<code>getTask()</code>方法的<code>workQueue.poll或者take</code>语句处或者&#x2F;&#x2F;5处（当执行器的状态为<code>RUNNING</code>）被复位，故不会递延到下一个任务的执行过程，得证</li>
</ul>
</li>
<li>在S点时，&#x2F;&#x2F;1处操作已执行且返回false，此时不发出中断信号</li>
<li>在S点时，&#x2F;&#x2F;1处操作未执行，根据前导第2点，S点时必有<code>state&gt;=COMPLETING</code>，此时执行&#x2F;&#x2F;1处操作会返回false，故不发出中断信号</li>
</ol>
<p><strong>3、其他</strong><br><code>run()</code>方法中<code>int s = state</code>语句前有一个注释<code>state must be re-read after nulling runner to prevent leaked interrupts</code>，就是说在这里需要加载最新的state，避免中断信号泄漏。接下来给出一种不重新加载最新state导致中断信号泄漏的情形：线程T2执行<code>cancel(true)</code>方法，执行到<code>T1.interrupt()</code>语句时等待CPU资源，此时state的状态为<code>INTERRUPTING</code>，线程T1执行<code>run()</code>方法，执行到<code>if (s &gt;= INTERRUPTING)</code>语句时，由于s没有重新加载最新的state值，因此还是<code>NEW</code>，条件判断失败，不会执行<code>handlePossibleCancellationInterrupt(s)</code>方法，继续执行直到下一个真实任务的执行逻辑，此时T2分配到CPU资源，执行<code>T1.interrupt()</code>语句，发出中断信号，即出现了“中断信号泄漏”。</p>
<h4 id="3-2-2、runAndReset"><a href="#3-2-2、runAndReset" class="headerlink" title="3.2.2、runAndReset()"></a><strong>3.2.2、runAndReset()</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAndReset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.call(); <span class="comment">// don&#x27;t set result</span></span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        s = state;                                                <span class="comment">//44</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有成功执行，未抛出异常，才是一个合法的周期性任务</span></span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、前导</strong></p>
<ol>
<li>在<code>cancel(boolean mayInterruptIfRunning)</code>方法中，<code>Thread t = runner</code>语句内隐含的加载<code>runner</code>操作不能被重排序到<code>UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</code>语句之前，因为结合<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>和<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>可知，后者隐式带有StoreLoad绑定型内存屏障，故后续的Load操作不能被重排序到该Store操作之前</li>
<li>同理，在<code>runAndReset()</code>方法中，<code>int s = state</code>语句内隐含的加载<code>state</code>操作不能被重排序到会调用的<code>setException(Throwable t)</code>方法内的<code>UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)</code>语句之前</li>
<li>同理，在<code>runAndReset()</code>方法中，<code>int s = state</code>语句内隐含的加载<code>state</code>操作不能被重排序到<code>runner = null</code>语句之前，因为后者是一个volatile变量写入，隐式带有StoreLoad内存屏障</li>
</ol>
<p><strong>2、具体证明</strong><br>根据以上贴出的源码和“3.2.1、run()”小节中贴出的源码，进行具体证明，以“&#x2F;&#x2F;44处加载到最新state时机”为讨论基点S，根据在S点时&#x2F;&#x2F;1处CAS操作的执行情况分为3类完备情况（如果不是CAS操作，考虑到可见性问题，则有不只3类完备情况）：</p>
<ol>
<li>在S点时，&#x2F;&#x2F;1处操作已执行且返回true<ul>
<li>如果此时S点的<code>state=CANCELLED</code>，则不发出中断信号</li>
<li>如果此时S点的<code>state=INTERRUPTING | INTERRUPTED</code>，需要注意的是，<code>INTERRUPTED</code>状态通过<code>UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED)</code>语句设置，并不立即可见。查看&#x2F;&#x2F;44处后<code>handlePossibleCancellationInterrupt(s)</code>方法，存在一个确保逻辑：如果当前<code>state=INTERRUPTING</code>，则进入一个循环，直到<code>state!=INTERRUPTING</code>，根据可能的state状态转移，此时必有<code>state=INTERRUPTED</code>。根据<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>中的“广义的volatile变量happens-before规则”，再结合happens-before规则——“程序顺序规则”和“传递性规则”，有<code>//2 -hb-&gt; //3 -hb-&gt; TPE类中runWorker()方法内的下一轮getTask()语句执行 -hb-&gt; TPE类中runWorker()方法内的下一轮//5语句执行</code>，如果&#x2F;&#x2F;2处实际上未执行到，自然不发出中断信号；如果&#x2F;&#x2F;2处实际执行到了，且出现中断信号泄漏（如果该中断信号在真实任务执行逻辑内部被复位掉，即<code>c.call();</code>内部，则没有泄漏），根据分析可知，此时该泄漏的中断信号必然会在<code>getTask()</code>方法的<code>workQueue.poll或者take</code>语句处或者&#x2F;&#x2F;5处（当执行器的状态为<code>RUNNING</code>）被复位，故不会递延到下一个任务的执行过程，得证</li>
</ul>
</li>
<li>在S点时，&#x2F;&#x2F;1处操作已执行且返回false，此时不发出中断信号</li>
<li>在S点时，&#x2F;&#x2F;1处操作未执行：<ul>
<li>如果有执行<code>setException(ex)</code>语句，根据前导第2点，S点时必有<code>state&gt;=COMPLETING</code>，此时执行&#x2F;&#x2F;1处操作会返回false，故不发出中断信号</li>
<li>如果未有执行<code>setException(ex)</code>语句，根据前导第1和第3点，此时执行&#x2F;&#x2F;1处操作，<code>runner = null</code>语句必然已经执行完且结果对其可见，<code>Thread t = runner</code>语句不可能重排序到&#x2F;&#x2F;1处操作之前，故<code>if (t != null)</code>判断语句结果为false，不会发出中断信号</li>
</ul>
</li>
</ol>
<p><strong>3、其他</strong><br>针对“在S点时，&#x2F;&#x2F;1处操作未执行，且未执行<code>setException(ex)</code>语句”情形，本来笔者还认为存在一种“中断信号泄漏递延给下一个任务”的可能，具体是“线程T1执行<code>runAndReset()</code>方法，S点时有<code>state=NEW</code>，<code>runner = null;</code>语句重排序到&#x2F;&#x2F;44之后，故此时<code>runner!=NULL</code>，另外一个线程T2在S点时执行<code>cancel(true)</code>方法，执行到<code>T1.interrupt()</code>语句时等待CPU资源分配，T1继续执行直到下一个真实任务的执行逻辑（不会调用<code>handlePossibleCancellationInterrupt(s)</code>方法，因为<code>if (s &gt;= INTERRUPTING)</code>判断语句返回false），然后T2此时发出中断信号，该中断信号对新任务的执行过程可见，即出现了‘中断信号泄漏’”。针对以上“中断信号泄漏”可能，还特地向OpenJDK反馈了一个<a href="https://bugs.openjdk.java.net/browse/JDK-8269467">Bug</a>，后面根据Doug Lea的回复——<code>The case presented here includes assumption of a reordering that should be precluded because fields state and runner are volatile.</code>，才意识到了以上分析的错误在于没有考虑到前导第1和第3点。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>根据以下TPE类中<code>runWorker(Worker w)</code>方法源码可知，在TPE和STPE中调度执行的任务，<font color='red'>必须</font>在内部<code>catch</code>住自身过程抛出的<code>Throwable</code>，否则会导致执行该任务的Worker异常退出（虽然会被弥补）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();                    <span class="comment">//1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来针对TPE和STPE中的所有任务提交形式一一进行分析说明。</p>
<h3 id="4-1、TPE"><a href="#4-1、TPE" class="headerlink" title="4.1、TPE"></a><strong>4.1、TPE</strong></h3><p>存在4种提交形式，分为两类：</p>
<ol start="0">
<li>第一类：&#x2F;&#x2F;1处的<code>task</code>就是真实的任务实体，在该情形中，真实任务实体的执行方法<font color='red'>必须</font>在内部catch住自身过程抛出的<code>Throwable</code><ul>
<li><code>public void execute(Runnable command)</code>，真实任务实体是<code>command</code>，<font color='red'>必须</font>在<code>command.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
</ul>
</li>
<li>第二类：&#x2F;&#x2F;1处的<code>task</code>指代FutureTask实例，查看<code>FutureTask.run()</code>方法源码，可知在调用真实任务实体执行方法的外围有catch住异常的逻辑，故不会导致Worker异常退出，但是为统一起见，<font color='red'>建议</font>还是在真实任务实体执行方法内部catch住自身过程抛出的<code>Throwable</code><ul>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>，真实任务实体是<code>task</code>，<font color='red'>建议</font>在<code>task.call()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>，真实任务实体是<code>task</code>，<font color='red'>建议</font>在<code>task.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>，真实任务实体是<code>task</code>，<font color='red'>建议</font>在<code>task.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
</ul>
</li>
</ol>
<h3 id="4-2、STPE"><a href="#4-2、STPE" class="headerlink" title="4.2、STPE"></a><strong>4.2、STPE</strong></h3><p>存在8种提交形式，包括从TPE继承下来的4种提交形式（在STPE中覆盖实现），查看源码可知&#x2F;&#x2F;1处的<code>task</code>指代ScheduledFutureTask实例，查看<code>ScheduledFutureTask.run()</code>方法源码，其转发调用FutureTask的<code>run()</code>或者<code>runAndReset()</code>方法，查看上述两个方法源码，可知在调用真实任务实体执行方法的外围有catch住异常的逻辑，故不会导致Worker异常退出，但是为统一起见，<font color='red'>建议</font>还是在真实任务实体执行方法内部catch住自身过程抛出的<code>Throwable</code>：</p>
<ul>
<li>继承下来的4个方法说明见“4.1、TPE”小节</li>
<li><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code>，真实任务实体是<code>command</code>，<font color='red'>建议</font>在<code>command.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
<li><code>public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>，真实任务实体是<code>callable</code>，<font color='red'>建议</font>在<code>callable.call()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>，真实任务实体是<code>command</code>，<font color='red'>建议</font>在<code>command.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>，真实任务实体是<code>command</code>，<font color='red'>建议</font>在<code>command.run()</code>方法内部catch住自身过程抛出的<code>Throwable</code></li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/05/14/ScheduledThreadPoolExecutor/" title="ScheduledThreadPoolExecutor">《ScheduledThreadPoolExecutor》</a>中的ScheduledFutureTask类的<code>run()</code>方法<br>[2]<a href="https://www.cnblogs.com/thisiswhy/p/13791966.html">https://www.cnblogs.com/thisiswhy/p/13791966.html</a><br>[3]<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>GNU BRE正则表达式</title>
    <url>/blog/2017/06/05/GNU-BRE%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>GNU BRE正则表达式的正则表达式匹配引擎采用的匹配模型见<a href="/blog/2017/06/02/%E4%B8%80%E7%A7%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B/" title="一种正则表达式匹配模型">《一种正则表达式匹配模型》</a>。<br>由于GNU grep命令的默认模式使用GNU BRE正则表达式，因此本文接下来使用它进行实验。<br>特别需要强调的是，由于“locale设置”不同，操作系统环境不同等因素，同一个正则表达式可能具有不同的表达含义。比如在“locale&#x3D;C”设置下，“[a-d]”等价于“[abcd]”，而在有些locale设置下，“[a-d]”等价于“[aBbCcDd]”。又比如只在有些locale设置中，“\w”等价于“[a-zA-Z_0-9]”，“\W”等价于“[^a-zA-Z_0-9]”才成立。<br><font color='red'>接下来的语法介绍只针对“一般情形”，而不针对“特殊情形”，为了确保在你的“具体情形”下，正则表达式能够如你所期望地进行表达，最好能够提前进行一些测试。</font><br>正则表达式中不同语法单元具有不同的优先级顺序，无需记忆，使用“匹配组（即<code>\(\)</code>对）”方式更加清晰明了。<br>GNU BRE正则表达式跟GNU ERE正则表达式相比，表达能力几乎没有差别，主要差别在于：在GNU BRE正则表达式中，<code>?+&#123;&#125;()|</code>等这些字符原生没有特殊含义，只有添加前导“\”字符后才具有特殊含义，以上差别导致了GNU ERE正则表达式相较于GNU BRE正则表达式更加简洁清晰。<font color='red'>因此，在两者可选的情况下，一般选用GNU ERE正则表达式。</font></p>
<h2 id="一、字符类"><a href="#一、字符类" class="headerlink" title="一、字符类"></a><strong>一、字符类</strong></h2><h3 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a><strong>1.1、定义</strong></h3><table>
<thead>
<tr>
<th>字符类</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>匹配“a，b，c”3个字符之一</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配除了“a，b，c”3个字符之外的任意一个字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>匹配26个小写英文字符和26个大写英文字符中的任意一个</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>匹配除了26个小写英文字符之外的任意一个字符</td>
</tr>
</tbody></table>
<h3 id="1-2、实验"><a href="#1-2、实验" class="headerlink" title="1.2、实验"></a><strong>1.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;[old]&#39; a.txt</code></td>
<td>hello world</td>
</tr>
<tr>
<td><code>grep &#39;[^old]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;[x-z]&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
</tbody></table>
<h2 id="二、预定义字符类"><a href="#二、预定义字符类" class="headerlink" title="二、预定义字符类"></a><strong>二、预定义字符类</strong></h2><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a><strong>2.1、定义</strong></h3><table>
<thead>
<tr>
<th>预定义字符类</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符，除了行终止符</td>
</tr>
<tr>
<td>\w</td>
<td>等价于[a-zA-Z_0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>等价于[^\w]</td>
</tr>
</tbody></table>
<h3 id="2-2、实验"><a href="#2-2、实验" class="headerlink" title="2.2、实验"></a><strong>2.2、实验</strong></h3><p>有文件“a.txt”，内容如下（第5行是个“TAB”字符）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a$</span><br><span class="line">A$</span><br><span class="line">9$</span><br><span class="line">_$</span><br><span class="line">	</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;.&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$<br/>	<br/>$$</td>
</tr>
<tr>
<td><code>grep &#39;\w&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$</td>
</tr>
<tr>
<td><code>grep &#39;\W&#39; a.txt</code></td>
<td>a$<br/>A$<br/>9$<br/>_$<br/>	<br/>$$</td>
</tr>
</tbody></table>
<h2 id="三、量词修饰符"><a href="#三、量词修饰符" class="headerlink" title="三、量词修饰符"></a><strong>三、量词修饰符</strong></h2><h3 id="3-1、定义"><a href="#3-1、定义" class="headerlink" title="3.1、定义"></a><strong>3.1、定义</strong></h3><table>
<thead>
<tr>
<th>量词修饰符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>匹配0次或者1次</td>
</tr>
<tr>
<td>X*</td>
<td>匹配0次或者0次以上</td>
</tr>
<tr>
<td>X\+</td>
<td>匹配1次或者1次以上</td>
</tr>
<tr>
<td>X\{n\}</td>
<td>匹配n次</td>
</tr>
<tr>
<td>X\{n,\}</td>
<td>匹配至少n次</td>
</tr>
<tr>
<td>X\{,m\}</td>
<td>匹配至多m次</td>
</tr>
<tr>
<td>X\{n,m\}</td>
<td>匹配至少n次，至多m次</td>
</tr>
</tbody></table>
<h3 id="3-2、实验"><a href="#3-2、实验" class="headerlink" title="3.2、实验"></a><strong>3.2、实验</strong></h3><p>有文件“a.txt”，内容如下（第1行是空行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;a\?&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep &#39;a*&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep &#39;b\+&#39; a.txt</code></td>
<td>bb</td>
</tr>
<tr>
<td><code>grep &#39;.\&#123;2\&#125;&#39; a.txt</code></td>
<td>bb<br/>ccc</td>
</tr>
<tr>
<td><code>grep &#39;.\&#123;1,\&#125;&#39; a.txt</code></td>
<td>a<br/>bb<br/>ccc</td>
</tr>
<tr>
<td><code>grep &#39;.\&#123;,2\&#125;&#39; a.txt</code></td>
<td><br/>a<br/>bb<br/>ccc<br/></td>
</tr>
<tr>
<td><code>grep &#39;.\&#123;2,3\&#125;&#39; a.txt</code></td>
<td>bb<br/>ccc</td>
</tr>
</tbody></table>
<h2 id="四、匹配组"><a href="#四、匹配组" class="headerlink" title="四、匹配组"></a><strong>四、匹配组</strong></h2><h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a><strong>4.1、定义</strong></h3><p>正则表达式中由“\(\)”对括起来的子表达式被称为“匹配组”，它作为独立的匹配单元参与匹配。在正则表达式中，“匹配组”的数量就是“\(\)”对的数量，“匹配组”的标号按照“\(”符号出现的先后顺序进行确定：从“1标号-匹配组”开始。<font color='red'>也存在“0标号-匹配组”，它是特殊的“匹配组”，它代表整个正则表达式。</font>比如有<code>\(\(A\)\(B\(C\)\)\)</code>，其中“匹配组”数量为“4”，“1标号-匹配组”是“\(\(A\)\(B\(C\)\)\)”，“2标号-匹配组”是“\(A\)”，“3标号-匹配组”是“\(B\(C\)\)”，“4标号-匹配组”是“\(C\)”，“0标号-匹配组”是“\(\(A\)\(B\(C\)\)\)”；又有<code>\(A\)\(B\(C\)\)</code>，其中“匹配组”数量为“3”，“1标号-匹配组”是“\(A\)”，“2标号-匹配组”是“\(B\(C\)\)”，“3标号-匹配组”是“\(C\)”，“0标号-匹配组”是“\(A\)\(B\(C\)\)”。<br>可通过“\匹配组标号”形式在正则表达式引用相应“匹配组”在目标字符串中的匹配字符串内容，需要注意的是，不能使用“\0”，因为这是“语义非法的”。证明如下：现有一个正则表达式“abc\0”（a，b，c分别表示3个部分），为使该正则表达式有意义，“abc”3部分至少有一个不为空，假定该正则表达式存在对应的匹配字符串T，由于“T”与“\0”匹配，而“abc”至少有一个不为空，得到一个矛盾，因此假定不成立，即该正则表达式无对应的匹配字符串。</p>
<h3 id="4-2、实验"><a href="#4-2、实验" class="headerlink" title="4.2、实验"></a><strong>4.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcabc</span><br><span class="line">abcabd</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;\([a-z]\&#123;3\&#125;\)\1&#39; a.txt</code></td>
<td>abcabc</td>
</tr>
<tr>
<td><code>grep &#39;\([a-z]\&#123;2\&#125;\)c\1&#39; a.txt</code></td>
<td>abcabc<br/>abcabd</td>
</tr>
</tbody></table>
<h2 id="五、边界匹配符"><a href="#五、边界匹配符" class="headerlink" title="五、边界匹配符"></a><strong>五、边界匹配符</strong></h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a><strong>5.1、定义</strong></h3><table>
<thead>
<tr>
<th>边界匹配符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>索引位置为“行首位置”，跟行终止符无关</td>
</tr>
<tr>
<td>$</td>
<td>索引位置为“行尾位置”，行终止符为“\n”</td>
</tr>
<tr>
<td>&lt;</td>
<td>索引位置为“行首位置”，跟行终止符无关，跟“^”等价</td>
</tr>
<tr>
<td>\&gt;</td>
<td>索引位置为“行尾位置”，行终止符为“\r”或者“\n”</td>
</tr>
<tr>
<td>\b</td>
<td>索引位置为“单词边界位置”</td>
</tr>
<tr>
<td>\B</td>
<td>索引位置为“非单词边界位置”</td>
</tr>
</tbody></table>
<h3 id="5-2、实验"><a href="#5-2、实验" class="headerlink" title="5.2、实验"></a><strong>5.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>
<p>执行<code>od -A d -t x1cz -v -w10 a.txt</code>命令，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000  68  65  6c  6c  6f  20  77  6f  72  6c</span><br><span class="line">          h   e   l   l   o       w   o   r   l  &gt;hello worl&lt;</span><br><span class="line">0000010  64  0a  74  68  69  73  20  69  73  20</span><br><span class="line">          d  \n   t   h   i   s       i   s      &gt;d.this is &lt;</span><br><span class="line">0000020  61  6e  20  65  78  70  65  72  69  6d</span><br><span class="line">          a   n       e   x   p   e   r   i   m  &gt;an experim&lt;</span><br><span class="line">0000030  65  6e  74  0a</span><br><span class="line">          e   n   t  \n                          &gt;ent.&lt;</span><br><span class="line">0000034</span><br></pre></td></tr></table></figure>
<p>有文件“b.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">this is an experiment</span><br></pre></td></tr></table></figure>
<p>执行<code>od -A d -t x1cz -v -w10 b.txt</code>命令，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000  68  65  6c  6c  6f  20  77  6f  72  6c</span><br><span class="line">          h   e   l   l   o       w   o   r   l  &gt;hello worl&lt;</span><br><span class="line">0000010  64  0d  0a  74  68  69  73  20  69  73</span><br><span class="line">          d  \r  \n   t   h   i   s       i   s  &gt;d..this is&lt;</span><br><span class="line">0000020  20  61  6e  20  65  78  70  65  72  69</span><br><span class="line">              a   n       e   x   p   e   r   i  &gt; an experi&lt;</span><br><span class="line">0000030  6d  65  6e  74  0d  0a</span><br><span class="line">          m   e   n   t  \r  \n                  &gt;ment..&lt;</span><br><span class="line">0000036</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;\be&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;\Bh\B&#39; a.txt</code></td>
<td>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;^[ht]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;^[ht]&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;\&lt;[ht]&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;\&lt;[ht]&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;[dt]$&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;[dt]$&#39; b.txt</code></td>
<td></td>
</tr>
<tr>
<td><code>grep &#39;[dt]\&gt;&#39; a.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
<tr>
<td><code>grep &#39;[dt]\&gt;&#39; b.txt</code></td>
<td>hello world<br/>this is an experiment</td>
</tr>
</tbody></table>
<h2 id="六、转义"><a href="#六、转义" class="headerlink" title="六、转义"></a><strong>六、转义</strong></h2><h3 id="6-1、定义"><a href="#6-1、定义" class="headerlink" title="6.1、定义"></a><strong>6.1、定义</strong></h3><p>在正则表达式中，使用前导“\”字符来转义元字符。元字符有<code>[].^$*-</code>等。</p>
<h3 id="6-2、实验"><a href="#6-2、实验" class="headerlink" title="6.2、实验"></a><strong>6.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;.&#39; a.txt</code></td>
<td>a<br/>.</td>
</tr>
<tr>
<td><code>grep &#39;\.&#39; a.txt</code></td>
<td>.</td>
</tr>
</tbody></table>
<h2 id="七、操作符"><a href="#七、操作符" class="headerlink" title="七、操作符"></a><strong>七、操作符</strong></h2><h3 id="7-1、定义"><a href="#7-1、定义" class="headerlink" title="7.1、定义"></a><strong>7.1、定义</strong></h3><table>
<thead>
<tr>
<th>操作符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;#124;</td>
<td>“或”操作符</td>
</tr>
</tbody></table>
<h3 id="7-2、实验"><a href="#7-2、实验" class="headerlink" title="7.2、实验"></a><strong>7.2、实验</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab</span><br><span class="line">dc</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>执行命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>grep &#39;ab&amp;#124;dc&#39; a.txt</code></td>
<td>ab<br/>dc</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]man grep
[2]http://www.regular-expressions.info/gnu.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>GTD工具：todo.txt</title>
    <url>/blog/2017/08/22/GTD%E5%B7%A5%E5%85%B7%EF%BC%9Atodo-txt/</url>
    <content><![CDATA[<p>本文介绍一种GTD工具，它包括两层：数据层和接口层。<br>数据层实际上就是4个文本文件：“todo.txt”，“done.txt”，“todo.txt.bak”和“report.txt”；接口层包含一个名为“todo.sh”的脚本以及一系列扩展插件。</p>
<h2 id="一、接口层"><a href="#一、接口层" class="headerlink" title="一、接口层"></a><strong>一、接口层</strong></h2><p>“todo.sh”脚本作为接口层的主体程序，它支持扩展机制，作者安装的扩展插件列表如下：birdseye，due，edit，graph，lately。</p>
<h2 id="二、数据层"><a href="#二、数据层" class="headerlink" title="二、数据层"></a><strong>二、数据层</strong></h2><p>接口层实质上定义了一种DSL语言，数据层的文本文件中的内容都遵循该DSL语言所描述的语法规范。<br>在数据层的4个文本文件中，以“todo.txt”为核心，故而该GTD工具被命名为“todo.txt”。“todo.txt”文本文件中每行内容都描述了一个“todo项”，它遵循如下语法规范：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(A-Z) todo项说明 due:yyyy-MM-dd @context +project</span><br></pre></td></tr></table></figure>
<p>以上语法规范中元素含义说明如下表。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(A-Z)</td>
<td>定义todo项优先级，可选</td>
</tr>
<tr>
<td>todo项说明</td>
<td>描述todo项，必选</td>
</tr>
<tr>
<td>due:yyyy-MM-dd</td>
<td>定义todo项截止日期，可选</td>
</tr>
<tr>
<td>@context</td>
<td>定义todo项上下文环境，可选</td>
</tr>
<tr>
<td>+project</td>
<td>定义todo项所属项目，可选</td>
</tr>
</tbody></table>
<h2 id="三、操作"><a href="#三、操作" class="headerlink" title="三、操作"></a><strong>三、操作</strong></h2><h3 id="3-1、增加todo项"><a href="#3-1、增加todo项" class="headerlink" title="3.1、增加todo项"></a><strong>3.1、增加todo项</strong></h3><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo add &#x27;(A-Z) todo项说明 due:yyyy-MM-dd @context +project&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、删除todo项"><a href="#3-2、删除todo项" class="headerlink" title="3.2、删除todo项"></a><strong>3.2、删除todo项</strong></h3><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo del NUM</span><br></pre></td></tr></table></figure>
<p>其中，“NUM”表示相应todo项在“todo.txt”文本文件中的行号（用来作为相应todo项的序号），可通过<code>todo list</code>，<code>todo listall</code>或者<code>todo due</code>查看命令获得。</p>
<h3 id="3-3、完成todo项"><a href="#3-3、完成todo项" class="headerlink" title="3.3、完成todo项"></a><strong>3.3、完成todo项</strong></h3><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo do NUM</span><br></pre></td></tr></table></figure>
<h3 id="3-4、查看"><a href="#3-4、查看" class="headerlink" title="3.4、查看"></a><strong>3.4、查看</strong></h3><h4 id="3-4-1、list"><a href="#3-4-1、list" class="headerlink" title="3.4.1、list"></a><strong>3.4.1、list</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo list [KEYWORD]</span><br></pre></td></tr></table></figure>
<p>以“todo.txt”文本文件为数据来源。当不带“KEYWORD”，则列出所有未完成todo项；当带有“KEYWORD”，则列出所有内容中含有“KEYWORD”的未完成todo项。<br>另外，在结果列表中，优先级越高的todo项越靠前，在“A-Z”优先级范围中，“A”优先级最高，“Z”优先级最低。</p>
<h4 id="3-4-2、listall"><a href="#3-4-2、listall" class="headerlink" title="3.4.2、listall"></a><strong>3.4.2、listall</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo listall [KEYWORD]</span><br></pre></td></tr></table></figure>
<p>以“todo.txt”和“done.txt”文本文件为数据来源。当不带“KEYWORD”，则列出所有已完成和未完成todo项；当带有“KEYWORD”，则列出所有内容中含有“KEYWORD”的已完成和未完成todo项。<br>另外，在结果列表中，优先级越高的todo项越靠前，在“A-Z”优先级范围中，“A”优先级最高，“Z”优先级最低。</p>
<h4 id="3-4-3、due"><a href="#3-4-3、due" class="headerlink" title="3.4.3、due"></a><strong>3.4.3、due</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo due [n]</span><br></pre></td></tr></table></figure>
<p>以“todo.txt”文本文件为数据来源。当不带“n”，则列出所有定义有截止日期，且截止日期在<code>今天（今天+0）</code>包括<code>今天（今天+0）</code>之前的未完成todo项；当带有“n”，则列出所有定义有截止日期，且截止日期在<code>（今天+n）那天</code>包括<code>（今天+n）那天</code>之前的未完成todo项。</p>
<h4 id="3-4-4、graph"><a href="#3-4-4、graph" class="headerlink" title="3.4.4、graph"></a><strong>3.4.4、graph</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo graph [n]</span><br></pre></td></tr></table></figure>
<p>以“done.txt”文本文件为数据来源。当不带“n”，则列出7天之内每日todo项完成数量统计；当带有“n”，则列出n天之内每日todo项完成数量统计。</p>
<h4 id="3-4-5、lately"><a href="#3-4-5、lately" class="headerlink" title="3.4.5、lately"></a><strong>3.4.5、lately</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo lately [n]</span><br></pre></td></tr></table></figure>
<p>以“done.txt”文本文件为数据来源。当不带“n”，则列出7天之内所有完成的todo项；当带有“n”，则列出n天之内所有完成的todo项。</p>
<h4 id="3-4-6、birdseye"><a href="#3-4-6、birdseye" class="headerlink" title="3.4.6、birdseye"></a><strong>3.4.6、birdseye</strong></h4><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo birdseye </span><br></pre></td></tr></table></figure>
<p>以“todo.txt”和“done.txt”文本文件为数据来源。基于“上下文环境”和“项目”元素统计todo项完成情况。</p>
<h3 id="3-5、edit"><a href="#3-5、edit" class="headerlink" title="3.5、edit"></a><strong>3.5、edit</strong></h3><p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todo edit [done]</span><br></pre></td></tr></table></figure>
<p>当不带“done”，以默认文本编辑器编辑“todo.txt”；当带有“done”，以默认文本编辑器编辑“done.txt”。</p>
<br/>
参考文献：
[1]http://todotxt.com/
[2]https://github.com/todotxt/todo.txt-cli/releases
[3]https://github.com/todotxt/todo.txt-cli/wiki/user-documentation
[4]https://github.com/todotxt/todo.txt-cli/wiki/Todo.sh-Add-on-Directory
[5]./todo.sh help
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Flavored Markdown语法介绍</title>
    <url>/blog/2016/06/30/GitHub-Flavored-Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>自Markdown语言产生以来，出现了很多dialect（即语言变种），比如“GitHub Flavored Markdown、Multimarkdown、Maruku”等。本文介绍“GitHub Flavored Markdown”。</p>
<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a><strong>一、标题</strong></h2><h3 id="1-1、语法"><a href="#1-1、语法" class="headerlink" title="1.1、语法"></a><strong>1.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“（N个&#x27;#&#x27;）（空格）”</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<h3 id="1-2、效果"><a href="#1-2、效果" class="headerlink" title="1.2、效果"></a><strong>1.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20160630-1-1.png"></p>
<h2 id="二、加粗和斜体"><a href="#二、加粗和斜体" class="headerlink" title="二、加粗和斜体"></a><strong>二、加粗和斜体</strong></h2><h3 id="2-1、语法"><a href="#2-1、语法" class="headerlink" title="2.1、语法"></a><strong>2.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br></pre></td></tr></table></figure>
<h3 id="2-2、效果"><a href="#2-2、效果" class="headerlink" title="2.2、效果"></a><strong>2.2、效果</strong></h3><p><strong>加粗</strong><br><em>斜体</em></p>
<h2 id="三、有序列表"><a href="#三、有序列表" class="headerlink" title="三、有序列表"></a><strong>三、有序列表</strong></h2><h3 id="3-1、语法"><a href="#3-1、语法" class="headerlink" title="3.1、语法"></a><strong>3.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 项目1，“（数字）（.）（空格）”，最后有个空行</span><br><span class="line">2. 项目2</span><br><span class="line">3. 项目3</span><br><span class="line">    1. 子项目1，“（至少3个空格）（数字）（.）（空格）”</span><br><span class="line">    2. 子项目2</span><br><span class="line">    3. 子项目3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2、效果"><a href="#3-2、效果" class="headerlink" title="3.2、效果"></a><strong>3.2、效果</strong></h3><ol>
<li>项目1，“（数字）（.）（空格）”，最后有个空行</li>
<li>项目2</li>
<li>项目3<ol>
<li>子项目1，“（至少3个空格）（数字）（.）（空格）”</li>
<li>子项目2</li>
<li>子项目3</li>
</ol>
</li>
</ol>
<h2 id="四、无序列表"><a href="#四、无序列表" class="headerlink" title="四、无序列表"></a><strong>四、无序列表</strong></h2><h3 id="4-1、语法"><a href="#4-1、语法" class="headerlink" title="4.1、语法"></a><strong>4.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 项目1，“（-）（空格）”，最后有个空行</span><br><span class="line">- 项目2</span><br><span class="line">- 项目3</span><br><span class="line">  - 项目4，“（至少两个空格）（-）（空格）”</span><br><span class="line">  - 项目5</span><br><span class="line">  - 项目6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2、效果"><a href="#4-2、效果" class="headerlink" title="4.2、效果"></a><strong>4.2、效果</strong></h3><ul>
<li>项目1，“（-）（空格）”，最后有个空行</li>
<li>项目2</li>
<li>项目3<ul>
<li>项目4，“（至少两个空格）（-）（空格）”</li>
<li>项目5</li>
<li>项目6</li>
</ul>
</li>
</ul>
<h2 id="五、链接图片"><a href="#五、链接图片" class="headerlink" title="五、链接图片"></a><strong>五、链接图片</strong></h2><h3 id="5-1、语法"><a href="#5-1、语法" class="headerlink" title="5.1、语法"></a><strong>5.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![提示文字](图片地址：可以是网络地址，也可以是本地地址)</span><br></pre></td></tr></table></figure>
<h3 id="5-2、效果"><a href="#5-2、效果" class="headerlink" title="5.2、效果"></a><strong>5.2、效果</strong></h3><p><img src="https://blog.dslztx.top/imgs/20160630-1-2.png" alt="Google Logo"></p>
<h2 id="六、链接URL"><a href="#六、链接URL" class="headerlink" title="六、链接URL"></a><strong>六、链接URL</strong></h2><h3 id="6-1、语法"><a href="#6-1、语法" class="headerlink" title="6.1、语法"></a><strong>6.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[提示文字](http://www.google.com)</span><br><span class="line">或者</span><br><span class="line">URL自动识别：http://www.google.com</span><br></pre></td></tr></table></figure>
<h3 id="6-2、效果"><a href="#6-2、效果" class="headerlink" title="6.2、效果"></a><strong>6.2、效果</strong></h3><p><a href="http://www.google.com/">提示文字</a><br>或者<br>URL自动识别：<a href="http://www.google.com/">http://www.google.com</a></p>
<h2 id="七、行内引用"><a href="#七、行内引用" class="headerlink" title="七、行内引用"></a><strong>七、行内引用</strong></h2><h3 id="7-1、语法"><a href="#7-1、语法" class="headerlink" title="7.1、语法"></a><strong>7.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接下来是引用文字:`引用内容`</span><br></pre></td></tr></table></figure>
<h3 id="7-2、效果"><a href="#7-2、效果" class="headerlink" title="7.2、效果"></a><strong>7.2、效果</strong></h3><p>接下来是引用文字:<code>引用内容</code></p>
<h2 id="八、块级引用"><a href="#八、块级引用" class="headerlink" title="八、块级引用"></a><strong>八、块级引用</strong></h2><h3 id="8-1、语法"><a href="#8-1、语法" class="headerlink" title="8.1、语法"></a><strong>8.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;这是块级引用第一部分，最后有个空行</span><br><span class="line">&gt;这是块级引用第二部分</span><br><span class="line">&gt;这是块级引用第三部分</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-2、效果"><a href="#8-2、效果" class="headerlink" title="8.2、效果"></a><strong>8.2、效果</strong></h3><blockquote>
<p>这是块级引用第一部分，最后有个空行<br>这是块级引用第二部分<br>这是块级引用第三部分</p>
</blockquote>
<h2 id="九、代码引用"><a href="#九、代码引用" class="headerlink" title="九、代码引用"></a><strong>九、代码引用</strong></h2><h3 id="9-1、语法"><a href="#9-1、语法" class="headerlink" title="9.1、语法"></a><strong>9.1、语法</strong></h3><p>```指定代码使用语言，可选<br>代码<br>```</p>
<h3 id="9-2、效果"><a href="#9-2、效果" class="headerlink" title="9.2、效果"></a><strong>9.2、效果</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a><strong>十、表格</strong></h2><h3 id="10-1、语法"><a href="#10-1、语法" class="headerlink" title="10.1、语法"></a><strong>10.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|firstCol|secondCol|</span><br><span class="line">|-|-|</span><br><span class="line">|firstContent|secondContent|</span><br></pre></td></tr></table></figure>
<h3 id="10-2、效果"><a href="#10-2、效果" class="headerlink" title="10.2、效果"></a><strong>10.2、效果</strong></h3><table>
<thead>
<tr>
<th>firstCol</th>
<th>secondCol</th>
</tr>
</thead>
<tbody><tr>
<td>firstContent</td>
<td>secondContent</td>
</tr>
</tbody></table>
<h2 id="十一、删除线"><a href="#十一、删除线" class="headerlink" title="十一、删除线"></a><strong>十一、删除线</strong></h2><h3 id="11-1、语法"><a href="#11-1、语法" class="headerlink" title="11.1、语法"></a><strong>11.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure>
<h3 id="11-2、效果"><a href="#11-2、效果" class="headerlink" title="11.2、效果"></a><strong>11.2、效果</strong></h3><p><del>删除</del></p>
<h2 id="十二、使用“-”转义元控制字符"><a href="#十二、使用“-”转义元控制字符" class="headerlink" title="十二、使用“\”转义元控制字符"></a><strong>十二、使用“\”转义元控制字符</strong></h2><h3 id="12-1、语法"><a href="#12-1、语法" class="headerlink" title="12.1、语法"></a><strong>12.1、语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\</span><br><span class="line">\`</span><br><span class="line">\*</span><br><span class="line">\_</span><br><span class="line">\&#123;\&#125;</span><br><span class="line">\[\]</span><br><span class="line">\(\)</span><br><span class="line">\#</span><br><span class="line">\+</span><br><span class="line">\-</span><br><span class="line">\.</span><br><span class="line">\!</span><br></pre></td></tr></table></figure>
<h3 id="12-2、效果"><a href="#12-2、效果" class="headerlink" title="12.2、效果"></a><strong>12.2、效果</strong></h3><p>\<br>`<br>*<br>_<br>{}<br>[]<br>()<br>#<br>+<br>-<br>.<br>!</p>
<h2 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a><strong>十三、其他</strong></h2><p>“有序列表”，“无序列表”和“块级引用”最后需要一个空行的原因是：以换行符作为结束标记，否则会“惯性”地继续“有序列表”的条目，“无序列表”的条目和“块级引用”的内容。</p>
<br/>
参考文献：
[1]https://guides.github.com/features/mastering-markdown/
[2]https://guides.github.com/pdfs/markdown-cheatsheet-online.pdf
[3]https://daringfireball.net/projects/markdown/syntax
[4]http://erikge.com/articles/markdownSyntax/
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Git快速入门教程</title>
    <url>/blog/2017/07/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>作者的操作系统环境是Ubuntu。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>Git由Linux内核开发者Linus使用C语言开发创建，是一个分布式版本控制系统工具。</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h2><p>在Ubuntu上安装Git的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h2 id="三、起点"><a href="#三、起点" class="headerlink" title="三、起点"></a><strong>三、起点</strong></h2><p>首先需创建一个Git的本地仓库，有两种方式：</p>
<ol>
<li>在某个目录下执行<code>git init</code>命令，初始化创建得到一个Git的本地仓库</li>
<li>执行<code>git clone 远程仓库地址</code>命令，克隆远程仓库创建得到一个Git的本地仓库</li>
</ol>
<p>作者采用第1种方式，具体是在“dslztx”目录下执行<code>git init</code>命令，此时“dslztx”目录便是一个Git的本地仓库，在“dslztx”目录下执行<code>ls -A</code>命令，打印结果如下，即目录下存在一个名为“.git”的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsl@ubuntu:~/tmp2/dslztx$ ls -A</span><br><span class="line">.git</span><br></pre></td></tr></table></figure>
<h2 id="四、基础操作"><a href="#四、基础操作" class="headerlink" title="四、基础操作"></a><strong>四、基础操作</strong></h2><h3 id="4-1、说明"><a href="#4-1、说明" class="headerlink" title="4.1、说明"></a><strong>4.1、说明</strong></h3><p>本地仓库由两部分构成：“本地工作区域”和“.git目录区域”。“.git目录区域”是本地仓库的核心数据区域，尽量不要进行手动更改。“.git目录区域”内包含有“配置文件，数据文件，提交节点拓扑图，暂存区”等内容，其中对我们理解Git工作原理比较重要的是“暂存区”和“提交节点拓扑图”。</p>
<h4 id="4-1-1、本地工作区域"><a href="#4-1-1、本地工作区域" class="headerlink" title="4.1.1、本地工作区域"></a><strong>4.1.1、本地工作区域</strong></h4><p>本地仓库下除“.git目录区域”以外的区域，在这里对文件进行直接操作。</p>
<h4 id="4-1-2、暂存区"><a href="#4-1-2、暂存区" class="headerlink" title="4.1.2、暂存区"></a><strong>4.1.2、暂存区</strong></h4><p>通过Git命令将在“本地工作区域”中的操作记录保存到“暂存区”，在执行<code>git commit</code>命令时，保存在“暂存区”中的操作记录会被最终提交。</p>
<h4 id="4-1-3、提交节点拓扑图"><a href="#4-1-3、提交节点拓扑图" class="headerlink" title="4.1.3、提交节点拓扑图"></a><strong>4.1.3、提交节点拓扑图</strong></h4><p>每次成功执行<code>git commit</code>命令都会创建一个相应的“提交节点”，每个提交节点都包含有“提交节点ID，提交用户，提交用户邮箱，日期，提交说明”等内容，<font color='red'>每个“提交节点”实质上对应一个完整的版本快照，因此“提交节点ID”可作为版本号</font>。<br>每个“提交节点”还包含有另外一个重要的字段内容：一个“来源提交节点指针列表”，指针列表中的指针指向本提交节点的“来源提交节点”。每个提交节点的“来源提交节点指针列表”的大小大于等于1（除了“根提交节点”，它的指针列表的大小等于0，即没有“来源提交节点”），即每个“提交节点”至少有一个“来源提交节点”。因此，在一系列提交之后，最终可获得一个“提交节点拓扑图”。<br><font color='red'>“提交节点ID”由40个十六进制字符构成，为了便于操作，Git支持使用“提交节点ID”的可区别（可与已经存在的其他“提交节点ID”进行区别）的前缀子序列来指代该“提交节点”。比如有一个“提交节点”，它的“提交节点ID”为“46400e7d7bffaf8b9921bd4d48d3286364809cc2”，可使用“46400e”来指代该“提交节点”（假设“46400e”是可区别的前缀子序列）。</font></p>
<h3 id="4-2、实战"><a href="#4-2、实战" class="headerlink" title="4.2、实战"></a><strong>4.2、实战</strong></h3><h4 id="4-2-1、提交"><a href="#4-2-1、提交" class="headerlink" title="4.2.1、提交"></a><strong>4.2.1、提交</strong></h4><p><strong>1、命令和说明</strong><br><code>git commit</code>：最终提交保存在暂存区中的操作记录，如上所述，每次成功提交都会创建一个相应的提交节点。<br><strong>2、实战</strong><br>参见下面小节。</p>
<h4 id="4-2-2、增"><a href="#4-2-2、增" class="headerlink" title="4.2.2、增"></a><strong>4.2.2、增</strong></h4><p><strong>1、命令和说明</strong><br><code>git add FILE_NAME</code>：如果是新增文件，则将文件的新增操作记录保存到暂存区；如果是非新增文件，则将文件的修改操作记录保存到暂存区。<br><strong>2、实战</strong><br>新建文件“readme.md”，先执行<code>git add readme.md</code>命令，再执行<code>git commit . -m &#39;add&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“46400e7d7bffaf8b9921bd4d48d3286364809cc2”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 46400e7d7bffaf8b9921bd4d48d3286364809cc2</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 17:22:40 2017 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 46400e7 (HEAD, master) add</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3、改——修改内容"><a href="#4-2-3、改——修改内容" class="headerlink" title="4.2.3、改——修改内容"></a><strong>4.2.3、改——修改内容</strong></h4><p><strong>1、命令和说明</strong><br>修改内容没有特定的Git命令，使用VIM等文本编辑器即可，但是修改好后需要执行<code>git add FILE_NAME</code>命令，将文件的修改操作记录保存到暂存区。<br><strong>2、实战</strong><br>修改“readme.md”文件，修改后内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">床前明月光</span><br></pre></td></tr></table></figure>
<p>执行<code>git add readme.md</code>命令，再执行<code>git commit . -m &#39;alter&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“4c4c21a00b0d75acf853e5f7de1cd1c8fe87c0e4”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 4c4c21a00b0d75acf853e5f7de1cd1c8fe87c0e4</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 20:44:21 2017 +0800</span><br><span class="line"></span><br><span class="line">    alter</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 4c4c21a (HEAD, master) alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4、改——重命名"><a href="#4-2-4、改——重命名" class="headerlink" title="4.2.4、改——重命名"></a><strong>4.2.4、改——重命名</strong></h4><p><strong>1、命令和说明</strong><br><code>git mv FILE_NAME NEW_FILE_NAME</code>：将名为“FILE_NAME”的文件重命名为“NEW_FILE_NAME”，将文件的修改操作记录保存到暂存区。</p>
<p>备注：<br><code>git mv FILE_NAME NEW_FILE_NAME</code>实质上就是<code>git rm FILE_NAME</code>和<code>git add NEW_FILE_NAME</code>的命令组合。在执行<code>git mv FILE_NAME NEW_FILE_NAME</code>命令后，分别独立执行<code>git reset HEAD FILE_NAME</code>和<code>git reset HEAD NEW_FILE_NAME</code>命令得到两个不同的结果，可以借此加以辅证。<br><strong>2、实战</strong><br>先执行<code>git mv readme.md rename_readme.md</code>命令，再执行<code>git commit . -m &#39;rename&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“ba32a2c15af27a44080e813a8b37dc143dab7eb2”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit ba32a2c15af27a44080e813a8b37dc143dab7eb2</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 20:50:00 2017 +0800</span><br><span class="line"></span><br><span class="line">    rename</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* ba32a2c (HEAD, master) rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="4-2-5、撤销——未保存到暂存区"><a href="#4-2-5、撤销——未保存到暂存区" class="headerlink" title="4.2.5、撤销——未保存到暂存区"></a><strong>4.2.5、撤销——未保存到暂存区</strong></h4><p><strong>1、命令和说明</strong><br><code>git checkout -- FILE_NAME</code>：对文件进行了修改，但修改操作记录还未保存到暂存区，执行该命令可撤销修改。<br><strong>2、实战</strong><br>修改“rename_readme.md”文件，修改后内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">床前明月光</span><br><span class="line">疑是地上霜</span><br></pre></td></tr></table></figure>
<p>执行<code>git checkout -- rename_readme.md</code>命令，撤销修改。</p>
<h4 id="4-2-6、撤销——已保存到暂存区"><a href="#4-2-6、撤销——已保存到暂存区" class="headerlink" title="4.2.6、撤销——已保存到暂存区"></a><strong>4.2.6、撤销——已保存到暂存区</strong></h4><p><strong>1、命令和说明</strong><br>依次执行<code>git reset HEAD FILE_NAME（其实质就是“特定文件版本跳转”，详见“4.2.9、特定文件版本跳转”）</code>和<code>git checkout -- FILE_NAME</code>：对文件进行了修改，且修改操作记录已保存到暂存区，执行该组合命令可撤销修改。<br><strong>2、实战</strong><br>修改“rename_readme.md”文件，修改后内容如下，再执行<code>git add rename_readme.md</code>命令将修改操作记录保存到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">床前明月光</span><br><span class="line">疑是地上霜</span><br></pre></td></tr></table></figure>
<p>依次执行<code>git reset HEAD rename_readme.md</code>和<code>git checkout -- rename_readme.md</code>命令，撤销修改。</p>
<h4 id="4-2-7、删"><a href="#4-2-7、删" class="headerlink" title="4.2.7、删"></a><strong>4.2.7、删</strong></h4><p><strong>1、命令和说明</strong><br><code>git rm FILE_NAME</code>：删除文件，将删除操作记录保存到暂存区。<br><strong>2、实战</strong><br>先执行<code>git rm rename_readme.md</code>命令，再执行<code>git commit . -m &#39;delete&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“5fb58d0a15f1dc3d1fe1963832b7ddb3f774f036”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 5fb58d0a15f1dc3d1fe1963832b7ddb3f774f036</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 21:16:35 2017 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 5fb58d0 (HEAD, master) delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="4-2-8、版本跳转"><a href="#4-2-8、版本跳转" class="headerlink" title="4.2.8、版本跳转"></a><strong>4.2.8、版本跳转</strong></h4><p><strong>1、命令和说明</strong><br>可跳转到“过去版本”，也可在处于“过去版本”时跳转到“过去的<font color='red'>将来已存在版本（当然不能是未存在的版本）</font>”，即可在已存在版本间进行任意跳转。<br>版本跳转有两种方式：绝对跳转和相对跳转。<font color='red'>个人推荐使用绝对跳转</font>。</p>
<ul>
<li>绝对跳转：显式指定需要跳转到版本的版本号，由上述描述可知，即对应的“提交节点ID”，具体命令为<code>git reset 提交节点ID</code></li>
<li>相对跳转：使用“HEAD”标号，比如“git reset HEAD<del>N”形式，它表示跳转到当前版本的前第N个版本，另外还可使用“git reset HEAD<sup>^N</sup>”形式，“HEAD<sup>^N</sup>”等价于“HEAD</del>N”，比如“HEAD<sup>^</sup>”等价于“HEAD<del>1”，“HEAD<sup>^^</sup>”等价于“HEAD</del>2”。</li>
</ul>
<p>备注：<br>当处于“过去版本”时欲再跳转到“过去的将来已存在版本”时，有可能出现不能获取到“欲跳转到版本的版本号”的情形，此时可尝试使用<code>git reflog</code>命令，即通过Git命令历史记录尝试获取“欲跳转到版本的版本号”。<br><strong>2、实战</strong><br>经过上述一系列操作，本地仓库下除了“.git”目录外没有任何文件。执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 5fb58d0 (HEAD, master) delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<p>执行<code>git reset 46400e7</code>命令，跳转到版本“46400e7d7bffaf8b9921bd4d48d3286364809cc2”，此时有文件“readme.md”，且该文件的内容为空；接着执行<code>git reset ba32a2c</code>命令，跳转到版本“ba32a2c15af27a44080e813a8b37dc143dab7eb2”，此时文件“readme.md”有内容“床前明月光”，且已被重命名为“rename_readme.md”；继续执行<code>git rm rename_readme.md</code>命令，最后执行<code>git commit . -m &#39;delete again&#39;</code>命令进行提交。<br>此时执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“45c6a0062a302375ae5e1f8f7e9e47b798f74f76”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 45c6a0062a302375ae5e1f8f7e9e47b798f74f76</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 22:08:28 2017 +0800</span><br><span class="line"></span><br><span class="line">    delete again</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 45c6a00 (HEAD, master) delete again</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<p><font color='red'>最后执行<code>git reset 5fb58d0</code>命令，进行版本回跳</font>，执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 5fb58d0 (HEAD, master) delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="4-2-9、特定文件版本跳转"><a href="#4-2-9、特定文件版本跳转" class="headerlink" title="4.2.9、特定文件版本跳转"></a><strong>4.2.9、特定文件版本跳转</strong></h4><p><strong>1、命令和说明</strong><br>“4.2.8、版本跳转”小节介绍了整体版本跳转，有时候我们也需要“特定文件的版本跳转”，两者使用的命令几乎一致，只不过后者增加了一个“文件名参数”，因此命令形式为<code>git reset 提交节点ID FILE_NAME</code>。<br><strong>2、实战</strong><br>增加文件“1.txt”和“2.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">昔人已乘黄鹤去，此地空余黄鹤楼</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">渭城朝雨浥轻尘</span><br></pre></td></tr></table></figure>
<p>执行<code>git add .</code>命令，再执行<code>git commit . &#39;add again&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“d0c01f40c5205e69b4487e4581cb94f9c27fd79e”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit d0c01f40c5205e69b4487e4581cb94f9c27fd79e</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 22:40:30 2017 +0800</span><br><span class="line"></span><br><span class="line">    add again</span><br></pre></td></tr></table></figure>
<p>修改文件“1.txt”和“2.txt”，修改后内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">昔人已乘黄鹤去，此地空余黄鹤楼</span><br><span class="line">黄鹤一去不复返，白云千载空悠悠</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">渭城朝雨浥轻尘</span><br><span class="line">客舍青青柳色新</span><br></pre></td></tr></table></figure>
<p>执行<code>git add .</code>命令，再执行<code>git commit . &#39;alter again&#39;</code>命令，最后执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“7a9965c9fc2f328aeaf6434c93c2634fde8317e8”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 7a9965c9fc2f328aeaf6434c93c2634fde8317e8</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Sat Jul 8 22:42:38 2017 +0800</span><br><span class="line"></span><br><span class="line">    alter again</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 7a9965c (HEAD, master) alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<p>执行<code>git reset d0c01f4 1.txt</code>命令，跳转到版本“d0c01f40c5205e69b4487e4581cb94f9c27fd79e”，此时文件“1.txt”的内容为<code>昔人已乘黄鹤去，此地空余黄鹤楼</code>，文件“2.txt”的内容保持不变。</p>
<h2 id="五、进阶——分支"><a href="#五、进阶——分支" class="headerlink" title="五、进阶——分支"></a><strong>五、进阶——分支</strong></h2><h3 id="5-1、说明"><a href="#5-1、说明" class="headerlink" title="5.1、说明"></a><strong>5.1、说明</strong></h3><p>在Git中，具有“分支”的概念，从提交节点拓扑图的角度来看，从分支当前最新提交节点回溯到根提交节点的路径就是分支的完整内容。每条分支都具有一个相应的“分支名称变量”，该分支名称变量是一个指针变量，它指向该分支的当前最新提交节点。另外还有一个已在上面提及的“HEAD变量”，它也是一个指针变量，它始终指向当前分支的分支名称变量。<br>默认具有一条名为“master”的分支，上述描述操作都基于该条分支。</p>
<p>综上，具有多条分支的提交节点拓扑图示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170719-0-1.jpg"></p>
<p>一些分支相关操作的实现机理描述如下：</p>
<ol>
<li>整体版本跳转。当前分支的分支名称变量指向欲跳转到版本对应的提交节点</li>
<li>特定文件的版本跳转。当前分支的分支名称变量指向的提交节点保持不变</li>
<li>查看分支。查看所有分支以及当前分支。</li>
<li>创建分支。创建一个与新建分支名称对应的分支名称变量，它的初始值与创建分支时当前分支的分支名称变量值一致，即指向创建分支时当前分支的最新提交节点。在切换到该新建分支并进行一系列提交之后，该新建分支的分支名称变量会指向该新建分支中的最新提交节点</li>
<li>切换分支。切换分支时，HEAD变量指向欲切换到分支的分支名称变量，直接修改工作区的内容（关于这点，注意跟“整体版本跳转”和“特定文件的版本跳转”中的相关行为进行区分）</li>
<li>合并分支。在合并分支时，合并两个分支的内容，直接修改工作区的内容（关于这点，注意跟“整体版本跳转”和“特定文件的版本跳转”中的相关行为进行区分），并且可能自动提交创建一个最新的提交节点</li>
<li>删除分支。直接删除对应分支的分支名称变量，其他保持不变</li>
</ol>
<h3 id="5-2、实战"><a href="#5-2、实战" class="headerlink" title="5.2、实战"></a><strong>5.2、实战</strong></h3><h4 id="5-2-1、查看分支"><a href="#5-2-1、查看分支" class="headerlink" title="5.2.1、查看分支"></a><strong>5.2.1、查看分支</strong></h4><p><strong>1、命令和说明</strong><br><code>git branch</code>：查看所有分支以及当前分支（名称前有“*”符号的即为当前分支）。<br><strong>2、实战</strong><br>参见下面小节。</p>
<h4 id="5-2-2、创建分支"><a href="#5-2-2、创建分支" class="headerlink" title="5.2.2、创建分支"></a><strong>5.2.2、创建分支</strong></h4><p><strong>1、命令和说明</strong><br><code>git branch BRANCH_NAME</code>：创建名为“BRANCH_NAME”的新分支。<br><strong>2、实战</strong><br>执行<code>git branch dev</code>命令创建新分支dev，再执行<code>git branch</code>命令查看分支，结果如下（master分支为当前分支）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 7a9965c (HEAD, master, dev) alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3、切换分支"><a href="#5-2-3、切换分支" class="headerlink" title="5.2.3、切换分支"></a><strong>5.2.3、切换分支</strong></h4><p><strong>1、命令和说明</strong><br><code>git checkout BRANCH_NAME</code>：切换到名为“BRANCH_NAME”的分支。<br><strong>2、实战</strong><br>执行<code>git checkout dev</code>命令切换到dev分支，再执行<code>git branch</code>命令查看分支，结果如下（dev分支为当前分支）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 7a9965c (HEAD, master, dev) alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="5-2-4、合并分支"><a href="#5-2-4、合并分支" class="headerlink" title="5.2.4、合并分支"></a><strong>5.2.4、合并分支</strong></h4><p><strong>1、命令和说明</strong><br><code>git merge BRANCH_NAME</code>：合并名为“BRANCH_NAME”的分支到当前分支，如果合并有冲突需首先解决冲突。<br><strong>2、实战</strong><br>在master分支下，添加文件“3.txt”，并提交到Git本地仓库，执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“5c28268b825ec3d00f5908929b96cca99fe724b0”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 5c28268b825ec3d00f5908929b96cca99fe724b0</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Mon Jul 17 18:51:10 2017 +0800</span><br><span class="line"></span><br><span class="line">    3.txt</span><br></pre></td></tr></table></figure>
<p>在dev分支下，添加文件“4.txt”，并提交到Git本地仓库，执行<code>git log</code>命令，打印最近提交信息结果如下，可知本次提交的“提交节点ID”为“6252efa4705464efccb4213580a7376811c954e8”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 6252efa4705464efccb4213580a7376811c954e8</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Mon Jul 17 18:52:09 2017 +0800</span><br><span class="line"></span><br><span class="line">    4.txt</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 6252efa (HEAD, dev) 4.txt</span><br><span class="line">| * 5c28268 (master) 3.txt</span><br><span class="line">|/  </span><br><span class="line">* 7a9965c alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<p>切换到master分支，执行<code>git merge dev</code>命令合并dev分支到当前master分支。再执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下（合并时做了一次自动提交）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   5ba2e1a (HEAD, master) Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 6252efa (dev) 4.txt</span><br><span class="line">* | 5c28268 3.txt</span><br><span class="line">|/  </span><br><span class="line">* 7a9965c alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h4 id="5-2-5、删除分支"><a href="#5-2-5、删除分支" class="headerlink" title="5.2.5、删除分支"></a><strong>5.2.5、删除分支</strong></h4><p><strong>1、命令和说明</strong><br><code>git branch -d BRANCH_NAME</code>：删除名为“BRANCH_NAME”的分支。<br><strong>2、实战</strong><br>执行<code>git branch -d dev</code>命令删除dev分支，再执行<code>git branch</code>命令查看分支，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>执行<code>git log --graph --topo-order --decorate --oneline --all</code>命令，查看此时的提交节点拓扑图，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   5ba2e1a (HEAD, master) Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 6252efa 4.txt</span><br><span class="line">* | 5c28268 3.txt</span><br><span class="line">|/  </span><br><span class="line">* 7a9965c alter again</span><br><span class="line">* d0c01f4 add again</span><br><span class="line">* 5fb58d0 delete</span><br><span class="line">* ba32a2c rename</span><br><span class="line">* 4c4c21a alter</span><br><span class="line">* 46400e7 add</span><br></pre></td></tr></table></figure>
<h2 id="六、进阶——远程仓库"><a href="#六、进阶——远程仓库" class="headerlink" title="六、进阶——远程仓库"></a><strong>六、进阶——远程仓库</strong></h2><h3 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a><strong>6.1、说明</strong></h3><p>远程仓库的作用：既可作为本地仓库的远程备份，又可作为多人协作的中间联络者。接下来以流行的Github上的远程仓库为例进行介绍。</p>
<h3 id="6-2、实战"><a href="#6-2、实战" class="headerlink" title="6.2、实战"></a><strong>6.2、实战</strong></h3><h4 id="6-2-1、关联本地仓库和远程仓库"><a href="#6-2-1、关联本地仓库和远程仓库" class="headerlink" title="6.2.1、关联本地仓库和远程仓库"></a><strong>6.2.1、关联本地仓库和远程仓库</strong></h4><p><strong>1、命令和说明</strong><br>如果通过执行<code>git clone 远程仓库地址</code>命令方式，克隆远程仓库而创建得到本地仓库，那么该本地仓库已自动与远程仓库建立关联；如果通过在目录下执行<code>git init</code>命令而初始化创建得到本地仓库，那么后续可执行<code>git remote add SHORT_NAME 远程仓库地址（SHORT_NAME表示远程仓库别名，便于后续引用该远程仓库，默认的别名为origin）</code>命令建立该本地仓库与远程仓库的关联。<br><strong>2、实战</strong><br>在Github上新建一个远程仓库（假设远程仓库地址为“<a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:dslztx&#x2F;learngit.git”），Git本地仓库使用已存在的“dslztx”本地仓库，将两者进行关联的命令为<code>git remote add origin git@github.com:dslztx/learngit.git</code>。</p>
<h4 id="6-2-2、推送到远程仓库"><a href="#6-2-2、推送到远程仓库" class="headerlink" title="6.2.2、推送到远程仓库"></a><strong>6.2.2、推送到远程仓库</strong></h4><p><strong>1、命令和说明</strong><br><code>git push origin master</code>：将本地仓库的master分支的内容推送到远程仓库的master分支，如果有冲突，先解决冲突，再推送。<br><strong>2、实战</strong><br>在dslztx本地仓库下执行<code>git push origin master</code>命令，可发现“<a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>:dslztx&#x2F;learngit.git”指代的远程仓库下有了一个master分支，且该分支的内容与本地仓库的master分支内容一致。</p>
<h4 id="6-2-3、从远程仓库拉取"><a href="#6-2-3、从远程仓库拉取" class="headerlink" title="6.2.3、从远程仓库拉取"></a><strong>6.2.3、从远程仓库拉取</strong></h4><p><strong>1、命令和说明</strong><br><code>git pull origin master</code>：从远程仓库的master分支拉取内容到本地仓库的master分支。<br><strong>2、实战</strong><br>在dslztx本地仓库下执行<code>git pull origin master</code>命令，可发现本地仓库master分支的内容与“<a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:dslztx&#x2F;learngit.git”所指代远程仓库下master分支内容一致。</p>
<h2 id="七、进阶——标签管理"><a href="#七、进阶——标签管理" class="headerlink" title="七、进阶——标签管理"></a><strong>七、进阶——标签管理</strong></h2><h3 id="7-1、说明"><a href="#7-1、说明" class="headerlink" title="7.1、说明"></a><strong>7.1、说明</strong></h3><p>标签的作用：作为提交节点的别名，相较于提交节点ID，更加便于记忆和使用。</p>
<h3 id="7-2、实战"><a href="#7-2、实战" class="headerlink" title="7.2、实战"></a><strong>7.2、实战</strong></h3><h4 id="7-2-1、查看标签"><a href="#7-2-1、查看标签" class="headerlink" title="7.2.1、查看标签"></a><strong>7.2.1、查看标签</strong></h4><p><strong>1、命令和说明</strong><br><code>git tag</code>：查看所有标签，标签默认按照标签名称的字典序进行排序。<br><strong>2、实战</strong><br>参见下面小节。</p>
<h4 id="7-2-2、查看标签对应版本信息"><a href="#7-2-2、查看标签对应版本信息" class="headerlink" title="7.2.2、查看标签对应版本信息"></a><strong>7.2.2、查看标签对应版本信息</strong></h4><p><strong>1、命令和说明</strong><br><code>git show TAG_NAME</code>：查看指定标签对应的版本的信息。<br><strong>2、实战</strong><br>参见下面小节。</p>
<h4 id="7-2-3、创建标签"><a href="#7-2-3、创建标签" class="headerlink" title="7.2.3、创建标签"></a><strong>7.2.3、创建标签</strong></h4><p><strong>1、命令和说明</strong><br><code>git tag TAG_NAME [COMMIT_ID]</code>：给指定的提交节点添加名为“TAG_NAME”的标签，如果未指定提交节点，则默认给当前最新的提交节点添加标签。<br><strong>2、实战</strong><br>执行<code>git tag &quot;v1.0&quot; 5ba2e1</code>命令给“5ba2e1ab2756fdf2c1ed9f36cc01b2deb20d8b9b”提交节点添加标签“v1.0”，再分别执行<code>git tag</code>和<code>git show &quot;v1.0&quot;</code>命令，得到结果分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1.0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 5ba2e1ab2756fdf2c1ed9f36cc01b2deb20d8b9b</span><br><span class="line">Merge: 5c28268 6252efa</span><br><span class="line">Author: dslztx &lt;dslztx@email.com&gt;</span><br><span class="line">Date:   Mon Jul 17 19:02:22 2017 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-4、推送标签到远程仓库"><a href="#7-2-4、推送标签到远程仓库" class="headerlink" title="7.2.4、推送标签到远程仓库"></a><strong>7.2.4、推送标签到远程仓库</strong></h4><p><strong>1、命令和说明</strong><br><code>git push origin TAG_NAME</code>或者<code>git push origin --tags</code>：推送指定标签或者所有标签到远程仓库。<br><strong>2、实战</strong><br>执行<code>git push origin &quot;v1.0&quot;</code>命令，将“v1.0”标签推送到远程仓库。</p>
<h4 id="7-2-5、删除标签"><a href="#7-2-5、删除标签" class="headerlink" title="7.2.5、删除标签"></a><strong>7.2.5、删除标签</strong></h4><p><strong>1、命令和说明</strong><br><code>git tag -d TAG_NAME</code>：删除名为“TAG_NAME”的标签。<br><strong>2、实战</strong><br>执行<code>git tag -d &quot;v1.0&quot;</code>命令，删除“v1.0”标签。</p>
<h4 id="7-2-6、删除远程仓库标签"><a href="#7-2-6、删除远程仓库标签" class="headerlink" title="7.2.6、删除远程仓库标签"></a><strong>7.2.6、删除远程仓库标签</strong></h4><p><strong>1、命令和说明</strong><br>先在本地执行<code>git tag -d TAG_NAME</code>命令删除“TAG_NAME”标签，然后再执行<code>git push origin :refs/tags/TAG_NAME</code>命令将删除“TAG_NAME”标签操作推送到远程仓库。<br><strong>2、实战</strong><br>在“7.2.5、删除标签”小节中已删除本地“v1.0”标签的前提下，再执行<code>git push origin :refs/tags/v1.0</code>命令删除远程仓库中的“v1.0”标签。</p>
<h2 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a><strong>八、其他</strong></h2><h3 id="8-1、配置管理"><a href="#8-1、配置管理" class="headerlink" title="8.1、配置管理"></a><strong>8.1、配置管理</strong></h3><p>执行<code>git commit</code>命令时需要指定“提交用户”和“提交用户邮箱”（即提交信息中“Author:”字段的两部分内容），可使用<code>git config</code>命令进行配置，根据配置的作用域不同，可主要分为两种方式：用户级作用域和仓库级作用域。<br><strong>1、用户级作用域</strong><br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;dslztx&quot;</span><br><span class="line">git config --global user.email &quot;dslztx@email.com&quot;</span><br></pre></td></tr></table></figure>
<p><strong>2、仓库级作用域</strong><br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;dslztx&quot;</span><br><span class="line">git config --local user.email &quot;dslztx@email.com&quot;</span><br></pre></td></tr></table></figure>
<h3 id="8-2、文件过滤"><a href="#8-2、文件过滤" class="headerlink" title="8.2、文件过滤"></a><strong>8.2、文件过滤</strong></h3><p>Git允许使用名为“.gitignore”的特殊文件，在该特殊文件内可编写用于描述需要被过滤文件的表达式。一些常用的文件过滤表达式可参见<a href="https://github.com/github/gitignore">链接</a>。</p>
<h3 id="8-3、命令缩写"><a href="#8-3、命令缩写" class="headerlink" title="8.3、命令缩写"></a><strong>8.3、命令缩写</strong></h3><p>Git提供命令缩写机制，具体命令配置形式为<code>git config alias.SHORT_NAME FULL_NAME</code>，在配置后，执行<code>git SHORT_NAME</code>即等价于执行<code>git FULL_NAME</code>。根据配置的作用域不同，可主要分为两种方式：用户级作用域和仓库级作用域。<br><strong>1、用户级作用域</strong><br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p><strong>2、仓库级作用域</strong><br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local alias.st status</span><br></pre></td></tr></table></figure>
<h2 id="九、博文定位"><a href="#九、博文定位" class="headerlink" title="九、博文定位"></a><strong>九、博文定位</strong></h2><p>本博文的定位是作为Git快速入门的教程，因此，一些深入的细节并未探讨和涉及，比如下面这些内容：</p>
<ul>
<li>一些Git命令被实现得越来越智能，使得有些前导步骤可被省略。比如<code>git commit</code>命令：欲删除已在Git仓库中的文件，本来应依次执行<code>git rm</code>和<code>git commit</code>命令，现在依次执行<code>rm</code>和<code>git commit</code>命令也能达到等价的效果；欲提交对已存在Git仓库中的文件的修改，本来应依次执行<code>git add</code>和<code>git commit</code>命令，现在直接执行<code>git commit</code>命令即可达到等价的效果</li>
<li>对于本地仓库与远程仓库之间的内容推送和拉取，本文只讨论了默认单分支的简单情形，而没有考虑多分支等复杂情形</li>
<li>几个基础简单的命令并未进行讲解，默认读者都已经掌握，比如“git diff”，“git status”等命令</li>
</ul>
<br/>
参考文献：
[1]http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
[2]https://gist.github.com/datagrok/4221767
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Gnome Terminal快捷键</title>
    <url>/blog/2018/05/31/Gnome-Terminal%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="一、文件菜单栏"><a href="#一、文件菜单栏" class="headerlink" title="一、文件菜单栏"></a><strong>一、文件菜单栏</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+Ctrl+t</td>
<td>新建标签页</td>
</tr>
<tr>
<td>Shift+Ctrl+n</td>
<td>新建窗口</td>
</tr>
<tr>
<td>Shift+Ctrl+w</td>
<td>关闭标签页</td>
</tr>
<tr>
<td>Shift+Ctrl+q</td>
<td>关闭窗口</td>
</tr>
</tbody></table>
<h2 id="二、编辑菜单栏"><a href="#二、编辑菜单栏" class="headerlink" title="二、编辑菜单栏"></a><strong>二、编辑菜单栏</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+Ctrl+c</td>
<td>复制</td>
</tr>
<tr>
<td>Shift+Ctrl+v</td>
<td>粘贴</td>
</tr>
</tbody></table>
<h2 id="三、查看菜单栏"><a href="#三、查看菜单栏" class="headerlink" title="三、查看菜单栏"></a><strong>三、查看菜单栏</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>F11</td>
<td>全屏</td>
</tr>
<tr>
<td>Ctrl+<code>+</code></td>
<td>放大窗口</td>
</tr>
<tr>
<td>Ctrl+<code>-</code></td>
<td>缩小窗口</td>
</tr>
<tr>
<td>Ctrl+<code>0</code></td>
<td>正常大小</td>
</tr>
</tbody></table>
<h2 id="四、搜索菜单栏"><a href="#四、搜索菜单栏" class="headerlink" title="四、搜索菜单栏"></a><strong>四、搜索菜单栏</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+Ctrl+f</td>
<td>查找</td>
</tr>
<tr>
<td>Shift+Ctrl+h</td>
<td>查找下一个</td>
</tr>
<tr>
<td>Shift+Ctrl+g</td>
<td>查找上一个</td>
</tr>
</tbody></table>
<h2 id="五、标签页"><a href="#五、标签页" class="headerlink" title="五、标签页"></a><strong>五、标签页</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+PageUp</td>
<td>跳转到上一个标签页</td>
</tr>
<tr>
<td>Ctrl+PageDown</td>
<td>跳转到下一个标签页</td>
</tr>
<tr>
<td>Shift+Ctrl+PageUp</td>
<td>标签页左移</td>
</tr>
<tr>
<td>Shift+Ctrl+PageDown</td>
<td>标签页右移</td>
</tr>
<tr>
<td>Alt+<code>N</code></td>
<td>跳转到标签页N，N的值为<code>1-9</code></td>
</tr>
<tr>
<td>Alt+<code>0</code></td>
<td>跳转到标签页10</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]Gnome Terminal中“编辑”菜单栏下“键盘快捷键”
[2]https://help.gnome.org/users/gnome-terminal/stable/adv-keyboard-shortcuts.html.en
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Gnome Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Java编程规范</title>
    <url>/blog/2017/07/28/Google-Java%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>本博文是对<a href="https://google.github.io/styleguide/javaguide.html">《Google Java Style Guide》</a>的阅读笔记，由于在对IDE进行一番配置（参见“对IDE的具体配置”）后，执行<code>Reformat Code</code>命令能够使得自动遵循很多编程规范，因此，接下来只列出需要手动遵循的编程规范。</p>
<p>对IDE的具体配置：<br>1、使用的IDE为：IntelliJ IDEA<br>2、从<a href="https://github.com/google/styleguide">链接</a>处下载“intellij-java-google-style.xml”配置文件<br>3、选择“Settings–Editor–Code Style–Java”导入“intellij-java-google-style.xml”配置文件<br>4、勾选“Code–Show Reformat File Dialog”中“Optimize Imports”和“Rearrange Code”两个选项</p>
<h2 id="一、源文件"><a href="#一、源文件" class="headerlink" title="一、源文件"></a><strong>一、源文件</strong></h2><h3 id="1-1、源文件名"><a href="#1-1、源文件名" class="headerlink" title="1.1、源文件名"></a><strong>1.1、源文件名</strong></h3><p>源文件名由“源文件中主类类名”和“.java扩展名”构成。</p>
<h3 id="1-2、源文件编码格式"><a href="#1-2、源文件编码格式" class="headerlink" title="1.2、源文件编码格式"></a><strong>1.2、源文件编码格式</strong></h3><p>使用UTF-8编码格式。</p>
<h3 id="1-3、字符"><a href="#1-3、字符" class="headerlink" title="1.3、字符"></a><strong>1.3、字符</strong></h3><h4 id="1-3-1、空白字符-2"><a href="#1-3-1、空白字符-2" class="headerlink" title="1.3.1、空白字符[2]"></a><strong>1.3.1、空白字符[2]</strong></h4><p>源文件中不能包含除了“换行符和空格字符（0x20）”之外的其他空白字符。<br>这个具有两层含义：</p>
<ul>
<li>作为控制和修饰用途的“其他空白字符”不允许被使用。比如不允许出现“Tab字符（按下Tab键）”</li>
<li>作为实际有意义内容组成部分的“其他空白字符”不允许以“直接形式”被使用，而只能以或者“转义序列”，或者“八进制转义序列”，或者“Unicode转义序列”形式被使用。比如“\t”</li>
</ul>
<h4 id="1-3-2、字符表达形式优先级"><a href="#1-3-2、字符表达形式优先级" class="headerlink" title="1.3.2、字符表达形式优先级"></a><strong>1.3.2、字符表达形式优先级</strong></h4><p>字符表达形式有：直接形式（比如“a”），转义序列形式（比如“\b”），八进制转义序列形式（比如“\012”），Unicode转义序列形式（比如“\u000a”）。<font color='red'>每个字符所具有的表达形式是不定的</font>。在源文件中，尝试表达字符时，在该字符所具有的表达形式中依次按照“直接形式，转义序列形式，（八进制转义序列形式，Unicode转义序列形式）”的顺序选取最终表达形式。假如最终表达形式非“直接形式”，那么需添加注释进行说明。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">unitAbbrev</span> <span class="operator">=</span> <span class="string">&quot;\t&quot;</span>; <span class="comment">// Tab字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">unitAbbrev</span> <span class="operator">=</span> <span class="string">&quot;μs&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;\ufeff&#x27;</span> + content; <span class="comment">// byte order mark</span></span><br></pre></td></tr></table></figure>
<h2 id="二、源文件文件结构"><a href="#二、源文件文件结构" class="headerlink" title="二、源文件文件结构"></a><strong>二、源文件文件结构</strong></h2><p>1、源文件中依次包括4部分内容：版权信息（可选），package语句（可选），import语句（可选），主类定义<br>2、使用import语句导入类A的静态内部类B时，使用<code>import A.B</code>形式，而不使用<code>import static A.B</code>形式<br>3、重载方法需被置于一起，中间不包含任何其他内容（对于“重载的构造方法”，执行<code>Reformat Code</code>命令时，“重载的构造方法被置于一起”会被自动遵循）</p>
<h2 id="三、格式化"><a href="#三、格式化" class="headerlink" title="三、格式化"></a><strong>三、格式化</strong></h2><h3 id="3-1、运算表达式中的括号"><a href="#3-1、运算表达式中的括号" class="headerlink" title="3.1、运算表达式中的括号"></a><strong>3.1、运算表达式中的括号</strong></h3><p>在运算表达式中，尽量通过添加<code>()</code>括号对的形式提升运算顺序的可读性。</p>
<h3 id="3-2、变量定义"><a href="#3-2、变量定义" class="headerlink" title="3.2、变量定义"></a><strong>3.2、变量定义</strong></h3><p>1、每行只定义一个变量，禁止类似<code>int a, b</code>形式<br>2、对于局部变量来说，只在即将需要用到的时候进行局部变量的定义，而不要提前很多进行，从而减小局部变量的作用域<br>3、定义数组类型变量时，采用类似<code>String[] args</code>形式，禁止使用类似<code>String args[]</code>形式，因为类似<code>String[]</code>才是真正的数组类型</p>
<h3 id="3-3、switch语句"><a href="#3-3、switch语句" class="headerlink" title="3.3、switch语句"></a><strong>3.3、switch语句</strong></h3><p>switch语句中具有“块”的概念，“块”是指：一个或者多个分支语句（“case”或者“default”语句）进入同一个执行逻辑，这些分支语句连同上述的执行逻辑被称为一个“块”，比如下面展现的就是一个“块”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  prepareOneOrTwo();</span><br></pre></td></tr></table></figure>
<p>1、在switch语句中，必须包含“default”分支语句<br>2、在switch语句中，“块”的结束方式必须是且只能是下述5种方式之一：“break”，“continue”，“return”，“throw exception”和“<code>// fall through</code>注释语句（该注释语句声明继续执行进入下一个‘块’，但当处于最后‘块’中时，该注释语句可被省略）”<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4、注解"><a href="#3-4、注解" class="headerlink" title="3.4、注解"></a><strong>3.4、注解</strong></h3><p>当同时存在注解与JavaDoc时，注解应置于JavaDoc之后。</p>
<h3 id="3-5、修饰符"><a href="#3-5、修饰符" class="headerlink" title="3.5、修饰符"></a><strong>3.5、修饰符</strong></h3><p>Java修饰符的排列顺序应该按照如下顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public protected private abstract default static final transient volatile synchronized native strictfp</span><br></pre></td></tr></table></figure>
<h3 id="3-6、长整型字面量"><a href="#3-6、长整型字面量" class="headerlink" title="3.6、长整型字面量"></a><strong>3.6、长整型字面量</strong></h3><p>在表达一个长整型字面量时，使用<code>L</code>后缀，禁止使用<code>l</code>后缀。<br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Long a = 10000L;</span><br><span class="line">long b = 10000L;</span><br></pre></td></tr></table></figure>
<h2 id="四、命名"><a href="#四、命名" class="headerlink" title="四、命名"></a><strong>四、命名</strong></h2><p>所有Java标识符都由“大写英文字母，小写英文字母，数字和下划线”构成，即JDK正则表达式中“\w”所表达的字符范围。<br>大驼峰命名法：由1个或者多个单词构成，只允许包含“大写英文字母，小写英文字母，数字”，其中大写英文字母只允许在每个单词的首字符位置出现。<br>小驼峰命名法：由1个或者多个单词构成，只允许包含“大写英文字母，小写英文字母，数字”，其中大写英文字母只允许在每个单词（除了第一个单词）的首字符位置出现。</p>
<h3 id="4-1、包名"><a href="#4-1、包名" class="headerlink" title="4.1、包名"></a><strong>4.1、包名</strong></h3><p>多个部分以“.”字符连接构成，而每个部分又由“小写英文字母和数字”构成。</p>
<h3 id="4-2、类名"><a href="#4-2、类名" class="headerlink" title="4.2、类名"></a><strong>4.2、类名</strong></h3><p>采用“大驼峰命名法”。<br>1、“具体类，抽象类，枚举类”的类名一般是“名词词组”；“接口”的类名一般是“名词词组”，也可以是“形容词词组”；“注解类”的类名没有特定规范<br>2、测试类的类名是在被测试类的类名之后加上“Test”后缀<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayLis</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Readable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---分隔---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodeUtil</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodeUtilTest</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3、方法名"><a href="#4-3、方法名" class="headerlink" title="4.3、方法名"></a><strong>4.3、方法名</strong></h3><p>采用“小驼峰命名法”，一般是动词词组。测试方法的名称没有特定规范。</p>
<h3 id="4-4、常量成员变量名称"><a href="#4-4、常量成员变量名称" class="headerlink" title="4.4、常量成员变量名称"></a><strong>4.4、常量成员变量名称</strong></h3><p>由“大写英文字母，数字，下划线”构成，一般是名词词组。<br>“常量成员变量”定义：<br>1、由“static final”修饰符组合修饰的成员变量<br>2、成员变量的类型一般为“基本类型，String类型，不可变类型，元素为不可变类型的不可变集合类型”，更准确的描述是：一旦该成员变量定义完成，使得“包括该成员变量值所在内存区域在内，加上所有级联到内存区域”中的值都不再改变的类型都可作为该成员变量的类型<br>3、根据“枚举类”的定义，其中所有的“枚举值”实质上都是特殊的“常量成员变量名称”<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">&quot;Ed&quot;</span>, <span class="string">&quot;Ann&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of(<span class="string">&quot;Ed&quot;</span>, <span class="number">35</span>, <span class="string">&quot;Ann&quot;</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Joiner</span> <span class="variable">COMMA_JOINER</span> <span class="operator">=</span> Joiner.on(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// com.google.common.base.Joiner , Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnum</span> &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">nonFinal</span> <span class="operator">=</span> <span class="string">&quot;non-final&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">nonStatic</span> <span class="operator">=</span> <span class="string">&quot;non-static&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableMap&lt;String, SomeMutableType&gt; mutableValues =</span><br><span class="line">    ImmutableMap.of(<span class="string">&quot;Ed&quot;</span>, mutableInstance, <span class="string">&quot;Ann&quot;</span>, mutableInstance2);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">&quot;these&quot;</span>, <span class="string">&quot;can&quot;</span>, <span class="string">&quot;change&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-5、非常量成员变量名称"><a href="#4-5、非常量成员变量名称" class="headerlink" title="4.5、非常量成员变量名称"></a><strong>4.5、非常量成员变量名称</strong></h3><p>采用“小驼峰命名法”，一般是名词词组。</p>
<h3 id="4-6、方法参数变量名称"><a href="#4-6、方法参数变量名称" class="headerlink" title="4.6、方法参数变量名称"></a><strong>4.6、方法参数变量名称</strong></h3><p>采用“小驼峰命名法”，一般是名词词组，禁止只包含1个字符的名称。</p>
<h3 id="4-7、局部变量名称"><a href="#4-7、局部变量名称" class="headerlink" title="4.7、局部变量名称"></a><strong>4.7、局部变量名称</strong></h3><p>采用“小驼峰命名法”，一般是名词词组。</p>
<h3 id="4-8、泛型体系中类型参数名称"><a href="#4-8、泛型体系中类型参数名称" class="headerlink" title="4.8、泛型体系中类型参数名称"></a><strong>4.8、泛型体系中类型参数名称</strong></h3><p>泛型体系中类型参数名称有两种形式：1）一个大写英文字母，加上一个可选的数字；2）相应的类名加上“T”字母。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span>&lt;RequestT&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span>&lt;T1&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">map</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、编程实践"><a href="#五、编程实践" class="headerlink" title="五、编程实践"></a><strong>五、编程实践</strong></h2><h3 id="5-1、使用-Override注解"><a href="#5-1、使用-Override注解" class="headerlink" title="5.1、使用@Override注解"></a><strong>5.1、使用@Override注解</strong></h3><p>出现覆盖情形时，使用@Override注解。</p>
<h3 id="5-2、处理Caught-Exception"><a href="#5-2、处理Caught-Exception" class="headerlink" title="5.2、处理Caught Exception"></a><strong>5.2、处理Caught Exception</strong></h3><p>在“try-catch-finally”语句块的“catch语句”中，必须对异常进行处理：或者打印日志，或者重新抛出异常，或者进行注释说明。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (AException a) &#123;</span><br><span class="line">  logger.error(<span class="string">&quot;&quot;</span>, a);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BException b) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(b);</span><br><span class="line">&#125; <span class="keyword">catch</span> (CException c) &#123;</span><br><span class="line">  <span class="comment">// c exception is impossible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果是在测试方法中，且“catch语句”对应的异常是被期望的异常，那么可将该异常命名为“expected”或者以“expected”为前缀，而无需再在该“catch语句”中对该异常进行处理。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3、使用类引用类的静态成员"><a href="#5-3、使用类引用类的静态成员" class="headerlink" title="5.3、使用类引用类的静态成员"></a><strong>5.3、使用类引用类的静态成员</strong></h3><p>使用类引用类的静态成员，禁止使用类的实例引用类的静态成员。</p>
<h3 id="5-4、禁止依赖Object类的finalize-方法"><a href="#5-4、禁止依赖Object类的finalize-方法" class="headerlink" title="5.4、禁止依赖Object类的finalize()方法"></a><strong>5.4、禁止依赖Object类的finalize()方法</strong></h3><p>禁止依赖Object类的finalize()方法。</p>
<h2 id="六、JavaDoc"><a href="#六、JavaDoc" class="headerlink" title="六、JavaDoc"></a><strong>六、JavaDoc</strong></h2><p>1、对于类的成员，除非意义明显，否则都应该加上JavaDoc<br>2、每个JavaDoc都应该有一段文字描述<br>3、JavaDoc中，用<code>&lt;p&gt;</code>标签来分隔多段文字描述内容，多段文字描述内容之间以一行空格进行隔开<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;first thing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;second thing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;third thing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> return the result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://google.github.io/styleguide/javaguide.html
[2]https://en.wikipedia.org/wiki/Whitespace_character
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Google文本搜索技巧</title>
    <url>/blog/2018/04/16/Google%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>Google提供了文本搜索，语音搜索，图像搜索等搜索入口。接下来介绍常见的文本搜索技巧。</p>
<h2 id="一、拼写和大小写"><a href="#一、拼写和大小写" class="headerlink" title="一、拼写和大小写"></a><strong>一、拼写和大小写</strong></h2><p>Google文本搜索能够自动纠正搜索关键词中的拼写错误，且对大小写不敏感。</p>
<h2 id="二、快速搜索定义"><a href="#二、快速搜索定义" class="headerlink" title="二、快速搜索定义"></a><strong>二、快速搜索定义</strong></h2><p>在搜索关键词前加<code>define</code>前缀，能够快速搜索相应对象的定义。</p>
<h2 id="三、搜索关键词之间的逻辑关系"><a href="#三、搜索关键词之间的逻辑关系" class="headerlink" title="三、搜索关键词之间的逻辑关系"></a><strong>三、搜索关键词之间的逻辑关系</strong></h2><p>搜索关键词之间的逻辑关系默认是“与”，可使用<code>-</code>和<code>OR</code>分别表示“非”和“或”的逻辑关系。<br>下面给出几个例子：</p>
<ul>
<li>“A B”，搜索结果中既要包含“A”，也要包含“B”</li>
<li>“A -B”，搜索结果中需要包含“A”，但不能包含“B”</li>
<li>“A OR B”，搜索结果中或者包含“A”，或者包含“B”</li>
</ul>
<h2 id="四、精确搜索"><a href="#四、精确搜索" class="headerlink" title="四、精确搜索"></a><strong>四、精确搜索</strong></h2><p>将搜索关键词置于<code>&quot;&quot;</code>符号对之间，表示搜索结果中必须精确包含相应的搜索关键词。</p>
<h2 id="五、在特定站点或者域名中搜索"><a href="#五、在特定站点或者域名中搜索" class="headerlink" title="五、在特定站点或者域名中搜索"></a><strong>五、在特定站点或者域名中搜索</strong></h2><p>使用<code>site:</code>在特定站点或者域名中搜索。<br>下面给出几个例子：</p>
<ul>
<li>“java site:<a href="http://www.oracle.com”,在“www.oracle.com”站点中搜索“java”这个关键词/">www.oracle.com”，在“www.oracle.com”站点中搜索“java”这个关键词</a></li>
<li>“java site:org”，在“org”域名中搜索“java”这个关键词</li>
</ul>
<h2 id="六、高级搜索"><a href="#六、高级搜索" class="headerlink" title="六、高级搜索"></a><strong>六、高级搜索</strong></h2><p>打开<a href="https://www.google.com/advanced_search">链接</a>，使用高级搜索。</p>
<br/>
参考文献：
[1]https://support.google.com/websearch/answer/134479?hl=en&ref_topic=3081620
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap和ConcurrentHashMap</title>
    <url>/blog/2021/11/30/HashMap%E5%92%8CConcurrentHashMap/</url>
    <content><![CDATA[<p>本文介绍JDK 1.8下的HashMap和ConcurrentHashMap实现。</p>
<h2 id="一、HashMap"><a href="#一、HashMap" class="headerlink" title="一、HashMap"></a><strong>一、HashMap</strong></h2><p>基本描述：</p>
<ul>
<li>不用于并发场景的“映射表”</li>
<li>“键”允许<code>NULL</code>值，“键值”允许<code>NULL</code>值。因此如果取某一个键的值，当取到<code>NULL</code>键值有两种含义：1）对于该键不存在相应的映射记录；2）对于该键存在相应的映射记录，但是其键值为<code>NULL</code></li>
<li>底层是“节点数组”，对键作哈希计算（准确来说是“3次哈希计算”），映射到的节点数组中的节点被称为“槽”，不同键同槽碰撞的解决策略是“链地址法”，对应的链可称之为“碰撞冲突链”，为优化过长（超过一定阈值）“碰撞冲突链”的操作性能，将其转换为红黑树结构；后续红黑树如果过短，再退化成普通的链表结构</li>
<li>涉及到两类大小——“映射记录大小”和“节点数组大小”，当满足条件时，会对节点数组大小进行扩容</li>
<li>时间复杂度<ul>
<li>增：不碰撞，是<code>O(1)</code>；碰撞，假定碰撞冲突链长度为K，在转换为红黑树之前是<code>O(K)</code>，在转换为红黑树之后是<code>O(logK)</code></li>
<li>删：不碰撞，是<code>O(1)</code>；碰撞，假定碰撞冲突链长度为K，在转换为红黑树之前是<code>O(K)</code>，在转换为红黑树之后是<code>O(logK)</code></li>
<li>改：不碰撞，是<code>O(1)</code>；碰撞，假定碰撞冲突链长度为K，在转换为红黑树之前是<code>O(K)</code>，在转换为红黑树之后是<code>O(logK)</code></li>
<li>查：不碰撞，是<code>O(1)</code>；碰撞，假定碰撞冲突链长度为K，在转换为红黑树之前是<code>O(K)</code>，在转换为红黑树之后是<code>O(logK)</code></li>
</ul>
</li>
</ul>
<h3 id="1-1、哈希和碰撞"><a href="#1-1、哈希和碰撞" class="headerlink" title="1.1、哈希和碰撞"></a><strong>1.1、哈希和碰撞</strong></h3><p><strong>1、哈希算法</strong></p>
<ol>
<li>第一次哈希：键的<code>hashCode()</code>方法值</li>
<li>第二次哈希：其源代码见“源代码1”，<code>h ^ (h &gt;&gt;&gt; 16)</code>其含义是：计算保留高位比特信息，以利于第三次哈希后均匀散列到槽</li>
<li>第三次哈希：本次哈希是为了散列到槽，其计算公式为<code>p &amp; (n-1)</code>[假定节点数组大小为<code>n</code>，经过前两次哈希的结果值为<code>p</code>]</li>
</ol>
<p>源代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、碰撞解决策略</strong><br>碰撞可通过“链地址法”解决，对应的链可称之为“碰撞冲突链”，假定链表的长度为K。<br>当为普通链表时，增删改查的时间复杂度为<code>O(K)</code>，故为优化操作性能，当链表长度<code>&gt;=TREEIFY_THRESHOLD(8)</code>时，将其转换为红黑树，此时增删改查的时间复杂度为<code>O(logK)</code>；另外当红黑树大小满足条件<code>&lt;=UNTREEIFY_THRESHOLD(6)</code>时，红黑树退化为普通链表。</p>
<h3 id="1-2、大小"><a href="#1-2、大小" class="headerlink" title="1.2、大小"></a><strong>1.2、大小</strong></h3><p>HashMap涉及到两类大小：映射记录大小和节点数组大小。</p>
<h4 id="1-2-1、映射记录大小"><a href="#1-2-1、映射记录大小" class="headerlink" title="1.2.1、映射记录大小"></a><strong>1.2.1、映射记录大小</strong></h4><p>指HashMap中映射记录数量，比如“节点数组大小为8，在且只在第3个节点（槽）有一个长度为4的链表（碰撞冲突链），则映射记录大小为4”：</p>
<ul>
<li>对应于实例成员变量<code>transient int size</code></li>
<li>对应于实例成员方法<code>public int size()</code>的返回值（不考虑映射记录大小大于<code>Integer.MAX_VALUE</code>的情形），该方法直接返回成员变量<code>size</code>的值，因此时间复杂度<code>O(1)</code></li>
</ul>
<h4 id="1-2-2、节点数组大小"><a href="#1-2-2、节点数组大小" class="headerlink" title="1.2.2、节点数组大小"></a><strong>1.2.2、节点数组大小</strong></h4><p>指HashMap中节点数组大小，即成员变量<code> transient Node&lt;K, V&gt;[] table</code>的大小。</p>
<p>节点数组大小为2的整数次幂，其好处如下：</p>
<ul>
<li>第三次哈希的计算公式为<code>p &amp; (n - 1)</code>[假定节点数组大小为<code>n</code>，经过前两次哈希的结果值为<code>p</code>]，由于<code>n=2^x</code>，则<code>n-1</code>的低比特位全为1，使得“&amp;”运算能够充分利用<code>p</code>数值相应比特位位置的信息，利于均匀散列到槽</li>
<li>后续可知，节点数组大小为2的整数次幂，加快了扩容过程中的“rehash”操作</li>
</ul>
<p>接下来介绍“初始化节点数组大小”和“扩容节点数组大小”，在介绍之前首先作以下几点说明：</p>
<ul>
<li>为简化描述和便于理解，不考虑极值大小的情况，比如<code>节点数组大小&gt;=MAXIMUM_CAPACITY(1 &lt;&lt; 30)</code></li>
<li>成员变量<code>loadFactor</code>的语义是：负载因子，当<code>映射记录大小 &gt; 节点数组大小*loadFactor</code>时扩容节点数组</li>
<li>成员变量<code>threshold</code>的语义是：<ul>
<li>当节点数组未初始化时：<code>threshold &gt; 0</code>表示节点数组初始化大小等于<code>threshold</code>；<code>threshold = 0</code>表示节点数组初始化大小等于<code>DEFAULT_INITIAL_CAPACITY(1 &lt;&lt; 4)</code></li>
<li>当节点数组已初始化时：<code>threshold=节点数组大小*loadFactor</code>，即当<code>映射记录大小 &gt; threshold</code>时扩容节点数组</li>
</ul>
</li>
</ul>
<h5 id="1-2-2-1、初始化"><a href="#1-2-2-1、初始化" class="headerlink" title="1.2.2.1、初始化"></a><strong>1.2.2.1、初始化</strong></h5><p>惰性初始化，即“不是一开始就初始化，而是在需要时才初始化”。</p>
<p><strong>1、构造方法</strong><br>构造方法设置成员变量<code>threshold</code>和<code>loadFactor</code>的值，具体描述如下表。</p>
<table>
<thead>
<tr>
<th>构造方法\成员变量</th>
<th>threshold</th>
<th>loadFactor</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap()</code></td>
<td>等于“实例初始化默认0值”</td>
<td>等于<code>DEFAULT_LOAD_FACTOR(0.75f)</code></td>
</tr>
<tr>
<td><code>HashMap(int initialCapacity, float loadFactor)</code></td>
<td>等于<code>tableSizeFor(initialCapacity)</code></td>
<td>等于传入的<code>loadFactor</code></td>
</tr>
<tr>
<td><code>HashMap(int initialCapacity)</code></td>
<td>等于<code>tableSizeFor(initialCapacity)</code></td>
<td>等于<code>DEFAULT_LOAD_FACTOR(0.75f)</code></td>
</tr>
<tr>
<td><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td>等于<code>tableSizeFor( m.size() / loadFactor + 1.0f )</code></td>
<td>等于<code>DEFAULT_LOAD_FACTOR(0.75f)</code></td>
</tr>
</tbody></table>
<p>有两点说明：</p>
<ol>
<li>上述<code>tableSizeFor</code>方法（源代码见“源代码2”）的作用是：返回大于等于输入参数且为最近的“2的整数次幂”的数值，比如“输入10，返回16”</li>
<li>后续可知，扩容操作十分耗费性能（申请新节点数组内存资源，对原映射记录进行rehash操作），因此在创建HashMap实例时最好能够根据预估的“映射记录大小”预计算“节点数组的初始化大小”。由于当<code>映射记录大小 &gt; 节点数组大小*loadFactor</code>时进行扩容，故为尽量避免扩容，须使得满足<code>节点数组大小 &gt;= 映射记录大小/loadFactor</code>不等式，上述第4个构造方法中的<code>m.size() / loadFactor + 1.0f</code>就是基于该不等式的一个常用等式，<font color='red'>我们自己在创建HashMap实例时也应该使用该等式预计算传入的节点数组初始化大小</font></li>
</ol>
<p>源代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、惰性初始化</strong><br>根据<code>threshold</code>的值分为两种情况：</p>
<ul>
<li><code>threshold=0</code>：节点数组初始化大小等于<code>DEFAULT_INITIAL_CAPACITY(1 &lt;&lt; 4)</code>，新<code>threshold</code>值等于<code>DEFAULT_INITIAL_CAPACITY(1 &lt;&lt; 4) * DEFAULT_LOAD_FACTOR(0.75f)</code></li>
<li><code>threshold&gt;0</code>：节点数组初始化大小等于<code>threshold</code>，新<code>threshold</code>值等于<code>threshold * loadFactor</code></li>
</ul>
<h5 id="1-2-2-2、扩容"><a href="#1-2-2-2、扩容" class="headerlink" title="1.2.2.2、扩容"></a><strong>1.2.2.2、扩容</strong></h5><p>节点数组只有“扩容”，没有“收缩”，扩容条件为：<code>映射记录大小 &gt; threshold</code>。</p>
<p>扩容过程描述如下：</p>
<ul>
<li>2倍扩容。节点数组新大小是原来的2倍，成员变量<code>threshold</code>新值也是原来的2倍（语义不变）</li>
<li>对原映射记录进行rehash操作：假设原节点数组大小为<code>n</code>，有一个“键”的二次哈希值为<code>hash</code>，则原散列到槽<code>(n -1) &amp; hash</code>，现散列到槽<code>(2*n - 1) &amp; hash</code>，这里可以有个计算优化，我们知道节点数组大小<code>n</code>是2的整数次幂，分析其比特位特点可知，对于以上运算，低n位比特位的<code>&amp;</code>运算结果不变，故只需要计算从低位往高位方向第n位的比特位<code>&amp;</code>结果，即<code>n &amp; hash</code></li>
</ul>
<h3 id="1-3、与JDK-1-6中HashMap实现比较"><a href="#1-3、与JDK-1-6中HashMap实现比较" class="headerlink" title="1.3、与JDK 1.6中HashMap实现比较"></a><strong>1.3、与JDK 1.6中HashMap实现比较</strong></h3><p>与JDK 1.6中HashMap实现相比，主要有以下几点改进：</p>
<ol>
<li>在JDK 1.8中，当碰撞冲突链过长时，会转化为红黑树，优化操作性能；而在JDK 1.6中，没有该优化</li>
<li>对于节点数组的初始化，JDK 1.8中是惰性的，JDK 1.6中是即时的</li>
<li>对于第二次哈希算法，JDK 1.8中的实现相较JDK 1.6较为简单，其后果就是“第三次哈希后散列到槽相较不均匀，碰撞冲突链的长度相较更长的概率增大”，但是由于JDK 1.8中引入了过长碰撞冲突链转换为红黑树的机制，使得上述问题得到了充分的补偿</li>
<li>两者的实现都是针对非并发场景的，如果用于并发场景，可能会出现一些线程安全问题，比如：<ul>
<li>映射记录丢失。在JDK 1.8中并发执行<code>p.next = newNode(hash, key, value, null)</code>语句；在JDK 1.6中并发执行<code>table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e)</code>语句</li>
<li>扩容导致死循环。在JDK 1.6中，扩容会导致死循环，问题相关源代码见“源代码3”，一种可能是：线程A执行语句<code>A.next = newTable[i]; newTable[i] = A;</code>，线程B并发执行语句<code>A.next = newTable[i];</code>，然后最后有<code>A.next = A;</code>，导致产生了一个链表死循环；在JDK 1.8中，对此予以了改进，不存在扩容导致死循环问题</li>
</ul>
</li>
</ol>
<p>源代码3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];    <span class="comment">//1</span></span><br><span class="line">                newTable[i] = e;         <span class="comment">//2</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、ConcurrentHashMap"><a href="#二、ConcurrentHashMap" class="headerlink" title="二、ConcurrentHashMap"></a><strong>二、ConcurrentHashMap</strong></h2><p>基本描述：</p>
<ul>
<li>用于并发场景的“映射表”，使用“CAS自旋锁+synchronized锁”实现线程安全</li>
<li>“键”和“键值”都不允许<code>NULL</code>值。因此如果取某一个键的值，当取到<code>NULL</code>键值只有一种含义——对于该键不存在相应的映射记录</li>
<li>底层是“节点数组”，对键作哈希计算（准确来说是“3次哈希计算”），映射到的节点数组中的节点被称为“槽”，不同键同槽碰撞的解决策略是“链地址法”，对应的链可称之为“碰撞冲突链”，为优化过长（超过一定阈值）“碰撞冲突链”的操作性能，将其转换为红黑树结构；后续红黑树如果过短，再退化成普通的链表结构</li>
<li>涉及到两类大小——“映射记录大小”和“节点数组大小”，当满足条件时，会对节点数组大小进行扩容</li>
<li>时间复杂度：如果不考虑“CAS自旋”基本跟HashMap一致；否则，难以忽略而不可分析</li>
</ul>
<h3 id="2-1、哈希和碰撞"><a href="#2-1、哈希和碰撞" class="headerlink" title="2.1、哈希和碰撞"></a><strong>2.1、哈希和碰撞</strong></h3><p>核心基本跟HashMap一致，除了以下两点：</p>
<ul>
<li>需要考虑线程安全问题</li>
<li>第二次哈希算法不同，其源代码见“源代码4”，与<code>HASH_BITS(0x7fffffff)</code>进行<code>&amp;</code>运算是为了避免结果值与3个特殊哈希值（<code>MOVED = -1</code>，<code>TREEBIN = -2</code>，<code>RESERVED = -3</code>）冲突</li>
</ul>
<p>源代码4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、大小"><a href="#2-2、大小" class="headerlink" title="2.2、大小"></a><strong>2.2、大小</strong></h3><p>ConcurrentHashMap涉及到两类大小：映射记录大小和节点数组大小。</p>
<h4 id="2-2-1、映射记录大小"><a href="#2-2-1、映射记录大小" class="headerlink" title="2.2.1、映射记录大小"></a><strong>2.2.1、映射记录大小</strong></h4><p>指ConcurrentHashMap中映射记录数量，比如“节点数组大小为8，在且只在第3个节点（槽）有一个长度为4的链表（碰撞冲突链），则映射记录大小为4”：</p>
<ul>
<li>对应于实例成员变量<code>transient volatile long baseCount</code>和<code>transient volatile CounterCell[] counterCells</code>。在没竞争的时候只使用<code>baseCount</code>，在有竞争的时候同时使用<code>baseCount</code>和<code>counterCells</code></li>
<li>对应于实例成员方法<code>public int size()/public long mappingCount()</code>的返回值（当映射记录大小大于<code>Integer.MAX_VALUE</code>时，后者更为准确；但是一般情况下用前者就足够了），这两个方法返回都基于成员变量<code>transient volatile long baseCount</code>和<code>transient volatile CounterCell[] counterCells</code>，当没竞争只使用<code>baseCount</code>时，时间复杂度为<code>O(1)</code>；当有竞争同时使用<code>baseCount</code>和<code>counterCells</code>时，时间复杂度不是<code>O(1)</code></li>
</ul>
<h4 id="2-2-2、节点数组大小"><a href="#2-2-2、节点数组大小" class="headerlink" title="2.2.2、节点数组大小"></a><strong>2.2.2、节点数组大小</strong></h4><p>指ConcurrentHashMap中节点数组大小，即成员变量<code> transient Node&lt;K, V&gt;[] table</code>的大小。</p>
<p>节点数组大小为2的整数次幂，其好处如下：</p>
<ul>
<li>第三次哈希的计算公式为<code>p &amp; (n - 1)</code>[假定节点数组大小为<code>n</code>，经过前两次哈希的结果值为<code>p</code>]，由于<code>n=2^x</code>，则<code>n-1</code>的低比特位全为1，使得“&amp;”运算能够充分利用<code>p</code>数值相应比特位位置的信息，利于均匀散列到槽</li>
<li>后续可知，节点数组大小为2的整数次幂，加快了扩容过程中的“rehash”操作</li>
</ul>
<p>接下来介绍“初始化节点数组大小”和“扩容节点数组大小”，在介绍之前首先作以下几点说明：</p>
<ul>
<li>为简化描述和便于理解，不考虑极值大小的情况，比如<code>节点数组大小&gt;=MAXIMUM_CAPACITY(1 &lt;&lt; 30)</code></li>
<li>成员变量<code>sizeCtl</code>的语义是：<ul>
<li>当<code>sizeCtl &lt; 0</code>时，表示正在扩容过程中或者正在初始化</li>
<li>当<code>sizeCtl &gt;= 0</code>时，<ul>
<li>当节点数组未初始化时：<code>sizeCtl &gt; 0</code>表示节点数组初始化大小等于<code>sizeCtl</code>；<code>sizeCtl = 0</code>表示节点数组初始化大小等于<code>DEFAULT_CAPACITY(16)</code></li>
<li>当节点数组已初始化时：有<code>sizeCtl = 节点数组大小*3/4</code>（即<code>0.75</code>，表现形式为<code>n - (n &gt;&gt;&gt; 2)</code>），此时不可能出现<code>sizeCtl = 0</code>，当<code>映射记录大小 &gt;= sizeCtl</code>时扩容节点数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-2-1、初始化"><a href="#2-2-2-1、初始化" class="headerlink" title="2.2.2.1、初始化"></a><strong>2.2.2.1、初始化</strong></h5><p>惰性初始化，即“不是一开始就初始化，而是在需要时才初始化”。</p>
<p><strong>1、构造方法</strong><br>构造方法设置成员变量<code>sizeCtl</code>的值，具体描述如下表。</p>
<table>
<thead>
<tr>
<th>构造方法\成员变量</th>
<th>sizeCtl</th>
</tr>
</thead>
<tbody><tr>
<td><code>ConcurrentHashMap()</code></td>
<td>等于“实例初始化默认0值”</td>
</tr>
<tr>
<td><code>ConcurrentHashMap(int initialCapacity)</code></td>
<td>等于<code>tableSizeFor( initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1 )</code></td>
</tr>
<tr>
<td><code>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</code></td>
<td>等于<code>tableSizeFor( max(initialCapacity,concurrencyLevel) / loadFactor + 1.0 )</code></td>
</tr>
<tr>
<td><code>ConcurrentHashMap(int initialCapacity, float loadFactor)</code></td>
<td>等于<code>this(initialCapacity, loadFactor, 1)</code></td>
</tr>
<tr>
<td><code>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td>等于<code>max( tableSizeFor( m.size() + (m.size() &gt;&gt;&gt; 1) + 1 ), 16 )</code></td>
</tr>
</tbody></table>
<p>有两点说明：</p>
<ol>
<li>上述<code>tableSizeFor</code>方法（源代码见“源代码5”）的作用是：返回大于等于输入参数且为最近的“2的整数次幂”的数值，比如“输入10，返回16”</li>
<li>后续可知，扩容操作十分耗费性能（申请新节点数组内存资源，对原映射记录进行rehash操作），因此在创建ConcurrentHashMap实例时最好能够根据预估的“映射记录大小”预计算“节点数组的初始化大小”。由于当<code>映射记录大小 &gt;= 节点数组大小*3/4</code>时进行扩容，故为尽量避免扩容，须使得满足<code>节点数组大小 &gt; 映射记录大小*4/3</code>不等式，上述构造方法中的<code>(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)/(m.size() + (m.size() &gt;&gt;&gt; 1) + 1)</code>（即：映射记录大小*3&#x2F;2+1）和<code>max(initialCapacity,concurrencyLevel) / loadFactor + 1.0</code>（该等式满足条件与否跟loadFactor值有关，一般取值为0.75f，此时是满足条件的）就是基于该不等式的两个等式。<font color='red'>很明显，跟HashMap不同，这里的预计算在构造方法内部自动完成，而在HashMap处预计算需要在外部手动完成，后者反人性</font></li>
</ol>
<p>源代码5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、惰性初始化</strong><br>根据<code>sizeCtl</code>的值分为两种情况：</p>
<ul>
<li><code>sizeCtl=0</code>：节点数组初始化大小等于<code>DEFAULT_CAPACITY(16)</code>，新<code>sizeCtl</code>值等于<code>DEFAULT_CAPACITY(16) * 3/4</code></li>
<li><code>sizeCtl&gt;0</code>：节点数组初始化大小等于<code>sizeCtl</code>，新<code>sizeCtl</code>值等于<code>sizeCtl * 3/4</code></li>
</ul>
<h5 id="2-2-2-2、扩容"><a href="#2-2-2-2、扩容" class="headerlink" title="2.2.2.2、扩容"></a><strong>2.2.2.2、扩容</strong></h5><p>节点数组只有“扩容”，没有“收缩”，扩容条件为：<code>映射记录大小 &gt;= sizeCtl</code>。</p>
<p>扩容过程描述如下：</p>
<ul>
<li>2倍扩容。节点数组新大小是原来的2倍，成员变量<code>sizeCtl</code>新值也是原来的2倍（语义不变）</li>
<li>对原映射记录进行rehash操作：假设原节点数组大小为<code>n</code>，有一个“键”的二次哈希值为<code>hash</code>，则原散列到槽<code>(n -1) &amp; hash</code>，现散列到槽<code>(2*n - 1) &amp; hash</code>，这里可以有个计算优化，我们知道节点数组大小<code>n</code>是2的整数次幂，分析其比特位特点可知，对于以上运算，低n位比特位的<code>&amp;</code>运算结果不变，故只需要计算从低位往高位方向第n位的比特位<code>&amp;</code>结果，即<code>n &amp; hash</code></li>
</ul>
<p><font color='red'>需要注意的是，跟HashMap的设计单线程扩容不同，ConcurrentHashMap的扩容被设计为支持并发的，其过程描述如下</font>：</p>
<ol>
<li>线程A增加映射记录，使得进入扩容过程，节点数组根据特定策略划分为K个扩容区间，线程A默认根据扩容区间索引位置从高到低逐次完成所有扩容区间的扩容</li>
<li>后续有线程B，C，D，…，根据其操作类型分为两类：<ul>
<li>“增、删、改”映射记录，根据定位到槽S的状态分为两种情形：1）槽S已被标记为“扩容态（槽的第一个节点为ForwardingNode节点，其成员变量<code>hash</code>的值为<code>MOVED(-1)</code>）”，则并发抢占未完成扩容区间帮助扩容，只有加快完成扩容过程，槽S才能被正常操作；2）否则，正常操作成功，即“在扩容过程中，是可能正常操作成功的”</li>
<li>“查”映射记录，根据定位到槽S的状态分为两种情形：1）槽S已被标记为“扩容态（槽的第一个节点为ForwardingNode节点，其成员变量<code>hash</code>的值为<code>MOVED(-1)</code>）”，转发调用ForwardingNode节点的<code>Node&lt;K, V&gt; find(int h, Object k)</code>方法完成查找；2）否则，正常操作成功，即“在扩容过程中，是可能正常操作成功的”</li>
</ul>
</li>
<li>直到扩容完成：可能是线程A独自完成所有K个扩容区间的扩容，也可能是线程A与其他几个线程共同完成所有K个扩容区间的扩容</li>
</ol>
<h3 id="2-3、与JDK-1-6中ConcurrentHashMap实现作比较"><a href="#2-3、与JDK-1-6中ConcurrentHashMap实现作比较" class="headerlink" title="2.3、与JDK 1.6中ConcurrentHashMap实现作比较"></a><strong>2.3、与JDK 1.6中ConcurrentHashMap实现作比较</strong></h3><p>与JDK 1.6中ConcurrentHashMap实现相比，主要有以下几点改进：</p>
<ol>
<li>在JDK 1.8中，当碰撞冲突链过长时，会转化为红黑树，优化操作性能；而在JDK 1.6中，没有该优化</li>
<li>对于节点数组的初始化，JDK 1.8中是惰性的，JDK 1.6中是即时的</li>
<li>对于第二次哈希算法，JDK 1.8中的实现相较JDK 1.6较为简单，其后果就是“第三次哈希后散列到槽相较不均匀，碰撞冲突链的长度相较更长的概率增大”，但是由于JDK 1.8中引入了过长碰撞冲突链转换为红黑树的机制，使得上述问题得到了充分的补偿</li>
<li>对于线程安全的实现，JDK 1.6采取“分段+分段锁（ReentrantLock）”的方案，JDK 1.8采取“CAS自旋锁+synchronized锁”的方案，前者的并发粒度为分段数量（默认为16），后者的并发粒度可近似认为是节点数量（槽数量），后者的并发性能大大提升</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.yinxiang.com/everhub/note/b612e3b9-cb07-4c7a-85a2-4eeb897ee1d4">https://www.yinxiang.com/everhub/note/b612e3b9-cb07-4c7a-85a2-4eeb897ee1d4</a><br>[2]<a href="https://www.cnblogs.com/loading4/p/6239441.html">https://www.cnblogs.com/loading4/p/6239441.html</a><br>[3]<a href="https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in">https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in</a><br>[4]<a href="https://juejin.cn/post/6844903607901356046">https://juejin.cn/post/6844903607901356046</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo内支持“internal links”的语法</title>
    <url>/blog/2016/06/26/Hexo%E5%86%85%E6%94%AF%E6%8C%81%E2%80%9Cinternal-links%E2%80%9D%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a><strong>一、问题背景</strong></h2><p>站点内文章引用相同站点内其他资源时如果采用站点域名地址形式的话，下次迁移站点域名时，会造成很大成本。<br>为了应对以上情形，有两种思路：</p>
<ol>
<li>购买一个域名，长期持有，使得不必要迁移域名</li>
<li>引用相同站点内其他资源时采用站点内地址形式</li>
</ol>
<p>接下来讨论第二种思路的实现。</p>
<h2 id="二、引用相同站点内其他资源时采用站点内地址形式"><a href="#二、引用相同站点内其他资源时采用站点内地址形式" class="headerlink" title="二、引用相同站点内其他资源时采用站点内地址形式"></a><strong>二、引用相同站点内其他资源时采用站点内地址形式</strong></h2><p>使用Markdown语言语法引用站点内其他资源有两种形式：1）站点域名地址；2）站点内地址。<br>不过，经过Hexo转换引擎转换后，最终得到的站点内资源会被置于一定层次结构目录下，该种情形下使用Markdown语言语法的“站点内地址”形式，会比较繁琐。<br>经过Hexo转换引擎转换后，最终站点内资源的存放路径例子如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016/06/25/使用Github Pages搭建个人博客/index.html</span><br></pre></td></tr></table></figure>

<p>因此，使用Hexo转换引擎原生支持的“Hexo自带语法”才是最完美的解决方案，幸运的是，自3.0版本开始，Hexo提供满足上述要求的语法。具体语法定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_path hello-world %&#125;</span><br><span class="line">// /2015/01/16/hello-world/</span><br><span class="line">&#123;% post_link hello-world %&#125;</span><br><span class="line">// &lt;a href=&quot;/2015/01/16/hello-world/&quot;&gt;Hello World&lt;/a&gt;</span><br><span class="line">&#123;% post_link hello-world Custom Title %&#125;</span><br><span class="line">// &lt;a href=&quot;/2015/01/16/hello-world/&quot;&gt;Custom Title&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&#123;% asset_path example.jpg %&#125;</span><br><span class="line">// /2015/01/16/hello-world/example.jpg</span><br><span class="line">&#123;% asset_link example.jpg %&#125;</span><br><span class="line">// &lt;a href=&quot;/2015/01/16/hello-world/example.jpg&quot;&gt;example.jpg&lt;/a&gt;</span><br><span class="line">&#123;% asset_link example.jpg Example %&#125;</span><br><span class="line">// &lt;a href=&quot;/2015/01/16/hello-world/example.jpg&quot;&gt;Example&lt;/a&gt;</span><br><span class="line">&#123;% asset_img example.jpg %&#125;</span><br><span class="line">// &lt;img src=&quot;/2015/01/16/hello-world/example.jpg&quot;&gt;</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://github.com/hexojs/hexo/wiki/Breaking-Changes-in-Hexo-3.0
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>语法</tag>
        <tag>Internal Links</tag>
      </tags>
  </entry>
  <entry>
    <title>IPsec协议套装之AH和ESP协议</title>
    <url>/blog/2024/05/19/IPsec%E5%8D%8F%E8%AE%AE%E5%A5%97%E8%A3%85%E4%B9%8BAH%E5%92%8CESP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<style>
td 
{
text-align: center
}
</style>

<p>IPsec是个协议套装，其内协议工作在网络层，这些协议主要用来为IP协议提供加密和认证服务。<br>本文介绍IPsec协议套装内常见的AH和ESP协议。</p>
<br/>

<p>首先作一点说明，本文后续出现的<code>&#123;0,1&#125;</code>表示“出现0次或者1次”。</p>
<h2 id="一、AH协议"><a href="#一、AH协议" class="headerlink" title="一、AH协议"></a><strong>一、AH协议</strong></h2><p>AH（Authentication Header）协议：扩展IP协议报文提供无连接数据完整性、消息认证以及防重放攻击保护能力。<br>讨论AH协议须涉及4种情况：1）工作场景——“IPv4报文 VS IPv6报文”；2）工作模式——“隧道模式 VS 传输模式”。</p>
<p>AH报文整体格式为：</p>
<pre>
+-------------+---------------+---+
|  AH Header  |  AH Payload Data  |
+-------------+---------------+---+
</pre>

<hr>
<p>接下来介绍AH协议报文详细格式。</p>
<table style="text-align: center">
  <caption style="background:#781549; color:white;">
    <i>AH Packet Format</i></caption>
  <tbody>
    <tr>
      <th>
        <i>Offsets</i>
      </th>
      <th>Octet</th>
      <th colspan="8">0</th>
      <th colspan="8">1</th>
      <th colspan="8">2</th>
      <th colspan="8">3</th></tr>
    <tr>
      <th>Octet</th>
      <th>Bit</th>
      <th style="width:2.6%;">0</th>
      <th style="width:2.6%;">1</th>
      <th style="width:2.6%;">2</th>
      <th style="width:2.6%;">3</th>
      <th style="width:2.6%;">4</th>
      <th style="width:2.6%;">5</th>
      <th style="width:2.6%;">6</th>
      <th style="width:2.6%;">7</th>
      <th style="width:2.6%;">8</th>
      <th style="width:2.6%;">9</th>
      <th style="width:2.6%;">10</th>
      <th style="width:2.6%;">11</th>
      <th style="width:2.6%;">12</th>
      <th style="width:2.6%;">13</th>
      <th style="width:2.6%;">14</th>
      <th style="width:2.6%;">15</th>
      <th style="width:2.6%;">16</th>
      <th style="width:2.6%;">17</th>
      <th style="width:2.6%;">18</th>
      <th style="width:2.6%;">19</th>
      <th style="width:2.6%;">20</th>
      <th style="width:2.6%;">21</th>
      <th style="width:2.6%;">22</th>
      <th style="width:2.6%;">23</th>
      <th style="width:2.6%;">24</th>
      <th style="width:2.6%;">25</th>
      <th style="width:2.6%;">26</th>
      <th style="width:2.6%;">27</th>
      <th style="width:2.6%;">28</th>
      <th style="width:2.6%;">29</th>
      <th style="width:2.6%;">30</th>
      <th style="width:2.6%;">31</th></tr>
    <tr>
      <th>0</th>
      <th>0</th>
      <td colspan="8">
        <i>Next Header (8 bits)</i>
      </td>
      <td colspan="8">
        <i>Payload Length (8 bits)</i>
      </td>
      <td colspan="16">
        <i>Reserved (16 bits)</i>
      </td>
    </tr>
    <tr>
      <th>4</th>
      <th>32</th>
      <td colspan="32">
        <i>Security Parameters Index (SPI, 32 bits)</i>
      </td>
    </tr>
    <tr>
      <th>8</th>
      <th>64</th>
      <td colspan="32">
        <i>Sequence Number (32 bits)</i>
      </td>
    </tr>
    <tr>
      <th>12</th>
      <th>96</th>
      <td colspan="32" rowspan="2">
        <i>Integrity Check Value (ICV, variable bits)</i>
        <br>...</td></tr>
    <tr>
      <th>...</th>
      <th>...</th>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td colspan="32" rowspan="3">
        <i>Payload Data (variable bits)</i>
       </td>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
    </tr>
  </tbody>
</table>

<p>AH报文格式说明如下：</p>
<ul>
<li>Next Header：下一个首部的类型值，指明载荷数据中数据协议类型</li>
<li>Payload Length：名字太有歧义，实际是首部长度。首部长度&#x3D;<code>(Payload Length + 2) * 4</code></li>
<li>Reserved：保留值，当前为全0</li>
<li>Security Parameters Index（SPI）：安全参数索引用于定位<code>具体的SA（Security Association，指定了可被通信双方识别的安全属性集合）</code></li>
<li>Sequence Number：序列号</li>
<li>Integrity Check Value（ICV）：完整性验证值。另有：1）<font color='red'>其具体长度不由具体的SA指出</font>；2）可能存在填充数据使AH首部长度满足字节对齐条件（具体见扩展说明）</li>
<li>Payload Data：<font color='red'>AH报文的载荷数据</font></li>
</ul>
<p>扩展说明：</p>
<ol>
<li>当在IPv4报文工作场景中时，整个首部长度须是4字节倍数，不满足则在ICV中填充；当在IPv6报文工作场景中时，整个首部长度须是8字节倍数，不满足则在ICV中填充</li>
<li>示例可见<a href="https://github.com/dslztx/pcap-demo/blob/master/wireshark-capture-ipsec-ah-esp-transport.pcapng">Pcap文件</a></li>
</ol>
<h3 id="1-1、IPv4报文"><a href="#1-1、IPv4报文" class="headerlink" title="1.1、IPv4报文"></a><strong>1.1、IPv4报文</strong></h3><p>在IPv4报文中AH报文首部作为一般协议首部。</p>
<h4 id="1-1-1、传输模式"><a href="#1-1-1、传输模式" class="headerlink" title="1.1.1、传输模式"></a><strong>1.1.1、传输模式</strong></h4><p>在传输模式中，对原IPv4报文的载荷数据进行AH运算，然后添加一个AH首部。</p>
<pre>
+---------------+-+-+---------+-+-+---------------+
|               |             |                   |
|  IPv4 Header  |  AH Header  |  AH Payload Data  |
|               |             |                   |
+---------------+-+-+---------+-+-++------------+-+
                |                                 |
                <--------New IPv4 Payload Data---->
</pre>
<p><code>AH Payload Data</code>：对原IPv4报文载荷数据进行AH运算获得。</p>
<h4 id="1-1-2、隧道模式"><a href="#1-1-2、隧道模式" class="headerlink" title="1.1.2、隧道模式"></a><strong>1.1.2、隧道模式</strong></h4><p>在隧道模式中，对原IPv4报文整体进行AH运算，然后添加一个新IPv4首部和一个AH首部。</p>
<pre>
+-----------------+-+-----------+-+-+-------------+---+
|                   |             |                   |
|  New IPv4 Header  |  AH Header  |  AH Payload Data  |
|                   |             |                   |
+-----------------+-+-----------+-+-+-----------+-+---+
                    |                                 |
                    <-------New IPv4 Payload Data----->
</pre>
<p><code>AH Payload Data</code>：对原IPv4报文整体进行AH运算获得。</p>
<h3 id="1-2、IPv6报文"><a href="#1-2、IPv6报文" class="headerlink" title="1.2、IPv6报文"></a><strong>1.2、IPv6报文</strong></h3><p>在IPv6报文中AH报文首部作为扩展首部[4]。</p>
<h4 id="1-2-1、传输模式"><a href="#1-2-1、传输模式" class="headerlink" title="1.2.1、传输模式"></a><strong>1.2.1、传输模式</strong></h4><p>在传输模式中，对<code>原IPv6报文的载荷数据（不存在扩展首部情形）</code>&#x2F;<code>原IPv6报文中最内层扩展首部对应的载荷数据（存在扩展首部情形）</code>进行AH运算，然后添加一个AH首部。</p>
<pre>             
+---------------+--+--------------------------------+----------------+--+
|               |                                   |                   | 
|               |  Hop-by-Hop Options Header{0,1}   |                   |
|               |  Destination Options Header{0,1}  |                   |
|               |  Routing Header{0,1}              |                   |
|               |  Fragment Header{0,1}             |                   |
|  IPv6 Header  |  AH Header                        |  AH Payload Data  |
|               |                                   |                   |
+---------------+--+--------------------------------+----------------+--+
                |                                                       |
                <----------------New IPv6 Payload Data------------------>
</pre>

<p><code>AH Payload Data</code>：在不存在扩展首部情形下，对原IPv6报文的载荷数据进行AH运算获得；在存在扩展首部情形下，对原IPv6报文中最内层扩展首部对应的载荷数据进行AH运算获得，比如“最内存扩展首部是Fragment Header，那么对Fragment Header对应的载荷数据进行AH运算获得AH Payload Data”。</p>
<h4 id="1-2-2、隧道模式"><a href="#1-2-2、隧道模式" class="headerlink" title="1.2.2、隧道模式"></a><strong>1.2.2、隧道模式</strong></h4><p>在隧道模式中，对原IPv6报文整体进行AH运算，然后添加一个新IPv6首部和一个AH首部。</p>
<pre>
+-----------------+-+-----------+-+---------------+---+
|                   |             |                   |
|  New IPv6 Header  |  AH Header  |  AH Payload Data  |
|                   |             |                   |
+-----------------+-+-----------+-+---+---------+-+--++
                    |                                 |
                    <-------New IPv6 Payload Data-----> 
</pre>
<p><code>AH Payload Data</code>：对原IPv6报文整体进行AH运算获得。</p>
<br/>

<p><em>另外须注意</em>：我们知道在IPv6报文中扩展首部具有数量和顺序限制，在以上情形中——1）AH Payload Data内嵌IPv6报文扩展首部遵循该限制；2）“AH Header”和“AH Payload Data内嵌IPv6报文扩展首部”两者互相独立，无需遵循该限制。</p>
<h2 id="二、ESP协议"><a href="#二、ESP协议" class="headerlink" title="二、ESP协议"></a><strong>二、ESP协议</strong></h2><p>ESP（Encapsulating Security Payload）协议：为IP协议报文提供源可靠性、完整性和保密性支持。<br>讨论ESP协议须涉及4种情况：1）工作场景——“IPv4报文 VS IPv6报文”；2）工作模式——“隧道模式 VS 传输模式”。</p>
<p>ESP报文整体格式为：</p>
<pre>
+-------------++--------------+---+-+---------------+-----------+
|  ESP Header  |  ESP Payload Data  |  ESP Trailer  |  ESP ICV  |
+-------------++--------------+---+-+---------------+-----------+
</pre>

<p>后续为了叙述简单，可简化为：</p>
<pre>
+-------------++--------------+---+-+
|  ESP Header  |  ESP Payload Data  |
+-------------++--------------+---+-+
</pre>

<hr>
<p>接下来介绍ESP协议报文详细格式。</p>
<table style="text-align: center">
  <caption style="background:#781549; color:white;">
    <i>ESP Packet Format</i></caption>
  <tbody>
    <tr>
      <th>
        <i>Offsets</i>
      </th>
      <th>Octet</th>
      <th colspan="8">0</th>
      <th colspan="8">1</th>
      <th colspan="8">2</th>
      <th colspan="8">3</th></tr>
    <tr>
      <th>Octet</th>
      <th>Bit</th>
      <th style="width:2.6%;">0</th>
      <th style="width:2.6%;">1</th>
      <th style="width:2.6%;">2</th>
      <th style="width:2.6%;">3</th>
      <th style="width:2.6%;">4</th>
      <th style="width:2.6%;">5</th>
      <th style="width:2.6%;">6</th>
      <th style="width:2.6%;">7</th>
      <th style="width:2.6%;">8</th>
      <th style="width:2.6%;">9</th>
      <th style="width:2.6%;">10</th>
      <th style="width:2.6%;">11</th>
      <th style="width:2.6%;">12</th>
      <th style="width:2.6%;">13</th>
      <th style="width:2.6%;">14</th>
      <th style="width:2.6%;">15</th>
      <th style="width:2.6%;">16</th>
      <th style="width:2.6%;">17</th>
      <th style="width:2.6%;">18</th>
      <th style="width:2.6%;">19</th>
      <th style="width:2.6%;">20</th>
      <th style="width:2.6%;">21</th>
      <th style="width:2.6%;">22</th>
      <th style="width:2.6%;">23</th>
      <th style="width:2.6%;">24</th>
      <th style="width:2.6%;">25</th>
      <th style="width:2.6%;">26</th>
      <th style="width:2.6%;">27</th>
      <th style="width:2.6%;">28</th>
      <th style="width:2.6%;">29</th>
      <th style="width:2.6%;">30</th>
      <th style="width:2.6%;">31</th></tr>
    <tr>
      <th>0</th>
      <th>0</th>
      <td colspan="32">
        <i>Security Parameters Index (SPI, 32 bits)</i>
      </td>
    </tr>
    <tr>
      <th>4</th>
      <th>32</th>
      <td colspan="32">
        <i>Sequence Number (32 bits)</i>
      </td>
    </tr>
    <tr>
      <th>8</th>
      <th>64</th>
      <td colspan="32" rowspan="2">
        <i>Payload Data (variable bits)</i>
      </td>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th></tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td colspan="8" style="border-top-style: hidden;">&nbsp;</td>
      <td colspan="24" style="border-bottom-style: hidden;">&nbsp;</td></tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td colspan="8" style="border-right-style: hidden;">&nbsp;</td>
      <td colspan="16">
        <i>Padding (0-255 bytes)</i>
      </td>
      <td colspan="8" style="border-left-style: hidden;">&nbsp;</td></tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td colspan="16" style="border-top-style: hidden;">&nbsp;</td>
      <td colspan="8">
        <i>Pad Length (8 bits)</i>
      </td>
      <td colspan="8">
        <i>Next Header (8 bits)</i>
      </td>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td colspan="32" rowspan="2">
        <i>Integrity Check Value (ICV, multiple of 32 bits)</i>
        <br>...</td></tr>
    <tr>
      <th>...</th>
      <th>...</th></tr>
  </tbody>
</table>


<p>ESP报文格式说明如下：</p>
<ul>
<li>Security Parameters Index（SPI）：安全参数索引用于定位<code>具体的SA（Security Association，指定了可被通信双方识别的安全属性集合）</code></li>
<li>Sequence Number：序列号</li>
<li>Payload Data：<font color='red'>ESP报文的载荷数据</font></li>
<li>Padding：填充数据</li>
<li>Pad Length：填充长度</li>
<li>Next Header：下一个首部的类型值，指明载荷数据中数据协议类型</li>
<li>Reserved：保留值，当前为全0</li>
<li>Integrity Check Value（ICV）：完整性验证值。跟AH首部中的<code>Integrity Check Value</code>不一样：1）<font color='red'>其具体长度须由具体的SA指出</font>；2）不处于ESP首部中，故无需存在填充数据使ESP首部长度满足字节对齐条件（具体见扩展说明）</li>
</ul>
<p>扩展说明：</p>
<ol>
<li>ESP首部的长度为8字节，自然满足“当在IPv4报文工作场景中时，整个首部长度须是4字节倍数；当在IPv6报文工作场景中时，整个首部长度须是8字节倍数”</li>
<li>示例可见<a href="https://github.com/dslztx/pcap-demo/blob/master/wireshark-capture-ipsec-ah-esp-transport.pcapng">Pcap文件</a>。<font color='red'>ESP ICV区域长度由具体的SA指出，这是可解析出ESP报文的关键信息。</font>以上例子中ESP报文不能被完整解析就是因为我们本地缺失通信双方当初协商确定的具体SA信息</li>
</ol>
<h3 id="2-1、IPv4报文"><a href="#2-1、IPv4报文" class="headerlink" title="2.1、IPv4报文"></a><strong>2.1、IPv4报文</strong></h3><p>在IPv4报文中ESP报文首部作为一般协议首部。</p>
<h4 id="2-1-1、传输模式"><a href="#2-1-1、传输模式" class="headerlink" title="2.1.1、传输模式"></a><strong>2.1.1、传输模式</strong></h4><p>在传输模式中，对原IPv4报文的载荷数据进行ESP运算，然后添加一个ESP首部。</p>
<pre>
+---------------+-+-+----------++-+---------------+-+
|               |              |                    |
|  IPv4 Header  |  ESP Header  |  ESP Payload Data  |
|               |              |                    |
+---------------+-+-+----------++-++------------+-+-+
                |                                   |
                <-------New IPv4 Payload Data------->
</pre>

<p><code>ESP Payload Data</code>：对原IPv4报文载荷数据进行ESP运算获得。</p>
<h4 id="2-1-2、隧道模式"><a href="#2-1-2、隧道模式" class="headerlink" title="2.1.2、隧道模式"></a><strong>2.1.2、隧道模式</strong></h4><p>在隧道模式中，对原IPv4报文整体进行ESP运算，然后添加一个新IPv4首部和一个ESP首部。</p>
<pre>
+-----------------+-+-----------+-+++-------------+---+-+
|                   |              |                    |
|  New IPv4 Header  |  ESP Header  |  ESP Payload Data  |
|                   |              |                    |
+-----------------+-+-----------+-+++-----------+-+---+-+
                    |                                   +
                    <--------New IPv4 Payload Data------>
</pre>

<p><code>ESP Payload Data</code>：对原IPv4报文整体进行ESP运算获得。</p>
<h3 id="2-2、IPv6报文"><a href="#2-2、IPv6报文" class="headerlink" title="2.2、IPv6报文"></a><strong>2.2、IPv6报文</strong></h3><p>在IPv6报文中ESP报文首部作为扩展首部[4]。</p>
<h4 id="2-2-1、传输模式"><a href="#2-2-1、传输模式" class="headerlink" title="2.2.1、传输模式"></a><strong>2.2.1、传输模式</strong></h4><p>在传输模式中，对<code>原IPv6报文的载荷数据（不存在扩展首部情形）/原IPv6报文中最内层扩展首部对应的载荷数据（存在扩展首部情形）</code>进行ESP运算，然后添加一个ESP首部。</p>
<pre>
+---------------+-----------------------------------+-------------+---+--+
|               |                                   |                    | 
|               |  Hop-by-Hop Options Header{0,1}   |                    | 
|               |  Destination Options Header{0,1}  |                    | 
|               |  Routing Header{0,1}              |                    |  
|               |  Fragment Header{0,1}             |                    |  
|  IPv6 Header  |  ESP Header                       |  ESP Payload Data  |
|               |                                   |                    |  
+---------------+-----------------------------------+--------------+---+-+
                |                                                        | 
                <------------------New IPv6 Payload Data-----------------> 
</pre>

<p><code>ESP Payload Data</code>：在不存在扩展首部情形下，对原IPv6报文的载荷数据进行ESP运算获得；在存在扩展首部情形下，对原IPv6报文中最内层扩展首部对应的载荷数据进行ESP运算获得，比如“最内存扩展首部是Fragment Header，那么对Fragment Header对应的载荷数据进行ESP运算获得ESP Payload Data”。</p>
<h4 id="2-2-2、隧道模式"><a href="#2-2-2、隧道模式" class="headerlink" title="2.2.2、隧道模式"></a><strong>2.2.2、隧道模式</strong></h4><p>在隧道模式中，对原IPv6报文整体进行ESP运算，然后添加一个新IPv6首部和一个ESP首部。</p>
<pre>
+-----------------+-+-----------+-++--------------+---+-+
|                   |              |                    |
|  New IPv6 Header  |  ESP Header  |  ESP Payload Data  |
|                   |              |                    |
+-----------------+-+-----------+-++--+---------+-+---+-+
                    |                                   |
                    <--------New IPv6 Payload Data------>
</pre>

<p><code>ESP Payload Data</code>：对原IPv6报文整体进行ESP运算获得。</p>
<br/>

<p><em>另外须注意</em>：我们知道在IPv6报文中扩展首部具有数量和顺序限制，在以上情形中——1）ESP Payload Data内嵌IPv6报文扩展首部遵循该限制；2）“ESP Header”和“ESP Payload Data内嵌IPv6报文扩展首部”两者互相独立，无需遵循该限制。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/IPsec">https://en.wikipedia.org/wiki/IPsec</a><br>[2]<a href="https://datatracker.ietf.org/doc/html/rfc4302">https://datatracker.ietf.org/doc/html/rfc4302</a><br>[3]<a href="https://datatracker.ietf.org/doc/html/rfc4303">https://datatracker.ietf.org/doc/html/rfc4303</a><br>[4]<a href="/blog/2024/03/16/IPv6%E6%8A%A5%E6%96%87/" title="IPv6报文">《IPv6报文》</a><br>[5]<a href="https://www.twingate.com/blog/ipsec-tunnel-mode">https://www.twingate.com/blog/ipsec-tunnel-mode</a><br>[6]<a href="https://www.redhat.com/sysadmin/ipv6-packets-and-ipsec">https://www.redhat.com/sysadmin/ipv6-packets-and-ipsec</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>IPv4报文</title>
    <url>/blog/2024/03/13/IPv4%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<style>
td 
{
text-align: center
}
</style>

<p>IPv4报文是一种可变长报文，由“首部”和“载荷数据”两部分组成：</p>
<ol>
<li>首部：从<code>Version</code>字段到<code>Padding</code>字段为止，长度范围为<code>[20字节,60字节]</code>，且要求长度须为4字节倍数</li>
<li>载荷数据：IPv4报文载荷数据，长度范围为<code>[0字节,65535字节-首部至少20字节=65515字节]</code></li>
</ol>
<p>整个IPv4报文长度范围为<code>[20字节,65535字节]</code>。</p>
<p>IPv4报文示意如下。</p>
<pre>
+--------------+--------------------+
|              |                    |
|    Header    |    Payload Data    |
|              |                    |
+--------------+--------------------+
</pre>

<h2 id="一、首部"><a href="#一、首部" class="headerlink" title="一、首部"></a><strong>一、首部</strong></h2><p>首部逻辑上可分为两部分：</p>
<ul>
<li>固定首部：从<code>Version</code>字段到<code>Destination Address</code>字段为止，长度为定长<code>20字节</code></li>
<li>可选首部 + 填充数据：在<code>Destination Address</code>字段和<code>Payload Data</code>之间，长度范围为<code>[0字节,40字节]</code>，且要求长度须为4字节倍数（只有如此，“首部长度须为4字节倍数”的要求才能得到满足）</li>
</ul>
<p>IPv4报文首部示意图如下。</p>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>IPv4 Packet Header Format</i></caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%">0</th>
         <th style="width:2.6%">1</th>
         <th style="width:2.6%">2</th>
         <th style="width:2.6%">3</th>
         <th style="width:2.6%">4</th>
         <th style="width:2.6%">5</th>
         <th style="width:2.6%">6</th>
         <th style="width:2.6%">7</th>
         <th style="width:2.6%">8</th>
         <th style="width:2.6%">9</th>
         <th style="width:2.6%">10</th>
         <th style="width:2.6%">11</th>
         <th style="width:2.6%">12</th>
         <th style="width:2.6%">13</th>
         <th style="width:2.6%">14</th>
         <th style="width:2.6%">15</th>
         <th style="width:2.6%">16</th>
         <th style="width:2.6%">17</th>
         <th style="width:2.6%">18</th>
         <th style="width:2.6%">19</th>
         <th style="width:2.6%">20</th>
         <th style="width:2.6%">21</th>
         <th style="width:2.6%">22</th>
         <th style="width:2.6%">23</th>
         <th style="width:2.6%">24</th>
         <th style="width:2.6%">25</th>
         <th style="width:2.6%">26</th>
         <th style="width:2.6%">27</th>
         <th style="width:2.6%">28</th>
         <th style="width:2.6%">29</th>
         <th style="width:2.6%">30</th>
         <th style="width:2.6%">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="4">Version (4 bits)</td>
         <td colspan="4"><font color='red'>Internet Header Length (IHL, 4 bits)</font></td>
         <td colspan="6">Differentiated Services Codepoint (DSCP, 6 bits)</td>
         <td colspan="2">Explicit Congestion Notification (ECN, 2 bits)</td>
         <td colspan="16"><font color='red'>Total Length (16 bits)</font></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="16">Identification (16 bits)</td>
         <td colspan="3">Flags (3 bits)</td>
         <td colspan="13">Fragment Offset (13 bits)</td>
      </tr>
      <tr>
         <th>8</th>
         <th>64</th>
         <td colspan="8">Time to Live (8 bits)</td>
         <td colspan="8"><font color='red'>Protocol (8 bits)</font></td>
         <td colspan="16">Header Checksum (16 bits)</td>
      </tr>
      <tr>
         <th>12</th>
         <th>96</th>
         <td colspan="32"><font color='red'>Source Address (32 bits)</font></td>
      </tr>
      <tr>
         <th>16</th>
         <th>128</th>
         <td colspan="32"><font color='red'>Destination Address (32 bits)</font></td>
      </tr>
      <tr>
         <th>20</th>
         <th>160</th>
         <td colspan="32" rowspan="3">Options + Padding (variable bits) (if IHL &gt; 5)</td>
      </tr>
      <tr>
         <th>⋮ </th>
         <th>⋮ </th>
      </tr>
      <tr>
         <th>56</th>
         <th>448</th>
      </tr>
   </tbody>
</table>

<h3 id="1-1、Version"><a href="#1-1、Version" class="headerlink" title="1.1、Version"></a><strong>1.1、Version</strong></h3><p>中文名：<code>版本</code>。</p>
<p>长度：4 bits。</p>
<p>含义：指明IP协议版本号，IPv4版本的话其值为<code>0100</code>。</p>
<h3 id="1-2、Internet-Header-Length-IHL"><a href="#1-2、Internet-Header-Length-IHL" class="headerlink" title="1.2、Internet Header Length (IHL)"></a><strong>1.2、Internet Header Length (IHL)</strong></h3><p>中文名：<code>首部长度</code>。</p>
<p>长度：4 bits。</p>
<p>含义：指明本IPv4报文首部长度，以4字节为单位，故首部长度必为4字节倍数，其值范围为<code>[0101,1111]</code>，对应的首部长度范围为<code>[20字节,60字节]</code>。最常用的就是20字节，即：只有固定首部，没有可选首部和填充数据。</p>
<h3 id="1-3、Differentiated-Services-Codepoint-DSCP-3"><a href="#1-3、Differentiated-Services-Codepoint-DSCP-3" class="headerlink" title="1.3、Differentiated Services Codepoint (DSCP)[3]"></a><strong>1.3、Differentiated Services Codepoint (DSCP)[3]</strong></h3><p>中文名：<code>区分服务代码点</code>。</p>
<p>长度：6 bits。</p>
<p>含义：</p>
<ol>
<li>用来标识该IPv4报文的服务类型，在支持该字段的网络设备（一般是“路由器”）的配合下，可提供不同服务质量等级（Quality of Service，QoS）的IP服务</li>
<li>网络设备是否支持该字段、对该字段的支持程度、对该字段支持的具体落地方案等由生产厂商自决定</li>
<li>对于<code>恶意攻击流量恶意设置DSCP值，以期达成“攻击流量在网络中的优先级高于正常流量”目标</code>，是否可行以及可行情形如何应对，笔者不甚清晰[7]</li>
</ol>
<h4 id="1-3-1、支持DSCP字段的路由器的应对行为分类"><a href="#1-3-1、支持DSCP字段的路由器的应对行为分类" class="headerlink" title="1.3.1、支持DSCP字段的路由器的应对行为分类"></a><strong>1.3.1、支持DSCP字段的路由器的应对行为分类</strong></h4><p>支持DSCP字段的路由器的应对行为分为4类：</p>
<ol>
<li>Expedited Forwarding PHB (EF PHB)：迅速转发PHB</li>
<li>Assured Forwarding PHB (AF PHB)：确保转发PHB</li>
<li>Default Forwarding PHB (DF PHB)：默认转发PHB</li>
<li>Class Selector PHBs：该分类主要是为了兼容TOS</li>
</ol>
<h4 id="1-3-2、Service-Class"><a href="#1-3-2、Service-Class" class="headerlink" title="1.3.2、Service Class"></a><strong>1.3.2、Service Class</strong></h4><p>见<code>RFC 4594</code>。</p>
<h4 id="1-3-3、DSCP说明"><a href="#1-3-3、DSCP说明" class="headerlink" title="1.3.3、DSCP说明"></a><strong>1.3.3、DSCP说明</strong></h4><table>
<thead>
<tr>
<th>DSCP二进制</th>
<th>DSCP十进制</th>
<th>PHB</th>
<th>细分</th>
<th>Service Class</th>
</tr>
</thead>
<tbody><tr>
<td>001,010</td>
<td>10</td>
<td>AF</td>
<td>AF1 + 低丢弃优先级</td>
<td>High-Throughput Data</td>
</tr>
<tr>
<td>001,100</td>
<td>12</td>
<td>AF</td>
<td>AF1 + 中丢弃优先级</td>
<td>High-Throughput Data</td>
</tr>
<tr>
<td>001,110</td>
<td>14</td>
<td>AF</td>
<td>AF1 + 高丢弃优先级</td>
<td>High-Throughput Data</td>
</tr>
<tr>
<td>010,010</td>
<td>18</td>
<td>AF</td>
<td>AF2 + 低丢弃优先级</td>
<td>Low-Latency Data</td>
</tr>
<tr>
<td>010,100</td>
<td>20</td>
<td>AF</td>
<td>AF2 + 中丢弃优先级</td>
<td>Low-Latency Data</td>
</tr>
<tr>
<td>010,110</td>
<td>22</td>
<td>AF</td>
<td>AF2 + 高丢弃优先级</td>
<td>Low-Latency Data</td>
</tr>
<tr>
<td>011,010</td>
<td>26</td>
<td>AF</td>
<td>AF3 + 低丢弃优先级</td>
<td>Multimedia Streaming</td>
</tr>
<tr>
<td>011,100</td>
<td>28</td>
<td>AF</td>
<td>AF3 + 中丢弃优先级</td>
<td>Multimedia Streaming</td>
</tr>
<tr>
<td>011,110</td>
<td>30</td>
<td>AF</td>
<td>AF3 + 高丢弃优先级</td>
<td>Multimedia Streaming</td>
</tr>
<tr>
<td>100,010</td>
<td>34</td>
<td>AF</td>
<td>AF4 + 低丢弃优先级</td>
<td>Multimedia Conferencing</td>
</tr>
<tr>
<td>100,100</td>
<td>36</td>
<td>AF</td>
<td>AF4 + 中丢弃优先级</td>
<td>Multimedia Conferencing</td>
</tr>
<tr>
<td>100,110</td>
<td>38</td>
<td>AF</td>
<td>AF4 + 高丢弃优先级</td>
<td>Multimedia Conferencing</td>
</tr>
<tr>
<td>101,110</td>
<td>46</td>
<td>EF</td>
<td>&#x2F;</td>
<td>Telephony</td>
</tr>
<tr>
<td>001,000</td>
<td>8</td>
<td>Class Selector</td>
<td>CS1</td>
<td>Low-Priority Data</td>
</tr>
<tr>
<td>010,000</td>
<td>16</td>
<td>Class Selector</td>
<td>CS2</td>
<td>OAM</td>
</tr>
<tr>
<td>011,000</td>
<td>24</td>
<td>Class Selector</td>
<td>CS3</td>
<td>Broadcast Video</td>
</tr>
<tr>
<td>100,000</td>
<td>32</td>
<td>Class Selector</td>
<td>CS4</td>
<td>Real-Time Interactive</td>
</tr>
<tr>
<td>101,000</td>
<td>40</td>
<td>Class Selector</td>
<td>CS5</td>
<td>Signaling</td>
</tr>
<tr>
<td>110,000</td>
<td>48</td>
<td>Class Selector</td>
<td>CS6</td>
<td>Network Control</td>
</tr>
<tr>
<td>111,000</td>
<td>56</td>
<td>Class Selector</td>
<td>CS7</td>
<td><font color='red'>Reserved for future use</font></td>
</tr>
<tr>
<td>000,000</td>
<td>0</td>
<td>DF</td>
<td>&#x2F;</td>
<td>Standard</td>
</tr>
</tbody></table>
<p>扩展说明：其他DSCP值默认对应<code>DB PHB</code>和<code>Standard Service Class</code>。</p>
<h3 id="1-4、Explicit-Congestion-Notification-ECN-4"><a href="#1-4、Explicit-Congestion-Notification-ECN-4" class="headerlink" title="1.4、Explicit Congestion Notification (ECN)[4]"></a><strong>1.4、Explicit Congestion Notification (ECN)[4]</strong></h3><p>中文名：<code>显式拥塞通知</code>。</p>
<p>长度：2 bits。</p>
<p>含义：网络层提供的显式拥塞控制标记，设计用来完善整个拥塞控制机制：</p>
<ol>
<li>之前的拥塞控制机制——“传输层通过丢包感知到拥塞，进行拥塞控制”，其是隐式的，被动的，实际可根据路由器内排队情况提前预测是否拥塞，进行拥塞显式标记，以期提前介入，避免丢包，更快缓解拥塞，一般路由器只工作在网络层，故上述拥塞显式标记只能在网络层协议报文实现，此即ECN产生的背景</li>
<li>引入ECN后，传输层除了通过丢包感知拥塞之外，也可根据ECN感知拥塞</li>
</ol>
<p>ECN值含义如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>ECN值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>不支持ECN的传输，非ECT (Non ECN-Capable Transport)</td>
</tr>
<tr>
<td>10</td>
<td>支持ECN的传输，ECT (0)</td>
</tr>
<tr>
<td>01</td>
<td>支持ECN的传输，ECT (1)</td>
</tr>
<tr>
<td>11</td>
<td>发生拥塞，CE (Congestion Experienced)</td>
</tr>
</tbody></table>
<h3 id="1-5、Total-Length"><a href="#1-5、Total-Length" class="headerlink" title="1.5、Total Length"></a><strong>1.5、Total Length</strong></h3><p>中文名：<code>总长度</code>。</p>
<p>长度：16 bits。</p>
<p>含义：整个IPv4报文的长度（单位是“字节”，最大值为<code>2^16-1=65535</code>，即整个IPv4报文最大为65535个字节），包括“首部”和“载荷数据”。</p>
<h3 id="1-6、Identification、Flags和Fragment-Offset"><a href="#1-6、Identification、Flags和Fragment-Offset" class="headerlink" title="1.6、Identification、Flags和Fragment Offset"></a><strong>1.6、Identification、Flags和Fragment Offset</strong></h3><p>首先介绍IPv4报文分片概念：</p>
<ol>
<li>数据链路层协议都规定了一个该层协议报文能接收的上层协议递交数据的最大长度，该最大长度被称为最大传送单元MTU（Maximum Transfer Unit），比如以太网协议的MTU值为<code>1500个字节</code>。当IPv4报文总长度超过所使用数据链路层协议的MTU后，需要将该IPv4报文分割成几个，使得每个分割后IPv4报文总长度不超过MTU，该过程即为分片，在IPv4报文接收端会将属于同一个IPv4报文的分片报文重新组装成原IPv4报文</li>
<li>具体分片过程：<ul>
<li>首部。复制原报文的首部，在复制过程中，部分字段保持不变，部分字段有所变化：1）保持不变字段——版本，首部长度，区分服务代码点，显式拥塞通知，标识，生存时间，协议，源地址，目的地址，<font color='red'>可选首部，填充数据</font>；2）有所变化：总长度，标志，片偏移，首部检验和</li>
<li>载荷数据。分片载荷数据的长度具体协议实现软件具体决定，只须满足两个限制条件：1）分片后分片总长度不超过MTU；2）假如分成N个分片，则前N-1个分片载荷数据长度为8字节的倍数</li>
</ul>
</li>
</ol>
<p><strong>1、例子1</strong><br>一个IPv4报文长度为3820字节（载荷数据长度为3800字节，首部长度为20字节），其使用的数据链路层协议的MTU为<code>1500个字节</code>，须进行分片（示例中将分片载荷数据最大长度选为<code>1400个字节</code>），分片后首部中变化字段情况描述如下。</p>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>总长度</th>
<th>标志（DF-MF）</th>
<th>片偏移</th>
<th>首部检验和</th>
</tr>
</thead>
<tbody><tr>
<td>原始报文</td>
<td>3820</td>
<td>0-0</td>
<td>0</td>
<td>原始报文首部检验和</td>
</tr>
<tr>
<td>分片1报文</td>
<td>1420</td>
<td>0-1</td>
<td>0</td>
<td>分片1首部检验和，独立计算</td>
</tr>
<tr>
<td>分片2报文</td>
<td>1420</td>
<td>0-1</td>
<td>175(1400&#x2F;8&#x3D;175)</td>
<td>分片2首部检验和，独立计算</td>
</tr>
<tr>
<td>分片3报文</td>
<td>1020</td>
<td>0-0</td>
<td>350(2800&#x2F;8&#x3D;350)</td>
<td>分片3首部检验和，独立计算</td>
</tr>
</tbody></table>
<p>以上分片2报文假定经过一个网络，其使用的数据链路层协议的MTU为<code>1000个字节</code>，须进行再分片（示例中将分片载荷数据最大长度选为<code>800个字节</code>），分片后首部中变化字段情况描述如下。</p>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>总长度</th>
<th>标志（DF-MF）</th>
<th>片偏移</th>
<th>首部检验和</th>
</tr>
</thead>
<tbody><tr>
<td>分片2-1报文</td>
<td>820</td>
<td>0-1</td>
<td>175(1400&#x2F;8&#x3D;175)</td>
<td>分片2-1首部检验和，独立计算</td>
</tr>
<tr>
<td>分片2-2报文</td>
<td>620</td>
<td>0-1</td>
<td>275(2200&#x2F;8&#x3D;275)</td>
<td>分片2-2首部检验和，独立计算</td>
</tr>
</tbody></table>
<p><strong>2、例子2</strong><br>一个IPv4报文长度为1508字节（载荷数据长度为1488字节，首部长度为20字节），其使用的数据链路层协议的MTU为<code>1500个字节</code>，须进行分片（示例中将分片载荷数据最大长度选为<code>800个字节</code>），分片后首部中变化字段情况描述如下。</p>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>总长度</th>
<th>标志（DF-MF）</th>
<th>片偏移</th>
<th>首部检验和</th>
</tr>
</thead>
<tbody><tr>
<td>原始报文</td>
<td>1508</td>
<td>0-0</td>
<td>0</td>
<td>原始报文首部检验和，独立计算</td>
</tr>
<tr>
<td>分片1报文</td>
<td>820</td>
<td>0-1</td>
<td>0</td>
<td>分片1首部检验和，独立计算</td>
</tr>
<tr>
<td>分片2报文</td>
<td>708</td>
<td>0-0</td>
<td>100(800&#x2F;8&#x3D;100)</td>
<td>分片2首部检验和，独立计算</td>
</tr>
</tbody></table>
<h4 id="1-6-1、Identification"><a href="#1-6-1、Identification" class="headerlink" title="1.6.1、Identification"></a><strong>1.6.1、Identification</strong></h4><p>中文名：<code>标识</code>。</p>
<p>长度：16 bits。</p>
<p>含义：IPv4协议实现程序维持一个计数器，每产生一个IPv4报文，计数器就加1，并将此值赋值给该报文的标识字段，<font color='red'>标识字段作为该IPv4报文的“标识”，不是序号</font>。当报文不分片时，该标识无实际意义；当报文分片时，分片报文会复制原报文的标识字段，接收端据此会将属于同一个IPv4报文的分片报文重新组装成原IPv4报文。</p>
<h4 id="1-6-2、Flags"><a href="#1-6-2、Flags" class="headerlink" title="1.6.2、Flags"></a><strong>1.6.2、Flags</strong></h4><p>中文名：<code>标志</code>。</p>
<p>长度：3 bits。</p>
<p>含义：共3位，现在只有后面两位有意义：</p>
<ol>
<li>最低位记为MF（More Fragment）：<ul>
<li><code>MF=1</code>：表示后面还有分片</li>
<li><code>MF=0</code>：1）在分片情形中，表示已是若干分片中最后一个；2）在未分片情形中，表示即原报文本身</li>
</ul>
</li>
<li>次低位记为DF（Don’t Fragment）：<ul>
<li><code>DF=1</code>：表示不能分片，即便报文总长度超过所使用链路层协议的MTU值（该种情形下，链路层协议实现程序一般那是丢弃该报文，并发送“ICMP Packet Too Big”报文），此时必有<code>MF=0</code>[8]</li>
<li><code>DF=0</code>：表示允许分片</li>
</ul>
</li>
</ol>
<h4 id="1-6-3、Fragment-Offset"><a href="#1-6-3、Fragment-Offset" class="headerlink" title="1.6.3、Fragment Offset"></a><strong>1.6.3、Fragment Offset</strong></h4><p>中文名：<code>片偏移</code>。</p>
<p>长度：13 bits。</p>
<p>含义：当报文不分片时，片偏移字段无实际意义；当报文分片时，片偏移字段的含义是：分片内载荷数据相对于原报文内载荷数据的偏移量，偏移量的具体计算公式为<code>偏移字节数/8（偏移字节数必为8的倍数，这跟上面“假如分成N个分片，则前N-1个分片载荷数据长度为8字节的倍数”的论述是相对应的）</code>，具体例子可参见“例子1”和“例子2”。</p>
<h3 id="1-7、Time-to-Live"><a href="#1-7、Time-to-Live" class="headerlink" title="1.7、Time to Live"></a><strong>1.7、Time to Live</strong></h3><p>中文名：<code>生存时间</code>。</p>
<p>长度：：8 bits。</p>
<p>含义：生存时间，用于限制数据包在网络上的生存时间，防止数据包在网络中无限循环堵塞网络。在最初设计和实现中，其以秒为单位，报文在经过一个路由器时，该报文的TTL值会被减去在该路由器所耗费的时间，当TTL值减为0时，该报文就会被该路由器丢弃。后来随着技术发展，路由器处理报文的时间远小于1秒，但至少每次减1，因此演变成“跳数限制，每经过一个路由器转发就减去1，减至0后被路由器丢弃”。</p>
<h3 id="1-8、Protocol"><a href="#1-8、Protocol" class="headerlink" title="1.8、Protocol"></a><strong>1.8、Protocol</strong></h3><p>中文名：<code>协议</code>。</p>
<p>长度：8 bits。</p>
<p>含义：报文载荷数据对应的协议，这个协议一般是传输层协议（“TCP”和“UDP”），但也可能是其他协议，比如“IP（指的是IPv4报文再封装到IPv4报文中）”，“IPv6（指的是IPv6报文再封装到IPv4报文中）”。常见值及对应的协议见下表。</p>
<table>
<thead>
<tr>
<th>协议名</th>
<th>ICMP</th>
<th>IGMP</th>
<th>IP</th>
<th>TCP</th>
<th>EGP</th>
<th>IGP</th>
<th>UDP</th>
<th>IPv6</th>
<th>ESP</th>
<th>AH</th>
<th>ICMP-IPv6</th>
<th>OSPF</th>
</tr>
</thead>
<tbody><tr>
<td>字段值</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>8</td>
<td>9</td>
<td>17</td>
<td>41</td>
<td>50</td>
<td>51</td>
<td>58</td>
<td>89</td>
</tr>
</tbody></table>
<h3 id="1-9、Header-Checksum"><a href="#1-9、Header-Checksum" class="headerlink" title="1.9、Header Checksum"></a><strong>1.9、Header Checksum</strong></h3><p>中文名：<code>首部检验和</code>。</p>
<p>长度：16 bits。</p>
<p>含义：用来标识报文首部是否被篡改，须注意——通过首部检验和的检验是首部未被篡改的必要不充分条件。其具体工作机制是：在报文发送端，首先将首部检验和字段置为全0，然后将报文首部以16 bits为一组分成多组（由于首部长度是4字节的倍数，故正好能划分成整数组），执行<code>反码算术运算求和 + 取反码</code>运算，将结果置入首部检验和字段，后续每个路由器都执行上述运算过程，根据上述运算过程的特点，合法结果值应该是0，如果非0，表示必被篡改，直接丢弃。</p>
<h3 id="1-10、Source-Address"><a href="#1-10、Source-Address" class="headerlink" title="1.10、Source Address"></a><strong>1.10、Source Address</strong></h3><p>中文名：<code>源地址</code>。</p>
<p>长度：32 bits。</p>
<p>含义：源IP地址。</p>
<h3 id="1-11、Destination-Address"><a href="#1-11、Destination-Address" class="headerlink" title="1.11、Destination Address"></a><strong>1.11、Destination Address</strong></h3><p>中文名：<code>目的地址</code>。</p>
<p>长度：32 bits。</p>
<p>含义：目的IP地址。</p>
<h3 id="1-12、Options和Padding"><a href="#1-12、Options和Padding" class="headerlink" title="1.12、Options和Padding"></a><strong>1.12、Options和Padding</strong></h3><p><code>Internet Header Length（IHL）</code>字段指出首部长度范围是<code>[20字节,60字节]</code>，而固定首部为定长<code>20字节</code>，那么“Options”和“Padding”字段合起来的长度范围为<code>[0字节,40字节]</code>。<br>又要求首部长度须为4字节倍数，固定首部为<code>20字节</code>，所以“Options”和“Padding”字段合起来的长度也须为4字节倍数。</p>
<h4 id="1-12-1、Options"><a href="#1-12-1、Options" class="headerlink" title="1.12.1、Options"></a><strong>1.12.1、Options</strong></h4><p>中文名：<code>可选首部</code>。</p>
<p>长度：可变。“Options”和“Padding”字段合起来的长度范围为<code>[0字节,40字节]</code>，且须为4字节倍数。</p>
<p>含义：可选首部，用于扩展IPv4头部，<font color='red'>实际不常用</font>。</p>
<h4 id="1-12-2、Padding"><a href="#1-12-2、Padding" class="headerlink" title="1.12.2、Padding"></a><strong>1.12.2、Padding</strong></h4><p>中文名：<code>填充数据</code>。</p>
<p>长度：可变。“Options”和“Padding”字段合起来的长度范围为<code>[0字节,40字节]</code>，且须为4字节倍数。</p>
<p>含义：零字节填充数据，确保“Options”和“Padding”字段合起来的长度为4字节倍数。</p>
<h2 id="二、载荷数据"><a href="#二、载荷数据" class="headerlink" title="二、载荷数据"></a><strong>二、载荷数据</strong></h2><p>结合“1.5、Total Length”小节和“1.2、Internet Header Length (IHL)”小节可知：载荷数据长度范围为<code>[0字节,65535字节-首部至少20字节=65515字节]</code>。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/IPv4#Packet_structure">https://en.wikipedia.org/wiki/IPv4#Packet_structure</a><br>[2]<a href="https://datatracker.ietf.org/doc/html/rfc791">https://datatracker.ietf.org/doc/html/rfc791</a><br>[3]<a href="https://datatracker.ietf.org/doc/html/rfc2474">https://datatracker.ietf.org/doc/html/rfc2474</a><br>[4]<a href="https://datatracker.ietf.org/doc/html/rfc3168">https://datatracker.ietf.org/doc/html/rfc3168</a><br>[5]<a href="https://en.wikipedia.org/wiki/Differentiated_services">https://en.wikipedia.org/wiki/Differentiated_services</a><br>[6]<a href="https://zh.wikipedia.org/wiki/%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5">https://zh.wikipedia.org/wiki/%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5</a><br>[7]<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10314996">https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10314996</a><br>[8]<a href="https://support.huawei.com/enterprise/en/doc/EDOC1100278546/bc7714b7/understanding-mtu">https://support.huawei.com/enterprise/en/doc/EDOC1100278546/bc7714b7/understanding-mtu</a><br>[9]<a href="https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>IPv6报文</title>
    <url>/blog/2024/03/16/IPv6%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<style>
td 
{
text-align: center
}
</style>

<p>IPv6报文是一种可变长报文，由“首部”和“载荷数据”两部分组成：</p>
<ol>
<li>首部：从<code>Version</code>字段到<code>Destination Address</code>字段为止”，长度40字节</li>
<li>载荷数据：IPv6报文数据，长度范围为<code>[0字节,65535字节]</code></li>
</ol>
<p>整个IPv6报文长度范围为<code>[40字节,65535字节+40字节=65575字节]</code>。</p>
<p>IPv6报文示意如下。</p>
<pre>
+--------------+--------------------+
|              |                    |
|    Header    |    Payload Data    |
|              |                    |
+--------------+--------------------+
</pre>

<h2 id="一、首部"><a href="#一、首部" class="headerlink" title="一、首部"></a><strong>一、首部</strong></h2><p>IPv6报文首部示意如下。</p>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>IPv6 Packet Header Format</i></caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%;">0</th>
         <th style="width:2.6%;">1</th>
         <th style="width:2.6%;">2</th>
         <th style="width:2.6%;">3</th>
         <th style="width:2.6%;">4</th>
         <th style="width:2.6%;">5</th>
         <th style="width:2.6%;">6</th>
         <th style="width:2.6%;">7</th>
         <th style="width:2.6%;">8</th>
         <th style="width:2.6%;">9</th>
         <th style="width:2.6%;">10</th>
         <th style="width:2.6%;">11</th>
         <th style="width:2.6%;">12</th>
         <th style="width:2.6%;">13</th>
         <th style="width:2.6%;">14</th>
         <th style="width:2.6%;">15</th>
         <th style="width:2.6%;">16</th>
         <th style="width:2.6%;">17</th>
         <th style="width:2.6%;">18</th>
         <th style="width:2.6%;">19</th>
         <th style="width:2.6%;">20</th>
         <th style="width:2.6%;">21</th>
         <th style="width:2.6%;">22</th>
         <th style="width:2.6%;">23</th>
         <th style="width:2.6%;">24</th>
         <th style="width:2.6%;">25</th>
         <th style="width:2.6%;">26</th>
         <th style="width:2.6%;">27</th>
         <th style="width:2.6%;">28</th>
         <th style="width:2.6%;">29</th>
         <th style="width:2.6%;">30</th>
         <th style="width:2.6%;">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="4"><i>Version (4 bits)</i></td>
         <td colspan="8"><i>Traffic Class (8 bits)</i></td>
         <td colspan="20"><i>Flow Label (20 bits)</i></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="16"><i>Payload Length (16 bits)</i></td>
         <td colspan="8"><i>Next Header (8 bits)</i></td>
         <td colspan="8"><i>Hop Limit (8 bits)</i></td>
      </tr>
      <tr>
         <th>8</th>
         <th>64</th>
         <td colspan="32" rowspan="4"><i>Source Address (128 bits)</i></td>
      </tr>
      <tr>
         <th>12</th>
         <th>96</th>
      </tr>
      <tr>
         <th>16</th>
         <th>128</th>
      </tr>
      <tr>
         <th>20</th>
         <th>160</th>
      </tr>
      <tr>
         <th>24</th>
         <th>192</th>
         <td colspan="32" rowspan="4"><i>Destination Address (128 bits)</i></td>
      </tr>
      <tr>
         <th>28</th>
         <th>224</th>
      </tr>
      <tr>
         <th>32</th>
         <th>256</th>
      </tr>
      <tr>
         <th>36</th>
         <th>288</th>
      </tr>
   </tbody>
</table>

<br/>

<h3 id="1-1、Version"><a href="#1-1、Version" class="headerlink" title="1.1、Version"></a><strong>1.1、Version</strong></h3><p>中文名：<code>版本</code>。</p>
<p>长度：4 bits。</p>
<p>含义：指明IP协议版本号，IPv6版本的话其值为<code>0110</code>。</p>
<h3 id="1-2、Traffic-Class"><a href="#1-2、Traffic-Class" class="headerlink" title="1.2、Traffic Class"></a><strong>1.2、Traffic Class</strong></h3><p>中文名：<code>通信量类</code>。</p>
<p>长度：8 bits。</p>
<p>含义：为了区分不同的IPv6报文的类别或优先级，和IPv4的区分服务（DS）字段作用相似。</p>
<h3 id="1-3、Flow-Label"><a href="#1-3、Flow-Label" class="headerlink" title="1.3、Flow Label"></a><strong>1.3、Flow Label</strong></h3><p>中文名：<code>流标号</code>。</p>
<p>长度：20 bits。</p>
<p>含义：IPv6新支持资源预分配机制，具体是可以给流设定一个服务质量目标，然后所有属于该流的IPv6报文在所经过的实现该新机制的路由器上都会被保证提供所需的服务质量。流标号就用来标识本IPv6报文属于哪一个流，全置为0表示不属于任何一个流。实时数据（比如“音频”，“视频”等）应用流机制能够大大改善服务质量，非实时数据（比如“网页”，“电子邮件”等）没有太大必要应用流机制。</p>
<p>备注：“通信量类对应的区分服务机制”和“流标号对应的资源预分配机制”是可自定义IP网络服务质量的两种机制。</p>
<h3 id="1-4、Payload-Length"><a href="#1-4、Payload-Length" class="headerlink" title="1.4、Payload Length"></a><strong>1.4、Payload Length</strong></h3><p>中文名：<code>载荷数据长度</code>。</p>
<p>长度：16 bits。</p>
<p>含义：IPv6报文除首部之外的长度（单位是“字节”，最大值为<code>2^16-1=65535</code>）。</p>
<h3 id="1-5、Next-Header"><a href="#1-5、Next-Header" class="headerlink" title="1.5、Next Header"></a><strong>1.5、Next Header</strong></h3><p>中文名：<code>下一个首部的类型值</code>。</p>
<p>长度：8 bits。</p>
<p>含义：详见“2.1、扩展首部”小节内容。</p>
<h3 id="1-6、Hop-Limit"><a href="#1-6、Hop-Limit" class="headerlink" title="1.6、Hop Limit"></a><strong>1.6、Hop Limit</strong></h3><p>中文名：<code>跳数限制</code>。</p>
<p>长度：8 bits。</p>
<p>含义：生存时间，用于限制IPv6报文在网络上的生存时间，防止IPv6报文在网络中无限循环堵塞网络。跳数限制，每经过一个路由器转发就减去1，减至0后被路由器丢弃。即IPv4报文中的“生存时间”字段，只不过这里命名更加准确。</p>
<h3 id="1-7、Source-Address"><a href="#1-7、Source-Address" class="headerlink" title="1.7、Source Address"></a><strong>1.7、Source Address</strong></h3><p>中文名：<code>源IPv6地址</code>。</p>
<p>长度：128 bits。</p>
<p>含义：源IPv6地址。</p>
<h3 id="1-8、Destination-Address"><a href="#1-8、Destination-Address" class="headerlink" title="1.8、Destination Address"></a><strong>1.8、Destination Address</strong></h3><p>中文名：<code>目的IPv6地址</code>。</p>
<p>长度：128 bits。</p>
<p>含义：目的IPv6地址。</p>
<h2 id="二、载荷数据"><a href="#二、载荷数据" class="headerlink" title="二、载荷数据"></a><strong>二、载荷数据</strong></h2><p>IPv6报文的载荷数据根据是否包含扩展首部可分为两种：</p>
<ol>
<li>不包含扩展首部，直接就是Upper Layer Data（上层协议数据），如图1</li>
<li>包含扩展首部，如图2</li>
</ol>
<p>图1</p>
<pre>
+--------------+------------------------+
|              |                        |
|    Header    |    Upper Layer Data    |
|              |                        |
+----------+---+------------------------+
               |                        |
               <-------Payload Data----->
</pre>

<p>图2</p>
<pre>
+--------------+----------------------------------+------------------------+
|              |                                  |                        |
|              |    Hop-by-Hop Options Header     |                        |
|    Header    |    Destination Options Header    |    Upper Layer Data    |  
|              |    Routing Header                |                        |
|              |    Fragment Header               |                        |
|              |    ...                           |                        |
|              |                                  |                        |
+--------------+---+------------------------------+------------------------+
               |                                                           |
               <----------------------Payload Data-------------------------> 
</pre>

<p>接下来介绍扩展首部。</p>
<h3 id="2-1、扩展首部"><a href="#2-1、扩展首部" class="headerlink" title="2.1、扩展首部"></a><strong>2.1、扩展首部</strong></h3><p>扩展首部基本介绍：</p>
<ol>
<li>现在定义了多种扩展首部，常见的如下：<ul>
<li>Hop-by-Hop Options Header</li>
<li>Routing Header</li>
<li>Fragment Header</li>
<li>Destination Options Header</li>
<li>Authentication Header（AH Header）</li>
<li>Encapsulating Security Payload Header（ESP Header）</li>
<li>…</li>
</ul>
</li>
<li><font color='red'>扩展首部的本质是相应协议报文的首部，可在非IPv6报文场景使用，作为相应协议报文的首部</font>：<ul>
<li>扩展首部对应的协议报文的完整格式一般为<code>Header + Payload Data</code>，当然也有可能不是这个格式，比如ESP Header对应的ESP协议报文的完整格式为<code>ESP Header + ESP Payload Data + ESP Trailer + ESP ICV</code>，不过为了简化，本博文统一以第一种格式进行叙述</li>
<li>首部类型值（扩展首部类型值）即相应的协议类型值[3]，IPv6报文首部和扩展首部中的<code>Next Header</code>字段值指明本首部&#x2F;扩展首部对应的载荷数据中的协议类型值，据此可构成<code>[IPv6报文首部]  --Next Header--&gt;  [上层协议数据]</code>或者<code>[IPv6报文首部]  --Next Header--&gt;  扩展首部&#123;1,&#125;  --Next Header--&gt;  [上层协议数据]</code>链路</li>
</ul>
</li>
<li>这里被称为“扩展首部”的唯一原因是——“在IPv6报文的使用场景中具有其特殊性”：<ul>
<li>所有的扩展首部大小都为8字节的倍数</li>
<li>除了“Destination Options Header”，每种扩展首部只能出现一次。“Destination Options Header”最多允许出现2次：1）在“Routing Header”存在前提下，一次出现在“Routing Header”之前；2）一次出现在上层协议数据之前</li>
<li>多个扩展首部的出现须遵从如下合法顺序<ol>
<li>Hop-by-Hop Options Header</li>
<li>Destination Options Header</li>
<li>Routing Header</li>
<li>Fragment Header</li>
<li>Authentication Header（AH Header）</li>
<li>Encapsulating Security Payload Header（ESP Header）</li>
<li>Destination Options Header</li>
<li>Upper Layer Data</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="2-2、扩展首部详细介绍"><a href="#2-2、扩展首部详细介绍" class="headerlink" title="2.2、扩展首部详细介绍"></a><strong>2.2、扩展首部详细介绍</strong></h3><h4 id="2-2-1、Hop-by-Hop-Options-Header"><a href="#2-2-1、Hop-by-Hop-Options-Header" class="headerlink" title="2.2.1、Hop-by-Hop Options Header"></a><strong>2.2.1、Hop-by-Hop Options Header</strong></h4><p>中文名：<code>逐跳选项首部</code>。</p>
<p>首部类型：扩展首部。</p>
<p>首部类型值：<code>0</code>。</p>
<p>含义：承载传送路径上每个节点都必须处理的选项信息。</p>
<p>首部格式见下表，说明如下：</p>
<ul>
<li>Next Header：下一个首部的类型值</li>
<li>Header Extension Length：扩展首部长度，以8字节为单位（即当值为<code>11=3</code>时，表示3*8&#x3D;24个字节），另外有：1）这个长度不包括前面8个字节，即整个扩展首部长度为<code>(1 + Header Extension Length) * 8</code>字节；2）根据1有整个扩展首部长度字节数为8的倍数，且大于等于8字节</li>
<li>Options：扩展首部数据，由多个<code>TLV (Type-Length-Value) Encoded Option + Padding</code>构成</li>
</ul>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>Hop-by-Hop Options Header Format</caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%;">0</th>
         <th style="width:2.6%;">1</th>
         <th style="width:2.6%;">2</th>
         <th style="width:2.6%;">3</th>
         <th style="width:2.6%;">4</th>
         <th style="width:2.6%;">5</th>
         <th style="width:2.6%;">6</th>
         <th style="width:2.6%;">7</th>
         <th style="width:2.6%;">8</th>
         <th style="width:2.6%;">9</th>
         <th style="width:2.6%;">10</th>
         <th style="width:2.6%;">11</th>
         <th style="width:2.6%;">12</th>
         <th style="width:2.6%;">13</th>
         <th style="width:2.6%;">14</th>
         <th style="width:2.6%;">15</th>
         <th style="width:2.6%;">16</th>
         <th style="width:2.6%;">17</th>
         <th style="width:2.6%;">18</th>
         <th style="width:2.6%;">19</th>
         <th style="width:2.6%;">20</th>
         <th style="width:2.6%;">21</th>
         <th style="width:2.6%;">22</th>
         <th style="width:2.6%;">23</th>
         <th style="width:2.6%;">24</th>
         <th style="width:2.6%;">25</th>
         <th style="width:2.6%;">26</th>
         <th style="width:2.6%;">27</th>
         <th style="width:2.6%;">28</th>
         <th style="width:2.6%;">29</th>
         <th style="width:2.6%;">30</th>
         <th style="width:2.6%;">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="8"><i>Next Header (8 bits)</i></td>
         <td colspan="8"><i>Header Extension Length (8 bits)</i></td>
         <td colspan="16" style="border-bottom:hidden"></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="32" rowspan="3"><i>Options (variable bits)</i></td>
      </tr>
      <tr>
         <th>8</th>
         <th>64</th>
      </tr>
      <tr>
         <th>...</th>
         <th>...</th>
      </tr>
   </tbody>
</table>

<h4 id="2-2-2、Destination-Options-Header"><a href="#2-2-2、Destination-Options-Header" class="headerlink" title="2.2.2、Destination Options Header"></a><strong>2.2.2、Destination Options Header</strong></h4><p>中文名：<code>目的选项首部</code>。</p>
<p>首部类型：扩展首部。</p>
<p>首部类型值：<code>60</code>。</p>
<p>含义：</p>
<ul>
<li>承载只需目的节点处理的选项信息</li>
<li>如前所述可能出现在两个位置：1）路由扩展首部之前，此时该扩展首部被目的节点和路由头中指定的节点处理；2）上层协议数据之前，此时该扩展首部只能被目的节点处理</li>
</ul>
<p>首部格式见下表（跟“2.2.1、Hop-by-Hop Options Header”一致），说明如下：</p>
<ul>
<li>Next Header：下一个首部的类型值</li>
<li>Header Extension Length：扩展首部长度，以8字节为单位（即当值为<code>11=3</code>时，表示3*8&#x3D;24个字节），另外有：1）这个长度不包括前面8个字节，即整个扩展首部长度为<code>(1 + Header Extension Length) * 8</code>字节；2）根据1有整个扩展首部长度字节数为8的倍数，且大于等于8字节</li>
<li>Options：扩展首部数据，由多个<code>TLV (Type-Length-Value) Encoded Option + Padding</code>构成</li>
</ul>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>Destination Options Header Format</caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%;">0</th>
         <th style="width:2.6%;">1</th>
         <th style="width:2.6%;">2</th>
         <th style="width:2.6%;">3</th>
         <th style="width:2.6%;">4</th>
         <th style="width:2.6%;">5</th>
         <th style="width:2.6%;">6</th>
         <th style="width:2.6%;">7</th>
         <th style="width:2.6%;">8</th>
         <th style="width:2.6%;">9</th>
         <th style="width:2.6%;">10</th>
         <th style="width:2.6%;">11</th>
         <th style="width:2.6%;">12</th>
         <th style="width:2.6%;">13</th>
         <th style="width:2.6%;">14</th>
         <th style="width:2.6%;">15</th>
         <th style="width:2.6%;">16</th>
         <th style="width:2.6%;">17</th>
         <th style="width:2.6%;">18</th>
         <th style="width:2.6%;">19</th>
         <th style="width:2.6%;">20</th>
         <th style="width:2.6%;">21</th>
         <th style="width:2.6%;">22</th>
         <th style="width:2.6%;">23</th>
         <th style="width:2.6%;">24</th>
         <th style="width:2.6%;">25</th>
         <th style="width:2.6%;">26</th>
         <th style="width:2.6%;">27</th>
         <th style="width:2.6%;">28</th>
         <th style="width:2.6%;">29</th>
         <th style="width:2.6%;">30</th>
         <th style="width:2.6%;">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="8"><i>Next Header (8 bits)</i></td>
         <td colspan="8"><i>Header Extension Length (8 bits)</i></td>
         <td colspan="16" style="border-bottom:hidden"></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="32" rowspan="3"><i>Options (variable bits)</i></td>
      </tr>
      <tr>
         <th>8</th>
         <th>64</th>
      </tr>
      <tr>
         <th>...</th>
         <th>...</th>
      </tr>
   </tbody>
</table>


<h4 id="2-2-3、Routing-Header"><a href="#2-2-3、Routing-Header" class="headerlink" title="2.2.3、Routing Header"></a><strong>2.2.3、Routing Header</strong></h4><p>中文名：<code>路由首部</code>。</p>
<p>首部类型：扩展首部。</p>
<p>首部类型值：<code>43</code>。</p>
<p>含义：通过列出IPv6报文到达目的地所要经过的节点列表来提供路由选择功能。</p>
<p>首部格式见下表，说明如下：</p>
<ul>
<li>Next Header：下一个首部的类型值</li>
<li>Header Extension Length：扩展首部长度，以8字节为单位（即当值为<code>11=3</code>时，表示3*8&#x3D;24个字节），另外有：1）这个长度不包括前面8个字节，即整个扩展首部长度为<code>(1 + Header Extension Length) * 8</code>字节；2）根据1有整个扩展首部长度字节数为8的倍数，且大于等于8字节</li>
<li>Routing Type：路由类型</li>
<li>Segments Left：到达目的地还需要访问的节点数量</li>
<li>Type-Specific Data：跟具体路由类型有关的具体扩展首部数据</li>
</ul>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>Routing Header Format</i></caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%;">0</th>
         <th style="width:2.6%;">1</th>
         <th style="width:2.6%;">2</th>
         <th style="width:2.6%;">3</th>
         <th style="width:2.6%;">4</th>
         <th style="width:2.6%;">5</th>
         <th style="width:2.6%;">6</th>
         <th style="width:2.6%;">7</th>
         <th style="width:2.6%;">8</th>
         <th style="width:2.6%;">9</th>
         <th style="width:2.6%;">10</th>
         <th style="width:2.6%;">11</th>
         <th style="width:2.6%;">12</th>
         <th style="width:2.6%;">13</th>
         <th style="width:2.6%;">14</th>
         <th style="width:2.6%;">15</th>
         <th style="width:2.6%;">16</th>
         <th style="width:2.6%;">17</th>
         <th style="width:2.6%;">18</th>
         <th style="width:2.6%;">19</th>
         <th style="width:2.6%;">20</th>
         <th style="width:2.6%;">21</th>
         <th style="width:2.6%;">22</th>
         <th style="width:2.6%;">23</th>
         <th style="width:2.6%;">24</th>
         <th style="width:2.6%;">25</th>
         <th style="width:2.6%;">26</th>
         <th style="width:2.6%;">27</th>
         <th style="width:2.6%;">28</th>
         <th style="width:2.6%;">29</th>
         <th style="width:2.6%;">30</th>
         <th style="width:2.6%;">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="8"><i>Next Header (8 bits)</i></td>
         <td colspan="8"><i>Header Extension Length (8 bits)</i></td>
         <td colspan="8"><i>Routing Type (8 bits)</i></td>
         <td colspan="8"><i>Segments Left (8 bits)</i></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="32" rowspan="4"><i>Type-Specific Data (variable bits)</i></td>
      </tr>
      <tr>
         <th>8</th>
         <th>64</th>
      </tr>
      <tr>
         <th>12</th>
         <th>96</th>
      </tr>
      <tr>
         <th>...</th>
         <th>...</th>
      </tr>
   </tbody>
</table>

<h4 id="2-2-4、Fragment-Header"><a href="#2-2-4、Fragment-Header" class="headerlink" title="2.2.4、Fragment Header"></a><strong>2.2.4、Fragment Header</strong></h4><p>中文名：<code>分片首部</code>。</p>
<p>首部类型：扩展首部。</p>
<p>首部类型值：<code>44</code>。</p>
<p>含义：对IPv6报文进行分片时，用于保存分片信息。</p>
<p>IPv6与IPv4的分片机制不同：</p>
<ul>
<li>在IPv4中，分片可以在发送源节点和中间路由节点进行，故发送源节点和中间路由节点只需基于“<font color='red'>紧邻路径链路层MTU</font>”来做是否分片决策</li>
<li>在IPv6中，分片只能在发送源节点做，这导致发送源节点必须基于“<font color='red'>所经过全路径最小链路层MTU</font>”才能做是否分片决策。针对于此，IPv6中有两种解决方案：<ol>
<li>使用“路径MTU发现（Path MTU Discovery，PMD，具体参见RFC 1191）”机制来获得“<font color='red'>所经过全路径最小链路层MTU</font>”</li>
<li>使发送报文大小不大于1280字节，因为IPv6协议规定运行IPv6的所有链路都必须能够支持最小1280字节大小的报文</li>
</ol>
</li>
</ul>
<p>首部格式见下表，说明如下（可参比<a href="/blog/2024/03/13/IPv4%E6%8A%A5%E6%96%87/" title="IPv4报文">《IPv4报文》</a>中的相关内容）：</p>
<ul>
<li>Next Header：下一个首部的类型值</li>
<li>Reserved：保留值，当前为全0</li>
<li>Fragment Offset：当报文不分片时，片偏移字段无实际意义；当报文分片时，片偏移字段的含义是：分片内数据相对于原报文内数据的偏移量，偏移量的具体计算公式为偏移字节数&#x2F;8</li>
<li>Res：保留值，当前为全0</li>
<li>M Flag：<ul>
<li><code>MF=1</code>：表示后面还有分片</li>
<li><code>MF=0</code>：1）在分片情形中，表示已是若干分片中最后一个；2）在未分片情形中，表示即原报文本身</li>
</ul>
</li>
<li>Identification：分片标识</li>
</ul>
<table style="text-align: center">
   <caption  style="background:#781549; color:white;"><i>Fragment Header Format</i></caption>
   <tbody>
      <tr>
         <th><i>Offsets</i></th>
         <th>Octet</th>
         <th colspan="8">0</th>
         <th colspan="8">1</th>
         <th colspan="8">2</th>
         <th colspan="8">3</th>
      </tr>
      <tr>
         <th>Octet</th>
         <th>Bit</th>
         <th style="width:2.6%;">0</th>
         <th style="width:2.6%;">1</th>
         <th style="width:2.6%;">2</th>
         <th style="width:2.6%;">3</th>
         <th style="width:2.6%;">4</th>
         <th style="width:2.6%;">5</th>
         <th style="width:2.6%;">6</th>
         <th style="width:2.6%;">7</th>
         <th style="width:2.6%;">8</th>
         <th style="width:2.6%;">9</th>
         <th style="width:2.6%;">10</th>
         <th style="width:2.6%;">11</th>
         <th style="width:2.6%;">12</th>
         <th style="width:2.6%;">13</th>
         <th style="width:2.6%;">14</th>
         <th style="width:2.6%;">15</th>
         <th style="width:2.6%;">16</th>
         <th style="width:2.6%;">17</th>
         <th style="width:2.6%;">18</th>
         <th style="width:2.6%;">19</th>
         <th style="width:2.6%;">20</th>
         <th style="width:2.6%;">21</th>
         <th style="width:2.6%;">22</th>
         <th style="width:2.6%;">23</th>
         <th style="width:2.6%;">24</th>
         <th style="width:2.6%;">25</th>
         <th style="width:2.6%;">26</th>
         <th style="width:2.6%;">27</th>
         <th style="width:2.6%;">28</th>
         <th style="width:2.6%;">29</th>
         <th style="width:2.6%;">30</th>
         <th style="width:2.6%;">31</th>
      </tr>
      <tr>
         <th>0</th>
         <th>0</th>
         <td colspan="8"><i>Next Header (8 bits)</i></td>
         <td colspan="8"><i>Reserved (8 bits)</i></td>
         <td colspan="13"><i>Fragment Offset (13 bits)</i></td>
         <td colspan="2"><i>Res (2 bits)</i></td>
         <td colspan="1"><i>M (1 bit)</i></td>
      </tr>
      <tr>
         <th>4</th>
         <th>32</th>
         <td colspan="32"><i>Identification (32 bits)</i></td>
      </tr>
   </tbody>
</table>

<h4 id="2-2-5、Authentication-Header（AH-Header）"><a href="#2-2-5、Authentication-Header（AH-Header）" class="headerlink" title="2.2.5、Authentication Header（AH Header）"></a><strong>2.2.5、Authentication Header（AH Header）</strong></h4><p>关于AH Header详见后续博文。</p>
<h4 id="2-2-6、Encapsulating-Security-Payload-Header（ESP-Header）"><a href="#2-2-6、Encapsulating-Security-Payload-Header（ESP-Header）" class="headerlink" title="2.2.6、Encapsulating Security Payload Header（ESP Header）"></a><strong>2.2.6、Encapsulating Security Payload Header（ESP Header）</strong></h4><p>关于ESP Header详见后续博文。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/IPv6_packet">https://en.wikipedia.org/wiki/IPv6_packet</a><br>[2]<a href="https://datatracker.ietf.org/doc/html/rfc8200">https://datatracker.ietf.org/doc/html/rfc8200</a><br>[3]<a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a><br>[4]<a href="https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml">https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>IntelliJ IDEA快捷键</title>
    <url>/blog/2018/06/05/IntelliJ-IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="一、编辑"><a href="#一、编辑" class="headerlink" title="一、编辑"></a><strong>一、编辑</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Shift+Enter</td>
<td>辅助完成代码语句</td>
</tr>
<tr>
<td>Shift+Enter</td>
<td>光标跳到新的一行</td>
</tr>
<tr>
<td>Ctrl+p</td>
<td>查看方法定义中的形式参数声明（需要光标处于参数输入区域）</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>快速查看JavaDoc</td>
</tr>
<tr>
<td>Ctrl+F1</td>
<td>查看对光标处错误和警告的描述</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>快速输入代码（Getters，Setters，Constructors，hashCode()，equals()，toString()，方法实现，方法覆盖）</td>
</tr>
<tr>
<td>Ctrl+&#x2F;</td>
<td>行注释&#x2F;取消行注释</td>
</tr>
<tr>
<td>Ctrl+Shift+&#x2F;</td>
<td>块注释&#x2F;取消块注释</td>
</tr>
<tr>
<td>Alt+Enter</td>
<td>快速修复</td>
</tr>
<tr>
<td>Ctrl+Shift+l</td>
<td>格式化</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>全选</td>
</tr>
<tr>
<td>Ctrl+Shift+y</td>
<td>插入常见的Java代码片段和模板（Live Templates）</td>
</tr>
<tr>
<td>Ctrl+j</td>
<td>插入模板（Live Templates）</td>
</tr>
</tbody></table>
<h2 id="二、查找与替换"><a href="#二、查找与替换" class="headerlink" title="二、查找与替换"></a><strong>二、查找与替换</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Shift+f</td>
<td>指定区域查找</td>
</tr>
<tr>
<td>Ctrl+Shift+r</td>
<td>指定区域替换</td>
</tr>
<tr>
<td>Ctrl+Shift+u</td>
<td>查找对当前内容的引用</td>
</tr>
</tbody></table>
<h2 id="三、编译与运行"><a href="#三、编译与运行" class="headerlink" title="三、编译与运行"></a><strong>三、编译与运行</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F11</td>
<td>重编译项目</td>
</tr>
<tr>
<td>Ctrl+F10</td>
<td>选择配置运行</td>
</tr>
<tr>
<td>Ctrl+F9</td>
<td>选择配置调试运行</td>
</tr>
<tr>
<td>Shift+F10</td>
<td>运行</td>
</tr>
<tr>
<td>Shift+F9</td>
<td>调试运行</td>
</tr>
</tbody></table>
<h2 id="四、调试运行"><a href="#四、调试运行" class="headerlink" title="四、调试运行"></a><strong>四、调试运行</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F8</td>
<td>步过</td>
</tr>
<tr>
<td>F7</td>
<td>步入</td>
</tr>
<tr>
<td>Shift+F8</td>
<td>强制步过</td>
</tr>
<tr>
<td>Shift+F7</td>
<td>强制步入</td>
</tr>
<tr>
<td>Ctrl+Shift+9</td>
<td>强制步到光标所在处</td>
</tr>
<tr>
<td>Ctrl+Shift+8</td>
<td>执行表达式</td>
</tr>
<tr>
<td>Ctrl+Shift+b</td>
<td>强制返回，指定返回值</td>
</tr>
<tr>
<td>Ctrl+Shift+e</td>
<td>强制抛异常，指定具体异常对象</td>
</tr>
<tr>
<td>Ctrl+F5</td>
<td>重新调试运行</td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>停止调试运行</td>
</tr>
</tbody></table>
<h2 id="五、浏览"><a href="#五、浏览" class="headerlink" title="五、浏览"></a><strong>五、浏览</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+n</td>
<td>快速跳转到类</td>
</tr>
<tr>
<td>Ctrl+Shift+n</td>
<td>快速跳转到文件</td>
</tr>
<tr>
<td>Ctrl+Shift+Alt+n</td>
<td>快速跳转到符号</td>
</tr>
<tr>
<td>Ctrl+PageDown&#x2F;PageUp</td>
<td>跳转到右&#x2F;左侧标签页</td>
</tr>
<tr>
<td>Alt+向左&#x2F;右方向键</td>
<td>浏览回退&#x2F;前进</td>
</tr>
<tr>
<td>Ctrl+m</td>
<td>跳转到定义处，反向跳转等价于“Ctrl+Shift+u”</td>
</tr>
<tr>
<td>Ctrl+i</td>
<td>跳转到实现，与“Ctrl+u”互为一组</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>跳转到父类&#x2F;父方法，与“Ctrl+i”互为一组</td>
</tr>
<tr>
<td>Alt+向上&#x2F;下方向键</td>
<td>跳转到上一个&#x2F;下一个方法</td>
</tr>
<tr>
<td>Ctrl+h</td>
<td>跳转到类继承体系Tool窗口</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td>打开文件结构弹出窗口</td>
</tr>
<tr>
<td>F2&#x2F;Shift+F2</td>
<td>跳转到前一个&#x2F;后一个高亮错误（循环）</td>
</tr>
</tbody></table>
<h2 id="六、重构"><a href="#六、重构" class="headerlink" title="六、重构"></a><strong>六、重构</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td>复制</td>
</tr>
<tr>
<td>F6</td>
<td>移动</td>
</tr>
<tr>
<td>Alt+Delete</td>
<td>安全删除</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重命名</td>
</tr>
</tbody></table>
<h2 id="七、通用"><a href="#七、通用" class="headerlink" title="七、通用"></a><strong>七、通用</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Alt+1</td>
<td>项目Tool窗口</td>
</tr>
<tr>
<td>Alt+2</td>
<td>文件结构Tool窗口</td>
</tr>
<tr>
<td>Alt+3</td>
<td>Find Tool窗口</td>
</tr>
<tr>
<td>Alt+4</td>
<td>TODO Tool窗口</td>
</tr>
<tr>
<td>Alt+F12</td>
<td>命令行Tool窗口</td>
</tr>
<tr>
<td>Ctrl+Shift+j</td>
<td>快速查看Find Tool，Messages Tool，TODO Tool等窗口中的下一处命中</td>
</tr>
<tr>
<td>Ctrl+Shift+k</td>
<td>快速查看Find Tool，Messages Tool，TODO Tool等窗口中的上一处命中</td>
</tr>
<tr>
<td>Ctrl+Shift+x</td>
<td>关闭最近活动的Tool窗口</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>关闭编辑窗口中当前标签页</td>
</tr>
<tr>
<td>Ctrl+Shift+w</td>
<td>关闭编辑窗口中除了当前标签页之外的所有标签页</td>
</tr>
<tr>
<td>Esc</td>
<td>焦点从Tool窗口（除了命令行Tool窗口）转到编辑器窗口</td>
</tr>
<tr>
<td>Ctrl+Shift+F12</td>
<td>隐藏其他所有窗口，最大化编辑窗口</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>保存所有</td>
</tr>
<tr>
<td>Ctrl+Shift+s</td>
<td>项目同步</td>
</tr>
<tr>
<td>Ctrl+Shift+t</td>
<td>创建测试类及在测试类与被测试类之间互相跳转</td>
</tr>
<tr>
<td>Ctrl+Shift+o</td>
<td>打开最近项目</td>
</tr>
<tr>
<td>Ctrl+,</td>
<td>Maven项目重新加载</td>
</tr>
<tr>
<td>Ctrl+Shift+a</td>
<td>IDE行为查找</td>
</tr>
<tr>
<td>Ctrl+Shift+Alt+c</td>
<td>复制引用。<font color='red'>能够复制完整的类路径，方法路径，源代码行路径等</font></td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>快速查看文档信息（JavaDoc解析后信息）。连续按两下，依次打开&#x2F;关闭文档信息Tool窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA的条件调试</title>
    <url>/blog/2019/03/21/IntelliJ-IDEA%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>在IntelliJ IDEA的条件调试环境中，需要注意的是：条件断点对应的Java语句执行起来非常慢。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>IDE</category>
      </categories>
  </entry>
  <entry>
    <title>Intellij Idea调试之怪异事件</title>
    <url>/blog/2017/06/24/Intellij-Idea%E8%B0%83%E8%AF%95%E4%B9%8B%E6%80%AA%E5%BC%82%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、背景描述"><a href="#一、背景描述" class="headerlink" title="一、背景描述"></a><strong>一、背景描述</strong></h2><p>在使用Intellij Idea调试时出现以下两个怪异现象，导致我额外花费了大约一个晚上的时间。<br>1、某个变量莫名其妙地产生了变化，排除了“多线程导致”和“处于不同调试上下文环境”的可能性<br>2、在相同程序环境下，运行和调试的结果不一致</p>
<h2 id="二、原因排查"><a href="#二、原因排查" class="headerlink" title="二、原因排查"></a><strong>二、原因排查</strong></h2><p>最后发现，手滑设置的调试环境下的“Watch语句”是元凶。在调试过程中，“Watch语句”会自动执行，最终导致上述怪异现象。</p>
<h2 id="三、经验教训"><a href="#三、经验教训" class="headerlink" title="三、经验教训"></a><strong>三、经验教训</strong></h2><p>在调试过程中，如果遇到怪异现象，<font color='red'>必须首先排除是否设置了“Watch语句”。</font></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>JDK命令之两大系列使用总结</title>
    <url>/blog/2017/07/02/JDK%E5%91%BD%E4%BB%A4%E4%B9%8B%E4%B8%A4%E5%A4%A7%E7%B3%BB%E5%88%97%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文中，“JDK命令之两大系列”是指“Monitoring Tool系列”和“Troubleshooting Tool系列”。</p>
<h2 id="一、Monitoring-Tool系列"><a href="#一、Monitoring-Tool系列" class="headerlink" title="一、Monitoring Tool系列"></a><strong>一、Monitoring Tool系列</strong></h2><p>本系列下有JDK命令：jps，jstat，jstatd。</p>
<h3 id="1-1、“-J”选项"><a href="#1-1、“-J”选项" class="headerlink" title="1.1、“-J”选项"></a><strong>1.1、“-J”选项</strong></h3><p>执行“jps&#x2F;jstat&#x2F;jstatd”命令实质上会运行JVM进程，跟执行“java”命令运行JVM进程一样，执行“jps&#x2F;jstat&#x2F;jstatd”命令可传入“虚拟机参数”，只不过需要直接跟在“-J”选项后面，比如“-J-Xmx100M”，如果需要传入多个“虚拟机参数”，可配置多个“-J”选项，比如“-J-Xms50M -J-Xmx100M”。</p>
<h3 id="1-2、使用模式"><a href="#1-2、使用模式" class="headerlink" title="1.2、使用模式"></a><strong>1.2、使用模式</strong></h3><p>“jps&#x2F;jstat”命令的使用有两种模式：本地模式和联网模式。以上两种模式下都只有“实时模式”这种模式。</p>
<h4 id="1-2-1、本地模式"><a href="#1-2-1、本地模式" class="headerlink" title="1.2.1、本地模式"></a><strong>1.2.1、本地模式</strong></h4><p>待被监控的JVM进程运行在本地主机上，“jps&#x2F;jstat”命令也在本地主机上执行，无需执行“jstatd”命令。</p>
<h5 id="1-2-1-1、实时模式"><a href="#1-2-1-1、实时模式" class="headerlink" title="1.2.1.1、实时模式"></a><strong>1.2.1.1、实时模式</strong></h5><p>执行“jps和jstat”命令的形式分别如<code>jps</code>和<code>jstat JVM进程ID</code>。</p>
<h4 id="1-2-2、联网模式"><a href="#1-2-2、联网模式" class="headerlink" title="1.2.2、联网模式"></a><strong>1.2.2、联网模式</strong></h4><p>待被监控的JVM进程运行在远端主机上，“jps&#x2F;jstat”命令在本地主机上执行，需要在远端主机上执行“jstatd”命令。</p>
<h5 id="1-2-2-1、实时模式"><a href="#1-2-2-1、实时模式" class="headerlink" title="1.2.2.1、实时模式"></a><strong>1.2.2.1、实时模式</strong></h5><p>执行“jstatd”命令的形式如<code>jstatd [-n ServerId]</code>；执行“jps和jstat”命令的形式分别如<code>jps rmi://远端主机IP地址/ServerId</code>和<code>jstat -gcutil rmi://远端主机上JVM进程ID@远端主机IP地址/ServerId 1000 3</code>。</p>
<h3 id="1-3、JVM进程间的通信机制"><a href="#1-3、JVM进程间的通信机制" class="headerlink" title="1.3、JVM进程间的通信机制"></a><strong>1.3、JVM进程间的通信机制</strong></h3><p>假定本地主机上执行“jps&#x2F;jstat”命令运行的JVM进程为P1，本地主机上运行的待被监控的JVM进程或者JVM进程集合为P2；远端主机上执行“jstatd”命令运行的JVM进程为P3，远端主机上运行的待被监控的JVM进程或者JVM进程集合为P4。<br>JVM进程间的通信机制描述如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>空</th>
<th>本地模式-实时模式</th>
<th>本地模式-离线模式</th>
<th>联网模式-实时模式</th>
<th>联网模式-离线模式</th>
</tr>
</thead>
<tbody><tr>
<td>jps命令</td>
<td>P1与P2之间的通信机制为“jvmstat mechanism”</td>
<td>无</td>
<td>P1与P3之间的通信机制为“RMI”，P3与P4之间的通信机制为“jvmstat mechanism”</td>
<td>无</td>
</tr>
<tr>
<td>jstat命令</td>
<td>P1与P2之间的通信机制为“jvmstat mechanism”</td>
<td>无</td>
<td>P1与P3之间的通信机制为“RMI”，P3与P4之间的通信机制为“jvmstat mechanism”</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="1-4、使用总结"><a href="#1-4、使用总结" class="headerlink" title="1.4、使用总结"></a><strong>1.4、使用总结</strong></h3><p><font color='red'>综上所述，使用“jps，jstat”命令时，采用“本地模式-实时模式”就好，不能采用“本地模式-离线模式”和“联网模式-离线模式”，没有必要采用“联网模式-实时模式”，原因主要有两点：1）如果采用，增加复杂性；2）执行“jps&#x2F;jstat”命令运行的JVM进程不是GUI进程，因此根本没有必要以“执行‘jstatd’命令运行的JVM进程”作为代理者。</font></p>
<h2 id="二、Troubleshooting-Tool系列"><a href="#二、Troubleshooting-Tool系列" class="headerlink" title="二、Troubleshooting Tool系列"></a><strong>二、Troubleshooting Tool系列</strong></h2><p>本系列下有JDK命令：jinfo，jhat，jmap，jstack，jsadebugd。</p>
<h3 id="2-1、“-J”选项"><a href="#2-1、“-J”选项" class="headerlink" title="2.1、“-J”选项"></a><strong>2.1、“-J”选项</strong></h3><p>执行“jinfo&#x2F;jhat&#x2F;jmap&#x2F;jstack&#x2F;jsadebugd”命令实质上会运行JVM进程，跟执行“java”命令运行JVM进程一样，执行“jinfo&#x2F;jhat&#x2F;jmap&#x2F;jstack&#x2F;jsadebugd”命令可传入“虚拟机参数”，只不过需要直接跟在“-J”选项后面，比如“-J-Xmx100M”，如果需要传入多个“虚拟机参数”，可配置多个“-J”选项，比如“-J-Xms50M -J-Xmx100M”。</p>
<h3 id="2-2、使用模式"><a href="#2-2、使用模式" class="headerlink" title="2.2、使用模式"></a><strong>2.2、使用模式</strong></h3><p>“jinfo&#x2F;jmap&#x2F;jstack”命令的使用有两种模式：本地模式和联网模式。以上两种模式下又都有“实时模式”和“离线模式”这两种模式；“jhat”命令的使用只有“本地模式-离线模式（<font color='red'>跟其他的“离线模式”不一样，以hprof格式文件为目标文件，其他“离线模式”以Core Dump File为目标文件</font>）”方式。</p>
<h4 id="2-2-1、本地模式"><a href="#2-2-1、本地模式" class="headerlink" title="2.2.1、本地模式"></a><strong>2.2.1、本地模式</strong></h4><p>待被监控的JVM进程运行在本地主机上，“jinfo&#x2F;jmap&#x2F;jstack”命令也在本地主机上执行，无需执行“jsadebugd”命令。</p>
<h5 id="2-2-1-1、实时模式"><a href="#2-2-1-1、实时模式" class="headerlink" title="2.2.1.1、实时模式"></a><strong>2.2.1.1、实时模式</strong></h5><p>执行“jinfo，jmap和jstack”命令的形式分别如<code>jinfo JVM进程ID</code>，<code>jmap JVM进程ID</code>和<code>jstack JVM进程ID</code>。</p>
<h5 id="2-2-1-2、离线模式"><a href="#2-2-1-2、离线模式" class="headerlink" title="2.2.1.2、离线模式"></a><strong>2.2.1.2、离线模式</strong></h5><p>执行“jinfo，jmap和jstack”命令的形式分别如<code>jinfo Executable CoreDumpFile</code>，<code>jmap Executable CoreDumpFile</code>和<code>jstack Executable CoreDumpFile</code>。其中“CoreDumpFile”表示Core Dump File的路径，“Executable”表示借以生成该Core Dump File的程序，以便能够以正确格式进行解析。</p>
<h4 id="2-2-2、联网模式"><a href="#2-2-2、联网模式" class="headerlink" title="2.2.2、联网模式"></a><strong>2.2.2、联网模式</strong></h4><p>待被监控的JVM进程运行在远端主机上，“jinfo，jmap和jstack”命令在本地主机上执行，需要在远端主机上执行“jsadebugd”命令。</p>
<h5 id="2-2-2-1、实时模式"><a href="#2-2-2-1、实时模式" class="headerlink" title="2.2.2.1、实时模式"></a><strong>2.2.2.1、实时模式</strong></h5><p>执行“jsadebugd”命令的形式如<code>jsadebugd 远端主机上待被监控的JVM进程ID [ServerId]</code>；执行“jinfo，jmap和jstack”命令的形式如<code>jinfo/jmap/jstack ServerId@远端主机IP地址</code>。</p>
<h5 id="2-2-2-2、离线模式"><a href="#2-2-2-2、离线模式" class="headerlink" title="2.2.2.2、离线模式"></a><strong>2.2.2.2、离线模式</strong></h5><p>执行“jsadebugd”命令的形式如<code>jsadebugd Executable CoreDumpFile [ServerId]</code>；执行“jinfo，jmap和jstack”命令的形式如<code>jinfo/jmap/jstack ServerId@远端主机IP地址</code>。</p>
<h3 id="2-3、JVM进程间的通信机制"><a href="#2-3、JVM进程间的通信机制" class="headerlink" title="2.3、JVM进程间的通信机制"></a><strong>2.3、JVM进程间的通信机制</strong></h3><p>假定本地主机上执行“jinfo&#x2F;jmap&#x2F;jstack”命令运行的JVM进程为P1，本地主机上运行的待被监控的JVM进程为P2；远端主机上执行“jsadebugd”命令运行的JVM进程为P3，远端主机上运行的待被监控的JVM进程为P4。</p>
<p>JVM进程间的通信机制描述如表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>空</th>
<th>本地模式-实时模式</th>
<th>本地模式-离线模式</th>
<th>联网模式-实时模式</th>
<th>联网模式-离线模式</th>
</tr>
</thead>
<tbody><tr>
<td>jinfo命令</td>
<td>P1与P2之间的通信机制：“-flag”选项，采用“Dynamic Attach”机制；“其他”选项，采用“Serviceability Agent”机制</td>
<td>P1直接读取文件</td>
<td>P1与P3之间的通信机制为“RMI”，P3与P4之间的通信机制为“Serviceability Agent”</td>
<td>P1与P3之间的通信机制为“RMI”，P3直接读取文件</td>
</tr>
<tr>
<td>jmap命令</td>
<td>P1与P2之间的通信机制：“-dump”和“-histo”选项，采用“Dynamic Attach”机制；“其他”选项，采用“Serviceability Agent”机制（<font color='red'>如果包含“-F”选项，则显式指定采用“Serviceability Agent”机制</font>）</td>
<td>P1直接读取文件</td>
<td>P1与P3之间的通信机制为“RMI”，P3与P4之间的通信机制为“Serviceability Agent”</td>
<td>P1与P3之间的通信机制为“RMI”，P3直接读取文件</td>
</tr>
<tr>
<td>jstack命令</td>
<td>P1与P2之间的通信机制：“-m”选项，采用“Serviceability Agent”机制；“其他”选项，采用“Dynamic Attach”机制（<font color='red'>如果包含“-F”选项，则显式指定采用“Serviceability Agent”机制</font>）</td>
<td>P1直接读取文件</td>
<td>P1与P3之间的通信机制为“RMI”，P3与P4之间的通信机制为“Serviceability Agent”</td>
<td>P1与P3之间的通信机制为“RMI”，P3直接读取文件</td>
</tr>
</tbody></table>
<h3 id="2-4、使用总结"><a href="#2-4、使用总结" class="headerlink" title="2.4、使用总结"></a><strong>2.4、使用总结</strong></h3><p><font color='red'>综合来看，使用“jinfo，jmap，jstack”命令时，采用“本地模式-实时模式”就好，没有必要采用“联网模式”，原因主要有两点：1）如果采用，增加复杂性；2）执行“jinfo&#x2F;jmap&#x2F;jstack”命令运行的JVM进程不是GUI进程，因此根本没有必要以“执行‘jsadebugd’命令运行的JVM进程”作为代理者。一般也没有必要采用“离线模式”，原因见“三、离线模式”。</font></p>
<h2 id="三、离线模式"><a href="#三、离线模式" class="headerlink" title="三、离线模式"></a><strong>三、离线模式</strong></h2><p>离线模式：首先需获取进程的Core Dump File，可执行<code>gcore PID</code>命令获得；接着需要获取借以获得上述Core Dump File的可执行文件路径，注意并不是“gcore”命令对应的可执行文件路径，可通过<code>gdb --core=core.2162</code>（假设“core.2126”为获取到的Core Dump File的文件名）命令进行获取，比如如下内容显示借以获得相应Core Dump File的命令为“java”，进而可获取对应的可执行文件路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Core was generated by `java -Dtoolbox.wordsegment.lib=../lib -Djava.io.tmpdir=/dev/shm -server -Xmx1204&#x27;.</span><br></pre></td></tr></table></figure>
<p>接下来，介绍使用离线模式的优缺点。<br><strong>1、优点</strong><br>1）一旦Core Dump File得以生成，“jinfo，jmap，jstack”命令便可通过该Core Dump File多次获取需要的统计和监控信息，避免在统计和监控过程中，多次干扰目标JVM进程的正常运行。<br><strong>2、缺点</strong><br>1）生成的Core Dump File比较大<br>2）增加了一个中间步骤</p>
<p>总的来说，一般情况下，不使用“离线模式”，除非为保留现场环境已经生成了Core Dump File。</p>
<br/>
参考文献：
[1]http://openjdk.java.net/groups/serviceability/svcjdk.html
[2]http://openjdk.java.net/groups/serviceability/svcjdk.html#bjstatd
[3]http://openjdk.java.net/groups/hotspot/docs/Serviceability.html
[4]http://velocity.oreilly.com.cn/2013/ppts/java_web_serviceability_agent.pdf
[5]http://jagadesh4java.blogspot.hk/2013/10/playing-with-core-files.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK正则表达式</title>
    <url>/blog/2017/05/26/JDK%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79，它的正则表达式匹配引擎采用的匹配模型见<a href="/blog/2017/06/02/%E4%B8%80%E7%A7%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B/" title="一种正则表达式匹配模型">《一种正则表达式匹配模型》</a>。<br>匹配过程涉及到两个对象：正则表达式（可由所有字符构成，包括打印字符和非打印字符）和目标字符串（可由所有字符构成，包括打印字符和非打印字符）。</p>
<h2 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a><strong>一、语法</strong></h2><p>特别需要强调的是，由于“locale设置”不同，操作系统环境不同等因素，同一个正则表达式可能具有不同的表达含义。比如在“locale&#x3D;C”设置下，“[a-d]”等价于“[abcd]”，而在有些locale设置下，“[a-d]”等价于“[aBbCcDd]”。<br><font color='red'>接下来的语法介绍只针对“一般情形”，而不针对“特殊情形”，为了确保在你的“具体情形”下，正则表达式能够如你所期望地进行表达，最好能够提前进行一些测试。</font><br>正则表达式中不同语法单元具有不同的优先级顺序，无需记忆，使用“匹配组（即<code>()</code>对）”方式更加清晰明了。</p>
<h3 id="1-1、字符类"><a href="#1-1、字符类" class="headerlink" title="1.1、字符类"></a><strong>1.1、字符类</strong></h3><h4 id="1-1-1、定义"><a href="#1-1-1、定义" class="headerlink" title="1.1.1、定义"></a><strong>1.1.1、定义</strong></h4><table>
<thead>
<tr>
<th>字符类</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>匹配“a，b，c”3个字符之一</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配除了“a，b，c”3个字符之外的任意一个字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>匹配26个小写英文字符和26个大写英文字符中的一个</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>匹配除了a-z字符之外的任意一个字符</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>并集：等价于[a-dm-p]</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]</td>
<td>交集：匹配d或者e或者f字符</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>差集：匹配a-z，除了b，c字符，等价于[ad-z]</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>差集：匹配a-z，除了m-p，等价于[a-lq-z]</td>
</tr>
</tbody></table>
<h4 id="1-1-2、实验"><a href="#1-1-2、实验" class="headerlink" title="1.1.2、实验"></a><strong>1.1.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>[abc][^abc]</code></td>
<td><code>ad</code></td>
<td>I found the text “ad” starting at index 0 and ending at index 2.</td>
</tr>
<tr>
<td><code>[a-z][^a-z]</code></td>
<td><code>aA</code></td>
<td>I found the text “aA” starting at index 0 and ending at index 2.</td>
</tr>
<tr>
<td><code>[a-h[w-z]][a-z&amp;&amp;[c]]</code></td>
<td><code>bcyc</code></td>
<td>I found the text “bc” starting at index 0 and ending at index 2.<br/>I found the text “yc” starting at index 2 and ending at index 4.</td>
</tr>
<tr>
<td><code>[a-h&amp;&amp;[^b-h]][a-d&amp;&amp;[^acd]]</code></td>
<td><code>ab</code></td>
<td>I found the text “ab” starting at index 0 and ending at index 2.</td>
</tr>
</tbody></table>
<h3 id="1-2、预定义字符类"><a href="#1-2、预定义字符类" class="headerlink" title="1.2、预定义字符类"></a><strong>1.2、预定义字符类</strong></h3><h4 id="1-2-1、定义"><a href="#1-2-1、定义" class="headerlink" title="1.2.1、定义"></a><strong>1.2.1、定义</strong></h4><table>
<thead>
<tr>
<th>预定义字符类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符，除了行终止符</td>
</tr>
<tr>
<td>\d</td>
<td>等价于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>等价于[^\d]</td>
</tr>
<tr>
<td>\s</td>
<td>等价于[ \t\n\x0B\f\r]，<font color='red'>注意最前面有个空格字符</font></td>
</tr>
<tr>
<td>\S</td>
<td>等价于[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>等价于[a-zA-Z_0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>等价于[^\w]</td>
</tr>
</tbody></table>
<p>备注：<br>根据ASCII表，“\x0B”即十进制值为“11”的字符“vertical tab”。</p>
<h4 id="1-2-2、实验"><a href="#1-2-2、实验" class="headerlink" title="1.2.2、实验"></a><strong>1.2.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>.\d\D</code></td>
<td><code>z0b</code></td>
<td>I found the text “z0b” starting at index 0 and ending at index 3.</td>
</tr>
<tr>
<td><code>a\sb\S</code></td>
<td><code>a	bz</code></td>
<td>I found the text “a     bz” starting at index 0 and ending at index 4.</td>
</tr>
<tr>
<td><code>\w\W\w</code></td>
<td><code>_-a</code></td>
<td>I found the text “_-a” starting at index 0 and ending at index 3.</td>
</tr>
</tbody></table>
<h3 id="1-3、量词修饰符"><a href="#1-3、量词修饰符" class="headerlink" title="1.3、量词修饰符"></a><strong>1.3、量词修饰符</strong></h3><h4 id="1-3-1、定义"><a href="#1-3-1、定义" class="headerlink" title="1.3.1、定义"></a><strong>1.3.1、定义</strong></h4><table>
<thead>
<tr>
<th>贪心型量词修饰符</th>
<th>勉强型量词修饰符</th>
<th>占有型量词修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X??</td>
<td>X?+</td>
<td>匹配0次或者1次</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>匹配0次或者0次以上</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>匹配1次或者1次以上</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>匹配n次，由于匹配次数固定，实质上不分“贪心型”，“勉强型”和“占有型”</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>匹配至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>匹配至少n次，至多m次</td>
</tr>
</tbody></table>
<p>关于“量词修饰符”有以下3点需要强调：</p>
<ul>
<li>“量词修饰符”不仅能修饰单个字符，也能修饰字符类和匹配组等。比如“abc{n}”，“[abc]{n}”和“(abc){n}”</li>
<li>由于“量词修饰符”的存在，可能会导致匹配过程中出现“零长度匹配”，<font color='red'>千万不要落下“零长度匹配”</font></li>
<li>含有“量词修饰符”的正则表达式，与目标字符串的匹配过程不再是确定性的，因为“量词修饰符子表达式（即由“量词修饰符”所修饰的子表达式）”应该匹配多少次不能明确确定。与此“不确定性”相关，“量词修饰符”可分为3种类型：贪心型，勉强型和占有型（<font color='red'>不常用，可忽略</font>）</li>
</ul>
<p>对于含有“量词修饰符子表达式”的正则表达式（假定正则表达式由“abc”3部分构成，其中a和c部分表示“一般子表达式”，b部分为“量词修饰符子表达式”。以上是简单情形，对于更加复杂的情形其实是类似的），匹配过程可用伪代码描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">public boolean match() &#123;</span><br><span class="line">    A: if (!findNextMatch(a)) &#123;</span><br><span class="line">            //目标字符串中，从左往右尝试匹配a：成功，进入下一步；失败，则整个匹配过程失败</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (obtainType(b) == &#x27;贪心型&#x27;) &#123;</span><br><span class="line">        //b中的量词修饰符为“贪心型”</span><br><span class="line">        //b最小匹配min次，最多匹配max次</span><br><span class="line">        //按匹配次数从大到小尝试匹配</span><br><span class="line">        len = max;</span><br><span class="line">        while (len &gt;= min &amp;&amp; len &lt;= max) &#123;</span><br><span class="line">            b匹配len次</span><br><span class="line">            if (c 匹配) &#123;</span><br><span class="line">                //成功匹配，则整个匹配过程成功</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //尝试找下一个a匹配点</span><br><span class="line">        GOTO A;</span><br><span class="line">    &#125; else if (obtainType(b) == &#x27;勉强型&#x27;) &#123;</span><br><span class="line">        //b中的量词修饰符为“勉强型”</span><br><span class="line">        //b最小匹配min次，最多匹配max次</span><br><span class="line">        //按匹配次数从小到大尝试匹配</span><br><span class="line"></span><br><span class="line">        len = min;</span><br><span class="line">        while (len &gt;= min &amp;&amp; len &lt;= max) &#123;</span><br><span class="line">            b匹配len次</span><br><span class="line">            if (c 匹配) &#123;</span><br><span class="line">                //成功匹配，则整个匹配过程成功</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //尝试找下一个a匹配点</span><br><span class="line">        GOTO A;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //b中的量词修饰符为“占有型”</span><br><span class="line">        //b最小匹配min次，最多匹配max次</span><br><span class="line">        //直接匹配max次</span><br><span class="line"></span><br><span class="line">        len = max;</span><br><span class="line">        b匹配len次</span><br><span class="line">        if (c 匹配) &#123;</span><br><span class="line">            //成功匹配，则整个匹配过程成功</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //匹配失败，尝试找下一个a匹配点</span><br><span class="line">            GOTO A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2、实验"><a href="#1-3-2、实验" class="headerlink" title="1.3.2、实验"></a><strong>1.3.2、实验</strong></h4><p>下表“解释”列中的“S”代表目标字符串。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>aa.?f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabf” starting at index 0 and ending at index 4.<br/>I found the text “aaf” starting at index 7 and ending at index 10.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.?”匹配S中第3个字符，“f”匹配S中第4个字符，匹配成功；第二次匹配过程：“aa”匹配S中第8，9个字符，“.?”匹配S中第10个字符，“f”匹配失败，<font color='red'>匹配次数从大到小</font>，“.?”零长度匹配，“f”匹配S中第10个字符，匹配成功；第三次匹配过程：S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.??f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabf” starting at index 0 and ending at index 4.<br/>I found the text “aaf” starting at index 7 and ending at index 10.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.??”零长度匹配，“f”匹配失败，<font color='red'>匹配次数从小到大</font>，“.??”匹配S中第3个字符，“f”匹配S中第4个字符，匹配成功；第二次匹配过程：“aa”匹配S中第8，9个字符，“.??”零长度匹配，“f”匹配S中第10个字符，匹配成功；第三次匹配过程：S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.?+f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabf” starting at index 0 and ending at index 4.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.?+”匹配第3个字符，“f”匹配第4个字符，匹配成功；第二次匹配过程：“aa”匹配S中第8，9个字符，“.?+”匹配第10个字符，“f”匹配失败，S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.*f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabfbcdaaf” starting at index 0 and ending at index 10.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.*?f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabf” starting at index 0 and ending at index 4.<br/>I found the text “aaf” starting at index 7 and ending at index 10.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.*+f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.+f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabfbcdaaf” starting at index 0 and ending at index 10.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.+”匹配S中第3-10个字符，“f”匹配失败，<font color='red'>匹配次数从大到小</font>，“.+”匹配S中第3-9个字符，“f”匹配S中第10个字符，匹配成功；第二次匹配过程，S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.+?f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>I found the text “aabf” starting at index 0 and ending at index 4.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.+?”匹配S中第3个字符，“f”匹配S中第4个字符，匹配成功；第二次匹配过程：“aa”匹配S中第8，9个字符，“.+?”匹配S中第10个字符，“f”匹配失败，<font color='red'>匹配次数从小到大</font>，“.+?”当下最大匹配次数是1，已经到最大，S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.++f</code></td>
<td><code>aabfbcdaaf</code></td>
<td>No match found.</td>
<td>第一次匹配过程：“aa”匹配S中第1，2个字符，“.++”匹配S中第3-10个字符，“f”匹配失败，接下来“aa”匹配S中第8，9个字符，“.++”匹配S中第10个字符，“f”匹配失败，S中找不到未匹配过的“aa”字符串，匹配失败</td>
</tr>
<tr>
<td><code>aa.&#123;4&#125;f</code></td>
<td><code>abbbbfccaabbbbf</code></td>
<td>I found the text “aabbbbf” starting at index 8 and ending at index 15.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;4&#125;?f</code></td>
<td><code>abbbbfccaabbbbf</code></td>
<td>I found the text “aabbbbf” starting at index 8 and ending at index 15.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;4&#125;+f</code></td>
<td><code>abbbbfccaabbbbf</code></td>
<td>I found the text “aabbbbf” starting at index 8 and ending at index 15.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,&#125;f</code></td>
<td><code>aabbfaabf</code></td>
<td>I found the text “aabbfaabf” starting at index 0 and ending at index 9.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,&#125;?f</code></td>
<td><code>aabbfaabf</code></td>
<td>I found the text “aabbf” starting at index 0 and ending at index 5.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,&#125;+f</code></td>
<td><code>aabbfaabf</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,6&#125;f</code></td>
<td><code>aabbfaabf</code></td>
<td>I found the text “aabbfaabf” starting at index 0 and ending at index 9.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,6&#125;?f</code></td>
<td><code>aabbfaabf</code></td>
<td>I found the text “aabbf” starting at index 0 and ending at index 5.</td>
<td>无</td>
</tr>
<tr>
<td><code>aa.&#123;2,6&#125;+f</code></td>
<td><code>aabbfaabf</code></td>
<td>I found the text “aabbfaabf” starting at index 0 and ending at index 9.</td>
<td>无</td>
</tr>
<tr>
<td><code>a?</code></td>
<td>&#96;&#96;</td>
<td>I found the text “” starting at index 0 and ending at index 0.</td>
<td>零长度匹配例子（目标字符串为空）</td>
</tr>
<tr>
<td><code>a*</code></td>
<td>&#96;&#96;</td>
<td>I found the text “” starting at index 0 and ending at index 0.</td>
<td>零长度匹配例子（目标字符串为空）</td>
</tr>
<tr>
<td><code>a?</code></td>
<td><code>abab</code></td>
<td>I found the text “a” starting at index 0 and ending at index 1.<br/>I found the text “” starting at index 1 and ending at index 1.<br/>I found the text “a” starting at index 2 and ending at index 3.<br/>I found the text “” starting at index 3 and ending at index 3.<br/>I found the text “” starting at index 4 and ending at index 4.</td>
<td>零长度匹配例子</td>
</tr>
<tr>
<td><code>a*</code></td>
<td><code>abaab</code></td>
<td>I found the text “a” starting at index 0 and ending at index 1.<br/>I found the text “” starting at index 1 and ending at index 1.<br/>I found the text “aa” starting at index 2 and ending at index 4.<br/>I found the text “” starting at index 4 and ending at index 4.<br/>I found the text “” starting at index 5 and ending at index 5.</td>
<td>零长度匹配例子</td>
</tr>
<tr>
<td><code>[abc]&#123;3&#125;</code></td>
<td><code>abccabaaaccbbbc</code></td>
<td>I found the text “abc” starting at index 0 and ending at index 3.<br/>I found the text “cab” starting at index 3 and ending at index 6.<br/>I found the text “aaa” starting at index 6 and ending at index 9.<br/>I found the text “ccb” starting at index 9 and ending at index 12.<br/>I found the text “bbc” starting at index 12 and ending at index 15.</td>
<td>不只匹配“aaa”，“bbb”或者“ccc”</td>
</tr>
</tbody></table>
<h3 id="1-4、匹配组"><a href="#1-4、匹配组" class="headerlink" title="1.4、匹配组"></a><strong>1.4、匹配组</strong></h3><h4 id="1-4-1、定义"><a href="#1-4-1、定义" class="headerlink" title="1.4.1、定义"></a><strong>1.4.1、定义</strong></h4><p>正则表达式中由“()”对括起来的子表达式被称为“匹配组”，它作为独立的匹配单元参与匹配。在正则表达式中，“匹配组”的数量就是“()”对的数量，“匹配组”的标号按照“(”符号出现的先后顺序进行确定：从“1标号-匹配组”开始。<font color='red'>也存在“0标号-匹配组”，它是特殊的“匹配组”，它代表整个正则表达式。</font>比如有<code>((A)(B(C)))</code>，其中“匹配组”数量为“4”，“1标号-匹配组”是“((A)(B(C)))”，“2标号-匹配组”是“(A)”，“3标号-匹配组”是“(B(C))”，“4标号-匹配组”是“(C)”，“0标号-匹配组”是“((A)(B(C)))”；又有<code>(A)(B(C))</code>，其中“匹配组”数量为“3”，“1标号-匹配组”是“(A)”，“2标号-匹配组”是“(B(C))”，“3标号-匹配组”是“(C)”，“0标号-匹配组”是“(A)(B(C))”。<br>可通过“\匹配组标号”形式在正则表达式引用相应“匹配组”在目标字符串中的匹配字符串内容，需要注意的是，不能使用“\0”，因为这是“语义非法的”。证明如下：现有一个正则表达式“abc\0”（a，b，c分别表示3个部分），为使该正则表达式有意义，“abc”3部分至少有一个不为空，假定该正则表达式存在对应的匹配字符串T，由于“T”与“\0”匹配，而“abc”至少有一个不为空，得到一个矛盾，因此假定不成立，即该正则表达式无对应的匹配字符串。</p>
<h4 id="1-4-2、实验"><a href="#1-4-2、实验" class="headerlink" title="1.4.2、实验"></a><strong>1.4.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>(\d\d)\1</code></td>
<td><code>1212</code></td>
<td>I found the text “1212” starting at index 0 and ending at index 4.</td>
</tr>
<tr>
<td><code>(\d\d)\1</code></td>
<td><code>1234</code></td>
<td>No match found.</td>
</tr>
</tbody></table>
<h4 id="1-4-3、特殊匹配组"><a href="#1-4-3、特殊匹配组" class="headerlink" title="1.4.3、特殊匹配组"></a><strong>1.4.3、特殊匹配组</strong></h4><h5 id="1-4-3-1、定义"><a href="#1-4-3-1、定义" class="headerlink" title="1.4.3.1、定义"></a><strong>1.4.3.1、定义</strong></h5><table>
<thead>
<tr>
<th>特殊匹配组</th>
<th>定义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(?idmsux)</td>
<td>“idmsux”无需被匹配，同时不被作为一个普通的“匹配组”。影响“匹配组”计数和通过“\匹配组标号”形式的引用行为。详见“2.1、Pattern类”小节的“等价正则表达式语法”</td>
<td><font color='red'>常用</font></td>
</tr>
<tr>
<td>(?:子表达式)</td>
<td>“子表达式”需被匹配，但不被作为一个普通的“匹配组”。影响“匹配组”计数和通过“\匹配组标号”形式的引用行为</td>
<td><font color='red'>常用</font></td>
</tr>
<tr>
<td>(?idmsux:子表达式)</td>
<td>“(?idmsux)”和“(?:子表达式)”的结合，“子表达式”需被匹配</td>
<td>无</td>
</tr>
<tr>
<td>(?&#x3D;X)</td>
<td>详见[2][3]</td>
<td>无</td>
</tr>
<tr>
<td>(?!X)</td>
<td>详见[2][3]</td>
<td>无</td>
</tr>
<tr>
<td>(?&lt;&#x3D;X)</td>
<td>详见[2][3]</td>
<td>无</td>
</tr>
<tr>
<td>(?&lt;!X)</td>
<td>详见[2][3]</td>
<td>无</td>
</tr>
<tr>
<td>(?&gt;X)</td>
<td>详见[2][3]</td>
<td>无</td>
</tr>
</tbody></table>
<h5 id="1-4-3-2、实验"><a href="#1-4-3-2、实验" class="headerlink" title="1.4.3.2、实验"></a><strong>1.4.3.2、实验</strong></h5><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
<th>正则表达式中“匹配组”数量</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?i)(ab)\1</code></td>
<td><code>ababiabi</code></td>
<td>I found the text “abab” starting at index 0 and ending at index 4.</td>
<td>1</td>
</tr>
<tr>
<td><code>(ac)(?:hello)(bd)\2</code></td>
<td><code>achellobdbdachellobdhello</code></td>
<td>I found the text “achellobdbd” starting at index 0 and ending at index 11.</td>
<td>2</td>
</tr>
</tbody></table>
<h3 id="1-5、边界匹配符"><a href="#1-5、边界匹配符" class="headerlink" title="1.5、边界匹配符"></a><strong>1.5、边界匹配符</strong></h3><h4 id="1-5-1、定义"><a href="#1-5-1、定义" class="headerlink" title="1.5.1、定义"></a><strong>1.5.1、定义</strong></h4><table>
<thead>
<tr>
<th>边界匹配府</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>索引位置为“行首位置”</td>
</tr>
<tr>
<td>$</td>
<td>索引位置为“行尾位置”，“行尾位置”的定义前提是：过滤掉“行终止符”</td>
</tr>
<tr>
<td>\A</td>
<td>索引位置为“输入起始位置”</td>
</tr>
<tr>
<td>\Z</td>
<td>索引位置为“输入结尾位置”，此处“输入结尾位置”是指过滤掉“行终止符”后的“输入结尾位置”</td>
</tr>
<tr>
<td>\z</td>
<td>索引位置为“输入结尾位置”，此处“输入结尾位置”是指未过滤掉“行终止符”情形下的“输入结尾位置”</td>
</tr>
<tr>
<td>\b</td>
<td>索引位置为“单词边界位置”</td>
</tr>
<tr>
<td>\B</td>
<td>索引位置为“非单词边界位置”</td>
</tr>
<tr>
<td>\G</td>
<td>索引位置为“前一个匹配的结束位置”</td>
</tr>
</tbody></table>
<p><font color='red'>如何更好地理解“边界匹配符”</font>：正则表达式中的“边界匹配符”给相邻字符的匹配额外增加了一层约束。比如有正则表达式“\bhe\Bllo$”，则“h”字符在匹配时需额外满足“左侧索引位置为单词边界位置”条件，“e”和“l”字符在匹配时需额外满足“两者之间索引位置为非单词边界位置”条件，“o”字符在匹配时需额外满足“右侧索引位置为行尾位置”条件。</p>
<h4 id="1-5-2、实验"><a href="#1-5-2、实验" class="headerlink" title="1.5.2、实验"></a><strong>1.5.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>^aab$</code></td>
<td><code>aab</code></td>
<td>I found the text “aab” starting at index 0 and ending at index 3.</td>
</tr>
<tr>
<td><code>^aab$</code></td>
<td><code>aab\naab</code></td>
<td>No match found.</td>
</tr>
<tr>
<td><code>^dog[\w\W]*$</code></td>
<td><code>		dog(two tab chars before)</code></td>
<td>No match found.</td>
</tr>
<tr>
<td><code>^(\s)*dog[\w\W]*$</code></td>
<td><code>		dog(two tab chars before)</code></td>
<td>I found the text “        dog(two tab chars before)” starting at index 0 and ending at index 33.</td>
</tr>
<tr>
<td><code>^dog\w*</code></td>
<td><code>dogblahblah</code></td>
<td>I found the text “dogblahblah” starting at index 0 and ending at index 11.</td>
</tr>
<tr>
<td><code>\Aaab</code></td>
<td><code>aab\naab</code></td>
<td>I found the text “aab” starting at index 0 and ending at index 3.</td>
</tr>
<tr>
<td><code>aab\Z</code></td>
<td><code>aabaab</code></td>
<td>I found the text “aab” starting at index 3 and ending at index 6.</td>
</tr>
<tr>
<td><code>aab\Z</code></td>
<td><code>aabaab\n</code></td>
<td>I found the text “aab” starting at index 3 and ending at index 6.</td>
</tr>
<tr>
<td><code>aab\z</code></td>
<td><code>aabaab\n</code></td>
<td>No match found.</td>
</tr>
<tr>
<td><code>aab\n\z</code></td>
<td><code>aabaab\n</code></td>
<td>I found the text “aab<br/>“ starting at index 3 and ending at index 7.</td>
</tr>
<tr>
<td><code>he\Bllo\b \bworld</code></td>
<td><code>hello world</code></td>
<td>I found the text “hello world” starting at index 0 and ending at index 11.</td>
</tr>
<tr>
<td><code>\Gaab</code></td>
<td><code>aabaab</code></td>
<td>I found the text “aab” starting at index 0 and ending at index 3.<br/>I found the text “aab” starting at index 3 and ending at index 6.</td>
</tr>
<tr>
<td><code>\Gaab</code></td>
<td><code>aabcaab</code></td>
<td>I found the text “aab” starting at index 0 and ending at index 3.</td>
</tr>
</tbody></table>
<h3 id="1-6、转义"><a href="#1-6、转义" class="headerlink" title="1.6、转义"></a><strong>1.6、转义</strong></h3><h4 id="1-6-1、定义"><a href="#1-6-1、定义" class="headerlink" title="1.6.1、定义"></a><strong>1.6.1、定义</strong></h4><p>正则表达式中有元字符<code>&lt;([&#123;\^-=$!|]&#125;)?*+.&gt;</code>，可通过两种方式进行转义：1）在元字符前加前导“\”字符；2）将元字符嵌在“\Q”和“\E”标记字符对之间。</p>
<p>备注：<br>“\”字符可转义后续单个元字符，“\Q”和“\E”标记字符对可转义被嵌套的字符串中的所有元字符。</p>
<h4 id="1-6-2、实验"><a href="#1-6-2、实验" class="headerlink" title="1.6.2、实验"></a><strong>1.6.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>\.</code></td>
<td><code>.</code></td>
<td>I found the text “.” starting at index 0 and ending at index 1.</td>
</tr>
<tr>
<td><code>\Q.\E</code></td>
<td><code>.</code></td>
<td>I found the text “.” starting at index 0 and ending at index 1.</td>
</tr>
<tr>
<td><code>\Q+*()\E</code></td>
<td><code>+*()</code></td>
<td>I found the text “+*()” starting at index 0 and ending at index 4.</td>
</tr>
</tbody></table>
<h3 id="1-7、操作符"><a href="#1-7、操作符" class="headerlink" title="1.7、操作符"></a><strong>1.7、操作符</strong></h3><h4 id="1-7-1、定义"><a href="#1-7-1、定义" class="headerlink" title="1.7.1、定义"></a><strong>1.7.1、定义</strong></h4><table>
<thead>
<tr>
<th>操作符</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td>“或”操作符</td>
</tr>
</tbody></table>
<h4 id="1-7-2、实验"><a href="#1-7-2、实验" class="headerlink" title="1.7.2、实验"></a><strong>1.7.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>a(ac&#124;bd)b</code></td>
<td><code>aacbdfabdb</code></td>
<td>I found the text “aacb” starting at index 0 and ending at index 4.<br/>I found the text “abdb” starting at index 6 and ending at index 10.</td>
</tr>
</tbody></table>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a><strong>二、使用</strong></h2><h3 id="2-1、Pattern类"><a href="#2-1、Pattern类" class="headerlink" title="2.1、Pattern类"></a><strong>2.1、Pattern类</strong></h3><h4 id="2-1-1、常用用法"><a href="#2-1-1、常用用法" class="headerlink" title="2.1.1、常用用法"></a><strong>2.1.1、常用用法</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern=Pattern.compile(String regex)</span><br><span class="line">Pattern pattern=Pattern.compile(String regex, int flags)</span><br><span class="line"></span><br><span class="line">//生成相应于目标字符串“input”的Matcher对象</span><br><span class="line">Matcher matcher=pattern.matcher(CharSequence input);</span><br><span class="line"></span><br><span class="line">//以下两者等价，返回生成Pattern对象时的正则表达式</span><br><span class="line">String toString();</span><br><span class="line">String pattern();</span><br></pre></td></tr></table></figure>
<p>其中<code>Pattern.compile(String regex)</code>等价于<code>Pattern.compile(String regex, 0)</code>。“flags”参数用于指定匹配模式，常见的匹配模式描述如下表，如果想使用混合匹配模式，可使用如<code>int flags=Pattern.CANON_EQ | Pattern.CASE_INSENSITIVE</code>的形式。</p>
<table>
<thead>
<tr>
<th>匹配模式</th>
<th>描述</th>
<th>等价正则表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.CANON_EQ</td>
<td>首先获取“正则表达式”和“目标字符串”各自的最终等价形式，再进行比较</td>
<td>无</td>
</tr>
<tr>
<td>Pattern.CASE_INSENSITIVE</td>
<td>“正则表达式”和“目标字符串”匹配时不区分大小写</td>
<td>(?i)</td>
</tr>
<tr>
<td>Pattern.COMMENTS</td>
<td>允许“正则表达式”中出现“空白字符和以‘#’开头的字符串”，这些被认为是注释而不参与匹配</td>
<td>(?x)</td>
</tr>
<tr>
<td>Pattern.DOTALL</td>
<td>使得“.”元字符能够匹配任意字符，包括行终止符</td>
<td>(?s)</td>
</tr>
<tr>
<td>Pattern.LITERAL</td>
<td>“正则表达式”中的所有字符被认为是没有特殊含义的“原义字符”</td>
<td>无</td>
</tr>
<tr>
<td>Pattern.MULTILINE</td>
<td>开启“多行模式”，默认为“单行模式”，从而影响“^”和“$”边界匹配符的含义。在“单行模式”中，“^”等价于“\A”，“$”等价于“\Z”；而在“多行模式”中，“^”不再等价于“\A”，“$”不再等价于“\Z”。具体内容见实验例子</td>
<td>(?m)</td>
</tr>
<tr>
<td>Pattern.UNICODE_CASE</td>
<td>与“Pattern.CASE_INSENSITIVE”联合使用。在开启“Pattern.CASE_INSENSITIVE”后，默认为“ASCII”语境下的“不区分大小写”，再开启“Pattern.UNICODE_CASE”，则为“Unicode”语境下的“不区分大小写”</td>
<td>(?u)</td>
</tr>
<tr>
<td>Pattern.UNIX_LINES</td>
<td>默认行终止符为“\r”和“\n”，开启“Pattern.UNIX_LINES”后，行终止符为“\n”</td>
<td>(?d)</td>
</tr>
</tbody></table>
<p>上述的“等价正则表达式语法”所表示的含义是：类似如下两个代码片段等价。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;^aab$&quot;;</span><br><span class="line">int flags = Pattern.MULTILINE;</span><br><span class="line">Pattern pattern = Pattern.compile(regex, flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;(?m)^aab$&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2、实验"><a href="#2-1-2、实验" class="headerlink" title="2.1.2、实验"></a><strong>2.1.2、实验</strong></h4><table>
<thead>
<tr>
<th>正则表达式</th>
<th>flags值</th>
<th>目标字符串</th>
<th>匹配结果</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><code>a\u030A</code></td>
<td>0</td>
<td><code>\u00E5</code></td>
<td>No match found.</td>
<td>未首先获取“a\u030A”的最终等价形式“å”，此时“\u00E5”为“å”，故匹配失败</td>
</tr>
<tr>
<td><code>a\u030A</code></td>
<td>Pattern.CANON_EQ</td>
<td><code>\u00E5</code></td>
<td>I found the text “å” starting at index 0 and ending at index 1.</td>
<td>首先获取“a\u030A”的最终等价形式“å”，此时“\u00E5”为“å”，故匹配成功</td>
</tr>
<tr>
<td><code>abc</code></td>
<td>0</td>
<td><code>ABC</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>abc</code></td>
<td>Pattern.CASE_INSENSITIVE</td>
<td><code>ABC</code></td>
<td>I found the text “ABC” starting at index 0 and ending at index 3.</td>
<td>无</td>
</tr>
<tr>
<td><code>abc#comment</code></td>
<td>0</td>
<td><code>abc</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>abc#comment</code></td>
<td>Pattern.COMMENTS</td>
<td><code>abc</code></td>
<td>I found the text “abc” starting at index 0 and ending at index 3.</td>
<td>无</td>
</tr>
<tr>
<td><code>.</code></td>
<td>0</td>
<td><code>\n</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Pattern.DOTALL</td>
<td><code>\n</code></td>
<td>I found the text “<br/>“ starting at index 0 and ending at index 1.</td>
<td>无</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>0</td>
<td><code>1</code></td>
<td>I found the text “1” starting at index 0 and ending at index 1.</td>
<td>无</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>Pattern.LITERAL</td>
<td><code>1</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>^aab$</code></td>
<td>0</td>
<td><code>aab\naab</code></td>
<td>No match found.</td>
<td>无</td>
</tr>
<tr>
<td><code>^aab$</code></td>
<td>Pattern.MULTILINE</td>
<td><code>aab\naab</code></td>
<td>I found the text “aab” starting at index 0 and ending at index 3.<br/>I found the text “aab” starting at index 4 and ending at index 7.</td>
<td>无</td>
</tr>
<tr>
<td><code>á</code></td>
<td>0</td>
<td><code>Á</code></td>
<td>No match found.</td>
<td>程序运行编码环境需要为“UTF-8”</td>
</tr>
<tr>
<td><code>á</code></td>
<td>Pattern.UNICODE_CASE &#124; Pattern.CASE_INSENSITIVE</td>
<td><code>Á</code></td>
<td>I found the text “Á” starting at index 0 and ending at index 1.</td>
<td>程序运行编码环境需要为“UTF-8”</td>
</tr>
<tr>
<td><code>a\Z</code></td>
<td>0</td>
<td><code>a\r</code></td>
<td>I found the text “a” starting at index 0 and ending at index 1.</td>
<td>“\r”是行终止符</td>
</tr>
<tr>
<td><code>a\Z</code></td>
<td>0</td>
<td><code>a\n</code></td>
<td>I found the text “a” starting at index 0 and ending at index 1.</td>
<td>“\n”是行终止符</td>
</tr>
<tr>
<td><code>.</code></td>
<td>0</td>
<td><code>\r\n</code></td>
<td>No match found.</td>
<td>“\r”和“\n”是行终止符</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Pattern.UNIX_LINES</td>
<td><code>\r\n</code></td>
<td>&#34; starting at index 0 and ending at index 1.</td>
<td>“\n”是行终止符，“\r”不是行终止符</td>
</tr>
</tbody></table>
<h3 id="2-2、Matcher类"><a href="#2-2、Matcher类" class="headerlink" title="2.2、Matcher类"></a><strong>2.2、Matcher类</strong></h3><h4 id="2-2-1、常用用法"><a href="#2-2-1、常用用法" class="headerlink" title="2.2.1、常用用法"></a><strong>2.2.1、常用用法</strong></h4><p>“目标字符串”与“正则表达式”全匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean matches()</span><br></pre></td></tr></table></figure>

<p>在“目标字符串”中查找与“正则表达式”匹配的匹配字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从上一个匹配的结束位置开始，寻找下一个匹配字符串</span><br><span class="line">public boolean find()</span><br><span class="line"></span><br><span class="line">//从指定位置开始，寻找下一个匹配字符串</span><br><span class="line">public boolean find(int start)</span><br><span class="line"></span><br><span class="line">//首先通过“find()”或者“find(int start)”方法获取一个匹配字符串，再通过以下方法获取该匹配字符串的内容和位置信息</span><br><span class="line"></span><br><span class="line">//等价于group(0)</span><br><span class="line">public String group()</span><br><span class="line"></span><br><span class="line">//获取第“group”个匹配组对应的匹配字符串内容，“0”表示整个匹配字符串</span><br><span class="line">public String group(int group)</span><br><span class="line"></span><br><span class="line">//该匹配字符串的开始位置（对应“匹配模型”中的索引位置）</span><br><span class="line">public int start()</span><br><span class="line"></span><br><span class="line">//该匹配字符串的结束位置（对应“匹配模型”中的索引位置）</span><br><span class="line">public int end()</span><br><span class="line"></span><br><span class="line">//“指定匹配组”对应的匹配字符串内容的开始位置（对应“匹配模型”中的索引位置）</span><br><span class="line">public int start(int group)</span><br><span class="line"></span><br><span class="line">//“指定匹配组”对应的匹配字符串内容的结束位置（对应“匹配模型”中的索引位置）</span><br><span class="line">public int end(int group)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、实验"><a href="#2-2-2、实验" class="headerlink" title="2.2.2、实验"></a><strong>2.2.2、实验</strong></h4><p><strong>1、实验1</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;a[0-9]b&quot;);</span><br><span class="line"></span><br><span class="line">        Matcher matcher1 = pattern.matcher(&quot;a1b&quot;);</span><br><span class="line">        Matcher matcher2 = pattern.matcher(&quot;a2&quot;);</span><br><span class="line">        Matcher matcher3 = pattern.matcher(&quot;a3b4&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(matcher1.matches());</span><br><span class="line">        System.out.println(matcher2.matches());</span><br><span class="line">        System.out.println(matcher3.matches());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>2、实验2</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(ad)((bc)*)(df)&quot;);</span><br><span class="line"></span><br><span class="line">        Matcher matcher = pattern.matcher(&quot;addfadbcdfadbcbcdf&quot;);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(output(matcher));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        matcher.find(3);</span><br><span class="line">        System.out.println(&quot;\n---start from 3---&quot;);</span><br><span class="line">        System.out.println(output(matcher));</span><br><span class="line"></span><br><span class="line">        matcher.find(5);</span><br><span class="line">        System.out.println(&quot;\n---start from 5---&quot;);</span><br><span class="line">        System.out.println(output(matcher));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String output(Matcher matcher) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;[match str \&quot;&quot;);</span><br><span class="line">        sb.append(matcher.group());</span><br><span class="line">        sb.append(&quot;\&quot; &quot;);</span><br><span class="line">        sb.append(&quot;start pos &quot;);</span><br><span class="line">        sb.append(matcher.start());</span><br><span class="line">        sb.append(&quot; end pos &quot;);</span><br><span class="line">        sb.append(matcher.end());</span><br><span class="line">        sb.append(&quot; : &quot;);</span><br><span class="line">        sb.append(&quot;first group str \&quot;&quot;);</span><br><span class="line">        sb.append(matcher.group(1));</span><br><span class="line">        sb.append(&quot;\&quot; &quot;);</span><br><span class="line">        sb.append(&quot;start pos &quot;);</span><br><span class="line">        sb.append(matcher.start(1));</span><br><span class="line">        sb.append(&quot; end pos &quot;);</span><br><span class="line">        sb.append(matcher.end(1));</span><br><span class="line">        sb.append(&quot; ; &quot;);</span><br><span class="line">        sb.append(&quot;second group str \&quot;&quot;);</span><br><span class="line">        sb.append(matcher.group(2));</span><br><span class="line">        sb.append(&quot;\&quot; &quot;);</span><br><span class="line">        sb.append(&quot;start pos &quot;);</span><br><span class="line">        sb.append(matcher.start(2));</span><br><span class="line">        sb.append(&quot; end pos &quot;);</span><br><span class="line">        sb.append(matcher.end(2));</span><br><span class="line">        sb.append(&quot; ; &quot;);</span><br><span class="line">        sb.append(&quot;third group str \&quot;&quot;);</span><br><span class="line">        sb.append(matcher.group(3));</span><br><span class="line">        sb.append(&quot;\&quot; &quot;);</span><br><span class="line">        sb.append(&quot;start pos &quot;);</span><br><span class="line">        sb.append(matcher.start(3));</span><br><span class="line">        sb.append(&quot; end pos &quot;);</span><br><span class="line">        sb.append(matcher.end(3));</span><br><span class="line">        sb.append(&quot; ; &quot;);</span><br><span class="line">        sb.append(&quot;fourth group str \&quot;&quot;);</span><br><span class="line">        sb.append(matcher.group(4));</span><br><span class="line">        sb.append(&quot;\&quot; &quot;);</span><br><span class="line">        sb.append(&quot;start pos &quot;);</span><br><span class="line">        sb.append(matcher.start(4));</span><br><span class="line">        sb.append(&quot; end pos &quot;);</span><br><span class="line">        sb.append(matcher.end(4));</span><br><span class="line">        sb.append(&quot;]&quot;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[match str &quot;addf&quot; start pos 0 end pos 4 : first group str &quot;ad&quot; start pos 0 end pos 2 ; second group str &quot;&quot; start pos 2 end pos 2 ; third group str &quot;null&quot; start pos -1 end pos -1 ; fourth group str &quot;df&quot; start pos 2 end pos 4]</span><br><span class="line">[match str &quot;adbcdf&quot; start pos 4 end pos 10 : first group str &quot;ad&quot; start pos 4 end pos 6 ; second group str &quot;bc&quot; start pos 6 end pos 8 ; third group str &quot;bc&quot; start pos 6 end pos 8 ; fourth group str &quot;df&quot; start pos 8 end pos 10]</span><br><span class="line">[match str &quot;adbcbcdf&quot; start pos 10 end pos 18 : first group str &quot;ad&quot; start pos 10 end pos 12 ; second group str &quot;bcbc&quot; start pos 12 end pos 16 ; third group str &quot;bc&quot; start pos 14 end pos 16 ; fourth group str &quot;df&quot; start pos 16 end pos 18]</span><br><span class="line"></span><br><span class="line">---start from 3---</span><br><span class="line">[match str &quot;adbcdf&quot; start pos 4 end pos 10 : first group str &quot;ad&quot; start pos 4 end pos 6 ; second group str &quot;bc&quot; start pos 6 end pos 8 ; third group str &quot;bc&quot; start pos 6 end pos 8 ; fourth group str &quot;df&quot; start pos 8 end pos 10]</span><br><span class="line"></span><br><span class="line">---start from 5---</span><br><span class="line">[match str &quot;adbcbcdf&quot; start pos 10 end pos 18 : first group str &quot;ad&quot; start pos 10 end pos 12 ; second group str &quot;bcbc&quot; start pos 12 end pos 16 ; third group str &quot;bc&quot; start pos 14 end pos 16 ; fourth group str &quot;df&quot; start pos 16 end pos 18]</span><br></pre></td></tr></table></figure>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>上述描述内容中主要用到的实验代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.Console;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Console console = System.console();</span><br><span class="line">        if (console == null) &#123;</span><br><span class="line">            System.err.println(&quot;No console.&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Pattern pattern = Pattern.compile(console.readLine(&quot;%nEnter your regex: &quot;));</span><br><span class="line"></span><br><span class="line">            Matcher matcher = pattern.matcher(console.readLine(&quot;Enter input string to search: &quot;));</span><br><span class="line"></span><br><span class="line">            boolean found = false;</span><br><span class="line">            while (matcher.find()) &#123;</span><br><span class="line">                console.format(&quot;I found the text&quot; + &quot; \&quot;%s\&quot; starting at &quot; + &quot;index %d and ending at index %d.%n&quot;,</span><br><span class="line">                        matcher.group(), matcher.start(), matcher.end());</span><br><span class="line">                found = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!found) &#123;</span><br><span class="line">                console.format(&quot;No match found.%n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>需要注意的是</font>：有些特殊字符并不能通过“运行上述代码而得到的命令行界面”输入获得，可使用在代码中显式指定的方式，比如“\n”代表的换行符。</p>
<h2 id="四、常见匹配"><a href="#四、常见匹配" class="headerlink" title="四、常见匹配"></a><strong>四、常见匹配</strong></h2><h3 id="4-1、IP地址"><a href="#4-1、IP地址" class="headerlink" title="4.1、IP地址"></a><strong>4.1、IP地址</strong></h3><p>朴素版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9](\d)&#123;0,2&#125;(\.[1-9](\d)&#123;0,2&#125;)&#123;3&#125;</span><br></pre></td></tr></table></figure>

<p>精确版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]|[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]|[0-9]))&#123;3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2、邮箱"><a href="#4-2、邮箱" class="headerlink" title="4.2、邮箱"></a><strong>4.2、邮箱</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(\w)[\w\-]*(\.[\w\-]+)*@[\w\-]+(\.[\w\-]+)*</span><br></pre></td></tr></table></figure>
<h3 id="4-3、11位手机号"><a href="#4-3、11位手机号" class="headerlink" title="4.3、11位手机号"></a><strong>4.3、11位手机号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1(\d)&#123;10&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4、中文字符"><a href="#4-4、中文字符" class="headerlink" title="4.4、中文字符"></a><strong>4.4、中文字符</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://docs.oracle.com/javase/tutorial/essential/regex/index.html
[2]https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#jcc
[3]《Mastering Regular Expressions, 3rd Edition》
[4]https://books.google.com/books?id=HgtdsuQdOEUC&pg=PA600&lpg=PA600&dq=java+final+terminator&source=bl&ots=wWh7rkHxwz&sig=WR_9SYY6b1zwpBq0hR8IdeTenp8&hl=zh-CN&sa=X&ved=0ahUKEwjTl_-g-PjTAhXkj1QKHfUSBmkQ6AEIWTAH#v=onepage&q=java%20final%20terminator&f=false
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>JMM</title>
    <url>/blog/2020/07/24/JMM/</url>
    <content><![CDATA[<h2 id="一、内存模型"><a href="#一、内存模型" class="headerlink" title="一、内存模型"></a><strong>一、内存模型</strong></h2><h3 id="1-1、含义"><a href="#1-1、含义" class="headerlink" title="1.1、含义"></a><strong>1.1、含义</strong></h3><p>内存模型描述的是“对于一个变量A，线程t1能够读取到线程t2对该变量的写入”的条件，即关于内存可见性（这里和后续如无特别说明，都指代“广义内存可见性”）的条件。比如“线程t1对一个volatile变量的写入，线程t2能否读取到”，“线程t1将一个final变量传递给线程t2，在t2中该变量对应的实例是否真的已经构造完成，而不存在由于重排序导致的构造未完成情形”。</p>
<p>有4点需要注意：</p>
<ul>
<li>线程t1和t2可以是同一个线程</li>
<li>在有些场景中，不是“线程”，而是“协程” </li>
<li>有不同层级的内存模型，比如“处理器层级的内存模型”，“语言层级的内存模型”</li>
<li><font color='red'>“内存模型”主要围绕<code>可见性问题（“可见性问题”和“有序性问题”等价）</code>，这是主要矛盾，其中所涉及到的“原子性问题”是次要矛盾，因此，JMM内容归属于“可见性与有序性”分类</font></li>
</ul>
<h3 id="1-2、理论参考模型——顺序一致性内存模型"><a href="#1-2、理论参考模型——顺序一致性内存模型" class="headerlink" title="1.2、理论参考模型——顺序一致性内存模型"></a><strong>1.2、理论参考模型——顺序一致性内存模型</strong></h3><p>顺序一致性内存模型是一个理想化的理论参考模型，它提供极强的内存可见性保证。</p>
<p>顺序一致性内存模型有两大特性：</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。因为，在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见</li>
</ol>
<h3 id="1-3、实际内存模型"><a href="#1-3、实际内存模型" class="headerlink" title="1.3、实际内存模型"></a><strong>1.3、实际内存模型</strong></h3><p>根据顺序一致性内存模型的描述可知，顺序一致性内存模型与“重排序（这里和后续如无特别说明，都指代‘广义重排序’）”的冲突是显而易见的。<br>比如：</p>
<ul>
<li>如果存在引入<code>高速缓存-写缓冲器-失效队列</code>机制导致的狭义可见性问题（属于“广义重排序”的一种），那么顺序一致性内存模型的第2点就不能满足</li>
<li>如果存在狭义重排序问题，那么顺序一致性内存模型的第1点就不能满足</li>
</ul>
<p>而我们知道，当不允许重排序时，执行性能会变得很差。</p>
<p>因此，总结来说，顺序一致性内存模型具有的优缺点分别如下：</p>
<ul>
<li>优点，易编程性好</li>
<li>缺点，执行性能差</li>
</ul>
<br/>

<p>实际内存模型往往通过损失“易编程性”来获得“执行性能的提升”，具体手段就是允许重排序，所允许的重排序类型越多，则“损失的易编程性越大，执行性能提升越多”。</p>
<p>以下图1给出了几个实际内存模型（包括几个“处理器层级内存模型”和几个“语言层级内存模型”）在“执行性能-易编程性”二维图中的相对位置。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20200724-0-1.png"></p>
<h4 id="1-3-1、处理器层级实际内存模型"><a href="#1-3-1、处理器层级实际内存模型" class="headerlink" title="1.3.1、处理器层级实际内存模型"></a><strong>1.3.1、处理器层级实际内存模型</strong></h4><p>处理器层级实际内存模型根据所允许的重排序类型分为4种：TSO，PSO，RMO和PowerPC。如表1所示。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>内存模型类别</th>
<th>Store-Load重排序</th>
<th>Store-Store重排序</th>
<th>Load-Load和Load-Store重排序</th>
<th>可以更早读取到其他处理器的写（也是一种重排序）</th>
<th>可以更早读取到当前处理器的写（也是一种重排序）</th>
<th>具体处理器案例</th>
</tr>
</thead>
<tbody><tr>
<td>TSO</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>SPARC-TSO，X86</td>
</tr>
<tr>
<td>PSO</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
<td>SPARC-PSO</td>
</tr>
<tr>
<td>RMO</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>IA64<sup>[2]</sup></td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>PowerPC<sup>[3]</sup></td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ul>
<li>SPARC架构见[1]</li>
<li>两个PowerPC：一个是内存模型类别，一个是具体处理器案例</li>
</ul>
<h4 id="1-3-2、语言层级实际内存模型"><a href="#1-3-2、语言层级实际内存模型" class="headerlink" title="1.3.2、语言层级实际内存模型"></a><strong>1.3.2、语言层级实际内存模型</strong></h4><p>比如有：</p>
<ul>
<li>C++ 11的内存模型——C++ 11 MM</li>
<li>Java的内存模型——JMM</li>
<li>.Net的内存模型——CLR2.0 MM</li>
<li>Go的内存模型</li>
<li>Rust的内存模型</li>
</ul>
<h2 id="二、JMM"><a href="#二、JMM" class="headerlink" title="二、JMM"></a><strong>二、JMM</strong></h2><p>Java内存模型，英文全称为“Java Memory Model”，简称JMM。</p>
<p>在谈论JMM的时候，经常会涉及到JSR-133，这两者的关系是：JSR-133是一个定义JMM的规范，它增强改进了旧规范定义的JMM。</p>
<p>JMM有3大特性：</p>
<ul>
<li>单线程程序。单线程程序的执行具有顺序一致性，即“程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同”</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行具有顺序一致性，即“程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同”</li>
<li>未同步&#x2F;未正确同步的多线程程序。JMM为它们提供了最小安全性保障，即“线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）”</li>
</ul>
<p>为便于程序员编写正确同步的多线程程序，JMM设计了一整套规范，作了基础设施实现（主要使用“内存屏障”消除不需要的“重排序”），向程序员提供交付了“JMM内存抽象模型”，“相关语法关键词”，“happens-before规则”以及其他相关语义确保。</p>
<h3 id="2-1、JMM内存抽象模型"><a href="#2-1、JMM内存抽象模型" class="headerlink" title="2.1、JMM内存抽象模型"></a><strong>2.1、JMM内存抽象模型</strong></h3><p>JMM向程序员提供一个抽象的内存模型，向下屏蔽千差万别的具体硬件差异，具体如图2所示。</p>
<p>关于这个抽象内存模型有以下几点说明：</p>
<ul>
<li>Java进程的内存主要分为“程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区，直接内存”，其中对于线程私有内存（程序计数器，Java虚拟机栈，本地方法栈）中的变量不会存在可见性问题，因此示意图中的主内存指代线程共享内存（Java堆，方法区，直接内存），且一般就是指“Java堆”</li>
<li>在视图中每个线程都有一个私有的本地内存，本地内存中存储了主内存中共享变量的副本。但其实本地内存只是JMM用来便于描述的一个抽象概念，它并不真实存在，而只是“缓存、写缓冲区、寄存器”等机制的代指</li>
</ul>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20200724-0-2.jpg"></p>
<h3 id="2-2、相关语法关键词"><a href="#2-2、相关语法关键词" class="headerlink" title="2.2、相关语法关键词"></a><strong>2.2、相关语法关键词</strong></h3><p>相关实现提供的语法关键词有：</p>
<ul>
<li>synchronized</li>
<li>volatile</li>
<li>final</li>
<li>…</li>
</ul>
<p>需要注意的是，上述关键词的完整语法语义不只来自于JMM，也来自于其他的Java语言语法规范。</p>
<h3 id="2-3、happens-before规则"><a href="#2-3、happens-before规则" class="headerlink" title="2.3、happens-before规则"></a><strong>2.3、happens-before规则</strong></h3><p>详见<a href="/blog/2019/12/17/happens-before%E8%A7%84%E5%88%99/" title="happens-before规则">《happens-before规则》</a>。</p>
<h3 id="2-4、其他相关语义确保"><a href="#2-4、其他相关语义确保" class="headerlink" title="2.4、其他相关语义确保"></a><strong>2.4、其他相关语义确保</strong></h3><p>比如：</p>
<ul>
<li>JMM不保证对long型和double型变量的简单读和写操作具有原子性；JMM保证对除了long型和double型之外的变量的简单读和写操作具有原子性</li>
<li>在构造方法中对final实例成员变量A赋值，在构造方法返回之前，被构造对象的实例对象引用不被其他线程所见，在构造方法返回后，通过该实例对象引用读取A，那么对于该<code>读操作</code>来说，“构造方法中对A的赋值确保内存可见，如果A是个引用变量，其指向实例对象P，那么构造方法之前所有对P的操作都确保内存可见”。详见[10]中“final关键词内存可见语义规则”小节</li>
<li>类的初始化（Class被加载之后，被线程使用之前）是线程安全的，具体是通过加锁实现的[9]</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zh.wikipedia.org/wiki/SPARC">https://zh.wikipedia.org/wiki/SPARC</a><br>[2]<a href="https://baike.baidu.com/item/ia64">https://baike.baidu.com/item/ia64</a><br>[3]<a href="https://zh.wikipedia.org/wiki/PowerPC">https://zh.wikipedia.org/wiki/PowerPC</a><br>[4]<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html</a><br>[5]《Java并发编程的艺术》<br>[6]《JSR-133：Java内存<sup>TM</sup>模型与线程规范》<br>[7]<a href="https://developer.ibm.com/zh/articles/j-jtp03304/">https://developer.ibm.com/zh/articles/j-jtp03304/</a><br>[8]<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a><br>[9]《Java并发编程的艺术》P72<br>[10]<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>JVM垃圾收集器GC分类和触发</title>
    <url>/blog/2018/12/21/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E5%88%86%E7%B1%BB%E5%92%8C%E8%A7%A6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="一、GC分类"><a href="#一、GC分类" class="headerlink" title="一、GC分类"></a><strong>一、GC分类</strong></h2><h3 id="1-1、Minor-GC"><a href="#1-1、Minor-GC" class="headerlink" title="1.1、Minor GC"></a><strong>1.1、Minor GC</strong></h3><p>指代年轻代的GC。Minor GC又被称为Young GC，简称YGC。</p>
<h3 id="1-2、Major-GC"><a href="#1-2、Major-GC" class="headerlink" title="1.2、Major GC"></a><strong>1.2、Major GC</strong></h3><p>指代老年代的GC。</p>
<h3 id="1-3、Full-GC"><a href="#1-3、Full-GC" class="headerlink" title="1.3、Full GC"></a><strong>1.3、Full GC</strong></h3><p>年轻代+老年代的GC。</p>
<h3 id="1-4、Mixed-GC"><a href="#1-4、Mixed-GC" class="headerlink" title="1.4、Mixed GC"></a><strong>1.4、Mixed GC</strong></h3><p>年轻代+部分老年代的GC。当下只存在于G1垃圾收集器中。</p>
<h2 id="二、GC是否触发和GC触发条件"><a href="#二、GC是否触发和GC触发条件" class="headerlink" title="二、GC是否触发和GC触发条件"></a><strong>二、GC是否触发和GC触发条件</strong></h2><p>通常对“GC是否触发”和“GC触发条件”的描述是粗粒度和不准确的，细粒度和准确的描述需要结合所选用垃圾收集器，所选用垃圾收集器最终具体决定“GC是否触发，GC触发条件，GC算法”的所有细节。<font color='red'>要想获取全面准确细节的最好方式就是阅读所选用垃圾收集器的源代码</font>。</p>
<h3 id="2-1、GC是否触发"><a href="#2-1、GC是否触发" class="headerlink" title="2.1、GC是否触发"></a><strong>2.1、GC是否触发</strong></h3><p>举例说明对“GC是否触发”的细粒度准确描述需要结合所选用垃圾收集器：</p>
<ul>
<li>有“当年轻代Eden区不能分配对象时，触发Minor GC”的通用描述，实际上当选用面向整个Java堆不分年轻代和老年代的垃圾收集器时，根本就不存在Minor GC</li>
<li>有“满足XX条件时，触发Mixed GC”的通用描述，实际当选用非G1垃圾收集器时，根本就不存在Mixed GC</li>
</ul>
<h3 id="2-2、GC触发条件"><a href="#2-2、GC触发条件" class="headerlink" title="2.2、GC触发条件"></a><strong>2.2、GC触发条件</strong></h3><p>举例说明对“GC触发条件”的细粒度准确描述需要结合所选用垃圾收集器：</p>
<ul>
<li>有“满足XX条件时，触发Major GC”的通用描述，实际上当选用CMS垃圾收集器时，还可通过<code>-XX:CMSInitiatingOccupancyFraction=N</code>JVM参数配置Major GC触发的额外条件</li>
</ul>
<br/>
参考文献：
[1]http://www.importnew.com/15820.html
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM进程内5个主要内存区域中客体之间的联系</title>
    <url>/blog/2022/01/28/JVM%E8%BF%9B%E7%A8%8B%E5%86%855%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%AD%E5%AE%A2%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>本文默认基于64位的JDK 8（其虚拟机实现是HotSpot），除非特别说明。</p>
<p>本文介绍JVM进程内5个主要内存区域中客体（变量、字段、对象等）之间的联系，5个主要内存区域是“Java虚拟机栈，本地方法栈，Java堆，方法区，显式调用JNI方法直接分配内存”，即不包括“程序计数器，JVM进程运行自身所需内存”。[1]</p>
<h2 id="一、联系的本质"><a href="#一、联系的本质" class="headerlink" title="一、联系的本质"></a><strong>一、联系的本质</strong></h2><p>从内存和机器码的视角看，两块内存区域中客体之间的联系就是指针（概念引自“C&#x2F;C++语言”，这里是广义化的，可以是直接内存地址，也可以是间接内存地址）。</p>
<p>从JVM的视角看，以上5块内存区域只不过是内存上的逻辑划分，其内客体之间的联系就是指针，只不过：</p>
<ul>
<li>有些在Java语言视图下是Java对象引用，比如“在Java方法中有语句<code>Object obj = new Object()</code>，在Java语言视图下，Java虚拟机栈中的变量obj客体与Java堆中相应实例对象客体之间的指针是Java对象引用”</li>
<li>其他的则不是，比如“在Java方法中有语句<code>long base = sun.misc.Unsafe.allocateMemory(size)</code>，在Java语言视图下，Java虚拟机栈中的变量base客体与‘显式调用JNI方法直接分配内存’中相应内存块客体之间的指针不是Java对象引用”</li>
</ul>
<br/>

<p><font color='red'>一个指针是Java对象引用须满足两个条件</font>：</p>
<ol>
<li>[<strong>条件1</strong>]指针指向一个Java对象</li>
<li>[<strong>条件2</strong>]保存指针值的变量是Java对象引用变量</li>
</ol>
<p>这两个条件之间的关系是：</p>
<ul>
<li>条件1不满足，条件2必然不满足，否则此时Java对象引用变量便是一个非法定义</li>
<li>条件1满足，条件2可能满足，也可能不满足，不满足的情形比如有“Java程序中一个long型变量保存一个Java对象的内存地址”，“本地方法实现中，执行上下文语境不是Java，一个C&#x2F;C++语言指针变量保存一个Java对象的内存地址”</li>
</ul>
<h2 id="二、联系示意图和说明"><a href="#二、联系示意图和说明" class="headerlink" title="二、联系示意图和说明"></a><strong>二、联系示意图和说明</strong></h2><p>在继续叙述之前，首先作三点说明：</p>
<ul>
<li>对于“方法区”，本文只考虑“类元数据，即Klass对象”，不考虑“运行时常量池、即时编译器编译以后的代码等”</li>
<li>Java堆内是Java对象，分为：普通实例对象，数组对象，Class对象</li>
<li>对于JNI方法，本地方法栈存放中间过程变量，直接操作目标内存块可以认为只位于“显式调用JNI方法直接分配内存”和“Java堆”，而不可以位于“Java虚拟机栈”，“本地方法栈”和“方法区”（虽然JNI方法理论上可以操作所在JVM进程内所有内存，但是直接操作“Java虚拟机栈”，“本地方法栈”和“方法区”中的内存块被认为不安全，这里不作考虑，笔者不清楚JDK本身是否对上述不安全行为有所限制）</li>
</ul>
<h3 id="2-1、联系示意图"><a href="#2-1、联系示意图" class="headerlink" title="2.1、联系示意图"></a><strong>2.1、联系示意图</strong></h3><p>联系示意图见图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20220128-0-0.svg"></p>
<h3 id="2-2、联系说明"><a href="#2-2、联系说明" class="headerlink" title="2.2、联系说明"></a><strong>2.2、联系说明</strong></h3><ul>
<li>[<strong>1</strong>]和[<strong>2</strong>]：Java对象的对象头中的“Klass Pointer”，指向方法区中的“类元数据，即Klass对象”，该指针不是Java对象引用，因为条件1和2不满足；方法区中“类元数据”的“_java_mirror”指针，指向Java堆中对应的“java.lang.Class对象”，该指针不是Java对象引用，因为条件1满足而条件2不满足。比如“有一个自定义类me.dslztx.AObject，加载该类创建一个实例对象aObject之后，方法区存在一个对应于me.dslztx.AObject的Klass对象aKlass，在Java堆中存在一个对应于me.dslztx.AObject的Class对象aClz（即一个java.lang.Class类的实例对象），现在aObject实例对象的对象头中的Klass Pointer指向aKlass，aKlass中的“_java_mirror”指针指向aClz”</li>
<li>[<strong>3</strong>]：部分为Java语言视图下的Java对象引用，示例见源代码1；其他部分则不是（可能条件1不满足，此时条件2必然不满足，比如“指向一个字段的内存地址”；可能条件1满足而条件2不满足，比如“一个long型变量保存一个Java对象的内存地址”），示例见源代码2</li>
<li>[<strong>5</strong>]：部分为Java语言视图下的Java对象引用，示例见源代码3；其他部分则不是（可能条件1不满足，此时条件2必然不满足，比如“指向一个字段的内存地址”；可能条件1满足而条件2不满足，比如“一个long型变量保存一个Java对象的内存地址”），示例见源代码2</li>
<li>[<strong>7</strong>]：没有一个指针是Java对象引用，条件2必然不满足（因为是非Java方法的执行上下文），条件1可能满足也可能不满足，示例见源代码4。<font color='red'>这里有一点释疑：JNI方法声明中的输入参数和输出参数属于Java语言，如果相关变量是在本地方法栈中定义的，那条件2不是可能满足吗？答案是否的，因为在运行过程中，以上输入参数会被转换成适配JNI方法实现的输入参数，JNI方法实现的输出参数会被转换成适配以上输出参数，对于上述转换过程中的相关变量，笔者认为不存放在本地方法栈</font></li>
<li>[<strong>4</strong>]、[<strong>6</strong>]、[<strong>8</strong>]：没有一个指针是Java对象引用，条件1必然不满足（否则这部分内存应该属于Java堆），此时条件2也必然不满足，示例见源代码5和源代码6</li>
</ul>
<p>源代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AObject</span> <span class="variable">aObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">BObject</span> <span class="variable">bObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BObject</span>(aObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AObject</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BObject</span> &#123;</span><br><span class="line">    <span class="comment">// Java堆中BObject实例对象内a字段客体与Java堆中AObject实例对象之间的指针是Java对象引用</span></span><br><span class="line">    AObject a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BObject</span><span class="params">(AObject a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AObject</span> <span class="variable">aObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//obtainAddressJNI是一个待实现的获取对象内存地址的JNI方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java虚拟机栈中aAddressTmp局部变量客体与Java堆中AObject实例对象之间的指针不是Java对象引用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">aAddressTmp</span> <span class="operator">=</span> obtainAddressJNI(aObject);</span><br><span class="line"></span><br><span class="line">        <span class="type">BObject</span> <span class="variable">bObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BObject</span>(aAddressTmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AObject</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BObject</span> &#123;</span><br><span class="line">    <span class="comment">// Java堆中BObject实例对象内aAddress字段客体与Java堆中AObject实例对象之间的指针不是Java对象引用</span></span><br><span class="line">    <span class="type">long</span> aAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BObject</span><span class="params">(<span class="type">long</span> aAddress)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aAddress = aAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java虚拟机栈中aObject局部变量客体与Java堆中AObject实例对象之间的指针是Java对象引用</span></span><br><span class="line">        <span class="type">AObject</span> <span class="variable">aObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AObject</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码4：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapObject</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapObject&quot;</span>);</span><br><span class="line">  oop x = JNIHandles::<span class="built_in">resolve</span>(x_h); <span class="comment">// 新值</span></span><br><span class="line">  oop e = JNIHandles::<span class="built_in">resolve</span>(e_h); <span class="comment">// 预期值</span></span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// addr变量虽然指向了Java堆中的一个对象，但是在本地方法语境中不是Java对象引用</span></span><br><span class="line">  HeapWord* addr = (HeapWord *)<span class="built_in">index_oop_from_field_offset_long</span>(p, offset);<span class="comment">// 在内存中的具体位置</span></span><br><span class="line">  oop res = oopDesc::<span class="built_in">atomic_compare_exchange_oop</span>(x, addr, e, <span class="literal">true</span>);<span class="comment">// 调用了另一个方法</span></span><br><span class="line">  jboolean success  = (res == e);  <span class="comment">// 如果返回的res等于e，则判定满足compare条件（说明res应该为内存中的当</span></span><br><span class="line">前值），但实际上会有ABA的问题</span><br><span class="line">  <span class="keyword">if</span> (success) <span class="comment">// success为true时，说明此时已经交换成功（调用的是最底层的cmpxchg指令）</span></span><br><span class="line">    <span class="built_in">update_barrier_set</span>((<span class="type">void</span>*)addr, x); <span class="comment">// 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时&gt;中</span></span><br><span class="line">断操作，配合垃圾收集器</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>源代码5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java虚拟机栈中base局部变量客体与“显式调用JNI方法直接分配内存”中一个内存块的指针不是Java对象引用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CObject</span> <span class="variable">cObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CObject</span>(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CObject</span> &#123;</span><br><span class="line">    <span class="comment">// Java堆中CObject实例对象内address字段客体与“显式调用JNI方法直接分配内存”中一个内存块的指针不是Java对象引用</span></span><br><span class="line">    <span class="type">long</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CObject</span><span class="params">(<span class="type">long</span> address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码6：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jlong, <span class="built_in">Unsafe_AllocateMemory</span>(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_AllocateMemory&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> sz = (<span class="type">size_t</span>)size;</span><br><span class="line">  <span class="keyword">if</span> (sz != (julong)size || size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_0</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sz局部变量客体与“显式调用JNI方法直接分配内存”中一个内存块的指针不是Java对象引用</span></span><br><span class="line">  sz = <span class="built_in">round_to</span>(sz, HeapWordSize);</span><br><span class="line">  <span class="type">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtInternal);</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_0</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">addr_to_java</span>(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/12/19/JVM%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB/" title="JVM进程内存分类">《JVM进程内存分类》</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/104725313">https://zhuanlan.zhihu.com/p/104725313</a><br>[3]<a href="https://www.sczyh30.com/posts/Java/jvm-klass-oop/">https://www.sczyh30.com/posts/Java/jvm-klass-oop/</a><br>[4]<a href="https://zhuanlan.zhihu.com/p/104494807">https://zhuanlan.zhihu.com/p/104494807</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM进程内存分类</title>
    <url>/blog/2021/12/19/JVM%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>本文默认基于64位的JDK 8（其虚拟机实现是HotSpot），除非特别说明。</p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><h3 id="1-1、进程使用内存上限"><a href="#1-1、进程使用内存上限" class="headerlink" title="1.1、进程使用内存上限"></a><strong>1.1、进程使用内存上限</strong></h3><p>进程所能使用内存上限受到硬件和操作系统限制，比如32位Windows操作系统下进程所能使用内存上限为2G。</p>
<h3 id="1-2、虚拟机进程"><a href="#1-2、虚拟机进程" class="headerlink" title="1.2、虚拟机进程"></a><strong>1.2、虚拟机进程</strong></h3><p>我们平时说的Java进程其实是虚拟机进程——JVM进程。通过执行<code>java</code>命令触发运行JVM进程，比如<code>java com.dslztx.Main</code>和<code>java -version</code>等。</p>
<h3 id="1-3、JVM进程内存管理"><a href="#1-3、JVM进程内存管理" class="headerlink" title="1.3、JVM进程内存管理"></a><strong>1.3、JVM进程内存管理</strong></h3><p>如“1.1、进程使用内存上限”所述，JVM进程使用内存上限受到硬件和操作系统限制。根据虚拟机规范，JVM进程内存管理采取内存分类、内存动态分配、垃圾收集等技术。采用该种内存管理机制的优点是内存管理更加方便简单，缺点是一旦出现内存泄漏和溢出等问题，较难排查问题。</p>
<h2 id="二、JVM进程内存管理之内存分类"><a href="#二、JVM进程内存管理之内存分类" class="headerlink" title="二、JVM进程内存管理之内存分类"></a><strong>二、JVM进程内存管理之内存分类</strong></h2><p>分配给进程使用的一块内存区域被称为<code>Native Memory</code>（有时候也被称为<code>Native Heap</code>），如“1.1、进程使用内存上限”所述，<code>Native Memory</code>上限受到硬件和操作系统限制。</p>
<br/>

<p><code>Native Memory</code>如何被使用由进程自身决定，虚拟机规范人为对JVM进程使用的<code>Native Memory</code>进行了划分，虽然其实底层都使用了相同的方式操作和管理内存，比如都调用C&#x2F;C++语言的<code>malloc/free</code>函数。JVM进程内存管理对所使用的<code>Native Memory</code>的具体分类为：<font color='red'>程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区，显式调用JNI方法直接分配内存，JVM进程运行自身所需内存</font>。</p>
<p>关于上述内存分类有两点说明：</p>
<ol>
<li>基于是否由业务线程共享（这个共享是狭义的，基本可认为只有“Java堆”和“方法区”才算是线程共享的）可对上述内存分类进行再划分：<ul>
<li>线程私有：程序计数器、Java虚拟机栈、本地方法栈</li>
<li>线程共享：Java堆、方法区</li>
<li>其他类型：JVM进程运行自身所需内存、显式调用JNI方法直接分配内存（深究起来，该部分内存也是广义线程共享的，但这里只讨论狭义线程共享）</li>
</ul>
</li>
<li>虽然底层都使用C&#x2F;C++语言的内存分配&#x2F;回收函数，比如“malloc&#x2F;free”，但是除了“显式调用JNI方法直接分配内存”之外的内存分类，内存操作没有JNI方法调用中间层</li>
</ol>
<p>上述具体分类示例如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20211219-0-1.svg"></p>
<p>结合“作用”、“使用过程中可能遇到问题”和“其他描述”等信息，对内存分类进行深入介绍，如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>内存分类</th>
<th>英文名称</th>
<th>线程私有&#x2F;线程共享&#x2F;其他类型</th>
<th>作用</th>
<th>使用过程中可能遇到问题</th>
<th>其他描述</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>Program Counter Register</td>
<td>线程私有</td>
<td>执行Java方法时，存储线程当前执行字节码指令地址；执行本地方法（Native Method）时，存储空值</td>
<td>理论上不会抛出任何异常</td>
<td>内存空间小</td>
</tr>
<tr>
<td>Java虚拟机栈</td>
<td>Java Virtual Machine Stack</td>
<td>线程私有</td>
<td>存储Java方法执行时创建的栈帧</td>
<td>可能抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常</td>
<td>一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法调用生成栈帧，结束释放栈帧</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>Native Method Stack</td>
<td>线程私有</td>
<td>存储本地方法（Native Method）执行时创建的栈帧</td>
<td>可能抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常</td>
<td>本地方法栈跟Java虚拟机栈非常类似，只是：一个针对Java方法，另外一个针对本地方法（Native Method）</td>
</tr>
<tr>
<td>Java堆</td>
<td>Java Heap</td>
<td>线程共享</td>
<td>存储几乎所有的对象实例</td>
<td>可能抛出<code>OutOfMemoryError</code>异常</td>
<td>内存空间较大</td>
</tr>
<tr>
<td>方法区</td>
<td>Method Area</td>
<td>线程共享</td>
<td>存储已被虚拟机加载的类信息，即时编译器编译以后的代码等数据</td>
<td>可能抛出<code>OutOfMemoryError</code>异常</td>
<td>JDK 6使用“永久代”实现方法区，JDK 8使用“元空间”实现方法区：实现策略升级解决一些已知存在问题，具体原因没有必要深究[4]</td>
</tr>
<tr>
<td>JVM进程运行自身所需内存</td>
<td>&#x2F;</td>
<td>其他类型</td>
<td>JVM进程运行自身所需</td>
<td>理论上不会抛出任何异常</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>显式调用JNI方法直接分配内存</td>
<td>&#x2F;</td>
<td>其他类型</td>
<td>直接使用Native Memory</td>
<td>可能抛出<code>OutOfMemoryError</code>异常</td>
<td>有两类：<br/>1）JDK提供的JNI API，比如<code>sun.misc.Unsafe</code>类下的<code>public native long allocateMemory(long var1)</code>方法；<br/>2）自己实现的JNI方法<br/><br/>使用过程中需要显式声明和释放内存，否则会有内存泄漏。<br/><br/><font color='red'>有必要再介绍一个特殊的内存区域——直接内存，其英文名为Direct Memory，它是NIO引入的新机制，本质是调用<code>sun.misc.Unsafe.allocateMemory</code>JNI API而直接使用Native Memory，再作了一定封装，被特别命名为直接内存</font></td>
</tr>
</tbody></table>
<h2 id="三、内存溢出异常实验"><a href="#三、内存溢出异常实验" class="headerlink" title="三、内存溢出异常实验"></a><strong>三、内存溢出异常实验</strong></h2><h3 id="3-1、Java虚拟机栈和本地方法栈OutOfMemoryError和StackOverflowError异常"><a href="#3-1、Java虚拟机栈和本地方法栈OutOfMemoryError和StackOverflowError异常" class="headerlink" title="3.1、Java虚拟机栈和本地方法栈OutOfMemoryError和StackOverflowError异常"></a><strong>3.1、Java虚拟机栈和本地方法栈<code>OutOfMemoryError</code>和<code>StackOverflowError</code>异常</strong></h3><h4 id="3-1-1、测试代码"><a href="#3-1-1、测试代码" class="headerlink" title="3.1.1、测试代码"></a><strong>3.1.1、测试代码</strong></h4><p>测试<code>OutOfMemoryError</code>异常代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试OutOfMemoryError异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doNotStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createThreadForever</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    doNotStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">        oom.createThreadForever();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>测试<code>StackOverflowError</code>异常代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试StackOverflowError异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recurseExecution</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line"></span><br><span class="line">        recurseExecution();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackSOF</span> <span class="variable">sof</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sof.recurseExecution();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length: &quot;</span> + sof.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2、执行"><a href="#3-1-2、执行" class="headerlink" title="3.1.2、执行"></a><strong>3.1.2、执行</strong></h4><p>测试<code>OutOfMemoryError</code>异常执行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac JavaVMStackOOM.java</span><br><span class="line">java -Xss200m JavaVMStackOOM &gt; execution.out.2 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">        at java.lang.Thread.start0(Native Method)</span><br><span class="line">        at java.lang.Thread.start(Thread.java:717)</span><br><span class="line">        at JavaVMStackOOM.createThreadForever(JavaVMStackOOM.java:19)</span><br><span class="line">        at JavaVMStackOOM.main(JavaVMStackOOM.java:25)</span><br></pre></td></tr></table></figure>

<br/>

<p>测试<code>StackOverflowError</code>异常执行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac JavaVMStackSOF.java</span><br><span class="line">java -Xss256k JavaVMStackSOF &gt; execution.out 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack length: 3167</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">        at JavaVMStackSOF.recurseExecution(JavaVMStackSOF.java:10)</span><br><span class="line">        at JavaVMStackSOF.recurseExecution(JavaVMStackSOF.java:10)</span><br><span class="line">        at JavaVMStackSOF.recurseExecution(JavaVMStackSOF.java:10)</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<h4 id="3-1-3、说明"><a href="#3-1-3、说明" class="headerlink" title="3.1.3、说明"></a><strong>3.1.3、说明</strong></h4><p>根据上述可知，一个Java线程最多可关联两个栈——Java虚拟机栈和本地方法栈，分别存储“Java方法执行时创建的栈帧”和“本地方法执行时创建的栈帧”，但是<font color='red'>在HotSpot虚拟机实现中，不区分Java虚拟机栈和本地方法栈，故此时一个线程只会关联一个栈，该栈同时存储以上两种栈帧</font>。</p>
<p>本文是基于HotSpot虚拟机实现进行说明的，故后续统一以“栈”作为称呼。</p>
<p>关于栈的<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常作几点说明如下：</p>
<ul>
<li>栈的大小通过“-Xss”虚拟机参数设定</li>
<li>栈是线程私有的，因此当N个线程申请栈时，就需要<code>N *（Xss虚拟机参数设定值）</code>内存，如果内存不足，则会抛出<code>OutOfMemoryError</code>异常</li>
<li>假定一个栈帧大小为S，当一个栈内需要分配K个栈帧（栈帧数量只跟方法调用深度有关）时，如果<code>S * K &gt; Xss虚拟机参数设定值</code>，则抛出<code>StackOverflowError</code>异常</li>
</ul>
<h3 id="3-2、Java堆OutOfMemoryError异常"><a href="#3-2、Java堆OutOfMemoryError异常" class="headerlink" title="3.2、Java堆OutOfMemoryError异常"></a><strong>3.2、Java堆<code>OutOfMemoryError</code>异常</strong></h3><h4 id="3-2-1、测试代码"><a href="#3-2-1、测试代码" class="headerlink" title="3.2.1、测试代码"></a><strong>3.2.1、测试代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、执行"><a href="#3-2-2、执行" class="headerlink" title="3.2.2、执行"></a><strong>3.2.2、执行</strong></h4><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac HeapOOM.java</span><br><span class="line">java -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError HeapOOM</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid2927.hprof ...</span><br><span class="line">Heap dump file created [27538433 bytes in 0.310 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">        at java.util.ArrayList.grow(ArrayList.java:267)</span><br><span class="line">        at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)</span><br><span class="line">        at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)</span><br><span class="line">        at java.util.ArrayList.add(ArrayList.java:464)</span><br><span class="line">        at HeapOOM.main(HeapOOM.java:13)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3、说明"><a href="#3-2-3、说明" class="headerlink" title="3.2.3、说明"></a><strong>3.2.3、说明</strong></h4><p>通过“-Xms20m”和“-Xmx20m”虚拟机参数设定Java堆大小为固定的20MB，避免自动扩展；通过“-XX:+HeapDumpOnOutOfMemoryError”虚拟机参数设定使用Java堆出现<code>OutOfMemoryError</code>异常时，自动Dump出堆转储快照，以便事后分析。<br>Java堆的<code>OutOfMemoryError</code>异常后面还跟有提示信息：Java heap space，表明异常发生于使用“Java堆”的过程中。</p>
<h3 id="3-3、方法区OutOfMemoryError异常"><a href="#3-3、方法区OutOfMemoryError异常" class="headerlink" title="3.3、方法区OutOfMemoryError异常"></a><strong>3.3、方法区<code>OutOfMemoryError</code>异常</strong></h3><h4 id="3-3-1、测试代码"><a href="#3-3-1、测试代码" class="headerlink" title="3.3.1、测试代码"></a><strong>3.3.1、测试代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span></span><br><span class="line">                        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2、执行命令"><a href="#3-3-2、执行命令" class="headerlink" title="3.3.2、执行命令"></a><strong>3.3.2、执行命令</strong></h4><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp &quot;.:./cglib-3.2.4.jar:./asm-5.1.jar&quot; JavaMethodAreaOOM.java</span><br><span class="line"></span><br><span class="line">java -cp &quot;.:./cglib-3.2.4.jar:./asm-5.1.jar&quot; -XX:MaxMetaspaceSize=10m JavaMethodAreaOOM</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">        at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)</span><br><span class="line">        at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)</span><br><span class="line">        at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:114)</span><br><span class="line">        at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)</span><br><span class="line">        at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)</span><br><span class="line">        at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)</span><br><span class="line">        at JavaMethodAreaOOM.main(JavaMethodAreaOOM.java:20)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3、说明"><a href="#3-3-3、说明" class="headerlink" title="3.3.3、说明"></a><strong>3.3.3、说明</strong></h4><p>由以上描述可知，方法区存储已被虚拟机加载的类信息，即时编译器编译以后的代码等数据，通过CGLIB库提供的字节码操作技术，我们可以在运行时动态生成大量的新类，从而使得方法区的内存不够分配，最终导致抛出<code>OutOfMemoryError</code>异常。<br>JDK 8使用“元空间”实现方法区，可通过JVM参数“-XX:MaxMetaspaceSize”配置元空间的最大值。以上例子中，抛出的<code>OutOfMemoryError</code>异常后面还跟有提示信息：Metaspace，表明异常发生于使用“元空间”的过程中。</p>
<h3 id="3-4、直接内存OutOfMemoryError异常"><a href="#3-4、直接内存OutOfMemoryError异常" class="headerlink" title="3.4、直接内存OutOfMemoryError异常"></a><strong>3.4、直接内存<code>OutOfMemoryError</code>异常</strong></h3><h4 id="3-4-1、测试代码"><a href="#3-4-1、测试代码" class="headerlink" title="3.4.1、测试代码"></a><strong>3.4.1、测试代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);</span><br><span class="line">            buffers.add(bb);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">//为了便于观察，休眠1s</span></span><br><span class="line"></span><br><span class="line">            System.out.println(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2、执行"><a href="#3-4-2、执行" class="headerlink" title="3.4.2、执行"></a><strong>3.4.2、执行</strong></h4><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac DirectMemoryOOM.java</span><br><span class="line">java -XX:MaxDirectMemorySize=10m DirectMemoryOOM</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">        at java.nio.Bits.reserveMemory(Bits.java:695)</span><br><span class="line">        at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">        at DirectMemoryOOM.main(DirectMemoryOOM.java:12)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-3、说明"><a href="#3-4-3、说明" class="headerlink" title="3.4.3、说明"></a><strong>3.4.3、说明</strong></h4><p>可通过JVM参数“-XX:MaxDirectMemory”配置直接内存的最大值，以上例子中，抛出的<code>OutOfMemoryError</code>异常后面还跟有提示信息：Direct buffer memory，表明异常发生于使用“直接内存”的过程中。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://www.ibm.com/developerworks/library/j-nativememory-linux/">http://www.ibm.com/developerworks/library/j-nativememory-linux/</a><br>[2]<a href="https://geosmart.github.io/2016/03/07/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/">https://geosmart.github.io/2016/03/07/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</a><br>[3]<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html</a><br>[4]<a href="https://openjdk.java.net/jeps/122">https://openjdk.java.net/jeps/122</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM进程概述</title>
    <url>/blog/2018/09/22/JVM%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、JVM进程创建"><a href="#一、JVM进程创建" class="headerlink" title="一、JVM进程创建"></a><strong>一、JVM进程创建</strong></h2><p>编译JVM语言（比如“Java”，“Groovy”，“Scala”，“Kotlin”，“Clojure”，“Jython”，“JRuby”等）源代码 ——&gt; 字节码 ——&gt; 运行创建JVM进程。</p>
<h2 id="二、JVM进程内部机制"><a href="#二、JVM进程内部机制" class="headerlink" title="二、JVM进程内部机制"></a><strong>二、JVM进程内部机制</strong></h2><p>关于JVM进程内部机制，有以下几点描述：</p>
<ul>
<li>为充分利用JVM进程内存，设计了JVM进程内存模型（即包括有“堆”，“虚拟机栈”，“方法区”等内存区域）。<font color='red'>因此，“Scala”等非“Java”的JVM语言源代码编译运行创建生成的JVM进程跟“Java”语言源代码编译运行创建生成的JVM进程具有完全一致的内存模型</font></li>
<li>运行内存管理子模块</li>
<li>运行类加载子模块</li>
<li>运行JIT编译器</li>
<li>…</li>
</ul>
<h2 id="三、与JVM进程交互的命令工具"><a href="#三、与JVM进程交互的命令工具" class="headerlink" title="三、与JVM进程交互的命令工具"></a><strong>三、与JVM进程交互的命令工具</strong></h2><p>与JVM进程交互的命令工具有：jps，jmap，jstack等。</p>
<h2 id="四、JVM进程运行监控与问题定位"><a href="#四、JVM进程运行监控与问题定位" class="headerlink" title="四、JVM进程运行监控与问题定位"></a><strong>四、JVM进程运行监控与问题定位</strong></h2><p>须注意，在Linux下，“JVM进程”本质上是“Linux进程”，因此，对于“JVM进程运行监控与问题定位”，本质上包括“JVM进程特定运行监控与问题定位”和“Linux进程运行监控与问题定位”。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java中日期时间相关核心类</title>
    <url>/blog/2018/08/13/Java%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="一、日期时间基本概念"><a href="#一、日期时间基本概念" class="headerlink" title="一、日期时间基本概念"></a><strong>一、日期时间基本概念</strong></h2><p>对于日期时间，首先作以下几点基本说明：</p>
<ul>
<li>日期时间涉及到“年，月，日，时，分，秒，毫秒，时区”8个部分，当且仅当“年，月，日，时，分，秒，毫秒，时区”8个部分都明确时，才唯一可确定一个日期时间</li>
<li>只有在明确“时区”的前提下，谈论“年，月，日，时，分，秒，毫秒”才有意义，即：脱离“时区”，谈论“年，月，日，时，分，秒，毫秒”毫无意义</li>
<li>两个日期时间等价当且仅当这两个日期时间与某个基准日期时间的毫秒差值相等，一般选取“1970-01-01 00:00:00.000 GMT+00:00”作为基准日期时间，一个日期时间与该基准日期时间的毫秒差值称为“基准偏移量”。比如“2018-12-10 07:30:20.500 GMT+05:00”和“2018-12-10 08:30:20.500 GMT+06:00”这两个日期时间等价，它们与“1970-01-01 00:00:00.000 GMT+00:00”基准日期时间的毫秒差值都为“1544409020500”，即“基准偏移量”都为“1544409020500”。<font color='red'>日期时间的时区转换是一个等价转换，内部基于“基准偏移量”进行计算</font></li>
</ul>
<h2 id="二、Java中日期时间相关核心类"><a href="#二、Java中日期时间相关核心类" class="headerlink" title="二、Java中日期时间相关核心类"></a><strong>二、Java中日期时间相关核心类</strong></h2><p>Java中日期时间相关核心类有4个：TimeZone，Date，SimpleDateFormat，Calendar。<br><font color='red'>通过实际使用可发现“JDK1.8前的日期时间相关类设计极度糟糕”的论断是真的（比如“Calendar类的使用”，“从日期时间字符串获取时区信息”等），因此，推荐使用Joda-Time第三方库或者JDK1.8后的日期时间相关类。</font></p>
<h3 id="2-1、TimeZone"><a href="#2-1、TimeZone" class="headerlink" title="2.1、TimeZone"></a><strong>2.1、TimeZone</strong></h3><h4 id="2-1-1、基本介绍"><a href="#2-1-1、基本介绍" class="headerlink" title="2.1.1、基本介绍"></a><strong>2.1.1、基本介绍</strong></h4><p>表示时区对象。</p>
<h4 id="2-1-2、常用方法"><a href="#2-1-2、常用方法" class="headerlink" title="2.1.2、常用方法"></a><strong>2.1.2、常用方法</strong></h4><p><strong>1、getTimeZone(String ID)</strong><br>获取时区对象，推荐以时区的“IANA别名”或者“自定义ID”表示“ID”，而不要以“英文别名缩略”表示，原因参见<a href="/blog/2018/09/07/%E6%97%B6%E5%8C%BA/" title="时区">时区</a>。<br>时区的“IANA别名”可通过<code>TimeZone.getAvailableIDs()</code>方法获取，也可通过网络查询获取。<br>“自定义ID”的格式描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CustomID:</span><br><span class="line">        GMT Sign Hours : Minutes</span><br><span class="line">        GMT Sign Hours Minutes</span><br><span class="line">        GMT Sign Hours</span><br><span class="line">Sign: </span><br><span class="line">        one of + -</span><br><span class="line">Hours:</span><br><span class="line">        Digit</span><br><span class="line">        Digit Digit</span><br><span class="line">Minutes:</span><br><span class="line">        Digit Digit</span><br><span class="line">Digit: </span><br><span class="line">        one of 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>“自定义ID”规范化后的格式描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NormalizedCustomID:</span><br><span class="line">        GMT Sign TwoDigitHours : Minutes</span><br><span class="line">Sign: </span><br><span class="line">        one of + -</span><br><span class="line">TwoDigitHours:</span><br><span class="line">        Digit Digit</span><br><span class="line">Minutes:</span><br><span class="line">        Digit Digit</span><br><span class="line">Digit: </span><br><span class="line">        one of 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="2-2、Date"><a href="#2-2、Date" class="headerlink" title="2.2、Date"></a><strong>2.2、Date</strong></h3><h4 id="2-2-1、基本介绍"><a href="#2-2-1、基本介绍" class="headerlink" title="2.2.1、基本介绍"></a><strong>2.2.1、基本介绍</strong></h4><p>Java日期时间体系核心对象，时区固定为<code>TimeZone.getDefaultRef()</code>方法值所表示时区，即“操作系统所配置使用时区”。</p>
<h4 id="2-2-2、常用方法"><a href="#2-2-2、常用方法" class="headerlink" title="2.2.2、常用方法"></a><strong>2.2.2、常用方法</strong></h4><p><strong>1、Date()</strong><br>创建一个表示当前日期时间的Date对象。<br><strong>2、Date(long date)</strong><br>创建一个Date对象，该Date对象所表示日期时间的“基准偏移量”为<code>date</code>。<br><strong>3、getTime()</strong><br>返回该Date对象所表示日期时间的“基准偏移量”。<br><strong>4、setTime(long time)</strong><br>设置该Date对象所表示日期时间的“基准偏移量”为<code>time</code>。</p>
<h3 id="2-3、SimpleDateFormat"><a href="#2-3、SimpleDateFormat" class="headerlink" title="2.3、SimpleDateFormat"></a><strong>2.3、SimpleDateFormat</strong></h3><h4 id="2-3-1、基本介绍"><a href="#2-3-1、基本介绍" class="headerlink" title="2.3.1、基本介绍"></a><strong>2.3.1、基本介绍</strong></h4><p>格式化Date对象到日期时间字符串，从日期时间字符串解析获取Date对象。</p>
<p><strong>备注：</strong><br>通过传入Locale对象参数，设定日期时间字符串的语系环境。<br>示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">formatter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MMM-dd HH:mm:ss.SSS ZZZ&quot;</span>, Locale.ENGLISH);</span><br><span class="line">        System.out.println(formatter1.format(date));</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">formatter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MMM-dd HH:mm:ss.SSS ZZZ&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(formatter2.format(date));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-Aug-22 22:23:24.086 +0800</span><br><span class="line">2018-八月-22 22:23:24.086 +0800</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2、常用方法"><a href="#2-3-2、常用方法" class="headerlink" title="2.3.2、常用方法"></a><strong>2.3.2、常用方法</strong></h4><p><strong>1、format(Date date)</strong><br>格式化Date对象到日期时间字符串，涉及到“年，月，日，时，分，秒，毫秒，时区”。<br><strong>2、parse(String source)</strong><br>解析日期时间字符串获取Date对象，涉及到“年，月，日，时，分，秒，毫秒，时区”。<br><strong>3、setTimeZone(TimeZone zone)</strong><br>格式化时，设置目标时区；解析时，设置源时区。</p>
<h3 id="2-4、Calendar"><a href="#2-4、Calendar" class="headerlink" title="2.4、Calendar"></a><strong>2.4、Calendar</strong></h3><h4 id="2-4-1、基本介绍"><a href="#2-4-1、基本介绍" class="headerlink" title="2.4.1、基本介绍"></a><strong>2.4.1、基本介绍</strong></h4><p>用来操纵Date对象。<br>Calendar类是一个设计极度糟糕的类，要想获得预期结果必须严格管控方法是否调用和调用顺序，比如：</p>
<ul>
<li>在Calendar类内部完成所表示日期时间的计算之前，调用<code>setTimeZone(TimeZone value)</code>方法所设置的时区会参与后续日期时间的计算；否则，所设置的时区不会参与已经完成的日期时间的计算，而仅仅表示等价的时区转换</li>
<li>调用<code>set(int field, int value)</code>方法会令已经完成的日期时间的计算失效，当后续调用<code>getTimeInMillis()</code>，<code>getTime()</code>等方法时会重新触发日期时间的计算</li>
</ul>
<p>关于上述论述的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f1();</span><br><span class="line">        System.out.println(<span class="string">&quot;f1() result above\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        f2();</span><br><span class="line">        System.out.println(<span class="string">&quot;f2() result above\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        f3();</span><br><span class="line">        System.out.println(<span class="string">&quot;f3() result above\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2018</span>);</span><br><span class="line">        calendar.set(Calendar.MONTH, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">21</span>);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">30</span>);</span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">20</span>);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置的时区参与日期时间的计算</span></span><br><span class="line">        calendar.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;GMT+07:00&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用getTime()方法，触发日期时间的计算</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2018</span>);</span><br><span class="line">        calendar.set(Calendar.MONTH, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">21</span>);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">30</span>);</span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">20</span>);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用getTime()方法，触发日期时间的计算</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置的时区不参与日期时间的计算，只表示转换时区</span></span><br><span class="line">        calendar.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;GMT+07:00&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用getTime()方法，先前已经完成日期时间的计算，不重复触发计算</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2018</span>);</span><br><span class="line">        calendar.set(Calendar.MONTH, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">21</span>);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">10</span>);</span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">30</span>);</span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">20</span>);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用getTime()方法，触发日期时间的计算</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用set(int field, int value)方法，令先前完成的日期时间的计算失效</span></span><br><span class="line">        calendar.set(Calendar.YEAR, <span class="number">2018</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置的时区参与日期时间的计算</span></span><br><span class="line">        calendar.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;GMT+07:00&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用getTime()方法，触发日期时间的计算</span></span><br><span class="line">        System.out.println(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wed Nov 21 11:30:20 CST 2018</span><br><span class="line">f1() result above</span><br><span class="line"></span><br><span class="line">Wed Nov 21 10:30:20 CST 2018</span><br><span class="line">Wed Nov 21 10:30:20 CST 2018</span><br><span class="line">f2() result above</span><br><span class="line"></span><br><span class="line">Wed Nov 21 10:30:20 CST 2018</span><br><span class="line">Wed Nov 21 11:30:20 CST 2018</span><br><span class="line">f3() result above</span><br></pre></td></tr></table></figure>
<p>因此，为减少使用错误，须拟订Calendar类的使用规范。<br>首先，关于Calendar类的使用有以下几点描述：</p>
<ul>
<li>当且仅当Calendar类完成内部计算之后，Calendar类才能确定一个日期时间，准确地来说是确定一个“基准偏移量”</li>
<li>调用<code>setTime(Date date)</code>方法，即时完成内部计算，确定日期时间</li>
<li>调用<code>setTimeInMillis(long millis)</code>方法，即时完成内部计算，确定日期时间</li>
<li>调用一系列<code>set(int field, int value)</code>和<code>setTimeZone(TimeZone value)</code>方法，预确定日期时间，等待内部计算被触发完成后，真正确定日期时间</li>
<li><code>getTimeInMillis()</code>，<code>getTime()</code>，<code>get(int field)</code>和<code>getTimeZone()</code>这4个方法获取日期时间相关值。其中，<code>getTimeInMillis()</code>，<code>getTime()</code>和<code>get(int field)</code>这3个方法会触发内部计算；<code>getTimeZone()</code>方法不会触发内部计算，它获取被设置的时区，默认返回操作系统所配置使用时区，否则跟<code>setTimeZone(TimeZone value)</code>方法设置的时区一致</li>
<li><code>setTimeZone(TimeZone value)</code>方法设置时区，在完成内部计算之前调用，所设置时区参与内部计算；否则，不参与内部计算，只用于等价的时区转换，此时该方法的调用效果只影响这里正在讨论的<code>getTimeZone()</code>和<code>get(int field)</code>方法。<font color='red'>等价的时区转换不是Calendar类的主线应用场景（通过SimpleDateFormat类的<code>format(Date date)</code>方法完成等价的时区转换任务），因此禁止在完成内部计算之后调用<code>setTimeZone(TimeZone value)</code>方法</font></li>
</ul>
<p>根据上述描述，拟订Calendar类的使用规范：</p>
<ul>
<li><font color='red'>先设置，再获取。禁止获取之后再设置</font></li>
<li>设置有3条线，分别为：1）<code>setTime(Date date)</code>；2）<code>setTimeInMillis(long millis)</code>;3）<code>set(int field, int value)</code>，<code>setTimeZone(TimeZone value)</code></li>
<li>获取线为：<code>getTime()</code>，<code>getTimeInMillis()</code>，<code>get(int field)</code>和<code>getTimeZone()</code></li>
</ul>
<p>示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180813-0-1.svg"></p>
<h4 id="2-4-2、常用方法"><a href="#2-4-2、常用方法" class="headerlink" title="2.4.2、常用方法"></a><strong>2.4.2、常用方法</strong></h4><p><strong>1、getInstance()</strong><br>获取Calendar实例对象。<br><strong>2、setTime(Date date)</strong><br>Calendar内部日期时间对象直接设置为等价于<code>date</code>。<br><strong>3、setTimeInMillis(long millis)</strong><br>Calendar内部日期时间对象的“基准偏移量”直接设置为<code>millis</code>。<br><strong>4、set(int field, int value)</strong><br>显式设置“年，月，日，时，分，秒，毫秒”7个部分值。<br><strong>5、setTimeZone(TimeZone value)</strong><br>显式设置“时区”值。<br><strong>6、getTime()</strong><br>如果未完成内部计算，触发内部计算。获取对应于内部计算后所得日期时间的Date对象。<br><strong>7、getTimeInMillis()</strong><br>如果未完成内部计算，触发内部计算。获取对应于内部计算后所得日期时间的“基准偏移量”。<br><strong>8、get(int field)</strong><br>如果未完成内部计算，触发内部计算。获取对应于内部计算后所得日期时间的“年，月，日，时，分，秒，毫秒”值。<br><strong>9、getTimeZone()</strong><br>不触发内部计算。获取被设置的时区，默认返回操作系统所配置使用时区，否则跟<code>setTimeZone(TimeZone value)</code>方法设置的时区一致。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、4个核心类之间的关系示意图"><a href="#3-1、4个核心类之间的关系示意图" class="headerlink" title="3.1、4个核心类之间的关系示意图"></a><strong>3.1、4个核心类之间的关系示意图</strong></h3><p>“TimeZone，Date，SimpleDateFormat，Calendar”4个核心类之间的关系示意图如图2。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20180813-0-2.svg"></p>
<h3 id="3-2、对日期时间操作的基本思路"><a href="#3-2、对日期时间操作的基本思路" class="headerlink" title="3.2、对日期时间操作的基本思路"></a><strong>3.2、对日期时间操作的基本思路</strong></h3><p><strong>1、操作维度为“时区”</strong><br>这里所指“对日期时间操作”包括：对某个日期时间进行时区的等价转换。<br>上述对日期时间操作的基本思路是：由于Date对象默认所使用时区为“操作系统所配置使用时区”，因此如果要进行时区的等价转换，转换的目标对象一般不能是Date对象，而是日期时间字符串，那么很自然可推得这个等价转换是借助于“SimpleDateFormat”类，通过“SimpleDateFormat”类的<code>setTimeZone(TimeZone zone)</code>方法设置转换的目标时区。<br>示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss Z&quot;</span>);</span><br><span class="line">        format.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;GMT+07:00&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(format.format(now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wed Aug 29 03:24:16 CST 2018</span><br><span class="line">2018-08-29 02:24:16 +0700</span><br></pre></td></tr></table></figure>
<p><strong>2、操作维度为“日，时，分，秒，毫秒”</strong><br>这里所指“对日期时间操作”包括：对某个日期时间增加或者减少N日&#x2F;时&#x2F;分&#x2F;秒&#x2F;毫秒，计算两个日期时间之间间隔的日&#x2F;时&#x2F;分&#x2F;秒&#x2F;毫秒。<br>上述对日期时间操作的基本思路是：基于“基准偏移量”，然后再根据“1日&#x3D;24时&#x3D;24*60分&#x3D;24*60*60秒&#x3D;24*60*60*1000毫秒”的换算公式。<br><strong>3、操作维度为“年，月”</strong><br>这里所指“对日期时间操作”包括：对某个日期时间增加或者减少N年&#x2F;月，计算两个日期时间之间间隔的年&#x2F;月。<br>由于年&#x2F;月不能换算成精确的N日&#x2F;时&#x2F;分&#x2F;秒&#x2F;毫秒，因此相关操作的实现方案也是不精确的，常见有两种实现方案：</p>
<ul>
<li>基于“基准偏移量”，然后再采用“1年&#x3D;365日”和“1月&#x3D;30日”这两个不精确的换算公式</li>
<li>直接增加或者减少年&#x2F;月字段或者直接计算年&#x2F;月字段之间的差值，这是显而易见不精确的，比如“2018-01-31增加1个月后的2018-02-31不存在”，“2018-01-31 23:59:59与2018-02-01 00:00:00之间的月字段差值为1个月而实际只差1秒”等</li>
</ul>
<p>其实，实际中一般也不多见以“年，月”为操作维度的对日期时间操作。</p>
<br/>
参考文献：
[1]https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html
[2]https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中绕过语法限制的途径</title>
    <url>/blog/2020/10/10/Java%E4%B8%AD%E7%BB%95%E8%BF%87%E8%AF%AD%E6%B3%95%E9%99%90%E5%88%B6%E7%9A%84%E9%80%94%E5%BE%84/</url>
    <content><![CDATA[<p>对于Java语言，存在一些途径可绕过语法限制，有些途径是官方的，有些途径是非官方的，下表罗列一些途径。</p>
<table>
<thead>
<tr>
<th>途径名称</th>
<th>官方&#x2F;非官方</th>
<th>绕过的语法限制</th>
</tr>
</thead>
<tbody><tr>
<td>反射</td>
<td>官方</td>
<td>“不可访问的<code>方法</code>和<code>域</code>可访问化”，“能够对final域进行二次赋值”等</td>
</tr>
<tr>
<td>JDK序列化</td>
<td>官方</td>
<td>能够对final域进行二次赋值（本质是通过反射实现的）</td>
</tr>
<tr>
<td>官方原生方法</td>
<td>官方</td>
<td>理论上可以对Java进程所占有的内存做任何操作，比如“通过<code>System.setIn()</code>，<code>System.setOut()</code>和<code>System.setErr()</code>方法修改System类的<code>in</code>，<code>out</code>和<code>err</code>这3个<code>public final static</code>变量”</td>
</tr>
<tr>
<td>非官方原生方法</td>
<td>非官方</td>
<td>理论上可以对Java进程所占有的内存做任何操作</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5.1</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存泄漏</title>
    <url>/blog/2018/12/31/Java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>Java中引入了垃圾回收机制，为何还会出现内存泄漏？<br>接下来通过例子进行说明。</p>
<h2 id="一、Map，List等集合对象导致内存泄漏"><a href="#一、Map，List等集合对象导致内存泄漏" class="headerlink" title="一、Map，List等集合对象导致内存泄漏"></a><strong>一、Map，List等集合对象导致内存泄漏</strong></h2><p>假如Map，List等集合对象处于存活状态，此时如果该集合对象中有些元素（对象的引用）是不再被正常需要的，但是由于某些原因这些元素并未被从集合对象中删除，进而导致相应的对象不能被垃圾回收，那么就出现了内存泄漏。</p>
<h2 id="二、本地方法分配内存导致内存泄漏"><a href="#二、本地方法分配内存导致内存泄漏" class="headerlink" title="二、本地方法分配内存导致内存泄漏"></a><strong>二、本地方法分配内存导致内存泄漏</strong></h2><p>比如C&#x2F;C++语言实现的本地方法中使用<code>malloc</code>方法分配内存，如果未进行显式回收就会出现内存泄漏。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java内记录代码块执行时间最佳实践</title>
    <url>/blog/2016/08/12/Java%E5%86%85%E8%AE%B0%E5%BD%95%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、计时点名称必须具有可读性"><a href="#一、计时点名称必须具有可读性" class="headerlink" title="一、计时点名称必须具有可读性"></a><strong>一、计时点名称必须具有可读性</strong></h2><p>计时点名称必须具有可读性，制订如下两条原则：</p>
<ol>
<li>开始计时点名称与相应的结束计时点名称具有一致性，比如“s0和e0”，“s00和e00”</li>
<li>层次结构计时点的名称体现层次性，比如“s，s0，s00”</li>
</ol>
<p>例子见示例代码1。</p>
<h2 id="二、时间统计代码与业务逻辑代码进行分隔"><a href="#二、时间统计代码与业务逻辑代码进行分隔" class="headerlink" title="二、时间统计代码与业务逻辑代码进行分隔"></a><strong>二、时间统计代码与业务逻辑代码进行分隔</strong></h2><p>使用“花括号对”对时间统计代码与业务逻辑代码进行分隔，具体是：开始计时点紧邻一个左花括号而开始，相应的结束计时点紧邻相应的右花括号而结束，该“&lt;开始计时点，结束计时点&gt;对”负责统计的业务逻辑代码块置于上述“&lt;左花括号，右花括号&gt;对”之间。<br>例子见示例代码1。</p>
<p>示例代码1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public void executionTimeRecordExample() &#123;</span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        &#123;</span><br><span class="line">            long s0 = System.currentTimeMillis();</span><br><span class="line">            &#123;</span><br><span class="line">                long s00 = System.currentTimeMillis();</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                long e00 = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">            long e0 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            long s1 = System.currentTimeMillis();</span><br><span class="line">            &#123;</span><br><span class="line">                long s10 = System.currentTimeMillis();</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                long e10 = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">            long e1 = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        long e = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、禁止“一对多”关系"><a href="#三、禁止“一对多”关系" class="headerlink" title="三、禁止“一对多”关系"></a><strong>三、禁止“一对多”关系</strong></h2><p>禁止复用计时点，导致产生“一对多”关系，如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160812-0-1.png"></p>
<p>这会导致代码可读性变差，使用“花括号对”对时间统计代码与业务逻辑代码进行分隔也不再可行，而且你很快就会丢失“所统计时间区间的逻辑含义”信息。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void example() &#123;</span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 代码块</span><br><span class="line">            long e0 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;In normal process,it takes &quot; + (e0 - s) + &quot; ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // 代码块</span><br><span class="line">            long e1 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;In normal and exception process,it takes &quot; + (e1 - s) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void example2() &#123;</span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        // 代码块</span><br><span class="line">        long e0 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Firstly,it takes &quot; + (e0 - s) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        // 代码块</span><br><span class="line">        long e1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Secondly,it takes &quot; + (e1 - s) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遇到上述情形，应该进行转换，摒除“一对多”关系，如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160812-0-2.png"></p>
<p>针对上述代码，修改后内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void exampleAlter() &#123;</span><br><span class="line">        boolean expFlag = false;</span><br><span class="line"></span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long s0 = System.currentTimeMillis();</span><br><span class="line">                &#123;</span><br><span class="line">                    // 代码块</span><br><span class="line">                &#125;</span><br><span class="line">                long e0 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                if (!expFlag) &#123;</span><br><span class="line">                    System.out.println(&quot;In normal process,it takes &quot; + (e0 - s0) + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 代码块</span><br><span class="line"></span><br><span class="line">                expFlag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long e = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        if (expFlag) &#123;</span><br><span class="line">            System.out.println(&quot;In normal and exception process,it takes &quot; + (e - s) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void example2Alter() &#123;</span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        &#123;</span><br><span class="line">            long s0 = System.currentTimeMillis();</span><br><span class="line">            &#123;</span><br><span class="line">                // 代码块</span><br><span class="line">            &#125;</span><br><span class="line">            long e0 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;Firstly,it takes &quot; + (e0 - s0) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">            // 代码块</span><br><span class="line">        &#125;</span><br><span class="line">        long e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Secondly,it takes &quot; + (e - s) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Java容器</title>
    <url>/blog/2021/06/21/Java%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、Java容器绪论"><a href="#一、Java容器绪论" class="headerlink" title="一、Java容器绪论"></a><strong>一、Java容器绪论</strong></h2><p>Java容器主要包括两类，对应的根接口分别为<code>Map</code>和<code>Collection</code>。<br><code>Collection</code>又主要包括3类，对应的根接口分别为<code>List</code>，<code>Queue</code>和<code>Set</code>。</p>
<p><code>Map</code>、<code>List</code>、<code>Queue</code>和<code>Set</code>又都有“并发”和“非并发（普通）”之分。在并发容器中，如果简单粗暴使用<code>synchronized</code>实现操作的线程安全，该并发容器又可被称为“同步容器”。</p>
<p>故Java容器划分示意图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210621-0-0.svg"></p>
<h2 id="二、一些说明"><a href="#二、一些说明" class="headerlink" title="二、一些说明"></a><strong>二、一些说明</strong></h2><h3 id="2-1、Collection接口的迭代器"><a href="#2-1、Collection接口的迭代器" class="headerlink" title="2.1、Collection接口的迭代器"></a><strong>2.1、Collection接口的迭代器</strong></h3><p><code>Collection</code>接口继承<code>Iterable</code>接口，因此其有<code>Iterator&lt;E&gt; iterator()</code>方法生成迭代器。<br>迭代器的主要方法如下：</p>
<ul>
<li><code>boolean hasNext()</code>：是否存在下一个待遍历元素</li>
<li><code>E next()</code>：下一个待遍历元素</li>
<li><code>void remove()</code>：删除最近一个已遍历元素</li>
</ul>
<p>假设Collection实例为A，其生成的迭代器实例为B，一段时间内同时使用A和B进行操作（逻辑同时，指“使用A后再使用B”或者“使用B后再使用A”，故可以是多线程的，也可以是单线程的），根据“在A上修改后B的表现”和“在B上修改后A的表现”可将迭代器分为4类：快速失败、快照式、弱一致性和其他。</p>
<p>具体描述如下表。</p>
<table>
<thead>
<tr>
<th>迭代器类型</th>
<th>描述</th>
<th>在A上修改后B的表现</th>
<th>在B上修改（迭代器的修改操作只有<code>remove()</code>）后A的表现</th>
</tr>
</thead>
<tbody><tr>
<td>快速失败</td>
<td>fail-fast</td>
<td>抛出<code>ConcurrentModificationException</code>异常</td>
<td>具体实现具体定义。比如“ArrayList对应迭代器的<code>remove()</code>方法实现是转发调用外围ArrayList实例的<code>remove(int index)</code>方法”</td>
</tr>
<tr>
<td>快照式</td>
<td>snapshot，在创建生成迭代器时，复制一份内容，故后续两边的操作互相独立</td>
<td>不抛出异常，通过B不能感知A上修改</td>
<td>通过A不能感知B上修改</td>
</tr>
<tr>
<td>弱一致性</td>
<td>weakly consistent</td>
<td>不抛出异常，通过B不一定能够感知A上的修改，即便能够感知，也不一定是准确一致的，比如“有ArrayBlockingQueue实例A，其对应的迭代器实例为B，调用B的<code>hasNext()</code>方法返回true，后续再调用B的<code>next()</code>方法必返回一个元素，如果此时通过A已经删除该元素，则产生不一致”</td>
<td>通过A不一定能够感知B上的修改，即便能够感知，也不一定是准确一致的</td>
</tr>
<tr>
<td>其他</td>
<td>undefined</td>
<td>未定义</td>
<td>未定义</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zhuanlan.zhihu.com/p/300162795">https://zhuanlan.zhihu.com/p/300162795</a><br>[2]<a href="https://blog.csdn.net/yuanlaijike/article/details/108177720">https://blog.csdn.net/yuanlaijike/article/details/108177720</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>Java堆</title>
    <url>/blog/2022/01/16/Java%E5%A0%86/</url>
    <content><![CDATA[<p>本文默认基于64位的JDK 8（其虚拟机实现是HotSpot），除非特别说明。</p>
<p>Java堆内有：Java对象、字符串常量池、包装器类常量池等。</p>
<h2 id="一、Java对象"><a href="#一、Java对象" class="headerlink" title="一、Java对象"></a><strong>一、Java对象</strong></h2><p>参见<a href="/blog/2022/01/26/Java%E5%AF%B9%E8%B1%A1/" title="Java对象">《Java对象》</a>。</p>
<h2 id="二、字符串常量池"><a href="#二、字符串常量池" class="headerlink" title="二、字符串常量池"></a><strong>二、字符串常量池</strong></h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a><strong>2.1、概念</strong></h3><p>字符串常量池，英文名称为“String Literal Pool”或者“String Constant Pool”，几点基本说明：</p>
<ul>
<li>处于Java堆中，是为了复用String实例对象（在Java语言中，String实例对象不可修改，因此，既能节省内存又不至于引入并发修改等问题）而设计的一种机制所关联的内存区域</li>
<li>如上所述，“字符串常量池”是一种机制，该机制后续可知本质通过几个Java对象实现，契合“Java对象在Java堆内”</li>
<li><font color='red'>在设计之初，“字符串常量池”逻辑上属于“运行时常量池[1]”，而且他们都放置在方法区，比如在JDK 6中；但是现在前者和后者分别放置于Java堆和方法区，虽然“逻辑上属于”仍然成立，但已经名存实亡，意义不大</font></li>
</ul>
<p>“字符串常量池”的实现原理如下：</p>
<ul>
<li>维护一个String实例对象池P，再维护一个映射对象stringTable，可类比为<code>Map&lt;Integer,List&lt;String&gt;&gt;</code>，其“键”为“String实例对象的<code>hashCode</code>值”，其“键值”为“P内具有对应<code>hashCode</code>值的String实例对象的引用值集合”，图示见图1</li>
<li>与“字符串常量池”交互的唯一途径是通过String类的<code>intern()</code>本地方法（实现原理示意见以下源代码1）[2]：<ul>
<li>只有String实例对象才能调用String类的<code>intern()</code>本地方法，因此，使用“字符串常量池”机制，虽然最终可以复用String实例对象，但是中间过程中生成“临时的String实例对象”在所难免，这些“临时的String实例对象”最后由于“引用不可达”而被垃圾回收</li>
<li>对每一个字符串字面量（如“hello”，“world”等以直接形式给出的字符串），JVM会创建一个String实例对象，然后自动隐式调用其上的<code>intern()</code>方法</li>
</ul>
</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20220116-0-0.png"></p>
<p>源代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; stringTable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intern</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hv</span> <span class="operator">=</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stringTable.get(hv) == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringTable.put(hv, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            stringTable.get(hv).add(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = stringTable.get(hv);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、实验代码"><a href="#2-2、实验代码" class="headerlink" title="2.2、实验代码"></a><strong>2.2、实验代码</strong></h3><p>实验代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringLiteralPoolExp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行时，字符串字面量自动隐式调用“intern()”方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行时，字符串字面量自动隐式调用“intern()”方法，因此a与b指向同一块内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行时，显式调用“intern()”方法，因此a与c指向同一块内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.intern();</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行时，显式调用“intern()”方法，因此a与d指向同一块内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>).intern();</span><br><span class="line">        System.out.println(a == d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行时，“hello”字符串字面量虽然会自动隐式调用“intern()”方法，但是整体“new String(“hello&quot;)”创建一个新的String实例对象，它的内容为“hello”，因此a与e指向不同块内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(a == e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h2 id="三、包装器类常量池"><a href="#三、包装器类常量池" class="headerlink" title="三、包装器类常量池"></a><strong>三、包装器类常量池</strong></h2><h3 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a><strong>3.1、概念</strong></h3><p>包装器类（包括“Boolean，Byte，Character，Short，Integer，Long”，不包括“Float，Double”）常量池，几点基本说明：</p>
<ul>
<li>处于Java堆中，是为了复用包装器类实例对象（在Java语言中，包装器类实例对象不可修改，因此，既能节省内存又不至于引入并发修改等问题）而设计的一种机制所关联的内存区域</li>
<li>如上所述，包装器类常量池是一种机制，该机制后续可知本质通过几个Java对象实现，契合“Java对象在Java堆内”</li>
</ul>
<p>“包装器类常量池”的实现原理如下：</p>
<ul>
<li>维护一个包装器类实例对象池P，再维护一个映射对象，其“键”为“基本类型值”，其“键值”为“基本类型值对应的包装器类实例对象引用值”</li>
<li>与“包装器类常量池”交互的唯一途径是通过包装器类的<code>valueOf(boolean/byte/char/short/int/long)</code>方法（以Integer为例进行说明，实现原理示意见以下源代码2）：<ul>
<li>基本类型（boolean，byte，char，short，int，long）的字面量值在转换为对应的包装器类实例时，会自动隐式调用相应包装器类的<code>valueOf(boolean/byte/char/short/int/long)</code>方法</li>
</ul>
</li>
</ul>
<p>源代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、实验代码"><a href="#3-2、实验代码" class="headerlink" title="3.2、实验代码"></a><strong>3.2、实验代码</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerLiteralPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 查看“Integer.valueOf(int i)”的源代码</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行时，“100”整型字面量会自动隐式调用“Integer.valueOf(int)”方法，因此a与c指向同一块内存</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行时，“100”整型字面量虽然会自动隐式调用“Integer.valueOf(int)”方法，但是整体“new Integer(100)”创建一个新的Integer实例对象，它的值为“100”，因此a与d指向不同块内存</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(a == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、JDK-6中的字符串常量池机制和实现"><a href="#4-1、JDK-6中的字符串常量池机制和实现" class="headerlink" title="4.1、JDK 6中的字符串常量池机制和实现"></a><strong>4.1、JDK 6中的字符串常量池机制和实现</strong></h3><p>JDK 6中的“字符串常量池机制和实现”跟JDK 8中的“字符串常量池机制和实现”相比有很大不同：</p>
<ul>
<li>在JDK 8的“字符串常量池机制和实现”中，“字符串常量池”内存区域处于Java堆中；而在JDK 6的“字符串常量池机制和实现”中，“字符串常量池”内存区域处于方法区中，图示见图2</li>
<li>针对<code>intern()</code>方法的实现逻辑，两者的区别：<ul>
<li>在JDK 8中，如果“字符串常量池”中不存在一个String实例对象与当前String实例对象A的内容相同，那么将A的引用值Aa加入到“字符串常量池”中的stringTable（相当于A被加入到“字符串常量池”），返回Aa；否则返回“字符串常量池”已存在String实例对象的引用值</li>
<li>在JDK 6中，如果“字符串常量池”中不存在一个String实例对象与当前String实例对象A的内容相同，那么在“字符串常量池”中复制新建（<font color='red'>因为分处于“Java堆”和“方法区”</font>）一个String实例对象B，B的内容与A相同，将B的引用值Bb加入到“字符串常量值”中的stringTable，返回Bb；否则返回“字符串常量池”已存在String实例对象的引用值</li>
</ul>
</li>
</ul>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20220116-0-1.png"></p>
<h4 id="4-1-1、证明实验1"><a href="#4-1-1、证明实验1" class="headerlink" title="4.1.1、证明实验1"></a><strong>4.1.1、证明实验1</strong></h4><p>有如下一段代码，分别使用JDK 6和JDK 8执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RuntimeConstantPoolExp &#123;</span><br><span class="line">    private static final String a = &quot;java&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、使用JDK 6执行</strong><br>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>在第一个判断中，由于“str1”指向Java堆中的String实例对象，而“str1.intern()”指向“字符串常量池”中的String实例对象，故而判断结果为“false”。<br>在第二个判断中，由于“str2”指向Java堆中的String实例对象，而“str2.intern()”指向“字符串常量池”中的String实例对象，故而判断结果也为“false”。</p>
<p><strong>2、使用JDK 8执行</strong><br>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>在第一个判断中，由于“str1”和“str1.intern()”都指向Java堆中的同一个String实例对象，故而判断结果为“true”。<br>在第二个判断中，由于“str2”指向Java堆中的String实例A，而“str2.intern()”指向Java堆中的另外一个String实例对象B，B指向的String实例对象在“字符串常量池”中。A和B不同，因为“java”字符串字面量已在之前加载“sun.misc.Version”类时被加载——<code>private static final String launcher_name = &quot;java&quot;;</code>，B指向彼时生成的String实例对象，故而判断结果为“false”。</p>
<h4 id="4-1-2、证明实验2"><a href="#4-1-2、证明实验2" class="headerlink" title="4.1.2、证明实验2"></a><strong>4.1.2、证明实验2</strong></h4><p>另外有如下一段代码，分别使用JDK 6和JDK 8执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class RuntimeConstantPoolOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(String.valueOf(i++).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;now i value is: &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、使用JDK 6执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac RuntimeConstantPoolOOM.java</span><br><span class="line">java -XX:PermSize=10M -XX:MaxPermSize=10M -Xms50m -Xmx50m RuntimeConstantPoolOOM</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">now i value is: 124018</span><br></pre></td></tr></table></figure>

<p>实验中方法区的内存使用量被设为固定的10M，而“字符串常量池”内存区域属于“方法区”，因此“字符串常量池”内存区域能够使用的内存上限也为10M。因此，当通过<code>String.valueOf(i++).intern()</code>方法不断消耗“字符串常量池”的内存时，最终导致出现“OutOfMemoryError”异常。另外在异常信息中，还提示“PermGen space”，这是因为在JDK 6的HotSpot虚拟机中，使用“永久代”来实现方法区。</p>
<p><strong>2、使用JDK 8执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac RuntimeConstantPoolOOM.java</span><br><span class="line">java -Xms50m -Xmx50m RuntimeConstantPoolOOM</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">now i value is: 792445</span><br></pre></td></tr></table></figure>

<p>实验中Java堆的内存使用量被设为固定的50M，而“字符串常量池”内存区域属于“Java堆”，因此“字符串常量池”内存区域能够使用的内存上限也为50M。因此，当通过<code>String.valueOf(i++).intern()</code>方法不断消耗“字符串常量池”的内存时，最终导致出现“OutOfMemoryError”异常。<br>需要注意的是，这里抛出的是“java.lang.OutOfMemoryError: GC overhead limit exceeded”异常，而不是预期的“java.lang.OutOfMemoryError: Java heap space”异常，它们的本质都是“Java堆内存不足”，只不过是两种表现，抛出以上哪种异常并不能被准确预测。[3]</p>
<h4 id="4-1-3、证明实验3"><a href="#4-1-3、证明实验3" class="headerlink" title="4.1.3、证明实验3"></a><strong>4.1.3、证明实验3</strong></h4><p>现有如下一段代码，分别使用JDK 6和JDK 8执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;hello&quot;);</span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        String s3 = new String(&quot;hello&quot;) + new String(&quot;world&quot;);</span><br><span class="line">        s3.intern();</span><br><span class="line">        String s4 = &quot;helloworld&quot;;</span><br><span class="line"> </span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、使用JDK 6执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>解析说明见下面代码中注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，字符串常量池是方法区的一个逻辑区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“hello”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“hello”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量a保存该String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理“new调用”语句，调用String类构造方法，在Java堆中创建一个String实例对象，String实例对象引用变量s1保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“hello”（即a引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s1.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象），故而s2=a</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1引用到的String实例对象在Java堆中，s2引用到的String实例对象在方法区中，因此，判断结果为“false”</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象）</span></span><br><span class="line">        <span class="comment">// 接着处理字符串字面量“world”，在Java堆中创建一个String实例对象（包含的字符串内容为“world”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“world”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“world”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量b保存该String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理两个“new调用”语句，分别调用String类构造方法，在Java堆中创建两个String实例对象</span></span><br><span class="line">        <span class="comment">// 最后处理“+”语句，在Java堆中创建一个String实例对象，字符串内容为上述两个String实例对象字符串内容（分别为“hello”和“world”）的拼接，即为“helloworld”，String实例对象引用变量s3保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“helloworld”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“helloworld”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量c保存该String实例对象的引用值</span></span><br><span class="line">        s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“helloworld”，在Java堆中创建一个String实例对象（包含的字符串内容为“helloworld”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“helloworld”（即c引用到的String实例对象），故而s4=c</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3引用到的String实例对象在Java堆中，s4引用到的String实例对象在方法区中，因此，判断结果为“false”</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、使用JDK 8执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>解析说明见下面代码中注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在JDK 8中，字符串常量池是Java堆的一个逻辑区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“hello”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量a保存当前String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理“new调用”语句，调用String类构造方法，在Java堆中创建一个String实例对象（该String实例对象跟a引用到的String实例对象虽然都处于Java堆中，但是内存地址不同），String实例对象引用变量s1保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“hello”（即a引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s1.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象），故而s2=a</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由上面说明可知，判断结果为“false”</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象）</span></span><br><span class="line">        <span class="comment">// 接着处理字符串字面量“world”，在Java堆中创建一个String实例对象（包含的字符串内容为“world”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“world”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量b保存当前String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理两个“new调用”语句，分别调用String类构造方法，在Java堆中创建两个String实例对象</span></span><br><span class="line">        <span class="comment">// 最后处理“+”语句，在Java堆中创建一个String实例对象，字符串内容为上述两个String实例对象字符串内容（分别为“hello”和“world”）的拼接，即为“helloworld”，String实例对象引用变量s3保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中不存在一个String实例对象，它所包含的字符串内容为“helloworld”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量c保存当前String实例对象的引用值，且有c=s3</span></span><br><span class="line">        s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“helloworld”，在Java堆中创建一个String实例对象（包含的字符串内容为“helloworld”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“helloworld”（即c引用到的String实例对象），故而s4=c</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由上面说明可知，判断结果为“true”</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4、证明实验4"><a href="#4-1-4、证明实验4" class="headerlink" title="4.1.4、证明实验4"></a><strong>4.1.4、证明实验4</strong></h4><p>现有如下一段代码（它是“4.1.3、证明实验3”中代码的变种），分别使用JDK 6和JDK 8执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;hello&quot;);</span><br><span class="line">        String s2 = &quot;hello&quot;;</span><br><span class="line">        s1.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        String s3 = new String(&quot;hello&quot;) + new String(&quot;world&quot;);</span><br><span class="line">        String s4 = &quot;helloworld&quot;;</span><br><span class="line">        s3.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、使用JDK 6执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>解析说明见下面代码中注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，字符串常量池是方法区的一个逻辑区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“hello”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“hello”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量a保存该String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理“new调用”语句，调用String类构造方法，在Java堆中创建一个String实例对象，String实例对象引用变量s1保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象），故而s2=a</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“hello”（即a引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s1.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1引用到的String实例对象在Java堆中，s2引用到的String实例对象在方法区中，因此，判断结果为“false”</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象）</span></span><br><span class="line">        <span class="comment">// 接着处理字符串字面量“world”，在Java堆中创建一个String实例对象（包含的字符串内容为“world”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“world”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“world”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量b保存该String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理两个“new调用”语句，分别调用String类构造方法，在Java堆中创建两个String实例对象</span></span><br><span class="line">        <span class="comment">// 最后处理“+”语句，在Java堆中创建一个String实例对象，字符串内容为上述两个String实例对象字符串内容（分别为“hello”和“world”）的拼接，即为“helloworld”，String实例对象引用变量s3保存相应引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“helloworld”，在Java堆中创建一个String实例对象（包含的字符串内容为“helloworld”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“helloworld”，因此在字符串常量池中创建一个String实例对象，它所包含的字符串内容为“helloworld”，并在stringTable对象中增加对该String实例对象的引用，假定String实例对象引用变量c保存该String实例对象的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“helloworld”（即c引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3引用到的String实例对象在Java堆中，s4引用到的String实例对象在方法区中，因此，判断结果为“false”</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、使用JDK 8执行</strong><br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>解析说明见下面代码中注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在JDK 8中，字符串常量池是Java堆的一个逻辑区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“hello”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量a保存当前String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理“new调用”语句，调用String类构造方法，在Java堆中创建一个String实例对象（该String实例对象跟a引用到的String实例对象虽然都处于Java堆中，但是内存地址不同），String实例对象引用变量s1保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象），故而s2=a</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“hello”（即a引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s1.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由上面说明可知，判断结果为“false”</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“hello”，在Java堆中创建一个String实例对象（包含的字符串内容为“hello”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中已存在一个String实例对象，它包含的字符串内容为“hello”（即a引用到的String实例对象）</span></span><br><span class="line">        <span class="comment">// 接着处理字符串字面量“world”，在Java堆中创建一个String实例对象（包含的字符串内容为“world”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“world”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量b保存当前String实例对象的引用值</span></span><br><span class="line">        <span class="comment">// 接着处理两个“new调用”语句，分别调用String类构造方法，在Java堆中创建两个String实例对象</span></span><br><span class="line">        <span class="comment">// 最后处理“+”语句，在Java堆中创建一个String实例对象，字符串内容为上述两个String实例对象字符串内容（分别为“hello”和“world”）的拼接，即为“helloworld”，String实例对象引用变量s3保存相应的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先处理字符串字面量“helloworld”，在Java堆中创建一个String实例对象（包含的字符串内容为“helloworld”），然后自动隐式调用其上的“intern()”方法，发现在字符串常量池中不存在一个String实例对象，它包含的字符串内容也为“helloworld”，因此在stringTable对象中增加对当前String实例对象的引用，此时，当前String实例对象其实被放入字符串常量池中，假定String实例对象引用变量c保存当前String实例对象的引用值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用“intern()”方法，字符串常量池中已存在String实例对象，它所包含的字符串内容为“helloworld”（即c引用到的String实例对象），故而没有任何效果</span></span><br><span class="line">        s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由上面说明可知，判断结果为“false”</span></span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、其他"><a href="#4-2、其他" class="headerlink" title="4.2、其他"></a><strong>4.2、其他</strong></h3><ol>
<li>本文的很多描述有很多瑕疵，比如“处理字符串字面量的时机是在加载类文件的过程中，而不是在执行相应代码语句的过程中（如有<code>String a=“hello world”</code>代码语句，处理字符串字面量“hello world”的时机是在加载代码语句所在类文件的过程中，而不是在执行该代码语句的过程中）”等。但是，经过分析和实验可以发现，这些瑕疵，对于我们介绍本文的核心内容并没有很大的负面影响</li>
<li>要想透彻完整了解很多概念，最好的方式还是看JDK的源代码</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2022/01/10/%E6%96%B9%E6%B3%95%E5%8C%BA/" title="方法区">《方法区》</a><br>[2]<code>java.lang.String</code>类中<code>public native String intern()</code>方法的JavaDoc<br>[3]<a href="https://blog.csdn.net/renfufei/article/details/77585294">https://blog.csdn.net/renfufei/article/details/77585294</a><br>[4]<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a><br>[5]<a href="http://java-performance.info/string-intern-in-java-6-7-8/">http://java-performance.info/string-intern-in-java-6-7-8/</a><br>[6]<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html">http://tech.meituan.com/in_depth_understanding_string_intern.html</a><br>[7]<a href="http://blog.csdn.net/u010297957/article/details/50995869">http://blog.csdn.net/u010297957/article/details/50995869</a><br>[8]<a href="http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/index.html">http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/index.html</a><br>[9]<a href="https://jimlife.wordpress.com/2007/08/10/java-constant-pool-string/">https://jimlife.wordpress.com/2007/08/10/java-constant-pool-string/</a><br>[10]<a href="http://www.javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html">http://www.javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>[11]<a href="http://theopentutorials.com/tutorials/java/strings/string-literal-pool/">http://theopentutorials.com/tutorials/java/strings/string-literal-pool/</a><br>[12]<a href="http://www.thejavageek.com/2013/06/19/the-string-constant-pool/">http://www.thejavageek.com/2013/06/19/the-string-constant-pool/</a><br>[13]<a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a><br>[14]<a href="https://www.hollischuang.com/archives/6569">https://www.hollischuang.com/archives/6569</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java对象</title>
    <url>/blog/2022/01/26/Java%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>本文默认基于64位的JDK 8（其虚拟机实现是HotSpot），除非特别说明。</p>
<h2 id="一、Java对象"><a href="#一、Java对象" class="headerlink" title="一、Java对象"></a><strong>一、Java对象</strong></h2><p>Java对象处于Java堆中，Java对象可分为：</p>
<ul>
<li>普通实例对象，比如“java.lang.String类实例对象”，“java.util.List类实例对象”，“me.dslztx.A自定义类实例对象”</li>
<li>数组对象，比如“java.lang.String[]数组对象”，“int[]数组对象”</li>
<li><font color='red'>Class对象，较为特殊，具有两种身份：1）作为一切Java类（当然也包括“java.lang.Class”类）的Class对象，然后这些Java类的静态字段数据放置在其相应的Class对象中[1]；2）作为“java.lang.Class”类的实例对象。参见以下源代码1和相应的执行结果可帮助理解</font></li>
</ul>
<p>源代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClz</span> <span class="operator">=</span> A.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">arrayClz</span> <span class="operator">=</span> <span class="type">int</span>[].class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classClz</span> <span class="operator">=</span> java.lang.Class.class;</span><br><span class="line"></span><br><span class="line">        System.out.println(aClz <span class="keyword">instanceof</span> java.lang.Class);</span><br><span class="line">        System.out.println(arrayClz <span class="keyword">instanceof</span> java.lang.Class);</span><br><span class="line">        System.out.println(classClz <span class="keyword">instanceof</span> java.lang.Class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h2 id="二、Java对象的内存布局"><a href="#二、Java对象的内存布局" class="headerlink" title="二、Java对象的内存布局"></a><strong>二、Java对象的内存布局</strong></h2><h3 id="2-1、基本说明"><a href="#2-1、基本说明" class="headerlink" title="2.1、基本说明"></a><strong>2.1、基本说明</strong></h3><p>在HotSpot虚拟机中，Java对象的内存布局可分为3块区域：对象头，实例数据和对齐填充。</p>
<p>需要说明的是，Java对象的内存布局除了跟具体的虚拟机实现（这里是基于64位的JDK 8所对应的具体HotSpot虚拟机实现）有关之外，还跟很多因素有关，包括但不限于以下：</p>
<ul>
<li>JVM参数<code>-XX:+/-UseCompressedOops</code>，说明见下面</li>
<li>JVM参数<code>-XX:+/-CompactFields</code>，说明见下面</li>
<li>JVM参数<code>-XX:FieldsAllocationStyle=N</code>，说明见下面</li>
<li><code>@sun.misc.Contended</code>注解，说明见[2]</li>
<li>…</li>
</ul>
<h4 id="2-1-1、对象头"><a href="#2-1-1、对象头" class="headerlink" title="2.1.1、对象头"></a><strong>2.1.1、对象头</strong></h4><p>包括3个部分，描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>占据字节数</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象自身的运行时数据，比如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</td>
<td>8个字节</td>
</tr>
<tr>
<td>类元数据指针（Klass Pointer）</td>
<td>指向相应Klass对象（即方法区内的“类元数据”，详见<a href="/blog/2022/01/10/%E6%96%B9%E6%B3%95%E5%8C%BA/" title="方法区">《方法区》</a>）的指针。<font color='red'>注意不是指向Java堆中相应Class对象的指针，这点极易混淆</font></td>
<td><font color='red'>跟JVM参数<code>-XX:+/-UseCompressedOops</code>有关，其表示是否开启指针压缩。当关闭（<code>-XX:-UseCompressedOops</code>）时，指针大小为8字节；当开启<code>-XX:+UseCompressedOops</code>时，指针大小为4字节</font></td>
</tr>
<tr>
<td>数组长度记录区域</td>
<td>当对象类型为数组时，本区域记录数组长度；否则，本区域为空</td>
<td>当对象类型为数组，占据4个字节；否则，占据0个字节</td>
</tr>
</tbody></table>
<h4 id="2-1-2、实例数据"><a href="#2-1-2、实例数据" class="headerlink" title="2.1.2、实例数据"></a><strong>2.1.2、实例数据</strong></h4><p>存储一系列字段数据，字段类型可以是8种原生基本类型（boolean，byte，char，short，int，float，long，double）之一或者是对象引用类型（reference），不同类型字段数据占据字节数描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>字段类型</th>
<th>占据字节数</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1个字节</td>
</tr>
<tr>
<td>byte</td>
<td>1个字节</td>
</tr>
<tr>
<td>char</td>
<td>2个字节</td>
</tr>
<tr>
<td>short</td>
<td>2个字节</td>
</tr>
<tr>
<td>int</td>
<td>4个字节</td>
</tr>
<tr>
<td>float</td>
<td>4个字节</td>
</tr>
<tr>
<td>long</td>
<td>8个字节</td>
</tr>
<tr>
<td>double</td>
<td>8个字节</td>
</tr>
<tr>
<td>reference</td>
<td><font color='red'>跟JVM参数<code>-XX:+/-UseCompressedOops</code>有关，其表示是否开启指针压缩。当关闭（<code>-XX:-UseCompressedOops</code>）时，占据字节数为8字节；当开启<code>-XX:+UseCompressedOops</code>时，占据字节数为4字节</font></td>
</tr>
</tbody></table>
<p><font color='red'>特别需要注意的是，本文的“字段数据”都是指“非静态字段数据”，因为“静态字段数据”都放置在相应的Class对象中，这与“一、Java对象”小节中对“Class对象”的描述是呼应的。</font></p>
<h4 id="2-1-3、对齐填充"><a href="#2-1-3、对齐填充" class="headerlink" title="2.1.3、对齐填充"></a><strong>2.1.3、对齐填充</strong></h4><p>对齐填充规则可归纳为如下几条：<br><strong>规则1</strong>：8种原生基本类型或者对象引用类型字段内存起始地址需满足“相应类型占据字节数-对齐”，比如“int”类型字段的内存起始地址需满足“4-对齐”，“reference”类型字段的内存起始地址需满足“8-对齐”<br><strong>规则2</strong>：同一类中所有字段按照以下字段类型顺序排列分配内存，字段类型顺序为“long&#x2F;double，int&#x2F;float，char&#x2F;short，boolean&#x2F;byte，reference”<br><strong>规则3</strong>：父类中所有字段排列于子类中所有字段之前<br><strong>规则4</strong>：假定父类中存在至少一个字段，那么子类中首字段内存起始地址需满足“8-对齐”<br><strong>规则5</strong>：如果是“数组对象”，那么具体元素队列中第一个元素的内存起始地址需满足“8-对齐”<br><strong>规则6</strong>：如有必要需进行字节填充，以使得接下来毗邻的Java对象内存起始地址满足“8-对齐”</p>
<p><strong>备注</strong>：</p>
<ul>
<li>JVM参数<code>-XX:+/-CompactFields</code>含义是：是否开启将对象中较窄的数据插入到间隙中。如果开启，上述规则2不再适用[3]</li>
<li>JVM参数<code>-XX:FieldsAllocationStyle=N</code>含义是：设定字段分配策略。如果<code>-XX:FieldsAllocationStyle!=1</code>，上述规则2不再适用[3]</li>
</ul>
<p>对齐填充一般遵循上述对齐填充规则，但还受到“JVM参数<code>-XX:+/-CompactFields</code>”，“JVM参数<code>-XX:FieldsAllocationStyle=N</code>”，“<code>@sun.misc.Contended</code>注解”等因素影响，使得最终策略相当复杂，笔者的目标只是概要理解，故没有必要追求理解准确和完备的对齐填充策略。</p>
<h3 id="2-2、实验"><a href="#2-2、实验" class="headerlink" title="2.2、实验"></a><strong>2.2、实验</strong></h3><p>接下来进行实验，实验环境为：</p>
<ul>
<li>基于64位的JDK 8（其虚拟机实现是HotSpot）</li>
<li><code>-XX:-UseCompressedOops</code></li>
<li><code>-XX:-CompactFields</code></li>
<li><code>-XX:FieldsAllocationStyle=1</code></li>
<li>其他因素暂不考虑</li>
</ul>
<p>OpenJDK项目下提供了一个名为“jol”的工具，它的名字全称为“Java Object Layout”，由名称即可知，该工具能够提供关于Java对象的内存布局信息。详细的关于“jol”的介绍和使用说明见<a href="https://github.com/openjdk/jol">链接</a>。笔者在本文中使用<code>jol-core-0.16.jar</code>版本。</p>
<p>故最终实验命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -classpath &quot;.:./jol-core-0.16.jar&quot; Main.java</span><br><span class="line"></span><br><span class="line">java -XX:-UseCompressedOops -XX:-CompactFields -XX:FieldsAllocationStyle=1 -classpath &quot;.:./jol-core-0.16.jar&quot; Main</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1、实验1——主要针对对象头"><a href="#2-2-1、实验1——主要针对对象头" class="headerlink" title="2.2.1、实验1——主要针对对象头"></a><strong>2.2.1、实验1——主要针对对象头</strong></h4><p>实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseClass(Class.class).toPrintable(String.class));  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseClass(Class.class).toPrintable(Integer.class)); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseClass(String.class).toPrintable(<span class="string">&quot;hello world&quot;</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] aa = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(ClassLayout.parseClass(<span class="type">int</span>[].class).toPrintable(aa));            <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行实验命令后：</p>
<ul>
<li>&#x2F;&#x2F;1语句对应的打印结果见图1</li>
<li>&#x2F;&#x2F;2语句对应的打印结果见图2</li>
<li>&#x2F;&#x2F;3语句对应的打印结果见图3</li>
<li>&#x2F;&#x2F;4语句对应的打印结果见图4</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-1.png"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-2.png"></p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-3.png"></p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-4.png"></p>
<p>分析图1和图2，发现两处的Klass Pointer值（即“object header: class”描述对应的值，不过这里有个瑕疵就是不该用“class”文案，而该用“klass”文案，否则会造成歧义）都为<code>0x00007f29f2740058</code>，契合“String类的Class对象和Integer类的Class对象都是java.lang.Class的实例对象，故Klass Pointer都指向方法区中相应于java.lang.Class的同一个类元数据——Klass对象”。</p>
<h4 id="2-2-2、实验2——主要针对实例数据"><a href="#2-2-2、实验2——主要针对实例数据" class="headerlink" title="2.2.2、实验2——主要针对实例数据"></a><strong>2.2.2、实验2——主要针对实例数据</strong></h4><p>实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseClass(MyObject.class).toPrintable(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> g;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> h;</span><br><span class="line"></span><br><span class="line">    Object i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行实验命令后结果如图5。</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-5.png"></p>
<h4 id="2-2-3、实验3——主要针对实例数据"><a href="#2-2-3、实验3——主要针对实例数据" class="headerlink" title="2.2.3、实验3——主要针对实例数据"></a><strong>2.2.3、实验3——主要针对实例数据</strong></h4><p>本实验主要是为了说明：在非静态内部类实例中隐式含有一个对象引用类型字段，该字段值指向相应外部类实例对象。</p>
<p>实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        main.jol();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jol</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseClass(c.getClass()).toPrintable(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行实验命令后结果如图6。</p>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-6.png"></p>
<h4 id="2-2-4、实验4——主要针对对齐填充"><a href="#2-2-4、实验4——主要针对对齐填充" class="headerlink" title="2.2.4、实验4——主要针对对齐填充"></a><strong>2.2.4、实验4——主要针对对齐填充</strong></h4><p>实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyObjectC</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObjectC</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseClass(MyObjectC.class).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObjectCParent</span> &#123;</span><br><span class="line">    <span class="type">char</span> k;</span><br><span class="line">    <span class="type">byte</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObjectC</span> <span class="keyword">extends</span> <span class="title class_">MyObjectCParent</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> a;</span><br><span class="line">    <span class="type">byte</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">long</span> g;</span><br><span class="line">    <span class="type">double</span> h;</span><br><span class="line"></span><br><span class="line">    Object o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行实验命令后结果如图7。</p>
<p>图7</p>
<p><img src="https://blog.dslztx.top/imgs/20220126-0-7.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a><br>[2]<a href="/blog/2020/07/22/%E4%BC%AA%E5%85%B1%E4%BA%AB/" title="伪共享">《伪共享》</a><br>[3]<a href="https://blog.csdn.net/qq_34212276/article/details/117914322">https://blog.csdn.net/qq_34212276/article/details/117914322</a><br>[4]<a href="http://psy-lob-saw.blogspot.com/2013/05/know-thy-java-object-memory-layout.html">http://psy-lob-saw.blogspot.com/2013/05/know-thy-java-object-memory-layout.html</a><br>[5]<a href="https://www.zhihu.com/question/59174759">https://www.zhihu.com/question/59174759</a><br>[6]<a href="https://www.zhihu.com/question/38496907/answer/156793201">https://www.zhihu.com/question/38496907/answer/156793201</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java常用第三方库</title>
    <url>/blog/2018/04/11/Java%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<p>优先使用一些常用的知名的第三方库（比如Apache Commons，Google Guava，Netty等），在没有的前提下，再自己封装第三方库。<br>养成使用第三方库的习惯，不仅可以提升开发效率，也能提升开发质量。</p>
<h2 id="一、Apache-Commons"><a href="#一、Apache-Commons" class="headerlink" title="一、Apache Commons"></a><strong>一、Apache Commons</strong></h2><p>关键词：Apache维护，多个常用的第三方库，覆盖面广<br>网址：<a href="http://commons.apache.org/">http://commons.apache.org</a></p>
<h2 id="二、Google-Guava"><a href="#二、Google-Guava" class="headerlink" title="二、Google Guava"></a><strong>二、Google Guava</strong></h2><p>关键词：Google维护，高性能<br>网址：<a href="https://github.com/google/guava">https://github.com/google/guava</a></p>
<h2 id="三、Netty"><a href="#三、Netty" class="headerlink" title="三、Netty"></a><strong>三、Netty</strong></h2><p>关键词：异步的事件驱动的网络框架库，高性能基础网络通信组件<br>网址：<a href="http://netty.io/">http://netty.io</a></p>
<h2 id="四、Spring-Framework"><a href="#四、Spring-Framework" class="headerlink" title="四、Spring Framework"></a><strong>四、Spring Framework</strong></h2><p>关键词：优秀的IoC和AOP框架<br>网址：<a href="https://projects.spring.io/spring-framework">https://projects.spring.io/spring-framework</a></p>
<h2 id="五、AspectJ"><a href="#五、AspectJ" class="headerlink" title="五、AspectJ"></a><strong>五、AspectJ</strong></h2><p>关键词：强大的，高性能，高质量，编译时代理类库<br>网址：<a href="https://www.eclipse.org/aspectj">https://www.eclipse.org/aspectj</a></p>
<h2 id="六、CGLIB"><a href="#六、CGLIB" class="headerlink" title="六、CGLIB"></a><strong>六、CGLIB</strong></h2><p>关键词：强大的，高性能，高质量，运行时代理类库<br>网址：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<h2 id="七、SLF4J"><a href="#七、SLF4J" class="headerlink" title="七、SLF4J"></a><strong>七、SLF4J</strong></h2><p>关键词：统一的日志接口<br>网址：<a href="https://www.slf4j.org/">https://www.slf4j.org</a></p>
<h2 id="八、Logback"><a href="#八、Logback" class="headerlink" title="八、Logback"></a><strong>八、Logback</strong></h2><p>关键词：完美实现SLF4J<br>网址：<a href="https://logback.qos.ch/">https://logback.qos.ch</a></p>
<h2 id="九、JUnit"><a href="#九、JUnit" class="headerlink" title="九、JUnit"></a><strong>九、JUnit</strong></h2><p>关键词：流行的单元测试框架<br>网址：<a href="https://junit.org/">https://junit.org</a></p>
<h2 id="十、Mockito"><a href="#十、Mockito" class="headerlink" title="十、Mockito"></a><strong>十、Mockito</strong></h2><p>关键词：简单，强大，Mock测试框架<br>网址：<a href="http://site.mockito.org/">http://site.mockito.org</a></p>
<h2 id="十一、Disruptor"><a href="#十一、Disruptor" class="headerlink" title="十一、Disruptor"></a><strong>十一、Disruptor</strong></h2><p>关键词：用于线程间通信的高效低延时的消息组件<br>网址：<a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a></p>
<h2 id="十二、Quartz"><a href="#十二、Quartz" class="headerlink" title="十二、Quartz"></a><strong>十二、Quartz</strong></h2><p>关键词：功能丰富，任务调度框架<br>网址：<a href="http://www.quartz-scheduler.org/">http://www.quartz-scheduler.org</a></p>
<h2 id="十三、Apache-HttpComponents"><a href="#十三、Apache-HttpComponents" class="headerlink" title="十三、Apache HttpComponents"></a><strong>十三、Apache HttpComponents</strong></h2><p>关键词：高效的，最新的，功能丰富的支持HTTP协议的客户端&#x2F;服务端编程框架<br>网址：<a href="http://hc.apache.org/">http://hc.apache.org</a></p>
<h2 id="十四、Druid"><a href="#十四、Druid" class="headerlink" title="十四、Druid"></a><strong>十四、Druid</strong></h2><p>关键词：阿里巴巴开源，为监控而生，Java语言中最好的数据库连接池<br>网址：<a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p>
<h2 id="十五、Apache-JMeter"><a href="#十五、Apache-JMeter" class="headerlink" title="十五、Apache JMeter"></a><strong>十五、Apache JMeter</strong></h2><p>关键词：功能，性能测试工具<br>网址：<a href="https://jmeter.apache.org/">https://jmeter.apache.org</a></p>
<h2 id="十六、Metrics"><a href="#十六、Metrics" class="headerlink" title="十六、Metrics"></a><strong>十六、Metrics</strong></h2><p>关键词：应用，服务的度量监控系统<br>网址：<a href="http://metrics.dropwizard.io/">http://metrics.dropwizard.io</a></p>
<h2 id="十七、Micrometer"><a href="#十七、Micrometer" class="headerlink" title="十七、Micrometer"></a><strong>十七、Micrometer</strong></h2><p>关键词：应用，服务的度量监控系统，相较于Metrics提供更加简洁的API且业务侵入程度更小<br>网址：<a href="https://micrometer.io/">https://micrometer.io</a></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发引入之优缺点</title>
    <url>/blog/2019/08/20/Java%E5%B9%B6%E5%8F%91%E5%BC%95%E5%85%A5%E4%B9%8B%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<p>并发分为“进程并发”和“线程并发”，Java并发属于后者。</p>
<h2 id="一、优点"><a href="#一、优点" class="headerlink" title="一、优点"></a><strong>一、优点</strong></h2><ul>
<li>使能充分利用现代计算机的多CPU和多CPU核，提升并行&#x2F;并发度，加快程序执行速度</li>
<li>契合某些问题域模型，比如“生产者-消费者问题”</li>
</ul>
<h2 id="二、缺点"><a href="#二、缺点" class="headerlink" title="二、缺点"></a><strong>二、缺点</strong></h2><ul>
<li>需要耗费额外的资源，比如“线程创建”，“用于保存线程对象的内存”，“因上下文切换而消耗的CPU时间”等</li>
<li>需要耗费更多精力用于编写正确可运行，线程安全的程序，需要考虑“可见性，有序性，原子性，死锁”等问题</li>
</ul>
<p>以下是一份简单的会导致出现死锁的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deadLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该Java程序，通过<code>jstack</code>命令查看线程栈，以下是呈现死锁状态的线程栈相关内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Thread-1&quot; #9 prio=5 os_prio=0 tid=0x00007f34d80cd000 nid=0x513c waiting for monitor entry [0x00007f34dcb69000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at DeadLockDemo$2.run(DeadLockDemo.java:33)</span><br><span class="line">	- waiting to lock &lt;0x00000000b2e5a7e8&gt; (a java.lang.String)</span><br><span class="line">	- locked &lt;0x00000000b2e5a818&gt; (a java.lang.String)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; #8 prio=5 os_prio=0 tid=0x00007f34d80cb800 nid=0x513b waiting for monitor entry [0x00007f34dcc6a000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at DeadLockDemo$1.run(DeadLockDemo.java:21)</span><br><span class="line">	- waiting to lock &lt;0x00000000b2e5a818&gt; (a java.lang.String)</span><br><span class="line">	- locked &lt;0x00000000b2e5a7e8&gt; (a java.lang.String)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发编程的艺术</title>
    <url>/blog/2019/08/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<p><del>第一章 并发编程的挑战</del><br><del>第二章 Java并发机制的底层实现原理</del><br><del>第三章 Java内存模型</del><br><del>第四章 Java并发编程基础</del><br><del>第五章 Java中的锁</del><br><del>第六章 Java并发容器和框架</del><br><del>第七章 Java中的13个原子操作类</del><br><del>第八章 Java中的并发工具类</del><br><del>第九章 Java中的线程池</del><br><del>第十章 Executor框架</del><br><del>第十一章 Java并发编程实践</del></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>Java序列化机制释疑</title>
    <url>/blog/2018/11/26/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E9%87%8A%E7%96%91/</url>
    <content><![CDATA[<h2 id="一、同一个Java-Bean"><a href="#一、同一个Java-Bean" class="headerlink" title="一、同一个Java Bean"></a><strong>一、同一个Java Bean</strong></h2><p>一个Java Bean序列化时状态以“A”指代，反序列化时状态以“B”指代，那么存在如下兼容性描述：</p>
<ul>
<li>如果A和B的<code>serialVersionUID</code>字段值不一致，那么反序列化“序列化A生成的字节流”尝试获取B时失败，抛出<code>java.io.InvalidClassException</code>异常</li>
<li>如果A和B的<code>serialVersionUID</code>字段值一致，那么B相对于A增加或者减少字段，都不影响反序列化“序列化A生成的字节流”尝试获取B时的成功</li>
</ul>
<h2 id="二、不同Java-Bean"><a href="#二、不同Java-Bean" class="headerlink" title="二、不同Java Bean"></a><strong>二、不同Java Bean</strong></h2><p>不同的两个Java Bean “C”和“D”（包括“类名不同”和“类名相同，所在包路径不同”），无论其中的“serialVersionUID”字段值是否一致，反序列化“序列化C生成的字节流”尝试获取D时失败，抛出<code>java.lang.ClassCastException</code>异常</p>
<h2 id="三、有序列表或者数组中的元素顺序保持不变"><a href="#三、有序列表或者数组中的元素顺序保持不变" class="headerlink" title="三、有序列表或者数组中的元素顺序保持不变"></a><strong>三、有序列表或者数组中的元素顺序保持不变</strong></h2><p>对于有序列表或者数组，经过序列化和反序列化后，有序列表或者数组中的元素顺序保持不变。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java一般语法</category>
      </categories>
  </entry>
  <entry>
    <title>Java开发私人最佳实践</title>
    <url>/blog/2016/08/13/Java%E5%BC%80%E5%8F%91%E7%A7%81%E4%BA%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、Java打印日志最佳实践"><a href="#一、Java打印日志最佳实践" class="headerlink" title="一、Java打印日志最佳实践"></a><strong>一、Java打印日志最佳实践</strong></h2><a href="/blog/2016/08/13/Java%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Java打印日志最佳实践">《Java打印日志最佳实践》</a>
<h2 id="二、Java内记录代码块执行时间最佳实践"><a href="#二、Java内记录代码块执行时间最佳实践" class="headerlink" title="二、Java内记录代码块执行时间最佳实践"></a><strong>二、Java内记录代码块执行时间最佳实践</strong></h2><a href="/blog/2016/08/12/Java%E5%86%85%E8%AE%B0%E5%BD%95%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Java内记录代码块执行时间最佳实践">《Java内记录代码块执行时间最佳实践》</a>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>长期维护</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程基础</title>
    <url>/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、线程基本含义"><a href="#一、线程基本含义" class="headerlink" title="一、线程基本含义"></a><strong>一、线程基本含义</strong></h2><h3 id="1-1、Java线程与操作系统线程"><a href="#1-1、Java线程与操作系统线程" class="headerlink" title="1.1、Java线程与操作系统线程"></a><strong>1.1、Java线程与操作系统线程</strong></h3><p>Java线程由Java语言模型提供并确保在不同操作系统环境上的语义一致性，JDK负责具体实现和屏蔽操作系统环境差异，比如在现代Linux操作系统中，Java线程会被映射到Linux原生线程。</p>
<h3 id="1-2、线程对应的数据结构和属性"><a href="#1-2、线程对应的数据结构和属性" class="headerlink" title="1.2、线程对应的数据结构和属性"></a><strong>1.2、线程对应的数据结构和属性</strong></h3><p>进程和线程具有承载其数据的相应数据结构实体：</p>
<ul>
<li>Linux进程如是，由Linux内核提供</li>
<li>Linux线程如是，由Linux内核提供</li>
<li>Java进程如是，由JDK提供，比如“对应Unix操作系统环境的类java.lang.UNIXProcess”</li>
<li>Java线程如是，由JDK提供，具体且唯一（即不同操作系统环境对应同一个类）的类java.lang.Thread</li>
</ul>
<p>接下来介绍Java线程常见的几个属性（在相应的java.lang.Thread实例对象中设置），具体有：线程组，线程优先级，是否为后台线程，线程名字和target。</p>
<h4 id="1-2-1、线程组"><a href="#1-2-1、线程组" class="headerlink" title="1.2.1、线程组"></a><strong>1.2.1、线程组</strong></h4><p>通过线程组同时管理一批线程，所有线程默认属于“默认线程组”。<br>在实际使用场景中，几乎不被使用。</p>
<h4 id="1-2-2、线程优先级"><a href="#1-2-2、线程优先级" class="headerlink" title="1.2.2、线程优先级"></a><strong>1.2.2、线程优先级</strong></h4><p>线程优先级越高，被分配到CPU时间片的概率越大。</p>
<p>线程可设置优先级，线程调度器倾向于优先调用优先级高的线程。但仅是“倾向于”，不可依赖。<br>在实际使用场景中，几乎不被使用。因为：</p>
<ul>
<li>对于Java线程的线程优先级，JDK不确保在不同操作系统环境的语义一致性，因此：1）线程优先级设定在有些操作系统中可能完全无效；2）在线程优先级设定有效的前提下，相同优先级设定，在A操作系统和B操作系统的展现行为可能不同</li>
<li>在线程调度中，线程优先级只是一个维度的因素，还有其他维度的因素，因此，只能说“线程优先级越高，被分配到CPU时间片的概率越大”，而不是必然的</li>
</ul>
<h4 id="1-2-3、是否为后台线程"><a href="#1-2-3、是否为后台线程" class="headerlink" title="1.2.3、是否为后台线程"></a><strong>1.2.3、是否为后台线程</strong></h4><p>基于“是否为后台线程”的角度，Java线程分为：后台线程和非后台线程。<br>关于两者的描述有以下几点：</p>
<ul>
<li>常见的是非后台线程；后台线程不是Java进程中不可或缺的线程，一般只用来提供通用服务，比如“Finalizer线程”</li>
<li>非后台线程创建的线程默认为非后台线程；后台线程创建的线程默认为后台线程。或者可以且必须在线程启动之前，通过方法<code>setDaemon(boolean on)</code>手动设置是否为后台线程</li>
<li>当Java进程中不存在非后台线程，进程立即退出（会杀死所有后台线程），效果等价于执行<code>System.exit(int status)</code>方法。这里有一个引申点：我们知道“try-catch-finally”语句结构中的“finally”语句一般都会执行完成，但是当由于执行<code>System.exit(int status)</code>方法立即退出Java进程时，“finally”语句并不保证会被执行，现在新增一种“finally”语句并不保证会被执行的情形，即“不存在非后台线程，Java进程立即退出”，当然此时不保证会被执行的“finally”语句必在后台线程中</li>
</ul>
<h4 id="1-2-4、线程名字"><a href="#1-2-4、线程名字" class="headerlink" title="1.2.4、线程名字"></a><strong>1.2.4、线程名字</strong></h4><p>线程具有默认名字，<font color='red'>但是为了后续排查时的可读性，建议取一个可读性好的名字</font>。</p>
<h4 id="1-2-5、target"><a href="#1-2-5、target" class="headerlink" title="1.2.5、target"></a><strong>1.2.5、target</strong></h4><p>调用Thread实例的<code>start()</code>方法，开启一个Java线程，最终会去执行该Thread实例的<code>run()</code>方法，其源代码如下，其中的<code>target</code>是一个Runnable实例对象，其<code>run()</code>方法包含具体的工作逻辑。</p>
<p>Thread类的<code>run()</code>方法源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、线程常见动作方法"><a href="#二、线程常见动作方法" class="headerlink" title="二、线程常见动作方法"></a><strong>二、线程常见动作方法</strong></h2><p>线程常见动作方法（<code>java.lang.Thread</code>类中方法）如下：</p>
<ul>
<li><code>suspend</code>方法：已废弃</li>
<li><code>resume</code>方法：已废弃</li>
<li><code>stop</code>方法：已废弃</li>
<li><code>yield</code>方法：执行<code>yield</code>方法，表明当前线程愿意放弃剩下的时间片，“建议”线程调度器可以调度运行其他的线程。但仅是“建议”，不可依赖</li>
<li><code>start</code>方法：构造完Thread实例后，调用其上的<code>start()</code>方法，线程状态从<code>NEW</code>转到<code>RUNNABLE</code>，详见“三、线程状态与转移”小节。需要注意的是，在线程A中创建线程B对应的“java.lang.Thread”类实例，然后调用其上的<code>start()</code>方法，它会立即返回，并不会阻塞线程A的运行，此后线程B和线程A处于平等的地位由线程调度器统一调度</li>
<li><code>join</code>方法：在线程A中调用执行线程B对应的Thread实例上的<code>join</code>方法，表示挂起线程A直到线程B执行完成转到<code>TERMINATED</code>状态，详见“三、线程状态与转移”小节</li>
<li><code>interrupt</code>方法：中断线程，详见“四、中断”小节</li>
</ul>
<h2 id="三、线程状态与转移"><a href="#三、线程状态与转移" class="headerlink" title="三、线程状态与转移"></a><strong>三、线程状态与转移</strong></h2><p>Java线程的状态转移示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20200731-0-0.svg"></p>
<h3 id="3-1、Java线程状态"><a href="#3-1、Java线程状态" class="headerlink" title="3.1、Java线程状态"></a><strong>3.1、Java线程状态</strong></h3><p>Java线程状态如表1所示。</p>
<p>表1[1]</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，“java.lang.Thread”实例被构建，但是还未调用其上<code>start()</code>方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，实际上包括“RUNNING（运行）”，“READY（等待CPU）”和“IO_WAIT（等待IO）”3种情形</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程申请synchronized锁而不得</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或者中断）才能退出等待状态</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>超时等待状态，退出条件在<code>WAITING</code>状态的基础之上加了“到达指定的超时时间也可退出等待状态”</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<br/>

<p><strong>几点说明</strong>：</p>
<ul>
<li>参见<code>java.lang.Thread</code>类中<code>State</code>枚举类</li>
<li>Java线程状态由Java语言自定义，与Linux线程的状态（Linux线程的状态跟Linux进程的状态一致，参见[2]）非一一映射，比如“Java线程的<code>RUNNABLE</code>对应Linux线程的<code>R</code>和<code>S</code>”，“Java线程的<code>BLOCKED</code>，<code>WAITING</code>和<code>TIMED_WAITING</code>都对应Linux线程的<code>S</code>”。实验代码1证明当Java线程处于“IO_WAIT（等待IO）”情形时，其Java线程状态为<code>RUNNABLE</code>，对应的Linux线程状态为<code>S</code></li>
<li><code>挂起</code>虚状态包括<code>BLOCKED</code>，<code>WAITING</code>和<code>TIMED_WAITING</code></li>
<li>Java线程的存活期意指：从调用其对应的Thread实例的<code>start()</code>方法开始，到其执行完成进入<code>TERMINATED</code>状态之前。在Java线程存活期内，调用其对应Thread实例的<code>isAlive()</code>方法，返回<code>true</code>，否则返回<code>false</code>，实验代码2是一个实验验证。本文的很多讨论都建立在“Java线程处于存活期”的前提下，否则失去实际意义，比如“讨论<code>Thread.interrupt()</code>，<code>Thread.isInterrupted()</code>，<code>Thread.interrupted()</code>和<code>LockSupport.unpark(Thread thread)</code>这4个方法的调用，只有目标Java线程存活才有实际意义”</li>
</ul>
<p><strong>实验代码1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>ps</code>命令知上述Java进程的ID为18141，通过<code>jstack 18141</code>命令打印线程栈日志，并在其内找到对应的main线程记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007fe0b000a800 nid=0x46de runnable [0x00007fe0b6d86000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">        at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">        at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)</span><br><span class="line">        at java.io.BufferedInputStream.read(BufferedInputStream.java:265)</span><br><span class="line">        - locked &lt;0x000000078661b698&gt; (a java.io.BufferedInputStream)</span><br><span class="line">        at Main.main(Main.java:10)</span><br></pre></td></tr></table></figure>
<p>根据nid字段值“0x46de”知道对应的Linux线程ID为18142，再使用<code>view /proc/18141/task/18142/status</code>命令查看该Linux线程的状态[4]，部分结果如下，可知该Linux线程的状态为<code>S</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:   java</span><br><span class="line">Umask:  0002</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   18141</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    18142</span><br></pre></td></tr></table></figure>

<p><strong>实验代码2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(a.isAlive());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">finish</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="3-2、挂起-RUNNABLE的转移条件"><a href="#3-2、挂起-RUNNABLE的转移条件" class="headerlink" title="3.2、挂起 &lt;-&gt; RUNNABLE的转移条件"></a><strong>3.2、<code>挂起 &lt;-&gt; RUNNABLE</code>的转移条件</strong></h3><h4 id="3-2-1、Thread-sleep方法"><a href="#3-2-1、Thread-sleep方法" class="headerlink" title="3.2.1、Thread.sleep方法"></a><strong>3.2.1、<code>Thread.sleep</code>方法</strong></h4><p>有两个重载方法：<code>sleep(long millis)</code>和<code>sleep(long millis, int nanos)</code>，两者的区别只在于等待时间的设定精度。<br>线程A中执行<code>sleep</code>方法，线程A进入<code>TIMED_WAITING</code>状态，等待设定的时间到期后返回<code>RUNNABLE</code>状态。</p>
<p><strong>实验代码3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在100s睡眠时间到达前打印线程栈，线程栈中main线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f574c00a800 nid=0x1f36 waiting on condition [0x00007f5752474000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main.main(Main.java:3)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、synchronized方法-语句块"><a href="#3-2-2、synchronized方法-语句块" class="headerlink" title="3.2.2、synchronized方法&#x2F;语句块"></a><strong>3.2.2、synchronized方法&#x2F;语句块</strong></h4><p>线程A在执行synchronized方法&#x2F;语句块之前，需要申请相应的synchronized锁，如果申请不到，线程A被放入锁对象关联的<code>cxq</code>或者<code>EntryList</code>队列，并进入<code>BLOCKED</code>状态，待后续申请到synchronized锁时，从<code>cxq</code>或者<code>EntryList</code>队列移除，再返回到<code>RUNNABLE</code>状态。</p>
<p><strong>实验代码4</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让threadA去申请到obj对象对应的synchronized锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前，线程栈中threadA和threadB线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f9c440ef800 nid=0x2133 waiting for monitor entry [0x00007f9c2c67f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$2.run(Main.java:31)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b0c0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f9c440ee000 nid=0x212f waiting on condition [0x00007f9c2c780000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:13)</span><br><span class="line">        - locked &lt;0x000000078665b0c0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3、Object类的wait-notify-notifyAll实例方法"><a href="#3-2-3、Object类的wait-notify-notifyAll实例方法" class="headerlink" title="3.2.3、Object类的wait/notify/notifyAll实例方法"></a><strong>3.2.3、Object类的<code>wait/notify/notifyAll</code>实例方法</strong></h4><p>方法含义：</p>
<ul>
<li><code>wait</code>方法<ul>
<li>在调用对象obj的<code>wait</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，然后在调用<code>wait</code>方法之后会首先释放掉已获得的obj对应synchronized锁（<font color='red'>需要注意的是，不会释放其他已获得的synchronized锁</font>）</li>
<li>线程A调用执行对象obj的<code>wait</code>方法进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，线程A加入到obj对象关联的<code>WaitSet</code>队列，待后续尝试唤醒时，线程A移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列，即“等待再次申请获取相应的synchronized锁”，此时A处于<code>BLOCKED</code>状态，待最终获取到相应的synchronized锁，线程A从<code>cxq队列</code>或者<code>EntryList</code>队列移除，线程A被成功唤醒，进入<code>RUNNABLE</code>状态</li>
</ul>
</li>
<li><code>notify</code>方法<ul>
<li>在调用对象obj的<code>notify</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，跟<code>wait</code>方法不同，调用<code>notify</code>方法之后不会释放掉已获得的obj对应synchronized锁，而是需要等到相应的synchronized方法&#x2F;语句块执行完成退出</li>
<li>线程B调用执行对象obj的<code>notify</code>方法随机选中obj对象关联的<code>WaitSet队列</code>中的一个线程C尝试唤醒，即将其移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列</li>
</ul>
</li>
<li><code>notifyAll</code>方法<ul>
<li>在调用对象obj的<code>notifyAll</code>方法之前，必先获得对象obj对应的synchronized锁，否则会抛出<code>IllegalMonitorStateException</code>异常，跟<code>wait</code>方法不同，调用<code>notifyAll</code>方法之后不会释放掉已获得的obj对应synchronized锁，而是需要等到相应的synchronized方法&#x2F;语句块执行完成退出</li>
<li>线程B调用执行对象obj的<code>notifyAll</code>方法尝试唤醒obj对象关联的<code>WaitSet队列</code>中的所有线程，即将他们所有都移入obj对象关联的<code>cxq</code>或者<code>EntryList</code>队列</li>
</ul>
</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>对于<code>notify/notifyAll</code>方法和<code>wait</code>方法之间的调用顺序关系，默认是“后序”，即“<code>notify/notifyAll</code>方法在<code>wait</code>方法之后调用”，经过实验可发现，如果是“先序”，则<code>notify/notifyAll</code>方法调用发出的唤醒信号直接丢失。接下来在本文中称这类唤醒信号为“<font color='red'>一次性唤醒信号</font>”</li>
</ul>
<br/>

<p><code>wait</code>方法有3个重载方法：<code>wait()</code>，<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>。调用<code>wait()</code>方法进入<code>WAITING</code>状态；调用<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态。</p>
<h5 id="3-2-3-1、wait-方法"><a href="#3-2-3-1、wait-方法" class="headerlink" title="3.2.3.1、wait()方法"></a><strong>3.2.3.1、<code>wait()</code>方法</strong></h5><p>线程A调用执行对象obj的<code>wait()</code>方法进入<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行对象obj的<code>notify()</code>方法</li>
<li>线程B调用执行对象obj的<code>notifyAll()</code>方法</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup.</code>）</li>
</ul>
<p>成功唤醒：</p>
<ul>
<li><font color='red'>再次强调下，假定线程A调用对象obj的<code>wait()</code>方法进入<code>WAITING</code>状态，后续发生上述任一唤醒条件，且线程A被选中尝试唤醒，只有当线程A再次申请到obj对应synchronized锁时才被成功唤醒</font></li>
</ul>
<p><strong>实验代码5</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程栈中threadA线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f62e00f6000 nid=0x29f8 in Object.wait() [0x00007f62ca2a7000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果：threadA线程挂起不被唤醒。</p>
<p><strong>实验代码6</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：在threadB开始运行大约60秒后打印“hello world”，因为threadA被成功唤醒既需要调用<code>notify()</code>方法发出的唤醒信号，也需要threadB释放掉obj对应的synchronized锁。</p>
<p>在threadB执行完<code>obj.notify()</code>语句睡眠60s期间，查看线程栈状态，可发现此时threadA的线程状态为<code>BLOCKED</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f55400ff800 nid=0x592e waiting on condition [0x00007f5529398000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - locked &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f55400fd800 nid=0x592a in Object.wait() [0x00007f5529499000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665b028&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码7</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;world hello&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notifyAll();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：在threadC开始运行大约60秒后打印如下内容，因为threadA和threadB被成功唤醒既需要调用<code>notifyAll()</code>方法发出的唤醒信号，也需要threadC释放掉obj对应的synchronized锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">world hello</span><br></pre></td></tr></table></figure>

<p><strong>实验代码8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先让threadA获取synchronized锁，执行wait()方法，释放掉synchronized锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下，因为只有当threadB执行完成释放掉obj对应的synchronized锁，threadA获得上述synchronized锁后，threadA才能被成功唤醒：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-2、wait-long-timeout-和wait-long-timeout-int-nanos-方法"><a href="#3-2-3-2、wait-long-timeout-和wait-long-timeout-int-nanos-方法" class="headerlink" title="3.2.3.2、wait(long timeout)和wait(long timeout, int nanos)方法"></a><strong>3.2.3.2、<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法</strong></h5><p>线程A调用执行对象obj的<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态。<font color='red'>需要注意的是</font>，线程A调用执行对象obj的<code>wait(0)</code>和<code>wait(0,0)</code>方法进入的是<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行对象obj的<code>notify()</code>方法</li>
<li>线程B调用执行对象obj的<code>notifyAll()</code>方法</li>
<li>设定的超时时间到期</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup.</code>）</li>
</ul>
<p>成功唤醒：</p>
<ul>
<li><font color='red'>再次强调下，假定线程A调用对象obj的<code>wait(long timeout)</code>和<code>wait(long timeout, int nanos)</code>方法进入<code>TIMED_WAITING</code>状态，后续发生上述任一唤醒条件，且线程A被选中尝试唤醒，只有当线程A再次申请到obj对应synchronized锁时才被成功唤醒</font></li>
</ul>
<p><strong>实验代码9</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait(<span class="number">60000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在60s时间挂起时间到达前打印线程栈，线程栈中threadA线程的记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007fb2340f6000 nid=0x2cb5 in Object.wait() [0x00007fb21e9ae000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果：大约60秒后打印“hello world”，因为60秒后设定的超时时间到期尝试唤醒，在获得obj对应的synchronized锁后被成功唤醒。</p>
<h4 id="3-2-4、Thread类的join实例方法"><a href="#3-2-4、Thread类的join实例方法" class="headerlink" title="3.2.4、Thread类的join实例方法"></a><strong>3.2.4、Thread类的<code>join</code>实例方法</strong></h4><p><code>join</code>方法有3个重载方法：<code>join()</code>，<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>，后两者的区别只在于等待时间的设定精度。<br>现有线程B，其对应的Thread实例对象引用为threadB，在线程A中执行<code>threadB.join()/threadB.join(long millis)/join(long millis, int nanos)</code>方法，其含义是：线程A进入<code>WAITING</code>&#x2F;<code>TIMED_WAITING</code>状态，直到线程B执行完成进入<code>TERMINATED</code>状态或者设定的超时时间到期。<br>查看如下<code>join()</code>方法核心实现，可知其核心逻辑通过调用<code>wait(long timeout)</code>方法实现，当线程B执行完成进入<code>TERMINATED</code>状态后，会触发调用下<code>threadB.notifyAll()</code>方法（[1]中P190页对此有作阐明）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实验代码10</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前打印线程栈，线程栈信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadC&quot; #11 prio=5 os_prio=0 tid=0x00007f79cc0f9800 nid=0x42e4 in Object.wait() [0x00007f7996c1a000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1252)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1326)</span><br><span class="line">        at Main$3.run(Main.java:40)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f79cc0f7800 nid=0x42e3 in Object.wait() [0x00007f7996d1b000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1252)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1326)</span><br><span class="line">        at Main$2.run(Main.java:25)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f79cc0f5800 nid=0x42e2 waiting on condition [0x00007f7996e1c000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:8)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thu Dec 17 17:13:53 CST 2020:1</span><br><span class="line">Thu Dec 17 17:13:53 CST 2020:hello</span><br><span class="line">Thu Dec 17 17:15:28 CST 2020:2</span><br><span class="line">Thu Dec 17 17:15:28 CST 2020:world</span><br></pre></td></tr></table></figure>

<p><strong>实验代码11</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join(<span class="number">200000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join(<span class="number">200000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA睡眠时间100s到达前（此时threadB和threadC的睡眠时间更加没有可能到达）打印线程栈，线程栈信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadC&quot; #11 prio=5 os_prio=0 tid=0x00007f11fc0e9800 nid=0x60c2 in Object.wait() [0x00007f11e5da2000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1260)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at Main$3.run(Main.java:41)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f11fc0e8000 nid=0x60c1 in Object.wait() [0x00007f11e5ea3000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at java.lang.Thread.join(Thread.java:1260)</span><br><span class="line">        - locked &lt;0x000000078665b1e8&gt; (a java.lang.Thread)</span><br><span class="line">        at Main$2.run(Main.java:26)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f11fc0e6000 nid=0x60b1 waiting on condition [0x00007f11e5fa4000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at Main$1.run(Main.java:10)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sat Jan 02 20:35:20 CST 2021:hello</span><br><span class="line">Sat Jan 02 20:35:20 CST 2021:1</span><br><span class="line">Sat Jan 02 20:36:55 CST 2021:2</span><br><span class="line">Sat Jan 02 20:36:55 CST 2021:world</span><br></pre></td></tr></table></figure>

<br/>

<p>有一个疑惑点，既然核心逻辑是通过调用<code>wait</code>方法实现，那么在调用<code>threadB.join</code>方法后，是否可以不等待threadB执行完成，而是人为手动执行<code>threadB.notify()/notifyAll()</code>方法从而唤醒线程A呢？答案既是肯定的也是否定的，因为在人为唤醒线程A后会由于<code>while(isAlive())</code>语句而再次进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，参见实验代码12。</p>
<p><strong>实验代码12</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    threadA.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (threadA) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:notifyAll the wait on threadA&quot;</span>);</span><br><span class="line">                    threadA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;:notifyAll the wait on threadA finished&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadD.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thu Dec 17 17:20:50 CST 2020:1</span><br><span class="line">Thu Dec 17 17:20:50 CST 2020:hello</span><br><span class="line">Thu Dec 17 17:20:55 CST 2020:notifyAll the wait on threadA</span><br><span class="line">Thu Dec 17 17:20:55 CST 2020:notifyAll the wait on threadA finished</span><br><span class="line">//这里需要等待threadA的100s睡眠时间到达</span><br><span class="line">Thu Dec 17 17:22:25 CST 2020:2</span><br><span class="line">Thu Dec 17 17:22:25 CST 2020:world</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5、LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-unpark-Thread-thread-类方法"><a href="#3-2-5、LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-unpark-Thread-thread-类方法" class="headerlink" title="3.2.5、LockSupport类的park()/parkNanos(long nanos)/parkUtil(long deadline)/unpark(Thread thread)类方法"></a><strong>3.2.5、LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)/unpark(Thread thread)</code>类方法</strong></h4><p>方法含义：</p>
<ul>
<li><code>park()</code>方法。线程A执行<code>park()</code>方法进入<code>WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>parkNanos(long nanos)</code>方法。线程A执行<code>parkNanos(long nanos)</code>方法进入<code>TIMED_WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>parkUtil(long deadline)</code>方法。线程A执行<code>parkUtil(long deadline)</code>方法进入<code>TIMED_WAITING</code>状态，待后续被成功唤醒，进入<code>RUNNABLE</code>状态</li>
<li><code>unpark(Thread thread)</code>方法。线程B执行<code>unpark(Thread thread)</code>方法唤醒Java线程实例thread对应的线程</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>本文对<code>park()</code>，<code>parkNanos(long nanos)</code>和<code>parkUtil(long deadline)</code>这3个方法的相应重载方法<code>park(Object blocker)</code>，<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>不作讨论，因为核心语义一致</li>
<li>对于<code>unpark(Thread thread)</code>方法和<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法之间的调用顺序关系，默认是“后序”，即“<code>unpark(Thread thread)</code>方法在<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法之后调用”，经过实验可发现，如果是“先序”，<code>unpark(Thread thread)</code>方法调用发出的唤醒信号并不会直接丢失（可与<code>notify/notifyAll</code>方法调用发出的唤醒信号进行对比）。根据<code>unpark(Thread thread)</code>方法的实现原理，可知调用其发出的唤醒信号的特点是：设置一个0-1标志位，如果是“后序”调用，则经历“设置1标志位 -&gt; 唤醒先前的相应的<code>park/parkNanos/parkUtil</code>方法调用 -&gt; 复位0标志位”过程；如果是“先序”调用，则经历“设置1标志位 -&gt; 唤醒后续的相应的<code>park/parkNanos/parkUtil</code>方法调用 -&gt; 复位0标志位”过程。<font color='red'>需要注意的是，由于是一个0-1标志位，故在“先序”调用情形中，提前多次<code>unpark(Thread thread)</code>方法调用与提前1次<code>unpark(Thread thread)</code>方法调用等价</font>。接下来在本文中称这类唤醒信号为“<font color='red'>标志位唤醒信号</font>”</li>
</ul>
<h5 id="3-2-5-1、park-方法"><a href="#3-2-5-1、park-方法" class="headerlink" title="3.2.5.1、park()方法"></a><strong>3.2.5.1、<code>park()</code>方法</strong></h5><p>线程A执行<code>park()</code>方法进入<code>WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行<code>unpark(Thread thread)</code>方法，thread代表线程A对应的Thread实例</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>The call spuriously (that is, for no reason) returns</code>）</li>
</ul>
<p><strong>实验代码13</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：threadA线程挂起不被唤醒。</p>
<p>线程栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f14400f6000 nid=0x4aa8 waiting on condition [0x00007f1429499000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">        at Main$1.run(Main.java:9)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码14</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p><strong>实验代码15</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;again&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是一个0-1标志位，在“先序”调用情形中，提前多次unpark方法调用与提前1次unpark方法调用等价</span></span><br><span class="line">        LockSupport.unpark(threadA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">//挂起不被唤醒</span><br></pre></td></tr></table></figure>

<h5 id="3-2-5-2、parkNanos-long-nanos-和parkUntil-long-deadline"><a href="#3-2-5-2、parkNanos-long-nanos-和parkUntil-long-deadline" class="headerlink" title="3.2.5.2、parkNanos(long nanos)和parkUntil(long deadline)"></a><strong>3.2.5.2、<code>parkNanos(long nanos)</code>和<code>parkUntil(long deadline)</code></strong></h5><p>线程A执行<code>parkNanos(long nanos)</code>和<code>parkUntil(long deadline)</code>方法进入<code>TIMED_WAITING</code>状态。<br>唤醒条件：</p>
<ul>
<li>线程B调用执行<code>unpark(Thread thread)</code>方法，thread代表线程A对应的Thread实例</li>
<li>设定的超时时间到期</li>
<li>虚假唤醒。无任何理由直接自唤醒退出，虽然很少发生（JavaDoc的原话是<code>The call spuriously (that is, for no reason) returns</code>）</li>
</ul>
<p><strong>实验代码16</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">10L</span> * <span class="number">1000000000</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>在Java线程threadA的挂起时间10s到达前打印线程栈，线程栈记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007fed1c0ed800 nid=0x4d5e waiting on condition [0x00007fed04315000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338)</span><br><span class="line">        at Main$1.run(Main.java:9)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p><strong>实验代码17</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.parkUntil(System.currentTimeMillis() + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="3-2-6、Condition接口的await-awaitUninterruptibly-await-long-time-TimeUnit-unit-awaitNano-long-nanosTimeout-awaitUntil-Date-deadline-signal-signalAll-实例方法"><a href="#3-2-6、Condition接口的await-awaitUninterruptibly-await-long-time-TimeUnit-unit-awaitNano-long-nanosTimeout-awaitUntil-Date-deadline-signal-signalAll-实例方法" class="headerlink" title="3.2.6、Condition接口的await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)/signal()/signalAll()实例方法"></a><strong>3.2.6、Condition接口的<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)/signal()/signalAll()</code>实例方法</strong></h4><p>对于Condition接口，在Java并发包中已存在两个实现，分别是<code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject</code>和<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject</code>，查看两者实现，发现都通过调用LockSupport类的<code>park/parkNanos/parkUtil</code>方法实现<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>方法的核心逻辑，通过调用LockSupport类的<code>unpark</code>方法实现<code>signal()/signalAll()</code>方法的核心逻辑。</p>
<p>仅限于基于上述两个已存在类，可以有结论：</p>
<ul>
<li>调用<code>await()/awaitUninterruptibly()</code>会进入<code>WAITING</code>状态</li>
<li>调用<code>await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>会进入<code>TIMED_WAITING</code>状态</li>
</ul>
<p>另外值得叙述的是<code>awaitUninterruptibly()</code>方法（源码如下），它针对中断操作的处理步骤是：在被中断信号唤醒后，立即无条件复位中断标志位，然后判断while退出条件是否得到满足，如果满足则退出，否则继续挂起；而<code>await()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>方法针对中断操作的处理步骤是：在被中断信号唤醒后，立即无条件复位中断标志位，然后直接退出while循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a><strong>四、中断</strong></h2><p>中断的本质十分简单：“发出唤醒信号”和“设置中断标志位”。如何处理“唤醒信号”和“中断标志位”由后续具体逻辑具体负责。<br>发出的唤醒信号分为3类：</p>
<ul>
<li>针对<code>Thread.sleep</code>的唤醒信号</li>
<li>针对<code>Object.wait</code>的唤醒信号，等价于<code>Object.notify</code></li>
<li>针对<code>LockSupport.park</code>的唤醒信号，等价于<code>LockSupport.unpark</code></li>
</ul>
<p>在Thread类中跟中断有关的方法有3个：</p>
<ul>
<li><code>interrupt()</code>：在线程存活期调用，否则无实际意义</li>
<li><code>interrupted()</code>：如果设置了中断标志位则返回true，复位中断标志位；否则返回false</li>
<li><code>isInterrupted()</code>：如果设置了中断标志位则返回true，否则返回false。需要注意的是：<font color='red'>并不会复位中断标志位</font></li>
</ul>
<h3 id="4-1、针对Thread类的sleep方法"><a href="#4-1、针对Thread类的sleep方法" class="headerlink" title="4.1、针对Thread类的sleep方法"></a><strong>4.1、针对Thread类的<code>sleep</code>方法</strong></h3><p>一次性唤醒信号。</p>
<h4 id="4-1-1、后序"><a href="#4-1-1、后序" class="headerlink" title="4.1.1、后序"></a><strong>4.1.1、后序</strong></h4><p>一次性唤醒信号生效消失，线程被唤醒后检测到设置了中断标志位，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码18</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                        .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1609836534638</span><br><span class="line">1609836534639:[false]</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2、先序"><a href="#4-1-2、先序" class="headerlink" title="4.1.2、先序"></a><strong>4.1.2、先序</strong></h4><p>一次性唤醒信号丢失消失，后续线程调用<code>Thread.sleep</code>方法时发现设置了中断标志位，直接唤醒，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码19</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">aSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                        .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">hello world</span><br><span class="line">1609836587473:[false]</span><br></pre></td></tr></table></figure>

<h3 id="4-2、针对Object类的wait方法"><a href="#4-2、针对Object类的wait方法" class="headerlink" title="4.2、针对Object类的wait方法"></a><strong>4.2、针对Object类的<code>wait</code>方法</strong></h3><p>一次性唤醒信号。</p>
<p><strong>再次强调下</strong>：如上所述，我们知道，线程A调用对象obj的<code>wait</code>方法进入<code>WAITING</code>或者<code>TIMED_WAITING</code>状态，后续尝试唤醒时（线程B调用执行对象obj的<code>notify/notifyAll</code>方法；设定的超时时间到期；虚假唤醒），只有当线程A再次申请到obj对应的synchronized锁才被成功唤醒，<font color='red'>中断唤醒情形也不例外</font>。</p>
<h4 id="4-2-1、后序"><a href="#4-2-1、后序" class="headerlink" title="4.2.1、后序"></a><strong>4.2.1、后序</strong></h4><p>一次性唤醒信号生效消失，线程被唤醒后（<font color='red'>需要再次获取到synchronized锁</font>）检测到设置了中断标志位，抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码20</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[thread sleep finished]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[interrupt send]&quot;</span>);</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1609753806368:[interrupt send]</span><br><span class="line">1609753861368:[thread sleep finished]</span><br><span class="line">1609753861369:[false]</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2、先序"><a href="#4-2-2、先序" class="headerlink" title="4.2.2、先序"></a><strong>4.2.2、先序</strong></h4><p>一次性唤醒信号丢失消失，后续线程调用<code>wait</code>方法发现设置了中断标志位，直接唤醒（<font color='red'>需要再次获取到synchronized锁，不过笔者不是很确定——在该种情形中，是“先释放锁，再获取锁”，还是“发现设置了中断标志位直接不释放锁”</font>），抛出<code>InterruptedException</code>异常，复位中断标志位。</p>
<p><strong>实验代码21</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">aSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objA.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">hello world</span><br><span class="line">1609838232636:[false]</span><br></pre></td></tr></table></figure>

<h3 id="4-3、针对LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-方法"><a href="#4-3、针对LockSupport类的park-parkNanos-long-nanos-parkUtil-long-deadline-方法" class="headerlink" title="4.3、针对LockSupport类的park()/parkNanos(long nanos)/parkUtil(long deadline)方法"></a><strong>4.3、针对LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法</strong></h3><p>标志位唤醒信号。</p>
<h4 id="4-3-1、后序"><a href="#4-3-1、后序" class="headerlink" title="4.3.1、后序"></a><strong>4.3.1、后序</strong></h4><p>标志位唤醒信号生效消失，线程被唤醒后虽然检测到设置了中断标志位，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。</p>
<p><strong>实验代码22</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:[&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1609805900180</span><br><span class="line">true</span><br><span class="line">1609805900180:[true]</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2、先序"><a href="#4-3-2、先序" class="headerlink" title="4.3.2、先序"></a><strong>4.3.2、先序</strong></h4><p>标志位唤醒信号不会丢失，后续线程调用LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>发现存在唤醒信号，标志位唤醒信号生效消失，线程被唤醒后虽然检测到设置了中断标志位，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。<br>在没有标志位唤醒信号的情形下，后续线程调用LockSupport类的<code>park()/parkNanos(long nanos)/parkUtil(long deadline)</code>方法发现设置了中断标志位，直接唤醒，但是不会抛出<code>InterruptedException</code>异常，也不会复位中断标志位。</p>
<p><strong>实验代码23</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Switch aSwitch = new Switch();</span><br><span class="line"></span><br><span class="line">        Object obj = new Object();</span><br><span class="line"></span><br><span class="line">        Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (!aSwitch.flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        LockSupport.park();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out</span><br><span class="line">                            .println(System.currentTimeMillis() + &quot;:[&quot; + Thread.currentThread().isInterrupted() + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;world&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LockSupport.park();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello world again&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;threadA&quot;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        threadA.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadA.isInterrupted());</span><br><span class="line"></span><br><span class="line">        aSwitch.flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Switch &#123;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world again</span><br></pre></td></tr></table></figure>

<h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a><strong>五、死锁</strong></h2><h3 id="5-1、狭义"><a href="#5-1、狭义" class="headerlink" title="5.1、狭义"></a><strong>5.1、狭义</strong></h3><p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>Java死锁产生的四个必要条件：</p>
<ul>
<li>互斥使用，即当资源被一个线程占有使用时，别的线程不能使用</li>
<li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li>
<li>请求和保持，即当资源请求者在请求其他资源的同时保持对原有资源的占有</li>
<li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源，这样就形成了一个等待环路</li>
</ul>
<p>当上述四个条件都成立的时候，便形成死锁，在死锁的情况下如果打破上述任何一个条件，便可让死锁消失。</p>
<p>以上引用自[11]。</p>
<p>根据以上定义，可使用synchronized锁或者Lock显式锁构造死锁案例，接下来根据synchronized锁构造一个死锁案例。</p>
<p><strong>实验代码24</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程栈信息如下所示，发现jstack能够直接侦测到该种死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f39bc0e0000 nid=0x5774 waiting for monitor entry [0x00007f39a67ac000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f39bc0de000 nid=0x5773 waiting for monitor entry [0x00007f39a68ad000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at Main$1.run(Main.java:18)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">//这里省略</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f398c003a18 (object 0x000000078665b048, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadA&quot;</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f398c006568 (object 0x000000078665b058, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadB&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">        at Main$2.run(Main.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">        at Main$1.run(Main.java:18)</span><br><span class="line">        - waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h3 id="5-2、广义"><a href="#5-2、广义" class="headerlink" title="5.2、广义"></a><strong>5.2、广义</strong></h3><p>死锁是这样一种情形：多个线程同时被阻塞，它们互相循环依赖对方的动作才能被唤醒。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>实验代码25</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objA.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    objB.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objB.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objC) &#123;</span><br><span class="line">                    objC.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objC) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objC.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    objA.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h2><h3 id="6-1、挂起线程T0被线程T1唤醒的跨线程内存可见性"><a href="#6-1、挂起线程T0被线程T1唤醒的跨线程内存可见性" class="headerlink" title="6.1、挂起线程T0被线程T1唤醒的跨线程内存可见性"></a><strong>6.1、挂起线程T0被线程T1唤醒的跨线程内存可见性</strong></h3><p>这里讨论挂起线程T0被线程T1唤醒时的跨线程内存可见性问题，具体是：T1中的唤醒前动作集T1AS与T0中的被唤醒后动作集T0AS之间的happens-before规则（<font color='red'>需要注意的是，讨论对象从“内存可见性”到“happens-before规则”是因为：在内存可见性范畴，“happens-before规则”虽然只是其中一类规则，还有很多其他规则，比如“final关键词提供的内存可见语义规则”，但是“happens-before规则”相对来说最具有应用价值</font>）。</p>
<p>根据“3.2、<code>挂起 &lt;-&gt; RUNNABLE</code>的转移条件”小节内容，可知挂起线程T0的方法有6个：</p>
<ul>
<li>Thread类的<code>sleep</code>方法，唤醒方式有：超时自唤醒，T1调用T0的<code>interrupt()</code>方法</li>
<li>synchronized方法&#x2F;语句块，唤醒方式有：T1释放synchronized锁</li>
<li>Object类的<code>wait</code>方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用Object类的<code>notify()/notifyAll()</code>方法或者调用T0的<code>interrupt()</code>方法</li>
<li>Thread类的<code>join</code>实例方法，唤醒方式有：超时自唤醒，T1线程（T1就是T0所等待的线程，即T0线程调用<code>T1.join()</code>挂起）执行完成进入<code>TERMINATED</code>状态，T1（T1可以是T0所等待的线程，也可以不是，一般是后者）调用T0的<code>interrupt()</code>方法</li>
<li>LockSupport类的<code>park/parkNano/parkUntil</code>方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用LockSupport类的<code>unpark(T0)</code>方法或者调用T0的<code>interrupt()</code>方法</li>
<li>Condition接口的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>实例方法，唤醒方式有：虚假唤醒，超时自唤醒，T1调用Condition接口的<code>signal()/signalAll()</code>方法或者调用T0的<code>interrupt()</code>方法（需要注意的是，<code>awaitUninterruptibly</code>方法不响应中断）</li>
</ul>
<p><strong>在继续讨论之前，先作几点说明</strong>：</p>
<ul>
<li>接下来，以“hb”简指“happens-before”</li>
<li>下表中的<code>NO</code>意指：T1中的中断唤醒前动作集T1AS与T0中的被唤醒后动作集T0AS没有必然的内存可见性关系，自然也没有必然的hb规则</li>
<li>Condition实例对象关联的锁一般是指ReentrantLock锁，这里也基于此进行说明。跟synchronized锁一样，ReentrantLock锁的使用也遵循“监视器锁”hb规则，具体证明可参见<a href="/blog/2021/04/02/Lock%E6%8E%A5%E5%8F%A3/" title="Lock接口">《Lock接口》</a></li>
<li>对于<code>wait-notify/notifyAll</code>和<code>await/awaitUninterruptibly/awaitNano/awaitUntil-signal/signalAll</code>过程的hb规则，须具体情况具体分析，核心基于“监视器锁”hb规则，再次提醒下：在调用<code>wait</code>和<code>await/awaitNano/awaitUntil</code>方法后立即中断的情形中，锁的申请和释放过程是有点特殊的</li>
</ul>
<table>
<thead>
<tr>
<th>T0挂起方法</th>
<th>T0自唤醒</th>
<th>T1非中断唤醒</th>
<th>T1中断唤醒</th>
</tr>
</thead>
<tbody><tr>
<td>Thread类的<code>sleep</code>方法</td>
<td>NO</td>
<td>不存在T1非中断唤醒情形</td>
<td>NO</td>
</tr>
<tr>
<td>synchronized方法&#x2F;语句块</td>
<td>不可能情形</td>
<td>T1释放相应的synchronized锁，关于内存可见性，遵循<code>监视器锁hb规则</code></td>
<td>NO</td>
</tr>
<tr>
<td>Object类的<code>wait</code>方法</td>
<td>NO</td>
<td>见“论述1”</td>
<td>NO</td>
</tr>
<tr>
<td>Thread类的<code>join</code>方法</td>
<td>NO</td>
<td>T0线程调用<code>T1.join()</code>挂起，T1执行完成进入<code>TERMINATED</code>状态唤醒T0，关于内存可见性，遵循<code>join() hb规则</code>。<br/><br/>根据“3.2.4、Thread类的<code>join</code>实例方法”可知，<code>join() hb规则</code>可简单由“论述1”中的<code>wait/notify/notifyAll hb规则</code>推得，因此，<code>join() hb规则</code>本质也是来源于<code>监视器锁hb规则</code></td>
<td>NO</td>
</tr>
<tr>
<td>LockSupport类的<code>park/parkNano/parkUntil</code>方法</td>
<td>NO</td>
<td>T1调用LockSupport类的<code>unpark(T0)</code>方法，关于内存可见性，T1中的<code>unpark()</code>方法前动作集T1AS与T0中的被唤醒后动作集T0AS没有必然的内存可见性关系[8]</td>
<td>NO</td>
</tr>
<tr>
<td>Condition的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法</td>
<td>NO</td>
<td>见“论述2”</td>
<td>NO</td>
</tr>
</tbody></table>
<p><strong>论述1</strong>：<br>T0调用<code>wait</code>方法挂起，T1调用<code>notify()/notifyAll()</code>方法尝试唤醒，</p>
<ul>
<li>未成功唤醒：不可能出现的情形。因为“根据已知前提，唤醒信号必定发送，调用<code>notify()/notifyAll()</code>方法后最终必定会自动隐式释放掉synchronized锁，成功唤醒的条件得到满足”</li>
<li>成功唤醒：调用<code>notify()/notifyAll()</code>方法后最终必定会自动隐式释放掉synchronized锁，该锁被T0获取而成功唤醒（实际可能是形如“T1释放锁 Tm获取锁 Tm释放锁 Tn获取锁 Tn释放锁 … T0获取锁”过程，但是根据“传递性”hb规则，不影响证明），基于“程序顺序”，“监视器锁”和“传递性”这3个hb规则，可推导得：T1调用<code>notify()/notifyAll()</code>方法之前的操作（更准确的说，T1在调用<code>notify()/notifyAll()</code>后最终隐式释放掉synchronized锁之前的操作） happens-before 于T0调用<code>wait</code>方法被成功唤醒之后的操作。据此，在实验代码26中，有“&#x2F;&#x2F;1 -hb-&gt; &#x2F;&#x2F;2 -hb-&gt; &#x2F;&#x2F;3 -hb-&gt; &#x2F;&#x2F;4 -hb-&gt; &#x2F;&#x2F;5 -hb-&gt; &#x2F;&#x2F;6 -hb-&gt; &#x2F;&#x2F;7”</li>
</ul>
<p><strong>论述2</strong>：<br>T0调用Condition的<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法挂起，T1调用<code>signal()/signalAll()</code>方法尝试唤醒，</p>
<ul>
<li>未成功唤醒：根据已知前提，唤醒信号必定发送，故未成功唤醒只能是因为T1中最后未释放对应的ReentrantLock锁，此时无谓谈论happens-before关系。但是根据如下“ReentrantLock锁使用的惯用法”，该种情形理论上不会出现</li>
<li>成功唤醒：调用<code>signal()/signalAll()</code>方法后最终在finally语句中显式释放掉ReentrantLock锁，该锁被T0获取而成功唤醒（实际可能是形如“T1释放锁 Tm获取锁 Tm释放锁 Tn获取锁 Tn释放锁 … T0获取锁”过程，但是根据“传递性”hb规则，不影响证明），基于“程序顺序”，“监视器锁”和“传递性”这3个hb规则，可推导得：T1调用<code>signal()/signalAll()</code>方法之前的操作（更准确的说，T1在调用<code>signal()/signalAll()</code>后最终显式释放掉ReentrantLock锁之前的操作） happens-before 于T0调用<code>await/awaitUninterruptibly/awaitNano/awaitUntil</code>方法被成功唤醒之后的操作</li>
</ul>
<p>ReentrantLock锁使用的惯用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockUseExample</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>实验代码26</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 被唤醒，这里重新获得synchronized锁</span></span><br><span class="line">                        obj.wait();              <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;5&quot;</span>); <span class="comment">// 5</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;6&quot;</span>); <span class="comment">// 6</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;7&quot;</span>); <span class="comment">// 7</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">6000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">                &#125;                            <span class="comment">// 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、惯用法"><a href="#6-2、惯用法" class="headerlink" title="6.2、惯用法"></a><strong>6.2、惯用法</strong></h3><p>Object类的<code>wait</code>和LockSupport类的<code>park</code>方法使用的惯用形式为：在一个while语句块中调用<code>wait</code>方法和<code>park</code>方法，被唤醒后如果不满足while循环退出条件继续挂起。可参见实验代码27。<br>以上惯用形式的合理和必要之处在于：调用<code>wait</code>和<code>park</code>方法的原始意图本就在于等待某个条件的达成，如果被非法唤醒而条件未达成则会导致违背这种原始意图，通过while语句块可以避免这种情形。<br>非法唤醒的情形包括两种：</p>
<ul>
<li>代码实现Bug，误调用Object类的<code>notify/notifyAll</code>方法&#x2F;LockSupport类的<code>unpark</code>方法、设定的唤醒超时时间到期、误调用Thread类的<code>interrupt()</code>方法。从这个角度来看，如果不用惯用法，代码健壮性差</li>
<li><code>wait</code>和<code>park</code>方法都有一个“虚假唤醒”的唤醒情形。从这个角度来看，如果不用惯用法，代码存在漏洞</li>
</ul>
<p><strong>实验代码27</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只是示例，没有考虑代码健壮性（包括线程安全性）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> Thread parkThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            obj.notify();</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parkMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            parkThread = Thread.currentThread();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unparkMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        LockSupport.unpark(parkThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、垃圾回收"><a href="#6-3、垃圾回收" class="headerlink" title="6.3、垃圾回收"></a><strong>6.3、垃圾回收</strong></h3><p>创建Thread实例对象，并开启对应线程后，它会被注册到“<font color='red'>某处</font>”，因此在线程存活期内是引用可达的，并不会被垃圾回收；线程结束后相应的Thread实例对象才会被解除注册，此时可被垃圾回收。</p>
<h3 id="6-4、main主线程与普通线程的异同"><a href="#6-4、main主线程与普通线程的异同" class="headerlink" title="6.4、main主线程与普通线程的异同"></a><strong>6.4、main主线程与普通线程的异同</strong></h3><p>main主线程与普通线程相比，除了是入口线程外，并无二致。</p>
<h3 id="6-5、线程内异常处理"><a href="#6-5、线程内异常处理" class="headerlink" title="6.5、线程内异常处理"></a><strong>6.5、线程内异常处理</strong></h3><p>Java线程内抛出异常（包括“错误”，接下来未作特别声明，“异常”都包括“错误”）时，有两条运行路径。</p>
<h4 id="6-5-1、异常在线程内被catch住"><a href="#6-5-1、异常在线程内被catch住" class="headerlink" title="6.5.1、异常在线程内被catch住"></a><strong>6.5.1、异常在线程内被catch住</strong></h4><p>正确合理的应对方式。</p>
<h4 id="6-5-2、异常未在线程内被catch住"><a href="#6-5-2、异常未在线程内被catch住" class="headerlink" title="6.5.2、异常未在线程内被catch住"></a><strong>6.5.2、异常未在线程内被catch住</strong></h4><p>线程内异常未在线程内被catch住，即逃逸到线程外，这会导致该线程死亡，但不会影响所在Java进程。不过在线程死亡之前，会去执行Thread类的“private void dispatchUncaughtException(Throwable e)”方法（“e”指代未被处理异常）。<br>默认会调用ThreadGroup类下<code>uncaughtException()</code>方法，可通过<code>setUncaughtExceptionHandler()</code>方法自定义设置“UncaughtExceptionHandler”实例对象，从而自定义对未处理异常的处理逻辑。</p>
<p><font color='red'>特别需要注意的是</font>：Java线程运行在独立的线程空间，内部未处理的异常不能被其它线程处理，示例见以下两个示例代码。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionNotCatch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 以下抛出异常内部未能处理，执行Thread类的“private void dispatchUncaughtException(Throwable e)”方法，该异常作为参数传入</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;hello world exception&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                            <span class="comment">// 没有抓住RuntimeException异常</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;can not run to here&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 线程内部异常不能被其它线程处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有抓住异常，线程直接结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread is alive ? &quot;</span> + thread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionUncaughtExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;hello world exception&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                            <span class="comment">// 没有抓住RuntimeException异常</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;can not run to here&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;dslztx-thread-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">UncaughtExceptionHandler</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常catch了,当前线程为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，异常线程为：&quot;</span> + t.getName()</span><br><span class="line">                        + <span class="string">&quot;，异常信息为：&quot;</span> + e.getStackTrace());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 线程内部异常不能被其它线程处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有抓住异常，线程直接结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread is alive ? &quot;</span> + thread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6、调用Object-wait或者Thread-join方法挂起查看所打印jstack命令结果的一个注意点"><a href="#6-6、调用Object-wait或者Thread-join方法挂起查看所打印jstack命令结果的一个注意点" class="headerlink" title="6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点"></a><strong>6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点</strong></h3><p>调用Object.wait或者Thread.join（本质通过调用Object.wait实现）方法挂起查看所打印jstack命令结果的一个注意点：虽然显示某个synchronized锁被获取，但实际上调用wait方法挂起后是释放掉该锁的，比如在如下jstack命令结果中，“threadA”在挂起时已经释放掉“0x000000078665afb8”指代的synchronized锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f62e00f6000 nid=0x29f8 in Object.wait() [0x00007f62ca2a7000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at Main$1.run(Main.java:11)</span><br><span class="line">        - locked &lt;0x000000078665afb8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<br/>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]《Java并发编程的艺术》<br>[2]<a href="https://www.cnblogs.com/YDDMAX/p/5208561.html">https://www.cnblogs.com/YDDMAX/p/5208561.html</a><br>[3]<a href="https://blog.csdn.net/qq_38244610/article/details/106106276">https://blog.csdn.net/qq_38244610/article/details/106106276</a><br>[4]<a href="https://stackoverflow.com/questions/9577231/how-to-check-the-state-of-linux-threads">https://stackoverflow.com/questions/9577231/how-to-check-the-state-of-linux-threads</a><br>[5]<a href="https://cgiirw.github.io/2018/05/27/Interrupt_Ques/">https://cgiirw.github.io/2018/05/27/Interrupt_Ques/</a><br>[6]<a href="https://cgiirw.github.io/2018/05/17/Thread01/">https://cgiirw.github.io/2018/05/17/Thread01/</a><br>[7]<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.2.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.2.1</a><br>[8]<a href="https://stackoverflow.com/questions/2475067/java-locksupport-memory-consistency">https://stackoverflow.com/questions/2475067/java-locksupport-memory-consistency</a><br>[9]<a href="https://blogs.oracle.com/dave/a-race-in-locksupport-park-arising-from-weak-memory-models">https://blogs.oracle.com/dave/a-race-in-locksupport-park-arising-from-weak-memory-models</a><br>[10]<a href="https://cgiirw.github.io/2018/10/17/Blocked03/">https://cgiirw.github.io/2018/10/17/Blocked03/</a><br>[11]<a href="https://www.runoob.com/java/thread-deadlock.html">https://www.runoob.com/java/thread-deadlock.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java打印日志最佳实践</title>
    <url>/blog/2016/08/13/Java%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、只记录DEBUG，INFO和ERROR级别日志"><a href="#一、只记录DEBUG，INFO和ERROR级别日志" class="headerlink" title="一、只记录DEBUG，INFO和ERROR级别日志"></a><strong>一、只记录DEBUG，INFO和ERROR级别日志</strong></h2><p>只记录DEBUG，INFO和ERROR级别的日志信息，DEBUG级别日志记录“调试信息”，INFO级别日志记录“一般信息”，ERROR级别日志记录“异常信息”，这3个级别的日志记录已经能够充分包含关键有价值的信息；如果再记录其他级别的日志信息，一方面，这些日志信息的价值度不是很高（DEBUG，INFO和ERROR这3个级别的日志信息已经能够充分包含关键有价值的信息），另外一方面，过多的日志信息会降低可读性。<br>需要特别强调的是，DEBUG级别的日志记录非常重要，它与INFO级别的日志记录和ERROR级别的日志记录一起，能够充分包含关键有价值的信息，三者缺一不可。<br>举例子说明DEBUG级别日志记录的重要性，我们常常使用第三方库（比如Spring，Mybatis等），在使用这些第三方库的过程中，如果遇到问题，我们往往可以通过设置“将DEBUG级别的日志记录显式打印出来”，从而获得排查问题的线索。因此，如果某些第三方库没有记录DEBUG级别的日志信息，那么它们的易用性就会受到很大的损害。</p>
<h2 id="二、只在调试模式下显式打印DEBUG级别日志信息"><a href="#二、只在调试模式下显式打印DEBUG级别日志信息" class="headerlink" title="二、只在调试模式下显式打印DEBUG级别日志信息"></a><strong>二、只在调试模式下显式打印DEBUG级别日志信息</strong></h2><p>“一、只记录DEBUG，INFO和ERROR级别日志”中介绍到需要记录DEBUG，INFO和ERROR级别的日志信息，但是，需要注意的是，在一般模式下，只显式打印INFO和ERROR级别的日志信息，而不显式打印DEBUG级别的日志信息。这是因为在一般模式下，DEBUG级别的日志信息并没有很大价值，如果显式打印会降低可读性，只有在调试模式时，才需要将DEBUG，INFO和ERROR这3个级别的日志信息一起同时显式打印。</p>
<h2 id="三、日志记录内容：日志级别，时间，地点，人物，事件"><a href="#三、日志记录内容：日志级别，时间，地点，人物，事件" class="headerlink" title="三、日志记录内容：日志级别，时间，地点，人物，事件"></a><strong>三、日志记录内容：日志级别，时间，地点，人物，事件</strong></h2><h3 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a><strong>3.1、概念</strong></h3><p>日志级别：根据“一、只记录DEBUG，INFO和ERROR级别日志”，日志级别可取值有“DEBUG，INFO和ERROR”<br>时间：日志记录行为发生时间<br>地点：日志记录行为发生时所处类，根据具体情况可取“全限定类类名”或者“简单类类名”<br>人物：进行日志记录行为的当前线程的线程名称<br>事件：使用日志进行记录的事件内容</p>
<h3 id="3-2、举例说明"><a href="#3-2、举例说明" class="headerlink" title="3.2、举例说明"></a><strong>3.2、举例说明</strong></h3><p>选择使用Log4J日志框架，使用的Log4J日志框架配置文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, file</span><br><span class="line"></span><br><span class="line">log4j.appender.file=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=logging.log</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c %t - %m%n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现有如下类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.dslztx;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private static final Logger LOG = Logger.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOG.info(&quot;Run Thread&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;ThreadName&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上类main方法之后，日志文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO 2016-08-13 19:18:24 com.dslztx.Main ThreadName - Run Thread</span><br></pre></td></tr></table></figure>
<h2 id="四、日志对人必须具有可读性"><a href="#四、日志对人必须具有可读性" class="headerlink" title="四、日志对人必须具有可读性"></a><strong>四、日志对人必须具有可读性</strong></h2><p>日志对人必须具有可读性，这个“人”一般是指具有使用Linux下基本的文本处理命令（比如grep，sed，cut，tail等命令）能力的人。</p>
<br/>
参考文献：
[1]https://blog.log4d.com/2015/10/how-to-log/
[2]http://dev.splunk.com/view/logging-best-practices/SP-CAAADP6
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Java技术栈中的伪流行</title>
    <url>/blog/2018/04/14/Java%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%B5%81%E8%A1%8C/</url>
    <content><![CDATA[<p>很多“流行”都是“伪流行”，不结合具体应用强行使用只会带来负面效果。</p>
<h2 id="一、Mybatis"><a href="#一、Mybatis" class="headerlink" title="一、Mybatis"></a><strong>一、Mybatis</strong></h2><p>额外依赖耦合Mybatis框架，增加学习成本，提升使用难度。<br>SQL本就是语言，直接使用，高效简洁，功能强大，无额外依赖耦合。可统一在DAO层完成Java对象与数据库表的转换操作（可借助<code>Apache Commons DbUtils</code>或者<code>Spring JDBCTemplate</code>等第三方库）。</p>
<h2 id="二、Hibernate"><a href="#二、Hibernate" class="headerlink" title="二、Hibernate"></a><strong>二、Hibernate</strong></h2><p>额外依赖耦合Hibernate框架，增加学习成本，提升使用难度。<br>SQL本就是语言，直接使用，高效简洁，功能强大，无额外依赖耦合。可统一在DAO层完成Java对象与数据库表的转换操作（可借助<code>Apache Commons DbUtils</code>或者<code>Spring JDBCTemplate</code>等第三方库）。</p>
<h2 id="三、SpringBoot"><a href="#三、SpringBoot" class="headerlink" title="三、SpringBoot"></a><strong>三、SpringBoot</strong></h2><p>使用不灵活，不易管理控制，易引入冗余依赖。</p>
<h2 id="四、Spring-Framework"><a href="#四、Spring-Framework" class="headerlink" title="四、Spring Framework"></a><strong>四、Spring Framework</strong></h2><p>只是优秀的IoC和AOP框架，不是<code>必须使用</code>，结合实际应用场景再决定是否使用。</p>
<h2 id="五、Gradle"><a href="#五、Gradle" class="headerlink" title="五、Gradle"></a><strong>五、Gradle</strong></h2><p>基于Apache Ant和Apache Maven概念的项目自动化构建工具，功能强大，但是构建脚本可读性差，易导致出现“构建工程师”。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口是否继承Object类</title>
    <url>/blog/2018/04/22/Java%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BFObject%E7%B1%BB/</url>
    <content><![CDATA[<p>我们知道Java具体类继承Object类，那么Java接口是否继承Object类？</p>
<h2 id="一、看似继承"><a href="#一、看似继承" class="headerlink" title="一、看似继承"></a><strong>一、看似继承</strong></h2><p>Java接口引用类型可访问Object类中“public”方法顺利通过编译，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExtendsObjectIs</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    System.out.println(a.hashCode());</span><br><span class="line">    System.out.println(a.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、实则不继承"><a href="#二、实则不继承" class="headerlink" title="二、实则不继承"></a><strong>二、实则不继承</strong></h2><p>Java接口类型不能进行实例化。如果Java接口继承Object类，那么“Java接口类型不能进行实例化”论断不再成立。</p>
<h2 id="三、本质"><a href="#三、本质" class="headerlink" title="三、本质"></a><strong>三、本质</strong></h2><p>根据“一、看似继承”和“二、实则不继承”，答案呼之欲出：Java接口不继承Object类，虚拟机制造了“继承的假象”。<br>在[1]中有下述一段说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If an interface has no direct superinterfaces, then the interface implicitly declares a public abstract member method m with signature s, return type r, and throws clause t corresponding to each public instance method m with signature s, return type r, and throws clause t declared in Object, unless a method with the same signature, same return type, and a compatible throws clause is explicitly declared by the interface.</span><br></pre></td></tr></table></figure>
<p>因此，准确的描述是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟机会在顶层接口（没有父接口的接口）中自动定义一系列对应于Object类中“public”方法的虚方法，除非已经得到了显式定义，这点跟虚拟机会自动定义一个默认构造器类似。</span><br></pre></td></tr></table></figure>
<h3 id="3-1、顶层接口中自动定义的虚方法"><a href="#3-1、顶层接口中自动定义的虚方法" class="headerlink" title="3.1、顶层接口中自动定义的虚方法"></a><strong>3.1、顶层接口中自动定义的虚方法</strong></h3><p>参照Object类中的“public”方法，可知顶层接口中自动定义的虚方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、方法定义冲突"><a href="#3-2、方法定义冲突" class="headerlink" title="3.2、方法定义冲突"></a><strong>3.2、方法定义冲突</strong></h3><p>在同一个具体类或者接口中，两个相同方法签名的方法定义，如果返回类型不同，就会造成冲突。<br>根据上面叙述可知，在顶层接口中定义有一系列对应于Object类中“public”方法的虚方法，因此，在顶层接口中显式定义与这些虚方法“具有相同方法签名，但具有不同返回类型”的虚方法会造成冲突，导致编译错误。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译错误提示信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;toString()&#x27; in &#x27;chapter9.B&#x27; clashes with &#x27;toString()&#x27; in &#x27;java.lang.Object&#x27;; attempting to use incompatible return type</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类实际定义</title>
    <url>/blog/2018/03/27/Java%E7%B1%BB%E5%AE%9E%E9%99%85%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>本博文属于“自我理解”性质，主要基于“Java编译程序实现角度”推导而来。<br>考虑“继承”场景，继承子类（具体类和接口）允许包含“原生成员”和“继承成员”，非继承子类（即“顶层具体类<code>java.lang.Object</code>”和“顶层接口”）只允许包含“原生成员”。</p>
<h2 id="一、原生成员和继承成员"><a href="#一、原生成员和继承成员" class="headerlink" title="一、原生成员和继承成员"></a><strong>一、原生成员和继承成员</strong></h2><h3 id="1-1、原生成员"><a href="#1-1、原生成员" class="headerlink" title="1.1、原生成员"></a><strong>1.1、原生成员</strong></h3><p>原生成员：在本类自身中定义的成员。包括：原生字段（一般字段，静态字段）和原生方法（一般方法，静态方法）。</p>
<h3 id="1-2、继承成员"><a href="#1-2、继承成员" class="headerlink" title="1.2、继承成员"></a><strong>1.2、继承成员</strong></h3><p>继承成员：在父类或者祖先类中定义且能够<font color='red'>继承到本类</font>的成员。包括：继承字段（一般字段，静态字段）和继承方法（一般方法，静态方法）。<br>对于每个继承成员，存在一条继承引用链，假设继承引用链有N个节点，则N&gt;&#x3D;2，且前N-1个节点对应于“继承成员”，最后1个节点对应于“原生成员”，具体可参见“二、Java类实际定义”中的3个例子。</p>
<h2 id="二、Java类实际定义"><a href="#二、Java类实际定义" class="headerlink" title="二、Java类实际定义"></a><strong>二、Java类实际定义</strong></h2><p>Java类的实际定义应该既包含“原生成员”，也包含“继承成员”，这样它的定义才是完整的。当类的定义是完整的，后续再涉及到该类时，可以无需再考虑该类的父类及祖先类，即只需考虑该类自身即可。<br>接下来是几个例子。<br><strong>1、例子1</strong><br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line">  <span class="comment">//int a;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PracticalClass</span> <span class="keyword">extends</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line">  <span class="comment">//int a;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">  <span class="comment">//int c;</span></span><br><span class="line">  <span class="comment">//int g();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>chapter6.PracticalClass.a</code>开始有一条引用链：<code>chapter6.PracticalClass.a -&gt; chapter6.BB.a -&gt; chapter6.AA.a</code>。<br>从<code>chapter6.PracticalClass.f()</code>开始有一条引用链：<code>chapter6.PracticalClass.f() -&gt; chapter6.BB.f() -&gt; chapter6.AA.f()</code>。<br>从<code>chapter6.PracticalClass.c</code>开始有一条引用链：<code>chapter6.PracticalClass.c -&gt; chapter6.BB.c</code>。<br>从<code>chapter6.PracticalClass.g()</code>开始有一条引用链：<code>chapter6.PracticalClass.g() -&gt; chapter6.BB.g()</code>。<br><strong>2、例子2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> <span class="keyword">extends</span> <span class="title class_">IA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line">  <span class="comment">//int a = 10;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IC</span> <span class="keyword">extends</span> <span class="title class_">IB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line">  <span class="comment">//int a = 10;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">  <span class="comment">//int b = 20;</span></span><br><span class="line">  <span class="comment">//int g();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>chapter6.IC.a</code>开始有一条引用链：<code>chapter6.IC.a -&gt; chapter6.IB.a -&gt; chapter6.IA.a</code>。<br>从<code>chapter6.IC.f()</code>开始有一条引用链：<code>chapter6.IC.f() -&gt; chapter6.IB.f() -&gt; chapter6.IA.f()</code>。<br>从<code>chapter6.IC.b</code>开始有一条引用链：<code>chapter6.IC.b -&gt; chapter6.IB.b</code>。<br>从<code>chapter6.IC.g()</code>开始有一条引用链：<code>chapter6.IC.g() -&gt; chapter6.IB.g()</code>。<br><strong>3、例子3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICB</span> <span class="keyword">extends</span> <span class="title class_">ICA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line">  <span class="comment">//int a = 10;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ICD</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICE</span> <span class="keyword">extends</span> <span class="title class_">ICD</span> <span class="keyword">implements</span> <span class="title class_">ICA</span>, ICB &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承成员</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承自ICA</span></span><br><span class="line">  <span class="comment">//int a = 10;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承自ICB</span></span><br><span class="line">  <span class="comment">//int a = 10;</span></span><br><span class="line">  <span class="comment">//int f();</span></span><br><span class="line">  <span class="comment">//int b = 20;</span></span><br><span class="line">  <span class="comment">//int g();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//继承自ICD</span></span><br><span class="line">  <span class="comment">//int c = 30;</span></span><br><span class="line">  <span class="comment">//int h();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>chapter6.ICE.a</code>开始有一条引用链：<code>chapter6.ICE.a -&gt; chapter6.ICA.a</code>。<br>从<code>chapter6.ICE.f()</code>开始有一条引用链：<code>chapter6.ICE.f() -&gt; chapter6.ICA.f()</code>。<br>从<code>chapter6.ICE.a</code>开始有一条引用链：<code>chapter6.ICE.a -&gt; chapter6.ICB.a -&gt; chapter6.ICA.a</code>。<br>从<code>chapter6.ICE.f()</code>开始有一条引用链：<code>chapter6.ICE.f() -&gt; chapter6.ICB.f() -&gt; chapter6.ICA.f()</code>。<br>从<code>chapter6.ICE.b</code>开始有一条引用链：<code>chapter6.ICE.b -&gt; chapter6.ICB.b</code>。<br>从<code>chapter6.ICE.g()</code>开始有一条引用链：<code>chapter6.ICE.g() -&gt; chapter6.ICB.g()</code>。<br>从<code>chapter6.ICE.c</code>开始有一条引用链：<code>chapter6.ICE.c -&gt; chapter6.ICD.c</code>。<br>从<code>chapter6.ICE.h()</code>开始有一条引用链：<code>chapter6.ICE.h() -&gt; chapter6.ICD.h()</code>。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>本博文只关注“Java类实际定义”的核心概念，因此未考虑实际情形中的几个约束条件，比如如下代码会提示<code>Instance method &#39;f()&#39; in &#39;chapter6.ICG&#39; cannot override static method &#39;f()&#39; in &#39;chapter6.ICF&#39;</code>编译错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ICF</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICG</span> <span class="keyword">extends</span> <span class="title class_">ICF</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程思想#一切都是对象</title>
    <url>/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="一、Java数据类型"><a href="#一、Java数据类型" class="headerlink" title="一、Java数据类型"></a><strong>一、Java数据类型</strong></h2><p>分为：基本类型和引用类型。<font color='red'>void&#x2F;Void是一个特殊类型，既可认为是基本类型，也可认为不是基本类型，在本系列中，不认为它是基本类型。</font></p>
<h3 id="1-1、基本类型"><a href="#1-1、基本类型" class="headerlink" title="1.1、基本类型"></a><strong>1.1、基本类型</strong></h3><p>Java中一共有8种基本类型，这些基本类型所占用的存储空间都是固定的，该特性使得Java程序比其他语言的程序更具有可移植性。<br>每种基本类型都有对应的包装器类，基本类型和对应的包装器类之间能够互相无缝转换。<br>关于8种基本类型的描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>类型占据大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>8 bits</td>
<td>-128</td>
<td>+127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16 bits</td>
<td>-2<sup>15</sup></td>
<td>+2<sup>15</sup>-1</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>16 bits</td>
<td>\u0000</td>
<td>\uffff</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>32 bits</td>
<td>-2<sup>31</sup></td>
<td>+2<sup>31</sup>-1</td>
<td>Integer</td>
</tr>
<tr>
<td>float</td>
<td>32 bits</td>
<td>-3.4028235E38</td>
<td>3.4028235E38</td>
<td>Float</td>
</tr>
<tr>
<td>long</td>
<td>64 bits</td>
<td>-2<sup>63</sup></td>
<td>+2<sup>63</sup>-1</td>
<td>Long</td>
</tr>
<tr>
<td>double</td>
<td>64 bits</td>
<td>-1.7976931348623157E308</td>
<td>1.7976931348623157E308</td>
<td>Double</td>
</tr>
</tbody></table>
<p>备注：</p>
<ol>
<li>所有数值类型都有正负号，所以不要去寻找无符号的数值类型</li>
<li>boolean类型所占用的存储空间没有明确指定，仅定义为能够取字面值<code>true</code>和<code>false</code></li>
<li>float和double都符合IEEE 754标准。另外，在Java的Float类中有以下几个静态变量（Double类中类似）<ul>
<li>Float.MAX_VALUE：表示最大正值，最大负值为“-Float.MAX_VALUE”</li>
<li>Float.MIN_VALUE：表示最小能够取到的正数值，这个名称取得很有歧义。注意，0不是正数</li>
<li>Float.MAX_EXPONENT：表示最大能够取到的科学计数法中的指数值</li>
<li>Float.MIN_NORMAL：表示最小能够取到的科学计数法中的底数值</li>
</ul>
</li>
</ol>
<h3 id="1-2、引用类型"><a href="#1-2、引用类型" class="headerlink" title="1.2、引用类型"></a><strong>1.2、引用类型</strong></h3><p>引用类型的类型占据大小为<code>32 bits（32位虚拟机）</code>或者<code>64 bits（64位虚拟机）</code>，引用类型的值逻辑上等价于所引用对象的内存地址，当不引用任何对象时，值为<code>NULL</code>。</p>
<h2 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a><strong>二、类</strong></h2><p>类对应“类对象”和“实例对象”。引用类型引用的对象就包括上述两种对象。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Object.class;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//实例对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>类中包含“字段”和“方法”，“方法”由“方法名”和“参数列表”进行唯一标识。“普通字段”和“普通方法”跟“实例对象”相关联，“静态字段”和“静态方法”跟“类对象”相关联。<br>类的定义中，“字段”（包括“普通字段”和“静态字段”）的默认值描述如表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>double</td>
<td>0.0D</td>
</tr>
<tr>
<td>引用类型</td>
<td>NULL</td>
</tr>
</tbody></table>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、注释"><a href="#3-1、注释" class="headerlink" title="3.1、注释"></a><strong>3.1、注释</strong></h3><p>注释有两种语法：<code>/*...*/</code>和<code>//</code>。</p>
<h3 id="3-2、JavaDoc"><a href="#3-2、JavaDoc" class="headerlink" title="3.2、JavaDoc"></a><strong>3.2、JavaDoc</strong></h3><p>JavaDoc代码位于<code>/**</code>和<code>*/</code>之间，它使得文档代码和源代码处于同一个文件，有利于维护。<br>JavaDoc代码语法主要包括两部分内容：嵌入HTML和文档标签。</p>
<h4 id="3-2-1、嵌入HTML"><a href="#3-2-1、嵌入HTML" class="headerlink" title="3.2.1、嵌入HTML"></a><strong>3.2.1、嵌入HTML</strong></h4><p>直接嵌入HTML标签，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 测试HTML语句&lt;br/&gt; </span><br><span class="line"> * &lt;ol&gt; </span><br><span class="line"> * &lt;li&gt;Item One </span><br><span class="line"> * &lt;li&gt;Item two </span><br><span class="line"> * &lt;li&gt;Item three </span><br><span class="line"> * &lt;/ol&gt; </span><br><span class="line"> */  </span><br></pre></td></tr></table></figure>
<h4 id="3-2-2、文档标签"><a href="#3-2-2、文档标签" class="headerlink" title="3.2.2、文档标签"></a><strong>3.2.2、文档标签</strong></h4><p>文档标签以“@”字符开头，可再细分为“独立文档标签”和“行内文档标签”。<br>独立文档标签只能出现于JavaDoc中每一行的第一个“*”字符后面，常见的独立文档标签有“@see，@version，@author，@since，@param，@return，@throws”，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @author dslztx </span><br><span class="line"> */  </span><br></pre></td></tr></table></figure>
<p>行内文档标签可出现于JavaDoc中每一行的任意位置，但是需要由花括号围括，常见的行内文档标签有“{@link package.class#member label}，{@docRoot}，{@inheritDoc}”，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 你好，这是JavaDoc&#123;@docRoot&#125;测试 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="3-3、作用域"><a href="#3-3、作用域" class="headerlink" title="3.3、作用域"></a><strong>3.3、作用域</strong></h3><h4 id="3-3-1、隐藏作用域"><a href="#3-3-1、隐藏作用域" class="headerlink" title="3.3.1、隐藏作用域"></a><strong>3.3.1、隐藏作用域</strong></h4><p>在C和C++中，将一个较大作用域的变量“隐藏”起来的做法，在Java里是不被允许的。比如如下写法，在C和C++中被允许，在Java中不被允许：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    int x = 12;  </span><br><span class="line">    &#123;  </span><br><span class="line">        int x = 96;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="3-3-2、存活"><a href="#3-3-2、存活" class="headerlink" title="3.3.2、存活"></a><strong>3.3.2、存活</strong></h4><p>“基本类型”和“引用类型”只能存活于作用域内，“对象”（包括“类对象”和“实例对象”）可存活于作用域外。</p>
<h3 id="3-4、向前引用"><a href="#3-4、向前引用" class="headerlink" title="3.4、向前引用"></a><strong>3.4、向前引用</strong></h3><p>Java解决了“向前引用”问题，即在某处可使用在其后定义的资源。</p>
<h3 id="3-5、默认导入包"><a href="#3-5、默认导入包" class="headerlink" title="3.5、默认导入包"></a><strong>3.5、默认导入包</strong></h3><p>默认导入“java.lang.*”包，即等价于在每个“.java”源文件中，默认包含“import java.lang.*”语句。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#初始化与清理</title>
    <url>/blog/2017/11/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>本文在“针对类（Class）和抽象类（Abstract Class）（即不包括接口（Interface），枚举（Enum），注解（Annotation）），且不存在继承关系”的背景下进行介绍。</p>
<h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a><strong>一、初始化</strong></h2><h3 id="1-1、实例对象和类对象初始化"><a href="#1-1、实例对象和类对象初始化" class="headerlink" title="1.1、实例对象和类对象初始化"></a><strong>1.1、实例对象和类对象初始化</strong></h3><h4 id="1-1-1、实例对象初始化"><a href="#1-1-1、实例对象初始化" class="headerlink" title="1.1.1、实例对象初始化"></a><strong>1.1.1、实例对象初始化</strong></h4><p>实例对象的字段（即普通字段）按照如下顺序进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、默认初始化</span><br><span class="line">2、定义初始化</span><br><span class="line">3、实例初始化语句初始化</span><br><span class="line">4、构造器初始化</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认初始化和定义初始化</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;定义初始化后 i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例初始化语句初始化</span></span><br><span class="line">    i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;实例初始化语句初始化后 i:&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InitialOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造器初始化</span></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;构造器初始化后 i:&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InitialOrder</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;默认初始化后 i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发条件：实例对象的创建。需要注意的是：1）实例对象初始化中“默认初始化”和“构造器初始化”初始化阶段必存在，“定义初始化”和“实例初始化语句初始化”初始化阶段可选存在；2）实例对象初始化中初始化阶段之间连续不间断。</p>
<h4 id="1-1-2、类对象初始化"><a href="#1-1-2、类对象初始化" class="headerlink" title="1.1.2、类对象初始化"></a><strong>1.1.2、类对象初始化</strong></h4><p>类对象的字段（即静态字段）按照如下顺序进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、默认初始化</span><br><span class="line">2、定义初始化</span><br><span class="line">3、静态初始化语句初始化</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialOrder2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//如果第一次遇见ExperimentObject类的声明，创建类对象，且触发“默认初始化”</span></span><br><span class="line">    <span class="type">ExperimentObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ExperimentObject类对象已经创建，则触发“定义初始化和静态初始化语句初始化”；否则创建ExperimentObject类对象，且触发“默认初始化，定义初始化，静态初始化语句初始化”</span></span><br><span class="line">    Class.forName(<span class="string">&quot;chapter5.ExperimentObject&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExperimentObject</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认初始化和定义初始化</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;定义初始化后 i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态初始化语句初始化</span></span><br><span class="line">    i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;静态初始化语句初始化后 i:&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;默认初始化后 i:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类对象初始化中“默认初始化”初始化阶段触发条件：第一次遇见类的声明，从而引发加载类的Class文件和创建类对象。<br>类对象初始化中“定义初始化和静态初始化语句初始化”初始化阶段触发条件：第一次访问类的“静态字段，静态方法，构造方法”，第一次子类触发级联触发父类，<code>Class.forName(相应类类路径)</code>语句第一次执行。<br>综合来看：1）类对象初始化中“默认初始化”初始化阶段必存在，“定义初始化”和“静态初始化语句初始化”初始化阶段可选存在；2）类对象初始化中“默认初始化”和“定义初始化，静态初始化语句初始化”初始化阶段之间可间断不连续（因为“默认初始化”初始化阶段和“定义初始化，静态初始化语句初始化”初始化阶段有相互独立的触发条件），“定义初始化”和“静态初始化语句初始化”初始化阶段之间连续不间断。</p>
<h3 id="1-2、其他"><a href="#1-2、其他" class="headerlink" title="1.2、其他"></a><strong>1.2、其他</strong></h3><p>关于实例对象和类对象初始化有以下几点说明：</p>
<ul>
<li>实例对象和类对象初始化中“默认初始化”初始化阶段的默认初始化值遵照<a href="/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/" title="Java编程思想#一切都是对象">Java编程思想#一切都是对象</a>中的表2</li>
<li>类对象初始化先于实例对象初始化</li>
<li>类对象初始化至多进行1次，实例对象初始化可进行任意多次</li>
</ul>
<p>最后是一个关于实例对象和类对象初始化的综合示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一次访问Main类的静态方法，使得加载Main类的Class文件，创建类对象，引发类对象初始化中的“默认初始化”，接着引发类对象初始化中的“定义初始化和静态初始化语句初始化”&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 1）分配完类对象的内存之后，首先进行静态字段的“默认初始化”。静态字段a，b，c被默认初始化为0值&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 2）接下来进行静态字段的“定义初始化”。按照静态字段的定义顺序，依次进行静态字段的定义初始化，a没有定义初始化，b有定义初始化被初始化为10，这同时说明此时c还未被定义初始化，还只是默认初始化得到的0值，c有定义初始化，被初始化为20&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 3）执行“静态初始化语句初始化”过程。a被赋值为10，c被赋值为30&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 创建Main类实例对象&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 1）分配完实例对象的内存之后，首先进行普通字段的“默认初始化”。普通字段d，f，g被默认初始化为0值&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 2）按照普通字段的定义顺序，依次进行普通字段的“定义初始化”。d没有定义初始化，f有定义初始化被初始化为10，这同时说明此时g还未被定义初始化，还只是默认初始化得到的0值，g有定义初始化，被初始化为20&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 3）执行“实例初始化语句初始化”过程。d被赋值为10，g被赋值为40&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 4）执行“构造器初始化”过程。d被赋值为20，g被赋值为30&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> f();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;static initialize start&quot;</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">&quot;static initialize end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> h();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;initialize start&quot;</span>);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(g);</span><br><span class="line"></span><br><span class="line">    d = <span class="number">10</span>;</span><br><span class="line">    g = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(g);</span><br><span class="line">    System.out.println(<span class="string">&quot;initialize end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">    d = <span class="number">20</span>;</span><br><span class="line">    g = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;constructor print start&quot;</span>);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(g);</span><br><span class="line">    System.out.println(<span class="string">&quot;constructor print end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 第一次访问Main类的静态方法，使得加载Main类的Class文件，创建类对象，引发类对象初始化中的“默认初始化”，接着引发类对象初始化中的“定义初始化和静态初始化语句初始化”</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    System.out.println(Main.a);</span><br><span class="line">    System.out.println(Main.b);</span><br><span class="line">    System.out.println(Main.c);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;分割线-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Main类的实例对象</span></span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    System.out.println(main.d);</span><br><span class="line">    System.out.println(main.f);</span><br><span class="line">    System.out.println(main.g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、清理"><a href="#二、清理" class="headerlink" title="二、清理"></a><strong>二、清理</strong></h2><p>实例对象和类对象由垃圾回收器负责进行回收。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、方法重载"><a href="#3-1、方法重载" class="headerlink" title="3.1、方法重载"></a><strong>3.1、方法重载</strong></h3><p>1、重载方法之间以参数类型列表进行区分，不能以返回值进行区分<br>2、调用重载方法时，最终会绑定到最契合传入实参的重载方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloading</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Overloading</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Overloading</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    o.f(a);</span><br><span class="line"></span><br><span class="line">    o.g(o);</span><br><span class="line"></span><br><span class="line">    o.h(a);</span><br><span class="line"></span><br><span class="line">    o.j(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">short</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f(short)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">(Object a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;g(Object)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">(<span class="type">short</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;h(short)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">(<span class="type">byte</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;h(byte)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">j</span><span class="params">(Object a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;j(Object)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">j</span><span class="params">(Overloading a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;j(Overloading)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、构造器"><a href="#3-2、构造器" class="headerlink" title="3.2、构造器"></a><strong>3.2、构造器</strong></h3><p>当且只当不显式指定构造器时，编译器才会自动创建一个默认构造器。<br>允许进行构造器方法重载。</p>
<h3 id="3-3、this关键词"><a href="#3-3、this关键词" class="headerlink" title="3.3、this关键词"></a><strong>3.3、this关键词</strong></h3><p>this关键词有两个用途：“指代本实例对象”和“在构造器中调用构造器”。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisKeyword</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThisKeyword</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThisKeyword</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(a, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> A)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = A;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ThisKeyword <span class="title function_">getThisInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用this调用构造器有以下限制：</p>
<ul>
<li>“this调用构造器”只能在构造器中使用</li>
<li>“this调用构造器”只能置于构造器最起始处</li>
<li>“this调用构造器”在同一个构造器中至多使用1次</li>
</ul>
<h3 id="3-4、finalize-方法"><a href="#3-4、finalize-方法" class="headerlink" title="3.4、finalize()方法"></a><strong>3.4、finalize()方法</strong></h3><p>垃圾回收过程中，在回收对象之前至多会调用1次对象的<code>finalize()</code>方法，因此，该方法机制的设计初衷是我们可以覆盖实现自己的<code>finalize()</code>方法，在覆盖实现后的<code>finalize()</code>方法中做垃圾回收前的清理工作，但是基于以下两点原因，我们不应该使用<code>finalize()</code>方法机制来做垃圾回收前的清理工作：</p>
<ul>
<li>有可能不进入垃圾回收过程，比如通过<code>System.exit()</code>命令直接退出Java进程</li>
<li>在垃圾回收过程中，回收对象之前至多会调用1次对象的<code>finalize()</code>方法，但也有可能不调用</li>
</ul>
<h3 id="3-5、内存泄漏"><a href="#3-5、内存泄漏" class="headerlink" title="3.5、内存泄漏"></a><strong>3.5、内存泄漏</strong></h3><p>在Java中，也有可能出现内存泄漏的情形，比如在本地方法中分配的内存（例如C&#x2F;C++语言实现的本地方法中使用<code>malloc</code>方法分配内存）。</p>
<h3 id="3-6、数组初始化"><a href="#3-6、数组初始化" class="headerlink" title="3.6、数组初始化"></a><strong>3.6、数组初始化</strong></h3><p>数组初始化有3种形式，需要注意的是，第1种只能用在数组定义处。分别以“int[]”和“String[]”数组为例进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayInitialize</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//该种数组初始化形式只能用在数组定义处</span></span><br><span class="line">    <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span>[] aa = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] aaa = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    aaa[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    aaa[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    aaa[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能用在数组定义处</span></span><br><span class="line">    String[] b = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    String[] bb = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">    String[] bbb = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">    bbb[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    bbb[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>备注：</font><br>1、数组初始化后，数组元素的默认值遵从<a href="/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/" title="Java编程思想#一切都是对象">Java编程思想#一切都是对象</a>中的表2</p>
<h3 id="3-7、可变参数列表"><a href="#3-7、可变参数列表" class="headerlink" title="3.7、可变参数列表"></a><strong>3.7、可变参数列表</strong></h3><p>自从JDK 1.5开始，Java引入了对可变参数列表的支持，可变参数列表本质上还是一个数组，因此适用于“foreach语法”，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArg</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>... a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> aa : a) &#123;</span><br><span class="line">      System.out.println(aa);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">(Object... b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object bb : b) &#123;</span><br><span class="line">      System.out.println(bb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8、方法实现体中的变量不会进行默认初始化"><a href="#3-8、方法实现体中的变量不会进行默认初始化" class="headerlink" title="3.8、方法实现体中的变量不会进行默认初始化"></a><strong>3.8、方法实现体中的变量不会进行默认初始化</strong></h3><p>方法实现体中的变量不会像类中的字段（包括普通和静态字段）一样进行默认初始化。编译过程会因为存在未被初始化的变量而失败。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodVariableInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="comment">//编译出错，提示变量b未被初始化</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9、失效的“向前引用”"><a href="#3-9、失效的“向前引用”" class="headerlink" title="3.9、失效的“向前引用”###"></a><strong>3.9、失效的“向前引用”</strong>###</h3><p>根据<a href="/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/" title="Java编程思想#一切都是对象">Java编程思想#一切都是对象</a>可知，Java解决了“向前引用”的问题，即在某处可使用在其后定义的资源。<br>但是现在有如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> f(c);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>int a = f(c);</code>语句处，编译器报出<code>Illegal forward reference</code>（非法的向前引用）错误。这看起来是“向前引用”失效了。<br>其实这个“向前引用”失效跟初始化顺序相关，编译器认为你的本意是将“10”传给<code>f()</code>方法，如果上面这段代码编译通过的话，<code>f()</code>方法最后得到的传入值将是“0”（c的默认初始化值为0)。为了防止这种“surprise”的产生，编译器报出了如上错误。（如果将<code>int a = f(c);</code>语句和<code>int c = 10;</code>语句互换位置，编译器就不会报错）<br>又有以下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> g();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    System.out.println(main.a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该段代码编译能够通过，但是从严格意义上来，如果按照上述思路，那么<code>int a = g();</code>语句也是一个非法的向前引用。<br>综上，Java关于这个问题的语法糖真是不伦不类。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#复用类</title>
    <url>/blog/2018/01/07/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>“类”有“广义”和“狭义”之分。“广义的类”包括：狭义的类（Class），抽象类（Abstract Class），接口（Interface），枚举（Enum），注解（Annotation）。<font color='red'>为了进行区分，在接下来的叙述中，“类”指代“广义的类”，“具体类”指代“狭义的类”。</font></p>
<h2 id="一、类的本质分类"><a href="#一、类的本质分类" class="headerlink" title="一、类的本质分类"></a><strong>一、类的本质分类</strong></h2><p>根据以上叙述可知，“类”包括：具体类（Class），抽象类（Abstract Class），接口（Interface），枚举（Enum），注解（Annotation）。但是本质上“类”只包括“具体类和接口”两种，原因描述如下：</p>
<ul>
<li>“抽象类”本质上是“含有抽象方法的具体类”</li>
<li>“枚举”本质上是“具体类”，可以使用<code>javap</code>命令进行查看</li>
<li>“注解”本质上是“接口”，可以使用<code>javap</code>命令进行查看</li>
</ul>
<p>而内部类只是处于类中的“具体类，抽象类，接口，枚举，注解”的特定称呼而已。<br><br/><br><font color='red'>在接下来的描述中，“类”就只包含“具体类”和“接口”。</font></p>
<h2 id="二、复用类的3种方式"><a href="#二、复用类的3种方式" class="headerlink" title="二、复用类的3种方式"></a><strong>二、复用类的3种方式</strong></h2><h3 id="2-1、组合"><a href="#2-1、组合" class="headerlink" title="2.1、组合"></a><strong>2.1、组合</strong></h3><p>复用现有类的功能。</p>
<h3 id="2-2、继承"><a href="#2-2、继承" class="headerlink" title="2.2、继承"></a><strong>2.2、继承</strong></h3><p>复用现有类的形式。</p>
<h3 id="2-3、代理"><a href="#2-3、代理" class="headerlink" title="2.3、代理"></a><strong>2.3、代理</strong></h3><p>组合和继承之间的中庸之道，我们将一个实例对象（只有具体类才具有实例对象）作为字段置于所要构造的新类（具体类）中（就像组合），但与此同时在新类中暴露该实例对象的某个方法子集（就像继承）。</p>
<h2 id="三、继承"><a href="#三、继承" class="headerlink" title="三、继承"></a><strong>三、继承</strong></h2><p>关于“继承”有以下几点描述：</p>
<ul>
<li>当创建一个类时，总是在继承，除非已明确指出要从其他类继承，否则就是在隐式地从Java的标准根类Object继承 （接口跟Object类的关系在“接口”章节进行详细介绍）</li>
<li>继承时，会自动继承基类中可被继承的字段和方法</li>
<li>继承时，可以继承基类方法，覆盖基类方法，重载基类方法，可以通过<code>@Override</code>注解断言“覆盖基类方法”，从而防止意外重载基类的方法 </li>
<li>生成导出类实例对象（导出类为具体类）时，会有基类子实例对象（基类为具体类）生成。当创建了一个导出类的实例对象时，该实例对象包含了一个基类的子实例对象，这个子实例对象与你用基类直接创建的实例对象是一样的。二者区别在于，后者来自外部，而基类的子实例对象被包装在导出类实例对象内部</li>
<li>在生成导出类实例对象时，对基类子实例对象的正确初始化也是至关重要的，这个只能通过调用基类构造器来完成。JVM会在导出类的构造器中插入对基类构造器的调用，只有基类构造器才能完成基类子实例对象的正确初始化。如果基类构造器为带参构造器，那么在导出类构造器中必须通过<code>super</code>语句显式调用基类的带参构造器</li>
</ul>
<h2 id="四、完备介绍“初始化与清理”"><a href="#四、完备介绍“初始化与清理”" class="headerlink" title="四、完备介绍“初始化与清理”"></a><strong>四、完备介绍“初始化与清理”</strong></h2><p>在包含“具体类，抽象类，接口，枚举，注解”（本质上只有“具体类”和“接口”），且存在继承关系的背景下，对<a href="/blog/2017/11/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java编程思想#初始化与清理">Java编程思想#初始化与清理</a>作补充，完备介绍“初始化与清理”相关内容。<br>一个综合复杂的继承关系示例图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180107-0-1.png"></p>
<h3 id="4-1、完备介绍“初始化”"><a href="#4-1、完备介绍“初始化”" class="headerlink" title="4.1、完备介绍“初始化”"></a><strong>4.1、完备介绍“初始化”</strong></h3><h4 id="4-1-1、完备介绍“类对象初始化”"><a href="#4-1-1、完备介绍“类对象初始化”" class="headerlink" title="4.1.1、完备介绍“类对象初始化”"></a><strong>4.1.1、完备介绍“类对象初始化”</strong></h4><p>触发时机：第一次访问类的“静态字段，静态方法，构造方法”，<code>Class.forName(相应类类路径)</code>语句第一次执行。<font color='red'>类对象初始化最多执行一次。</font><br>触发后初始化过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void initializeForClassObject(当前类) &#123;</span><br><span class="line">  当前类在之前已经完成初始化则直接返回</span><br><span class="line"></span><br><span class="line">  if (当前类是具体类) &#123;</span><br><span class="line">    if (存在当前类的“父类具体类”)&#123;</span><br><span class="line">      //递归进行“父类具体类”的类对象初始化</span><br><span class="line">      initializeForClassObject(父类具体类）</span><br><span class="line">          </span><br><span class="line">      1、默认初始化（有可能在此之前已经完成，那么不再重复）</span><br><span class="line">      2、定义初始化</span><br><span class="line">      3、静态初始化语句初始化</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      //即当前类是java.lang.Object</span><br><span class="line">      </span><br><span class="line">      1、默认初始化（有可能在此之前已经完成，那么不再重复）</span><br><span class="line">      2、定义初始化</span><br><span class="line">      3、静态初始化语句初始化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //即当前类是接口</span><br><span class="line"></span><br><span class="line">    1、默认初始化（有可能在此之前已经完成，那么不再重复）</span><br><span class="line">    2、定义初始化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：<br>类对象的默认初始化有可能已经先于其他初始化（定义初始化，静态初始化语句初始化）完成，具体机制跟虚拟机的具体实现相关，且默认初始化不是整个初始化流程的关键所在，因此这里不再深究。</p>
<h4 id="4-1-2、完备介绍“实例对象初始化”"><a href="#4-1-2、完备介绍“实例对象初始化”" class="headerlink" title="4.1.2、完备介绍“实例对象初始化”"></a><strong>4.1.2、完备介绍“实例对象初始化”</strong></h4><p>触发时机：创建实例对象（再次提醒：只能通过构造器创建实例对象，接口没有实例对象，只能对应于具体类）。<br>触发后初始化过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void initializeForInstanceObject(当前具体类) &#123;</span><br><span class="line">  首先分配当前具体类和所有祖先具体类的内存，并进行默认初始化</span><br><span class="line"></span><br><span class="line">  //接下来执行构造器方法</span><br><span class="line">  构造方法(当前具体类)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void 构造方法(当前具体类) &#123;</span><br><span class="line">  if (构造器方法中首语句是this语句) &#123;</span><br><span class="line">    调用this语句指代的构造器方法——构造方法(当前具体类)</span><br><span class="line">    执行“构造器方法中其他语句（不能再包含this语句）”</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (本类是Object类) &#123;</span><br><span class="line">      执行“定义初始化”（构造方法中隐式包含相应的触发执行语句）</span><br><span class="line">      执行“实例初始化语句初始化”（构造方法中隐式包含相应的触发执行语句）</span><br><span class="line">      执行“构造器方法中其他语句”</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      隐式或显式调用super语句，调用父类具体类的构造方法——构造方法(父类具体类)</span><br><span class="line"></span><br><span class="line">      执行“定义初始化”（构造方法中隐式包含相应的触发执行语句）</span><br><span class="line">      执行“实例初始化语句初始化”（构造方法中隐式包含相应的触发执行语句）</span><br><span class="line">      执行“构造器方法中其他语句”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2、完备介绍“清理”"><a href="#4-2、完备介绍“清理”" class="headerlink" title="4.2、完备介绍“清理”"></a><strong>4.2、完备介绍“清理”</strong></h3><p>由<a href="/blog/2017/11/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java编程思想#初始化与清理">Java编程思想#初始化与清理</a>可知，当我们需要清理一些自定义的资源时，不能依赖<code>finalize</code>方法，得自己编写特殊的清理方法。在继承场景下，另外还需要注意这些清理方法的调用顺序：跟资源初始化顺序相反，防止出现“在清理资源时，该资源所依赖资源已经被提前清理，而导致错误”的情形。</p>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a><strong>五、其他</strong></h2><h3 id="5-1、super关键词"><a href="#5-1、super关键词" class="headerlink" title="5.1、super关键词"></a><strong>5.1、super关键词</strong></h3><p>跟this关键词类似，关于this关键词可参见<a href="/blog/2017/11/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="Java编程思想#初始化与清理">Java编程思想#初始化与清理</a>。super关键词有两个用途：“指代基类实例对象”和“在构造器中调用基类构造器”。<br><font color='red'>跟this关键词不一样的是，可执行<code>return this;</code>语句，不可执行<code>return super;</code>语句，可认为这个区别基于“基类的子实例对象被包装在导出类实例对象内部”的特性。</font><br>使用super调用基类构造器有以下限制：</p>
<ul>
<li>“super调用基类构造器”只能在构造器中使用</li>
<li>“super调用基类构造器”只能置于构造器最起始处</li>
<li>“super调用基类构造器”在同一个构造器中至多使用1次</li>
</ul>
<h3 id="5-2、java命令能够作用于具有包访问权限的类生成的class文件"><a href="#5-2、java命令能够作用于具有包访问权限的类生成的class文件" class="headerlink" title="5.2、java命令能够作用于具有包访问权限的类生成的class文件"></a><strong>5.2、java命令能够作用于具有包访问权限的类生成的class文件</strong></h3><p>现在有一个“Main.java”文件，其中内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;Hello World&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SecondClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;Hello World&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>javac Main.java</code>命令，得到“Main.class”和“SecondClass.class”两个文件。执行<code>java Main</code>命令，得到打印的“Hello World”内容；执行<code>java SecondClass</code>命令，也能够得到打印的“Hello World”内容。<br>以上说明了java命令不只能够作用于具有public访问权限的类生成的class文件，也能够作用于具有包访问权限的类生成的class文件。</p>
<br/>
参考文献：
[1]https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html
[2]https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#对象导论</title>
    <url>/blog/2017/10/25/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="一、组合与继承"><a href="#一、组合与继承" class="headerlink" title="一、组合与继承"></a><strong>一、组合与继承</strong></h2><p>在建立新类时，应该首先考虑组合，因为它更加简单灵活，而使用继承往往会导致过分复杂的设计。</p>
<h2 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a><strong>二、多态</strong></h2><p>Java中动态绑定是默认的，C++中通过virtual修饰符来声明使用动态绑定（动态绑定又可以被称为后期绑定，跟动态绑定相对应的是静态绑定或者前期绑定）。</p>
<h2 id="三、垃圾回收机制"><a href="#三、垃圾回收机制" class="headerlink" title="三、垃圾回收机制"></a><strong>三、垃圾回收机制</strong></h2><p>Java的垃圾回收机制使得使用Java编程相对于使用C++编程要简单得多。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#控制执行流程</title>
    <url>/blog/2017/11/12/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Java中具有3种语句结构：顺序结构，条件结构和循环结构。“顺序结构”是常见的语句结构，接下来主要介绍“条件结构”和“循环结构”。</p>
<h2 id="一、条件结构"><a href="#一、条件结构" class="headerlink" title="一、条件结构"></a><strong>一、条件结构</strong></h2><h3 id="1-1、if-elseif-else结构"><a href="#1-1、if-elseif-else结构" class="headerlink" title="1.1、if-elseif-else结构"></a><strong>1.1、if-elseif-else结构</strong></h3><p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Boolean-expression )</span><br><span class="line">  statement</span><br><span class="line">[<span class="keyword">else</span> <span class="keyword">if</span> ( Boolean-expression )</span><br><span class="line">  statement]</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">else</span> <span class="keyword">if</span> ( Boolean-expression )</span><br><span class="line">  statement]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  statement]</span><br></pre></td></tr></table></figure>
<h3 id="1-2、switch结构"><a href="#1-2、switch结构" class="headerlink" title="1.2、switch结构"></a><strong>1.2、switch结构</strong></h3><p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( integral-selector ) &#123;</span><br><span class="line">  <span class="keyword">case</span> integral-value1 : [statement;] [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> integral-value2 : [statement;] [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> integral-value3 : [statement;] [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> integral-value4 : [statement;] [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> integral-value5 : [statement;] [<span class="keyword">break</span>;]</span><br><span class="line">  ...</span><br><span class="line">  [<span class="keyword">default</span> : [statement;] [<span class="keyword">break</span>;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求<code>integral-selector</code>表达式的值类型为“byte，short，char，int”4种类型之一，或者为以上4种类型对应包装器类型之一，或者为枚举类型，<code>integral-value</code>为相应于<code>integral-selector</code>表达式值类型的常量值，即至多int型范围内的整型常量值，或者char型范围内的字符，或者枚举常量值。</p>
<h2 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a><strong>二、循环结构</strong></h2><h3 id="2-1、while结构"><a href="#2-1、while结构" class="headerlink" title="2.1、while结构"></a><strong>2.1、while结构</strong></h3><p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( Boolean-expression )</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>
<h3 id="2-2、do-while结构"><a href="#2-2、do-while结构" class="headerlink" title="2.2、do-while结构"></a><strong>2.2、do-while结构</strong></h3><p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  statement</span><br><span class="line"><span class="title function_">while</span> <span class="params">( Boolean-expression )</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3、for结构"><a href="#2-3、for结构" class="headerlink" title="2.3、for结构"></a><strong>2.3、for结构</strong></h3><p>形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( [initialization] ; [Boolean-expression] ; [step] )</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>
<p><code>initialization</code>：初始化表达式，可空，可用逗号隔开一系列语句，从而可以定义任意数量的同一类型的变量。<br><code>Boolean-expression</code>：布尔表达式，可空。<br><code>step</code>：步进运算表达式，可空，可用逗号隔开一系列语句，从而可执行多个步进运算表达式。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">2</span>; i &lt; <span class="number">5</span>; i++, j = i * <span class="number">2</span>) &#123;</span><br><span class="line">      主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，Java SE5引入了一种新的更加简洁的用于数组和容器的for语法，即foreach语法，foreach语法使得更容易获得访问项，而无需再通过计数。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachFloat</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="type">float</span>[] f = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      f[i] = rand.nextFloat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> x : f) &#123;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#操作符</title>
    <url>/blog/2017/10/29/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="一、操作符"><a href="#一、操作符" class="headerlink" title="一、操作符"></a><strong>一、操作符</strong></h2><p>Java中几乎所有的操作符只能操作基本类型，例外的操作符有<code>=</code>，<code>==</code>和<code>!=</code>，这些操作符能够操作所有的对象，除此之外，<code>+</code>和<code>+=</code>操作符被String类支持。<br>具体操作符类别适用的类型范围无需特别关注，比如“逻辑操作符仅适用于boolean基本类型，移位操作符不适用于boolean基本类型”等，因为上述范围是显而易见的。<br>当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。最简单的规则是先乘除后加减，最好用括号明确规定计算顺序。<br>操作符描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>操作符类别</th>
<th>操作符列表</th>
</tr>
</thead>
<tbody><tr>
<td>赋值操作符</td>
<td><code>=</code></td>
</tr>
<tr>
<td>算术操作符</td>
<td><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></td>
</tr>
<tr>
<td>递增和递减操作符</td>
<td><code>++</code>，<code>--</code></td>
</tr>
<tr>
<td>关系操作符</td>
<td><code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>==</code>，<code>!=</code></td>
</tr>
<tr>
<td>逻辑操作符</td>
<td><code>&amp;&amp;</code>，<code>&#124;&#124;</code>，<code>!</code></td>
</tr>
<tr>
<td>按位操作符</td>
<td><code>&amp;</code>，<code>&#124;</code>，<code>^</code>，<code>~</code></td>
</tr>
<tr>
<td>移位操作符</td>
<td><code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code></td>
</tr>
<tr>
<td>包含赋值操作符的复合操作符</td>
<td><code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>&amp;=</code>，…，<code>&lt;&lt;=</code>，<code>&gt;&gt;=</code></td>
</tr>
<tr>
<td>三元操作符</td>
<td><code>boolean-exp?value0:value1</code></td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ol>
<li>递增和递减操作符。有“前缀式”和“后缀式”两种使用形式</li>
<li>逻辑操作符。使用逻辑操作符，存在短路现象。有些情况下对短路机制加以利用，可获得性能提升</li>
<li>移位操作符。<code>&lt;&lt;</code>，左移操作符，低位补0；<code>&gt;&gt;</code>，有符号右移操作符，高位补符号位；<code>&gt;&gt;&gt;</code>，无符号右移操作符，高位补0</li>
<li>按位操作符。布尔类型可被作为单比特值对待，因而可对布尔类型使用除了<code>~</code>之外的按位操作符，即<code>&amp;</code>，<code>|</code>和<code>^</code>。另外，对布尔类型使用按位操作符，不会产生短路现象。示例代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会短路</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不会短路</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> <span class="literal">true</span> &amp; <span class="literal">false</span> &amp; <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、基本类型之间的类型转换"><a href="#二、基本类型之间的类型转换" class="headerlink" title="二、基本类型之间的类型转换"></a><strong>二、基本类型之间的类型转换</strong></h2><h3 id="2-1、基本类型再细化"><a href="#2-1、基本类型再细化" class="headerlink" title="2.1、基本类型再细化"></a><strong>2.1、基本类型再细化</strong></h3><p>根据<a href="/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/" title="Java编程思想#一切都是对象">Java编程思想#一切都是对象</a>可知，基本类型有：boolean，byte，short，char，int，float，long，double。又可再细分为布尔型（boolean），整型（byte，short，char，int，long）和浮点型（float，double）这3类。</p>
<h3 id="2-2、类型转换分类"><a href="#2-2、类型转换分类" class="headerlink" title="2.2、类型转换分类"></a><strong>2.2、类型转换分类</strong></h3><p><strong>分类一：</strong>基本类型之间的类型转换根据是否需要明确指定类型转换过程而分为，<code>显式类型转换和隐式类型转换</code><br><strong>分类二：</strong>根据转换前后数值表达范围的变化可分为，<code>窄化转换和扩展转换</code>。窄化转换可能造成数据丢失，扩展转换不会造成数据丢失。<font color='red'>窄化转换必须是显式转换，扩展转换既允许是隐式转换，也允许是显式转换</font><br><strong>分类三：</strong>Java允许把任何基本类型转换成别的基本类型，但布尔型除外，布尔型根本不允许进行任何的类型转换。因此，最终允许的转换情形是：<code>整型集合内部的类型转换，浮点型集合内部的类型转换以及整型和浮点型之间的类型转换</code></p>
<h4 id="2-2-1、整型到浮点型"><a href="#2-2-1、整型到浮点型" class="headerlink" title="2.2.1、整型到浮点型"></a><strong>2.2.1、整型到浮点型</strong></h4><p>扩展转换，既允许是隐式转换，也允许是显式转换。</p>
<h4 id="2-2-2、浮点型到整型"><a href="#2-2-2、浮点型到整型" class="headerlink" title="2.2.2、浮点型到整型"></a><strong>2.2.2、浮点型到整型</strong></h4><p>窄化转换，必须是显式转换，处理方式是截尾，可能丢失信息。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未丢失信息</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1F</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) f;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//丢失信息</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) f;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3、整型到整型"><a href="#2-2-3、整型到整型" class="headerlink" title="2.2.3、整型到整型"></a><strong>2.2.3、整型到整型</strong></h4><p>如果是扩展转换，既允许是隐式转换，也允许是显式转换，不丢失信息；如果是窄化转换，必须是显式转换，处理方式是截取低端位相应位数的二进制位，可能丢失信息。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//丢失信息</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x1ff</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) a;</span><br><span class="line"><span class="comment">//那么截取低端位8位二进制位，得到b=0xff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//未丢失信息</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x1f</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) a;</span><br><span class="line"><span class="comment">//那么截取低端位8位二进制位，得到b=0x1f</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4、浮点型到浮点型"><a href="#2-2-4、浮点型到浮点型" class="headerlink" title="2.2.4、浮点型到浮点型"></a><strong>2.2.4、浮点型到浮点型</strong></h4><p>如果是扩展转换，既允许是隐式转换，也允许是显式转换，不丢失信息；如果是窄化转换，必须是显式转换，处理方式按照IEEE 754标准规范[1]，可能丢失信息。</p>
<h3 id="2-3、隐式扩展类型转换触发"><a href="#2-3、隐式扩展类型转换触发" class="headerlink" title="2.3、隐式扩展类型转换触发"></a><strong>2.3、隐式扩展类型转换触发</strong></h3><h4 id="2-3-1、操作符触发"><a href="#2-3-1、操作符触发" class="headerlink" title="2.3.1、操作符触发"></a><strong>2.3.1、操作符触发</strong></h4><p>当使用的操作符为“算术操作符，按位操作符，移位操作符”且操作数为“整型基本类型”时，操作符要求操作数的类型至少是“int型”，<font color='red'>即可以是int型或者long型</font>，如果是byte型，short型，char型则自动转换成int型。<br>以下示例以byte型为例，short型和char型同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">ba</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算术操作符的例子，编译错误。因为：右边表达式中ba和bb会被隐式扩展成int型，而左边变量为byte型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">bc</span> <span class="operator">=</span> ba + bb;</span><br><span class="line"><span class="type">byte</span> <span class="variable">bd</span> <span class="operator">=</span> ba - bb;</span><br><span class="line"><span class="type">byte</span> <span class="variable">be</span> <span class="operator">=</span> ba * bb;</span><br><span class="line"><span class="type">byte</span> <span class="variable">bf</span> <span class="operator">=</span> ba / bb;</span><br><span class="line"><span class="type">byte</span> <span class="variable">bg</span> <span class="operator">=</span> ba % bb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位操作符的例子，编译错误。因为：右边表达式中ba和bb会被隐式扩展成int型，而左边变量为byte型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">bh</span> <span class="operator">=</span> ba &amp; bb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移位操作符的例子，编译错误。因为：右边表达式中ba和bb会被隐式扩展成int型，而左边变量为byte型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">bi</span> <span class="operator">=</span> ba &gt;&gt; bb;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2、表达式中最大的数据类型决定了最终结果的数据类型"><a href="#2-3-2、表达式中最大的数据类型决定了最终结果的数据类型" class="headerlink" title="2.3.2、表达式中最大的数据类型决定了最终结果的数据类型"></a><strong>2.3.2、表达式中最大的数据类型决定了最终结果的数据类型</strong></h4><p>比如操作符两边都为整型，其中一边是整型中的A类型，另一边是整型中的B类型，A类型大于B类型，那么B类型变量会被隐式扩展成A类型。<br>比如如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//byte型的a被隐式扩展成int型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int型的b被隐式扩展成long型</span></span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> b + c;</span><br></pre></td></tr></table></figure>
<p>又比如操作符两边都为浮点型，其中一边是float型，另一边是double型，那么float型会被隐式扩展成double型；又比如操作符两边中一边是整型，另一边是浮点型，那么整型会被隐式扩展成浮点型。</p>
<h4 id="2-3-3、方法调用过程中的隐式扩展类型"><a href="#2-3-3、方法调用过程中的隐式扩展类型" class="headerlink" title="2.3.3、方法调用过程中的隐式扩展类型"></a><strong>2.3.3、方法调用过程中的隐式扩展类型</strong></h4><p>方法形参声明类型为A类型（整型或者浮点型），方法调用传入实参类型为B类型（整型或者浮点型），A类型大于B类型，那么B类型变量会被隐式扩展成A类型。<br>比如如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodArguExtending</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;int value is : &quot;</span> + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    f(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别需要注意的是，如果方法有重载，方法调用时，会绑定到最契合传入实参的方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodArguExtending</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;int value is : &quot;</span> + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">short</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;short value is : &quot;</span> + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    f(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short value is : 10</span><br></pre></td></tr></table></figure>
<h3 id="2-4、特殊的窄化转换"><a href="#2-4、特殊的窄化转换" class="headerlink" title="2.4、特殊的窄化转换"></a><strong>2.4、特殊的窄化转换</strong></h3><p>由以上描述可知，窄化转换必是显式转换，但是有一个特殊的窄化转换可以不必是显式转换，<font color='red'>可以认为这个特殊情况由编译器负责处理</font>。<br>有形如<code>（byte/short/char） 复合操作符（算术操作符的复合操作符，按位操作符的复合操作符，移位操作符的复合操作符） （另外一个整型或者浮点型）</code>的表达式，根据“2.3.1、操作符触发”和“2.3.2、表达式中最大的数据类型决定了最终结果的数据类型”小节内容，右侧表达式值类型至少为int型，因此赋值时是窄化转换，但是不进行显式转换，编译仍可顺利通过；而使用不使用复合操作符的等价表达式形式，这个窄化转换必须进行显式转换，否则编译不能通过。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10.0F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下不必进行显式转换</span></span><br><span class="line">a += b;</span><br><span class="line">a -= c;</span><br><span class="line">a &gt;&gt;= l;</span><br><span class="line">a |= l;</span><br><span class="line">a += f;</span><br><span class="line">a -= d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用复合操作符的等价表达式形式，必须进行显式转换</span></span><br><span class="line">a = (<span class="type">byte</span>) (a + b);</span><br><span class="line">a = (<span class="type">byte</span>) (a - c);</span><br><span class="line">a = (<span class="type">byte</span>) (a &gt;&gt; l);</span><br><span class="line">a = (<span class="type">byte</span>) (a | l);</span><br><span class="line">a = (<span class="type">byte</span>) (a + f);</span><br><span class="line">a = (<span class="type">byte</span>) (a - d);</span><br></pre></td></tr></table></figure>
<h2 id="三、数值直接常量"><a href="#三、数值直接常量" class="headerlink" title="三、数值直接常量"></a><strong>三、数值直接常量</strong></h2><p>在Java中有3种数值直接常量，分别是：十六进制数值常量，八进制数值常量和十进制数值常量。<br>十六进制数值常量：以前缀0x（0X），后面跟随0-9或小写（或大写）的a-f来表示，比如0xffff。只可表示整型。<br>八进制数值常量：由前缀0以及后续的0-7来表示，比如0177。只可表示整型。<br>十进制数值常量：由0-9组成，如果是整型首位非0（整型情况下，首位为0表示八进制）。比如199，1000.321213。既可表示整型，也可表示浮点型。</p>
<p>数值直接常量隐含对应一个基本类型的变量。关于数值直接常量隐含对应一个基本类型的变量有以下3条规则。</p>
<h3 id="3-1、规则1"><a href="#3-1、规则1" class="headerlink" title="3.1、规则1"></a><strong>3.1、规则1</strong></h3><p>在整型情形下（十六进制数值常量，八进制数值常量，十进制数值常量），数值直接常量对应的基本类型是int，通过在数值常量后加“l（或者L）”后缀，可以使得对应的基本类型是long。<br>在浮点型情形下（十进制数值常量），数值直接常量对应的基本类型是double，通过在数值常量后加“f（或者F）”后缀，可以使得对应的基本类型是float。通过在数值常量后加“d（或者D）”后缀，可以使得对应的基本类型是double。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    main.f1(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//main.f1(0x1fffffffff);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(char)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">byte</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">short</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(long)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(float)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(double)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1(int)</span><br></pre></td></tr></table></figure>
<p>从中可知，数值直接常量5对应的基本类型是int。<br>将注释语句的注释去掉，可以发现，编译器报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer number too large</span><br></pre></td></tr></table></figure>
<p>这是因为数值直接常量“0x1fffffffff”对应的基本类型是int，而它超出了int的表示范围，因而报出如上错误，如果在“0x1fffffffff”后加上L，那么显式指定对应的基本类型是long，编译就能通过。</p>
<p>又比如有以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    main.f1(<span class="number">5.0</span>);</span><br><span class="line">    main.f1(<span class="number">3.5E39</span>);</span><br><span class="line">    <span class="comment">//main.f1(3.5E39F);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(char)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">byte</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">short</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(long)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(float)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(double)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1(double)</span><br><span class="line">f1(double)</span><br></pre></td></tr></table></figure>
<p>从中可知，数值直接常量5.0和3.5E39对应的基本类型是double。<br>将注释语句的注释去掉，可以发现，编译器报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Floating point number too large</span><br></pre></td></tr></table></figure>
<p>这是因为显式指定数值直接常量“3.5E39F“对应的基本类型是float，而它超出了float的表示范围，因而报出如上错误。</p>
<h3 id="3-2、规则2"><a href="#3-2、规则2" class="headerlink" title="3.2、规则2"></a><strong>3.2、规则2</strong></h3><p>在Java程序中碰到数值直接常量，以其隐含对应的基本类型变量的身份去考虑，可以帮助我们理解，减少错误的发生。</p>
<h3 id="3-3、规则3"><a href="#3-3、规则3" class="headerlink" title="3.3、规则3"></a><strong>3.3、规则3</strong></h3><p>关于“在Java程序中碰到数值直接常量，以其隐含对应的基本类型变量的身份去考虑”有一个例外：当数值直接常量为整型，且隐含对应的基本类型是int型，去给byte类型，short类型，char类型变量赋值，且数值直接常量的数值在相应变量的表示范围内，虽说此时仍旧可以以数值直接常量隐含对应的int类型变量身份去考虑问题，但是却不像真正的int类型变量那样需要显式窄化转换，<font color='red'>可以认为这个特殊情况由编译器负责处理</font>。<br>除此情况外，当碰到数值直接常量时，就完全可以以其隐含对应的基本类型变量的身份去考虑问题：需要显式转换就显式转换，无需显式转换就无需显式转换。<br>可见如下代码所示例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> b;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> l;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> itmp;</span><br><span class="line">    <span class="type">long</span> ltmp;</span><br><span class="line">    <span class="type">float</span> ftmp;</span><br><span class="line">    <span class="type">double</span> dtmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 无需显式转换，验证的确无需显式转换</span></span><br><span class="line">    f = <span class="number">10</span>;</span><br><span class="line">    f = <span class="number">10L</span>;</span><br><span class="line">    d = <span class="number">10</span>;</span><br><span class="line">    d = <span class="number">10L</span>;</span><br><span class="line">    f = <span class="number">10.0F</span>;</span><br><span class="line">    d = <span class="number">10.0</span>;</span><br><span class="line">    d = <span class="number">10.0D</span>;</span><br><span class="line">    d = <span class="number">10.0F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    itmp = <span class="number">10</span>;</span><br><span class="line">    ltmp = <span class="number">10L</span>;</span><br><span class="line">    ftmp = <span class="number">10.0F</span>;</span><br><span class="line">    dtmp = <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    f = itmp;</span><br><span class="line">    f = ltmp;</span><br><span class="line">    d = itmp;</span><br><span class="line">    d = ltmp;</span><br><span class="line">    f = ftmp;</span><br><span class="line">    d = dtmp;</span><br><span class="line">    d = ftmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 需要显式转换，验证的确需要显式转换</span></span><br><span class="line">    f = (<span class="type">float</span>) <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    dtmp = <span class="number">10.0</span>;</span><br><span class="line">    f = (<span class="type">float</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 无需显式转换，验证的确无需显式转换</span></span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">    l = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    itmp = <span class="number">10</span>;</span><br><span class="line">    ltmp = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    i = itmp;</span><br><span class="line">    l = ltmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 需要显式转换，验证的确需要显式转换</span></span><br><span class="line">    b = (<span class="type">byte</span>) <span class="number">10.0F</span>;</span><br><span class="line">    b = (<span class="type">byte</span>) <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    s = (<span class="type">short</span>) <span class="number">10.0F</span>;</span><br><span class="line">    s = (<span class="type">short</span>) <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">char</span>) <span class="number">10.0F</span>;</span><br><span class="line">    c = (<span class="type">char</span>) <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    i = (<span class="type">int</span>) <span class="number">10.0F</span>;</span><br><span class="line">    i = (<span class="type">int</span>) <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    l = (<span class="type">long</span>) <span class="number">10.0F</span>;</span><br><span class="line">    l = (<span class="type">long</span>) <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    ftmp = <span class="number">10.0F</span>;</span><br><span class="line">    dtmp = <span class="number">10.0D</span>;</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">byte</span>) ftmp;</span><br><span class="line">    b = (<span class="type">byte</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    s = (<span class="type">short</span>) ftmp;</span><br><span class="line">    s = (<span class="type">short</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">char</span>) ftmp;</span><br><span class="line">    c = (<span class="type">char</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    i = (<span class="type">int</span>) ftmp;</span><br><span class="line">    i = (<span class="type">int</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    l = (<span class="type">long</span>) ftmp;</span><br><span class="line">    l = (<span class="type">long</span>) dtmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 需要显式转换，验证的确需要显式转换</span></span><br><span class="line">    b = (<span class="type">byte</span>) <span class="number">2100000000</span>;</span><br><span class="line">    b = (<span class="type">byte</span>) <span class="number">2100000000L</span>;</span><br><span class="line"></span><br><span class="line">    s = (<span class="type">short</span>) <span class="number">2100000000</span>;</span><br><span class="line">    s = (<span class="type">short</span>) <span class="number">2100000000L</span>;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">char</span>) <span class="number">2100000000</span>;</span><br><span class="line">    c = (<span class="type">char</span>) <span class="number">2100000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    itmp = <span class="number">2100000000</span>;</span><br><span class="line">    ltmp = <span class="number">2100000000L</span>;</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">byte</span>) itmp;</span><br><span class="line">    b = (<span class="type">byte</span>) ltmp;</span><br><span class="line"></span><br><span class="line">    s = (<span class="type">short</span>) itmp;</span><br><span class="line">    s = (<span class="type">short</span>) ltmp;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">char</span>) itmp;</span><br><span class="line">    c = (<span class="type">char</span>) ltmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 需要显式转换，验证的确需要显式转换</span></span><br><span class="line">    b = (<span class="type">byte</span>) <span class="number">10L</span>;</span><br><span class="line">    s = (<span class="type">short</span>) <span class="number">10L</span>;</span><br><span class="line">    c = (<span class="type">char</span>) <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    ltmp = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">byte</span>) ltmp;</span><br><span class="line">    s = (<span class="type">short</span>) ltmp;</span><br><span class="line">    c = (<span class="type">char</span>) ltmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符------------------------</span></span><br><span class="line">    <span class="comment">// 本应显式转换，却由编译器进行处理，验证的确是由编译器处理本应的显式转换</span></span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line">    s = <span class="number">10</span>;</span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    itmp = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">byte</span>) itmp;</span><br><span class="line">    s = (<span class="type">short</span>) itmp;</span><br><span class="line">    c = (<span class="type">char</span>) itmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文献：<br>[1]<a href="http://stackoverflow.com/questions/10075058/converting-from-double-to-float-in-java">http://stackoverflow.com/questions/10075058/converting-from-double-to-float-in-java</a><br>[2]<a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想第4版</title>
    <url>/blog/2018/07/29/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC4%E7%89%88/</url>
    <content><![CDATA[<h2 id="一、-对象导论"><a href="#一、-对象导论" class="headerlink" title="一、 对象导论"></a><strong>一、 对象导论</strong></h2><h2 id="二、一切都是对象"><a href="#二、一切都是对象" class="headerlink" title="二、一切都是对象"></a><strong>二、一切都是对象</strong></h2><h2 id="三、操作符"><a href="#三、操作符" class="headerlink" title="三、操作符"></a><strong>三、操作符</strong></h2><h2 id="四、控制执行流程"><a href="#四、控制执行流程" class="headerlink" title="四、控制执行流程"></a><strong>四、控制执行流程</strong></h2><h2 id="五、初始化与清理"><a href="#五、初始化与清理" class="headerlink" title="五、初始化与清理"></a><strong>五、初始化与清理</strong></h2><h2 id="六、访问权限控制"><a href="#六、访问权限控制" class="headerlink" title="六、访问权限控制"></a><strong>六、访问权限控制</strong></h2><h2 id="七、复用类"><a href="#七、复用类" class="headerlink" title="七、复用类"></a><strong>七、复用类</strong></h2><h2 id="八、多态"><a href="#八、多态" class="headerlink" title="八、多态"></a><strong>八、多态</strong></h2><h2 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a><strong>九、接口</strong></h2><h2 id="十、内部类"><a href="#十、内部类" class="headerlink" title="十、内部类"></a><strong>十、内部类</strong></h2><h2 id="十一、持有对象"><a href="#十一、持有对象" class="headerlink" title="十一、持有对象"></a><strong>十一、持有对象</strong></h2><h2 id="十二、通过异常处理错误"><a href="#十二、通过异常处理错误" class="headerlink" title="十二、通过异常处理错误"></a><strong>十二、通过异常处理错误</strong></h2><h2 id="十三、字符串"><a href="#十三、字符串" class="headerlink" title="十三、字符串"></a><strong>十三、字符串</strong></h2><h2 id="十四、类型信息"><a href="#十四、类型信息" class="headerlink" title="十四、类型信息"></a><strong>十四、类型信息</strong></h2><h2 id="十五、泛型"><a href="#十五、泛型" class="headerlink" title="十五、泛型"></a><strong>十五、泛型</strong></h2><h2 id="十六、数组"><a href="#十六、数组" class="headerlink" title="十六、数组"></a><strong>十六、数组</strong></h2><h2 id="十七、容器深入研究"><a href="#十七、容器深入研究" class="headerlink" title="十七、容器深入研究"></a><strong>十七、容器深入研究</strong></h2><h2 id="十八、Java-I-O系统"><a href="#十八、Java-I-O系统" class="headerlink" title="十八、Java I&#x2F;O系统"></a><strong>十八、Java I&#x2F;O系统</strong></h2><h2 id="十九、枚举类型"><a href="#十九、枚举类型" class="headerlink" title="十九、枚举类型"></a><strong>十九、枚举类型</strong></h2><h2 id="二十、注解"><a href="#二十、注解" class="headerlink" title="二十、注解"></a><strong>二十、注解</strong></h2><h2 id="二十一、并发"><a href="#二十一、并发" class="headerlink" title="二十一、并发"></a><strong>二十一、并发</strong></h2><p>关联内容博文：<br>0. <a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">Java并发编程基础</a></p>
<h2 id="二十二、图形化用户界面"><a href="#二十二、图形化用户界面" class="headerlink" title="二十二、图形化用户界面"></a><strong>二十二、图形化用户界面</strong></h2><br/>
附录A 补充材料
附录B 资源
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想#访问权限控制</title>
    <url>/blog/2017/12/04/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、Java的包机制"><a href="#一、Java的包机制" class="headerlink" title="一、Java的包机制"></a><strong>一、Java的包机制</strong></h2><h3 id="1-1、包机制的基本概念"><a href="#1-1、包机制的基本概念" class="headerlink" title="1.1、包机制的基本概念"></a><strong>1.1、包机制的基本概念</strong></h3><p>包机制是一个代码组织方案，用来解决名称冲突问题。为使得包的命名是独一无二的，常用的一个命名方案是使用反顺序的域名作为顶级包名。包的命名层次与目录层次结构一一对应。</p>
<h3 id="1-2、包机制关键词"><a href="#1-2、包机制关键词" class="headerlink" title="1.2、包机制关键词"></a><strong>1.2、包机制关键词</strong></h3><p>包机制有两个关键词：<code>package</code>和<code>import</code>。</p>
<h4 id="1-2-1、package"><a href="#1-2-1、package" class="headerlink" title="1.2.1、package"></a><strong>1.2.1、package</strong></h4><p><code>package</code>关键词用来定义包名：package语句必须是Java源文件中除注释以外的第一个程序语句；没有package语句，表示使用默认包。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2、import"><a href="#1-2-2、import" class="headerlink" title="1.2.2、import"></a><strong>1.2.2、import</strong></h4><p><code>import</code>关键词用于导入包下的某个类（一般形式）或者全部类（通配符形式），包下某个类的静态字段和静态方法（静态导入形式）；不用<code>import</code>关键词就得使用类，静态字段和静态方法的全名称方式，比如<code>java.util.List</code>。<br>在<a href="/blog/2017/10/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/" title="Java编程思想#一切都是对象">Java编程思想#一切都是对象</a>中已经指出，所有Java源文件默认包含<code>import java.lang.*</code>语句。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般形式</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通配符形式</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入形式</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Calendar.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// ArrayList类由&quot;import java.util.ArrayList&quot;语句导入</span></span><br><span class="line">    ArrayList&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File类由&quot;import java.io.*&quot;语句导入</span></span><br><span class="line">    File file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态字段&quot;YEAR&quot;由&quot;import static java.util.Calendar.*&quot;语句导入</span></span><br><span class="line">    System.out.println(YEAR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用&quot;import&quot;语句，就得使用全名称方式</span></span><br><span class="line">    java.util.Vector vector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、Java的访问权限控制"><a href="#二、Java的访问权限控制" class="headerlink" title="二、Java的访问权限控制"></a><strong>二、Java的访问权限控制</strong></h2><p>在本文中，“类成员”包括“一般字段，静态字段，一般方法，静态方法”。<br>接下来的论述内容更多的是属于“自我理解”性质的，基于“Java编译程序实现角度”推导而来。</p>
<h3 id="2-1、类的实际定义"><a href="#2-1、类的实际定义" class="headerlink" title="2.1、类的实际定义"></a><strong>2.1、类的实际定义</strong></h3><p>参考<a href="/blog/2018/03/27/Java%E7%B1%BB%E5%AE%9E%E9%99%85%E5%AE%9A%E4%B9%89/" title="Java类实际定义">Java类实际定义</a></p>
<h3 id="2-2、访问权限修饰符"><a href="#2-2、访问权限修饰符" class="headerlink" title="2.2、访问权限修饰符"></a><strong>2.2、访问权限修饰符</strong></h3><p>访问权限修饰符有：<code>public</code>，<code>protected</code>，<code>default</code>（包访问权限修饰符，该修饰符实质上不存在），<code>private</code>。</p>
<h4 id="2-2-1、类访问权限修饰符"><a href="#2-2-1、类访问权限修饰符" class="headerlink" title="2.2.1、类访问权限修饰符"></a><strong>2.2.1、类访问权限修饰符</strong></h4><p>类（<font color='red'>本文所指“类”包含“类，抽象类，接口，枚举，注解”，不包含“内部类”</font>）的访问权限修饰符有：<code>public</code>和<code>default</code>；“内部类”的访问权限修饰符有：<code>public</code>，<code>protected</code>，<code>default</code>，<code>private</code>。</p>
<h4 id="2-2-2、类成员访问权限修饰符"><a href="#2-2-2、类成员访问权限修饰符" class="headerlink" title="2.2.2、类成员访问权限修饰符"></a><strong>2.2.2、类成员访问权限修饰符</strong></h4><p>类成员的访问权限修饰符有：<code>public</code>，<code>protected</code>，<code>default</code>，<code>private</code>。</p>
<h3 id="2-3、Java资源地址和访问者地址"><a href="#2-3、Java资源地址和访问者地址" class="headerlink" title="2.3、Java资源地址和访问者地址"></a><strong>2.3、Java资源地址和访问者地址</strong></h3><p>地址的形式是：<code>包名：类名</code>。</p>
<h4 id="2-3-1、Java资源地址"><a href="#2-3-1、Java资源地址" class="headerlink" title="2.3.1、Java资源地址"></a><strong>2.3.1、Java资源地址</strong></h4><p>Java资源包括：类，类成员。Java资源地址即“Java资源定义所在地址”。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“JavaResourceAddress”这个Java资源（类）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaResourceAddress</span> <span class="keyword">extends</span> <span class="title class_">JavaResourceAddressParent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//“b”这个Java资源（原生类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//“a”这个Java资源（原生类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//“g()”这个Java资源（原生类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//“f()”这个Java资源（原生类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//“c”这个Java资源（复制类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//“h()”这个Java资源（复制类成员）的地址为“chapter6.JavaResourceAddress”</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JavaResourceAddressParent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2、访问者地址"><a href="#2-3-2、访问者地址" class="headerlink" title="2.3.2、访问者地址"></a><strong>2.3.2、访问者地址</strong></h4><p>访问者地址即“访问Java资源语句所在地址”。</p>
<h3 id="2-4、访问控制"><a href="#2-4、访问控制" class="headerlink" title="2.4、访问控制"></a><strong>2.4、访问控制</strong></h3><p>对Java资源（类，类成员）的访问控制分为两部分。</p>
<h4 id="2-4-1、访问控制——类"><a href="#2-4-1、访问控制——类" class="headerlink" title="2.4.1、访问控制——类"></a><strong>2.4.1、访问控制——类</strong></h4><p>有以下两点论述：</p>
<ul>
<li>当访问权限修饰符为<code>public</code>时，无论“Java资源（类）地址”和“访问者地址”关系怎样，该Java资源（类）可被访问</li>
<li>当访问权限修饰符为<code>default</code>时，只有当“Java资源（类）地址”和“访问者地址”处于同一个包中，该Java资源（类）才可被访问</li>
</ul>
<h4 id="2-4-2、访问控制——类成员"><a href="#2-4-2、访问控制——类成员" class="headerlink" title="2.4.2、访问控制——类成员"></a><strong>2.4.2、访问控制——类成员</strong></h4><p>有以下几点论述：</p>
<ul>
<li>欲访问类中“类成员”，首先须能访问类，参照“2.4.1、访问控制——类”</li>
<li>欲访问的“类成员”须存在，可通过查看该类的完整定义进行确定</li>
<li>欲访问的“类成员”是原生定义的，则参照“规则集1”；否则，即欲访问的“类成员”是隐式复制下来的，则参照“规则集2”</li>
</ul>
<p><strong>规则集1：</strong></p>
<ul>
<li>当访问权限修饰符为<code>public</code>时，无论“Java资源（类成员）地址”和“访问者地址”关系怎样，该Java资源（类成员）可被访问</li>
<li>当访问权限修饰符为<code>protected</code>时，只有当“Java资源（类成员）地址”和“访问者地址”处于同一个包中，该Java资源（类成员）才可被访问。<font color='red'>在“访问控制”范畴内，<code>protected</code>和<code>default</code>访问权限修饰符语义完全一致</font></li>
<li>当访问权限修饰符为<code>default</code>时，只有当“Java资源（类成员）地址”和“访问者地址”处于同一个包中，该Java资源（类成员）才可被访问</li>
<li>当访问权限修饰符为<code>private</code>时，只有当“Java资源（类成员）地址”和“访问者地址”一致，该Java资源（类成员）才可被访问</li>
</ul>
<p><strong>规则集2：</strong></p>
<ul>
<li>从欲访问“复制类成员”对应节点开始可得到一条引用链</li>
<li>从前往后依次比较“访问者地址”与引用链中前<code>N-1</code>个节点对应的地址，一旦一致，则可访问；否则，再根据“规则集1”，比较“访问者地址”与引用链中最后一个节点对应的地址，满足则可访问，不满足则不可访问</li>
</ul>
<h3 id="2-5、继承控制"><a href="#2-5、继承控制" class="headerlink" title="2.5、继承控制"></a><strong>2.5、继承控制</strong></h3><p>“继承控制”与“访问控制”几乎一致，即“可访问的可继承，不可访问的不可继承”，除了：子类可继承祖先类中被<code>protected</code>访问权限修饰符修饰的Java资源（类成员），而与子类中是否可访问祖先类中该Java资源（类成员）无关。<br>综合“2.4、访问控制”和“2.5、继承控制”可知，<code>protected</code>访问权限修饰符的设计意图在于“继承控制”，而不在于“访问控制”。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6.subpackage1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter6.subpackage2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chapter6.subpackage1.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类B的完整定义</span></span><br><span class="line">  <span class="comment">//int c;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//加上注释语句，编译出错</span></span><br><span class="line">    <span class="comment">//System.out.println(a);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6、综合例子"><a href="#2-6、综合例子" class="headerlink" title="2.6、综合例子"></a><strong>2.6、综合例子</strong></h3><h4 id="2-6-1、说明"><a href="#2-6-1、说明" class="headerlink" title="2.6.1、说明"></a><strong>2.6.1、说明</strong></h4><p>接下来的例子完整地验证了上述介绍。在该例子中，有3个包：package1，package2和package3。在3个包中包含的类说明如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>所包含类类名</th>
</tr>
</thead>
<tbody><tr>
<td>package1</td>
<td>A，AA1，B</td>
</tr>
<tr>
<td>package2</td>
<td>AA2，C</td>
</tr>
<tr>
<td>package3</td>
<td>AAA，D</td>
</tr>
</tbody></table>
<p>这些类之间的关系如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20171204-0-1.png"></p>
<h4 id="2-6-2、具体代码"><a href="#2-6-2、具体代码" class="headerlink" title="2.6.2、具体代码"></a><strong>2.6.2、具体代码</strong></h4><p><strong>1、package1</strong><br>类A：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package2.AA2;</span><br><span class="line"><span class="keyword">import</span> package3.AAA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生类成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生类成员</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生类成员</span></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//原生类成员</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(a.a);</span><br><span class="line">    System.out.println(a.b);</span><br><span class="line">    System.out.println(a.c);</span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.b);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类AA1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package2.AA2;</span><br><span class="line"><span class="keyword">import</span> package3.AAA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同包子类（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类的完整定义包含下面“复制类成员”</span></span><br><span class="line">  <span class="comment">//public int d;</span></span><br><span class="line">  <span class="comment">//protected int c;</span></span><br><span class="line">  <span class="comment">//int b;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    System.out.println(a.b);</span><br><span class="line">    System.out.println(a.c);</span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aa1.b);</span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aa1.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类B：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package2.AA2;</span><br><span class="line"><span class="keyword">import</span> package3.AAA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问父类，子类1，子类2，孙类，跟父类和子类1同包（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    System.out.println(a.b);</span><br><span class="line">    System.out.println(a.c);</span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.b);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、package2</strong><br>类AA2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.A;</span><br><span class="line"><span class="keyword">import</span> package1.AA1;</span><br><span class="line"><span class="keyword">import</span> package3.AAA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同包子类（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA2</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类的完整定义包含下面“复制类成员”</span></span><br><span class="line">  <span class="comment">//public int d;</span></span><br><span class="line">  <span class="comment">//protected int c;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.c);</span></span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aa2.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中第二个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aaa.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中第二个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类C：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.A;</span><br><span class="line"><span class="keyword">import</span> package1.AA1;</span><br><span class="line"><span class="keyword">import</span> package3.AAA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问父类，子类1，子类2，孙类，跟子类2同包（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.c);</span></span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、package3</strong><br>类AAA：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.A;</span><br><span class="line"><span class="keyword">import</span> package1.AA1;</span><br><span class="line"><span class="keyword">import</span> package2.AA2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跨了两层包的孙类（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AAA</span> <span class="keyword">extends</span> <span class="title class_">AA2</span> &#123;</span><br><span class="line">  <span class="comment">//类的完整定义包含下面“复制类成员”</span></span><br><span class="line">  <span class="comment">//public int d;</span></span><br><span class="line">  <span class="comment">//protected int c;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.c);</span></span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aaa.c);</span><br><span class="line">    <span class="comment">//能访问，引用链中第一个节点对应地址与“访问者地址”一致</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类D：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.A;</span><br><span class="line"><span class="keyword">import</span> package1.AA1;</span><br><span class="line"><span class="keyword">import</span> package2.AA2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问父类，子类1，子类2，孙类，跟孙类同包（注释掉的资源表示不能被访问）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“类成员地址”与“访问者地址”不满足“规则集1”</span></span><br><span class="line">    <span class="comment">//System.out.println(a.c);</span></span><br><span class="line">    System.out.println(a.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA1</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA1</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.a);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa1.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa1.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AA2</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA2</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aa2.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aa2.d);</span><br><span class="line"></span><br><span class="line">    <span class="type">AAA</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAA</span>();</span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“a”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.a);</span></span><br><span class="line">    <span class="comment">//不能访问，在该类的完整定义中，“b”类成员不存在</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.b);</span></span><br><span class="line">    <span class="comment">//不能访问，“规则集2”不满足</span></span><br><span class="line">    <span class="comment">//System.out.println(aaa.c);</span></span><br><span class="line">    <span class="comment">//能访问，引用链中最后一个节点对应地址与“访问者地址”满足“规则集1”</span></span><br><span class="line">    System.out.println(aaa.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://stackoverflow.com/questions/15939002/protected-access-modifier-in-java
[2]http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程踩坑记</title>
    <url>/blog/2018/08/04/Java%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、使用File-renameTo-File-方法移动文件可能失败"><a href="#一、使用File-renameTo-File-方法移动文件可能失败" class="headerlink" title="一、使用File#renameTo(File)方法移动文件可能失败"></a><strong>一、使用<code>File#renameTo(File)</code>方法移动文件可能失败</strong></h2><p>使用<code>File#renameTo(File)</code>方法移动文件可能失败，查看该方法的JavaDoc，发现失败原因可能如下：</p>
<ul>
<li>移动到不同文件系统</li>
<li>目标文件已经存在</li>
<li>…</li>
</ul>
<p>因此，<code>File#renameTo(File)</code>方法逻辑上不等价于<code>mv</code>命令，“commons-io”包中实现有一系列移动文件的鲁棒性方法（逻辑上等价于<code>mv</code>命令）：<code>moveDirectory(File srcDir, File destDir)</code>，<code>moveDirectoryToDirectory(File src, File destDir, boolean createDestDir)</code>，<code>moveFile(File srcFile, File destFile)</code>，<code>moveFileToDirectory(File srcFile, File destDir, boolean createDestDir)</code>，<code>moveToDirectory(File src, File destDir, boolean createDestDir)</code>，可使用上述鲁棒性方法实现移动文件的逻辑。</p>
<h2 id="二、运行Java进程切忌遗漏标准输出流和标准错误输出流对应的日志数据"><a href="#二、运行Java进程切忌遗漏标准输出流和标准错误输出流对应的日志数据" class="headerlink" title="二、运行Java进程切忌遗漏标准输出流和标准错误输出流对应的日志数据"></a><strong>二、运行Java进程切忌遗漏标准输出流和标准错误输出流对应的日志数据</strong></h2><p>日志数据对于监控Java进程运行和定位问题非常重要，因此，切忌遗漏日志数据。日志数据的一般的目的地有“标准输出流，标准错误输出流，文件，数据库”等，其中去向“标准输出流”和“标准错误输出流”的日志数据最易遗漏，可采用“重定向标准输出流和标准错误输出流”的方式保存这部分日志数据，比如<code>nohup java -classpath &quot;$CLASSPATH&quot; xxxx &gt; $BINDIR/run.out 2&gt;&amp;1 &amp;</code>。<br>笔者曾遇到过这样一个案例：有一个运行中的Java进程，观察到其中线程不能正常工作，排查了好久（刚开始没有重定向标准错误输出流而是直接丢弃），最后才发现是由于线程内部抛出了不能被线程内部处理的异常（包括错误）而导致线程终止。线程由于不能处理内部抛出的异常（包括错误）而终止时，一般情况下，最终会调用ThreadGroup类中“uncaughtException(Thread t, Throwable e)”方法内的<code>System.err.print(&quot;Exception in thread \&quot;&quot; + t.getName() + &quot;\&quot; &quot;);  e.printStackTrace(System.err);</code>语句，因此，如果早早重定向标准错误输出流，就能很快捕捉到这个信息，而节省很多排查时间。</p>
<br/>
参考文献：
[1]http://xiaoych.iteye.com/blog/149328
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行时汇编指令查看</title>
    <url>/blog/2018/12/13/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<p>假设Java主类名为“Main.class”，如需查看运行时汇编指令，则执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:+PrintAssembly -XX:CompileCommand=compileonly,Main.main Main</span><br></pre></td></tr></table></figure>
<p>关于<code>-Xcomp</code>表示“对于字节码，使用编译器编译成汇编码或者机器码后执行，而不使用解释器解释执行”，详见<a href="/blog/2017/04/12/java%E5%91%BD%E4%BB%A4/" title="java命令">《java命令》</a>。<br>关于<code>-XX:CompileCommand=compileonly,Main.main</code>参见[4]。</p>
<br/>
有可能抛出如下错误：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Could not load hsdis-amd64.so; library not loadable; PrintAssembly is disabled</span><br></pre></td></tr></table></figure>

<p>在Ubuntu（Oracle JDK 1.8）上的解决步骤如下：</p>
<ul>
<li><code>sudo apt-get install libhsdis0-fcml</code></li>
<li><code>cp -L /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/hsdis-amd64.so $&#123;Oracle JDK 1.8安装目录&#125;/jre/lib/amd64/hsdis-amd64.so</code></li>
</ul>
<br/>
参考文献：
[1]https://www.jianshu.com/p/93821b08e774
[2]https://askubuntu.com/questions/710392/java-8-oracle-1-8-0-66-problem-with-printassembly-could-not-load-hsdis-amd64
[3]https://superuser.com/questions/216919/how-to-copy-symlinks-to-target-as-normal-folders
[4]https://blog.csdn.net/ning0323/article/details/75451955
[5]https://www.infoq.cn/article/zzm-java-hsdis-jvm
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka官方文档</title>
    <url>/blog/2017/08/30/Kafka%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<ol start="0">
<li><a href="/blog/2017/09/09/Kafka%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" title="Kafka官方文档之入门指南">GETTING STARTED</a></li>
<li>APIS</li>
<li>CONFIGURATION</li>
<li>DESIGN</li>
<li>IMPLEMENTATION</li>
<li>OPERATIONS</li>
<li>SECURITY</li>
<li>KAFKA CONNECT</li>
<li>KAFKA STREAMS</li>
</ol>
<br/>
文档地址：https://kafka.apache.org/0110/documentation.html
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka官方文档之入门指南</title>
    <url>/blog/2017/09/09/Kafka%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>Kafka是一个面向“消息流”的系统，它能够进行消息流的“发布，存储，处理和消费”。在实际生产环境中，Kafka一般以Kafka集群的形式被应用。</p>
<h2 id="二、设计简介"><a href="#二、设计简介" class="headerlink" title="二、设计简介"></a><strong>二、设计简介</strong></h2><h3 id="2-1、主题"><a href="#2-1、主题" class="headerlink" title="2.1、主题"></a><strong>2.1、主题</strong></h3><p>特定的消息流以主题名进行指代，即主题名作为特定消息流的名称，不同主题名对应的消息流互相独立。消息流中的消息由“键，值，时间戳”3部分构成。<br>Kafka集群性能跟主题存储所占用大小常系数相关，因此，主题存储所占用大小不是影响Kafka集群性能的主要因素。</p>
<h3 id="2-2、API提供与应用程序角色"><a href="#2-2、API提供与应用程序角色" class="headerlink" title="2.2、API提供与应用程序角色"></a><strong>2.2、API提供与应用程序角色</strong></h3><p>Kafka提供4类API：Producer API，Consumer API，Streams API，Connector API，基于这4类API编程的应用程序分别具有以下4种角色：生产者，消费者，流处理器，连接器。关于这4类API的简要说明见表1，示意图见图1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>API</th>
<th>基于编程应用程序角色</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>Producer API</td>
<td>生产者</td>
<td>允许生产者向主题发布消息</td>
</tr>
<tr>
<td>Consumer API</td>
<td>消费者</td>
<td>允许消费者从主题订阅消息</td>
</tr>
<tr>
<td>Streams API</td>
<td>流处理器</td>
<td>允许流处理器从主题订阅消息，处理消息，向主题发布消息</td>
</tr>
<tr>
<td>Connector API</td>
<td>连接器</td>
<td>允许使用连接器从数据源（比如日志文件，Mysql，HDFS等）导入数据到Kafka的消息流，从Kafka的消息流导出数据到数据目的地（比如日志文件，Mysql，HDFS等）</td>
</tr>
</tbody></table>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170909-0-1.jpg"></p>
<h3 id="2-3、“发布-订阅”模型中的数据流路径"><a href="#2-3、“发布-订阅”模型中的数据流路径" class="headerlink" title="2.3、“发布-订阅”模型中的数据流路径"></a><strong>2.3、“发布-订阅”模型中的数据流路径</strong></h3><p>根据Kafka提供的API，使用Kafka有3种模型：发布-订阅模型（基于Producer API和Consumer API），流处理模型（基于Streams API）和连接器模型（基于Connector API）。<br>最常见的使用模型是发布-订阅模型，关于该模型的几点描述（以1个特定的主题A为例）如下：</p>
<ul>
<li>1到多个生产者向主题A发布消息</li>
<li>消息消费的基本单元是“消费者组”，而不是“消费者”。基于消息消费的角度，订阅主题A的消费者组之间互相独立，订阅主题A的同一个消费者组内的消费者之间互相排斥，即“主题A对应的消息流中的任意一个消息会被所有订阅消费者组消费，却只会被订阅消费者组内的一个消费者消费”</li>
</ul>
<p>该模型的数据流路径有“宏观”和“微观”之分。</p>
<h4 id="2-3-1、宏观数据流路径"><a href="#2-3-1、宏观数据流路径" class="headerlink" title="2.3.1、宏观数据流路径"></a><strong>2.3.1、宏观数据流路径</strong></h4><p>宏观数据流路径如上所述，示意图如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170909-0-2.jpg"></p>
<h4 id="2-3-2、微观数据流路径"><a href="#2-3-2、微观数据流路径" class="headerlink" title="2.3.2、微观数据流路径"></a><strong>2.3.2、微观数据流路径</strong></h4><p>微观上，基于“负载均衡”考虑，主题由多个分区构成，同一个主题的所有分区均衡分布于Kafka集群的不同节点上，基于“容错性”考虑，对于“分区”，存在一定数量的“备份分区”，一旦“分区”不能正常工作，会选择相应的一个“备份分区”成为新“分区”。分区可被看作一个存储消息的队列，新消息只能被添加于队尾，新消息会被分配一个该队列中唯一的标识数字（被称为“<font color='red'>offset</font>”）。分区消息删除机制跟“消息是否被消费”无关，当<code>cleanup.policy=delete</code>时，根据配置的有效期或者大小，进行分区消息的删除；当<code>cleanup.policy=compact</code>时，根据“是否能够进行压缩”，进行分区消息的删除。主题分区结构示意图如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20170909-0-3.png"></p>
<p>生产者向主题发布消息，微观上，基于“负载均衡”考虑，生产者将自身的消息基于一定策略（比如“哈希函数”）均衡发布到主题的不同分区。<br>消费者组从主题订阅消息，微观上，基于“负载均衡”考虑，主题的任意一个分区被以一定策略绑定到订阅消费者组的某个特定消费者，分区的消息只被订阅消费者组内的相应绑定消费者消费，基于“负载均衡”考虑，这种绑定关系尽量均衡分布于订阅消费者组内的不同消费者，这种绑定关系是动态的以应对消费者组内消费者的增加和减少，具体由Kafka集群控制。基于上述绑定机制，分区的数量必须大于等于消费者组内的消费者数量，否则便会存在未绑定分区的消费者。另外，消费者被设计可自由消费分区中任意一个消息。<br>基于上述描述，微观数据流路径示意图如图4所示。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20170909-0-4.jpg"></p>
<h3 id="2-4、设计保证"><a href="#2-4、设计保证" class="headerlink" title="2.4、设计保证"></a><strong>2.4、设计保证</strong></h3><p>Kafka提供以下几点设计保证：</p>
<ul>
<li>同一个生产者向同一个主题的同一个分区先后发布两个消息，在该分区中存储这两个消息时保持相同的先后顺序</li>
<li>消费者所观察到的分区中消息的先后顺序，就是该分区中对应消息存储的先后顺序</li>
<li>对于主题，假如配置分区的备份因子值为<code>N</code>，则共有N个“分区或者备份分区”，因此至多允许N-1个“分区或者备份分区”不能正常工作，而不丢失消息数据</li>
</ul>
<h2 id="三、具体应用"><a href="#三、具体应用" class="headerlink" title="三、具体应用"></a><strong>三、具体应用</strong></h2><h3 id="3-1、发布-订阅模型具体应用"><a href="#3-1、发布-订阅模型具体应用" class="headerlink" title="3.1、发布-订阅模型具体应用"></a><strong>3.1、发布-订阅模型具体应用</strong></h3><p>网站行为收集系统，性能数据收集系统，日志收集系统，事件变化日志系统等。同类产品有ZeroMQ，RabbitMQ，ActiveMQ等。</p>
<h3 id="3-2、流处理模型具体应用"><a href="#3-2、流处理模型具体应用" class="headerlink" title="3.2、流处理模型具体应用"></a><strong>3.2、流处理模型具体应用</strong></h3><p>新闻素材收集处理推荐系统。同类产品有Apache Storm，Apache Samza等。</p>
<h3 id="3-3、连接器模型具体应用"><a href="#3-3、连接器模型具体应用" class="headerlink" title="3.3、连接器模型具体应用"></a><strong>3.3、连接器模型具体应用</strong></h3><p>“导入Mysql数据，导出到HDFS”系统，“导入日志数据，导出到Mysql”系统。同类产品有Flume，Scribe等。</p>
<h2 id="四、快速开始"><a href="#四、快速开始" class="headerlink" title="四、快速开始"></a><strong>四、快速开始</strong></h2><h3 id="4-1、搭建Kafka集群"><a href="#4-1、搭建Kafka集群" class="headerlink" title="4.1、搭建Kafka集群"></a><strong>4.1、搭建Kafka集群</strong></h3><p>Kafka主目录下有文件“config&#x2F;server.properties”，它是Kafka自带的一份完整的配置文件，当下我们只需关注其中的4个配置参数：broker.id，listeners，log.dir，zookeeper.connect。关于这4个配置参数的描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>配置参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>broker.id</td>
<td>整数，本Kafka节点在Kafka集群中的唯一标识符</td>
</tr>
<tr>
<td>listeners</td>
<td>本Kafka节点监听地址，客户端通过该地址访问本Kafka节点</td>
</tr>
<tr>
<td>log.dir</td>
<td>本Kafka节点的日志存放目录</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>Kafka集群使用ZooKeeper集群提供的服务。本配置参数配置ZooKeeper集群客户端监听地址或者地址列表（以逗号隔开）</td>
</tr>
</tbody></table>
<p>假定现有机器A，B，C，D，E，F，在A，B，C上运行ZooKeeper集群（客户端监听端口号都为2181）。<br>在D上，Kafka主目录下“config&#x2F;server.properties”文件内上述4个配置参数的配置值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">broker.id=0</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">log.dir=/tmp/kafka-logs</span><br><span class="line">zookeeper.connect=A:2181,B:2181,C:2181</span><br></pre></td></tr></table></figure>
<p>执行<code>bin/kafka-server-start.sh config/server.properties</code>命令，运行D上的Kafka节点。</p>
<p>在E上，Kafka主目录下“config&#x2F;server.properties”文件内上述4个配置参数的配置值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">log.dir=/tmp/kafka-logs</span><br><span class="line">zookeeper.connect=A:2181,B:2181,C:2181</span><br></pre></td></tr></table></figure>
<p>执行<code>bin/kafka-server-start.sh config/server.properties</code>命令，运行E上的Kafka节点。</p>
<p>在F上，Kafka主目录下“config&#x2F;server.properties”文件内上述4个配置参数的配置值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">log.dir=/tmp/kafka-logs</span><br><span class="line">zookeeper.connect=A:2181,B:2181,C:2181</span><br></pre></td></tr></table></figure>
<p>执行<code>bin/kafka-server-start.sh config/server.properties</code>命令，运行F上的Kafka节点。</p>
<h3 id="4-2、3种Kafka使用模型初体验"><a href="#4-2、3种Kafka使用模型初体验" class="headerlink" title="4.2、3种Kafka使用模型初体验"></a><strong>4.2、3种Kafka使用模型初体验</strong></h3><h4 id="4-2-1、发布-订阅模型初体验"><a href="#4-2-1、发布-订阅模型初体验" class="headerlink" title="4.2.1、发布-订阅模型初体验"></a><strong>4.2.1、发布-订阅模型初体验</strong></h4><p><strong>1、创建主题</strong><br>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper A:2181 --replication-factor 3 --partitions 3 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>“–zookeeper A:2181”：通过ZooKeeper集群中的配置地址连接到Kafka集群，具体ZooKeeper地址是ZooKeeper集群中任意一个（多个）ZooKeeper节点的地址（地址列表）<br>“–replication-factor 3”：分区的备份因子值，当值为<code>N</code>时，表示“每个分区都有<code>N-1</code>个备份分区”<br>“–partitions 3”：配置主题的分区数量<br>“–topic my-replicated-topic”：配置主题名称<br><strong>2、生产者向主题发布消息</strong><br>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list D:9092 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>“–broker-list D:9092”：Kafka集群内节点地址或者地址列表（以逗号隔开）<br>“–topic my-replicated-topic”：指定主题<br><strong>3、消费者从主题订阅消息</strong><br>命令如下（可认为，消费者组只含有一个消费者）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server D:9092 --from-beginning --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>“–bootstrap-server D:9092”：Kafka集群内节点地址<br>“–from-beginning”：从头开始订阅消费主题消息<br>“–topic my-replicated-topic”：指定主题</p>
<h4 id="4-2-2、流处理模型初体验"><a href="#4-2-2、流处理模型初体验" class="headerlink" title="4.2.2、流处理模型初体验"></a><strong>4.2.2、流处理模型初体验</strong></h4><p>以一个简单的“单词统计”应用程序为例，该独立的应用程序从Kafka集群的“streams-plaintext-input”主题读取单词数据，并将实时统计结果发布到Kafka集群的“streams-wordcount-output”主题。流处理模型初体验详细内容见<a href="https://kafka.apache.org/0110/documentation/streams/quickstart">链接</a>。<br><strong>1、创建数据源主题</strong><br>创建Kafka集群的“streams-plaintext-input”主题，命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper A:2181 --replication-factor 3 --partitions 3 --topic streams-plaintext-input</span><br></pre></td></tr></table></figure>
<p><strong>2、创建数据目的地主题</strong><br>创建Kafka集群的“streams-wordcount-output”主题，命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper A:2181 --replication-factor 3 --partitions 3 --topic streams-wordcount-output</span><br></pre></td></tr></table></figure>
<p><strong>3、运行“单词统计”应用程序</strong><br>命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-run-class.sh org.apache.kafka.streams.examples.wordcount.WordCountDemo</span><br></pre></td></tr></table></figure>
<p><strong>4、运行生产者向数据源主题发布消息</strong><br>命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list D:9092 --topic streams-plaintext-input</span><br></pre></td></tr></table></figure>
<p>运行对应于“streams-plaintext-input”主题的生产者，依次输入“all streams lead to kafka”，“hello kafka streams”，“join kafka summit”发布消息。<br><strong>5、运行消费者从数据目的地主题订阅消息</strong><br>命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server D:9092 --topic streams-wordcount-output --from-beginning --formatter kafka.tools.DefaultMessageFormatter --property print.key=true --property print.value=true --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer</span><br></pre></td></tr></table></figure>
<p>运行对应于“streams-wordcount-output”主题的消费者，获取“单词统计”应用程序的实时统计结果。</p>
<h4 id="4-2-3、连接器模型初体验"><a href="#4-2-3、连接器模型初体验" class="headerlink" title="4.2.3、连接器模型初体验"></a><strong>4.2.3、连接器模型初体验</strong></h4><p>以一个简单的“数据源是普通文本文件，数据目的地是普通文本文件”的应用程序为例，该独立的应用程序运行两个“连接器”：“Source Connector”和“Sink Connector”。“Source Connector”从普通文本文件读取数据并将其以消息的形式发布到Kafka集群的某个主题，“Sink Connector”从Kafka集群的某个主题订阅消费消息并将其写入普通文本文件。<br><strong>1、运行独立应用程序</strong><br>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</span><br></pre></td></tr></table></figure>
<p>“config&#x2F;connect-standalone.properties”：本独立应用程序的配置文件，配置了Kafka集群地址等参数，比如<code>bootstrap.servers=D:9092</code><br>“config&#x2F;connect-file-source.properties”：本独立应用程序调用的“Source Connector”的配置文件，默认配置按行读取“test.txt”文件的字符串作为结构化消息的主体内容，并将消息发布到Kafka集群的“connect-test”主题<br>“config&#x2F;connect-file-sink.properties”：本独立应用程序调用的“Sink Connector”的配置文件，默认配置订阅Kafka集群的“connect-test”主题，消费解析消息并将解析得到的主体内容按行写入“test.sink.txt”文件<br><strong>2、查看“connect-test”主题内容</strong><br>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server D:9092 --from-beginning --topic connect-test</span><br></pre></td></tr></table></figure>
<h2 id="五、生态系统"><a href="#五、生态系统" class="headerlink" title="五、生态系统"></a><strong>五、生态系统</strong></h2><p>Kafka生态系统详细内容见<a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem">链接</a>。</p>
<br/>
文档地址：https://kafka.apache.org/0110/documentation.html#gettingStarted
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Keepalived集群中VIP不断漂移</title>
    <url>/blog/2019/03/21/Keepalived%E9%9B%86%E7%BE%A4%E4%B8%ADVIP%E4%B8%8D%E6%96%AD%E6%BC%82%E7%A7%BB/</url>
    <content><![CDATA[<p>搭建有一个Keepalived集群，某段时间，VIP不断漂移，查看“&#x2F;var&#x2F;log&#x2F;messages”文件，发现有很多如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mar  4 14:39:42 xxxx kernel: [16309612.262615] nf_conntrack: table full, dropping packet</span><br></pre></td></tr></table></figure>
<p>调高<code>net.netfilter.nf_conntrack_max</code>参数值，解决问题。</p>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>高可用</category>
      </categories>
  </entry>
  <entry>
    <title>Keepalived集群初搭建</title>
    <url>/blog/2019/01/17/Keepalived%E9%9B%86%E7%BE%A4%E5%88%9D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>第一次搭建Keepalived集群，实现IP漂移。<br>笔者所搭建Keepalived集群额外满足下面两个需求点：</p>
<ul>
<li>监听HAProxy进程，一旦HAProxy进程不存在，可能触发IP漂移</li>
<li>互为主备，充分利用服务器资源</li>
</ul>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a><strong>一、安装</strong></h2><p>Debian下安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install keepalived</span><br></pre></td></tr></table></figure>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a><strong>二、配置</strong></h2><p>默认配置文件路径为：“&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf”。</p>
<h3 id="2-1、主节点配置"><a href="#2-1、主节点配置" class="headerlink" title="2.1、主节点配置"></a><strong>2.1、主节点配置</strong></h3><p>由于互为主备，故同时包含备份节点配置。<br>具体配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  notification_email &#123;</span><br><span class="line">    # 通知信息邮件接收者邮箱</span><br><span class="line">    xxx@domain.email </span><br><span class="line">  &#125;</span><br><span class="line">  # 通知信息邮件发送者邮箱</span><br><span class="line">  notification_email_from keepalived@domain.email</span><br><span class="line">  # 表示本地开启了一个SMTP Server进程，端口为默认端口25，通过该SMTP Server发送通知信息邮件</span><br><span class="line">  smtp_server 127.0.0.1</span><br><span class="line">  smtp_connect_timeout 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">  # 存在haproxy进程返回0，否则返回非0</span><br><span class="line">  script &quot;killall -0 haproxy&quot;</span><br><span class="line">  # 每隔2秒运行监听脚本</span><br><span class="line">  interval 2</span><br><span class="line">  # 上述脚本执行连续3次返回0，则将“VRRP实例”的状态置为“正常态”，结合其他条件，可能触发IP漂移</span><br><span class="line">  rise 3</span><br><span class="line">  # 上述脚本执行连续3次返回非0，则将“VRRP实例”的状态置为“错误态”，结合其他条件，可能触发IP漂移</span><br><span class="line">  fall 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置一个VRRP实例</span><br><span class="line">vrrp_instance VI_101 &#123;</span><br><span class="line">  # 配置作为该VRRP实例的主节点</span><br><span class="line">  state MASTER</span><br><span class="line">  # 同一个VRRP实例下的节点（主节点和备份节点）具有相同值</span><br><span class="line">  # 而且同一网段中virtual_router_id的值不能重复</span><br><span class="line">  virtual_router_id 101</span><br><span class="line">  # 在该VRRP实例中，本节点的优先级</span><br><span class="line">  priority 100</span><br><span class="line"></span><br><span class="line">  interface bond0</span><br><span class="line">  track_interface &#123;</span><br><span class="line">    bond0</span><br><span class="line">  &#125;</span><br><span class="line">  advert_int 1</span><br><span class="line">  smtp_alert</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass keep@lived</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    # 该VRRP实例的绑定到IP</span><br><span class="line">    10.200.164.101/22</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_haproxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置另外一个VRRP实例</span><br><span class="line">vrrp_instance VI_102 &#123;</span><br><span class="line">  # 配置作为该VRRP实例的备份节点</span><br><span class="line">  state BACKUP</span><br><span class="line">  # 同一个VRRP实例下的节点（主节点和备份节点）具有相同值</span><br><span class="line">  # 而且同一网段中virtual_router_id的值不能重复</span><br><span class="line">  virtual_router_id 102</span><br><span class="line">  # 在该VRRP实例中，本节点的优先级</span><br><span class="line">  priority 50</span><br><span class="line"></span><br><span class="line">  interface bond0</span><br><span class="line">  track_interface &#123;</span><br><span class="line">    bond0</span><br><span class="line">  &#125;</span><br><span class="line">  advert_int 1</span><br><span class="line">  smtp_alert</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass keep@lived</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    # 该VRRP实例的绑定到IP</span><br><span class="line">    10.200.164.102/22</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_haproxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、备份节点配置"><a href="#2-2、备份节点配置" class="headerlink" title="2.2、备份节点配置"></a><strong>2.2、备份节点配置</strong></h3><p>由于互为主备，故同时包含主节点配置。<br>具体配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  notification_email &#123;</span><br><span class="line">    # 通知信息邮件接收者邮箱</span><br><span class="line">    xxx@domain.email </span><br><span class="line">  &#125;</span><br><span class="line">  # 通知信息邮件发送者邮箱</span><br><span class="line">  notification_email_from keepalived@domain.email</span><br><span class="line">  # 表示本地开启了一个SMTP Server进程，端口为默认端口25，通过该SMTP Server发送通知信息邮件</span><br><span class="line">  smtp_server 127.0.0.1</span><br><span class="line">  smtp_connect_timeout 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">  # 存在haproxy进程返回0，否则返回非0</span><br><span class="line">  script &quot;killall -0 haproxy&quot;</span><br><span class="line">  # 每隔2秒运行监听脚本</span><br><span class="line">  interval 2</span><br><span class="line">  # 上述脚本执行连续3次返回0，则将“VRRP实例”的状态置为“正常态”，结合其他条件，可能触发IP漂移</span><br><span class="line">  rise 3</span><br><span class="line">  # 上述脚本执行连续3次返回非0，则将“VRRP实例”的状态置为“错误态”，结合其他条件，可能触发IP漂移</span><br><span class="line">  fall 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置一个VRRP实例</span><br><span class="line">vrrp_instance VI_101 &#123;</span><br><span class="line">  # 配置作为该VRRP实例的备份节点</span><br><span class="line">  state BACKUP </span><br><span class="line">  # 同一个VRRP实例下的节点（主节点和备份节点）具有相同值</span><br><span class="line">  # 而且同一网段中virtual_router_id的值不能重复</span><br><span class="line">  virtual_router_id 101</span><br><span class="line">  # 在该VRRP实例中，本节点的优先级</span><br><span class="line">  priority 50</span><br><span class="line"></span><br><span class="line">  interface bond0</span><br><span class="line">  track_interface &#123;</span><br><span class="line">    bond0</span><br><span class="line">  &#125;</span><br><span class="line">  advert_int 1</span><br><span class="line">  smtp_alert</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass keep@lived</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    # 该VRRP实例的绑定到IP</span><br><span class="line">    10.200.164.101/22</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_haproxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置另外一个VRRP实例</span><br><span class="line">vrrp_instance VI_102 &#123;</span><br><span class="line">  # 配置作为该VRRP实例的主节点</span><br><span class="line">  state MASTER </span><br><span class="line">  # 同一个VRRP实例下的节点（主节点和备份节点）具有相同值</span><br><span class="line">  # 而且同一网段中virtual_router_id的值不能重复</span><br><span class="line">  virtual_router_id 102</span><br><span class="line">  # 在该VRRP实例中，本节点的优先级</span><br><span class="line">  priority 100</span><br><span class="line"></span><br><span class="line">  interface bond0</span><br><span class="line">  track_interface &#123;</span><br><span class="line">    bond0</span><br><span class="line">  &#125;</span><br><span class="line">  advert_int 1</span><br><span class="line">  smtp_alert</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass keep@lived</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    # 该VRRP实例的绑定到IP</span><br><span class="line">    10.200.164.102/22</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_haproxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、启动，停止与重启"><a href="#三、启动，停止与重启" class="headerlink" title="三、启动，停止与重启"></a><strong>三、启动，停止与重启</strong></h2><p>启动：<code>sudo /etc/init.d/keepalived start</code><br>停止：<code>sudo /etc/init.d/keepalived stop</code><br>重启：<code>sudo /etc/init.d/keepalived restart</code></p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、同一网段中的virtual-router-id的值不能重复"><a href="#4-1、同一网段中的virtual-router-id的值不能重复" class="headerlink" title="4.1、同一网段中的virtual_router_id的值不能重复"></a><strong>4.1、同一网段中的<code>virtual_router_id</code>的值不能重复</strong></h3><p>特别需要注意的是，同一网段中的<code>virtual_router_id(vrid)</code>的值不能重复，否则会干扰其他Keepalived集群的正常运行。<br>可通过如下命令查看欲使用<code>vrid</code>值是否已经被使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -ani any vrrp | grep vrid</span><br></pre></td></tr></table></figure>
<h3 id="4-2、“VRRP实例的绑定到IP”对于所使用的网卡需要合法"><a href="#4-2、“VRRP实例的绑定到IP”对于所使用的网卡需要合法" class="headerlink" title="4.2、“VRRP实例的绑定到IP”对于所使用的网卡需要合法"></a><strong>4.2、“VRRP实例的绑定到IP”对于所使用的网卡需要合法</strong></h3><p>比如使用网卡“bond0”，该网卡的掩码为“255.255.255.0”，那么所使用的“VRRP实例的绑定到IP”的掩码也必须为“255.255.255.0”，即具有“xxx.xxx.xxx.xxx&#x2F;24”的形式。</p>
<br/>
参考文献：
[1]http://www.keepalived.org/manpage.html
[2]http://outofmemory.cn/wiki/keepalived-configuration
]]></content>
      <categories>
        <category>系统架构</category>
        <category>高可用</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Shell通配符模式表达式</title>
    <url>/blog/2017/05/10/Linux-Shell%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a><strong>一、语法</strong></h2><h3 id="1-1、通配符"><a href="#1-1、通配符" class="headerlink" title="1.1、通配符"></a><strong>1.1、通配符</strong></h3><p>“*”：匹配任意字符串，包括空字符串，不包含对“&#x2F;”字符的匹配。<br>“?”：匹配任意单个字符，不能匹配“&#x2F;”字符。</p>
<h3 id="1-2、字符类"><a href="#1-2、字符类" class="headerlink" title="1.2、字符类"></a><strong>1.2、字符类</strong></h3><p>“[abc]”：匹配“a”或者“b”或者“c”字符。<br>“[!abc]”：匹配除了“a，b，c”这3个字符之外的任意一个字符。</p>
<p>备注：<br>字符类内不包含对“&#x2F;”字符的匹配。</p>
<h3 id="1-3、字符范围"><a href="#1-3、字符范围" class="headerlink" title="1.3、字符范围"></a><strong>1.3、字符范围</strong></h3><p>“[a-z]”：匹配26个英文小写字符中任意一个。<br>“[!a-z]”：匹配除了“26个英文小写字符”之外的任意一个字符。</p>
<p>备注：<br>字符范围内不包含对“&#x2F;”字符的匹配。</p>
<h2 id="二、实验"><a href="#二、实验" class="headerlink" title="二、实验"></a><strong>二、实验</strong></h2><p>当前目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── 10.txt</span><br><span class="line">├── 1.txt</span><br><span class="line">├── aa.txt</span><br><span class="line">├── a.txt</span><br><span class="line">├── c</span><br></pre></td></tr></table></figure>
<h3 id="2-1、实验1"><a href="#2-1、实验1" class="headerlink" title="2.1、实验1"></a><strong>2.1、实验1</strong></h3><p>执行<code>ls *.txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.txt  1.txt  aa.txt  a.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-2、实验2"><a href="#2-2、实验2" class="headerlink" title="2.2、实验2"></a><strong>2.2、实验2</strong></h3><p>执行<code>ls ?.txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.txt  a.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-3、实验3"><a href="#2-3、实验3" class="headerlink" title="2.3、实验3"></a><strong>2.3、实验3</strong></h3><p>执行<code>ls [0-9].txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-4、实验4"><a href="#2-4、实验4" class="headerlink" title="2.4、实验4"></a><strong>2.4、实验4</strong></h3><p>执行<code>ls [012].txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-5、实验5"><a href="#2-5、实验5" class="headerlink" title="2.5、实验5"></a><strong>2.5、实验5</strong></h3><p>执行<code>ls [!0-9].txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-6、实验6"><a href="#2-6、实验6" class="headerlink" title="2.6、实验6"></a><strong>2.6、实验6</strong></h3><p>执行<code>ls [!789]?.txt</code>命令，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.txt  aa.txt</span><br></pre></td></tr></table></figure>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、“locale”设置影响"><a href="#3-1、“locale”设置影响" class="headerlink" title="3.1、“locale”设置影响"></a><strong>3.1、“locale”设置影响</strong></h3><p>“字符范围”所能匹配的字符跟“locale”设置息息相关。比如在有些“locale”设置中，“[a-d]”等价于“abcd”，而在有些“locale”设置中，“[a-d]”等价于“[aBbCcDd]”。</p>
<h3 id="3-2、一个匹配特殊点"><a href="#3-2、一个匹配特殊点" class="headerlink" title="3.2、一个匹配特殊点"></a><strong>3.2、一个匹配特殊点</strong></h3><p>想要使用“Linux Shell通配符模式表达式”匹配以“.”开头的文件，对于该开头“.”字符：必须显式指定“.”字符进行匹配，尝试使用“通配符”，“字符类”，“字符范围”匹配该开头“.”字符会失败。<br>比如在当前目录下有一个“.a.txt”文件，使用如下类似命令都不能打印该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls *</span><br><span class="line">ls [.]*</span><br><span class="line">ls [.-9]*</span><br></pre></td></tr></table></figure>
<p>只有使用如下类似命令才能打印该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls .*</span><br><span class="line">ls .[a]*</span><br><span class="line">ls .[a-z]*</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man 7 glob
[2]man 3 glob
[3]man sh
[4]man bash
[5]http://stackoverflow.com/questions/43862113/what-is-returned-after-pathname-expansion-in-shell?noredirect=1#comment74803794_43862113
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下如何定位Java进程内CPU消耗最多的Java线程</title>
    <url>/blog/2022/10/19/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8DJava%E8%BF%9B%E7%A8%8B%E5%86%85CPU%E6%B6%88%E8%80%97%E6%9C%80%E5%A4%9A%E7%9A%84Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、Linux下查看进程和线程的CPU消耗动态情况"><a href="#一、Linux下查看进程和线程的CPU消耗动态情况" class="headerlink" title="一、Linux下查看进程和线程的CPU消耗动态情况"></a><strong>一、Linux下查看进程和线程的CPU消耗动态情况</strong></h2><p>现代Linux是具有“进程-线程体系结构”的操作系统。</p>
<h3 id="1-1、查看进程的CPU消耗动态情况"><a href="#1-1、查看进程的CPU消耗动态情况" class="headerlink" title="1.1、查看进程的CPU消耗动态情况"></a><strong>1.1、查看进程的CPU消耗动态情况</strong></h3><p>在Linux中，可通过<code>top -p 进程A的ID</code>命令查看进程A的CPU消耗动态情况，此时“PID”列显示的是：进程ID。</p>
<h3 id="1-2、查看线程的CPU消耗动态情况"><a href="#1-2、查看线程的CPU消耗动态情况" class="headerlink" title="1.2、查看线程的CPU消耗动态情况"></a><strong>1.2、查看线程的CPU消耗动态情况</strong></h3><p>在Linux中，可通过<code>top -Hp 进程A的ID</code>命令查看进程A内所有线程的CPU消耗动态情况，此时“PID”列显示的是：线程ID。<br>Java进程也是Linux进程，因此可通过<code>top -Hp 进程A的ID</code>命令完美解决“Linux下如何定位Java进程内CPU消耗最多的Java线程”这个问题。</p>
<br/>

<p><strong>备注：</strong><br>1、top命令涉及到的进程和线程皆为“进程-线程体系结构”中的原生进程和原生线程<br>2、Linux下，Java线程直接对应于Linux原生线程</p>
<h2 id="二、查看Java进程内CPU消耗最多Java线程的即时运行状况"><a href="#二、查看Java进程内CPU消耗最多Java线程的即时运行状况" class="headerlink" title="二、查看Java进程内CPU消耗最多Java线程的即时运行状况"></a><strong>二、查看Java进程内CPU消耗最多Java线程的即时运行状况</strong></h2><p>JDK提供“jstack”命令用于查看Java进程内Java线程的即时运行状况。<br>执行<code>jstack Java进程A的ID</code>获取用于描述“Java进程A内所有Java线程的即时运行状况”的jstack栈，一个栈帧对应于一个Java线程的即时运行状况描述，栈帧中有一个“nid”字段，该字段的全称为“native thread id”，即原生线程ID（可佐证“Java线程对应于原生线程”），因此，可直接根据CPU消耗最多Java线程的线程ID定位到相应栈帧，查看该Java线程的即时运行状况。<br>需要注意的是，<code>top -Hp 进程A的ID</code>命令中得到的线程ID（PID列值）是十进制的，而jstack栈帧中的线程ID（nid字段值）是十六进制且是小写形式的，因此，在匹配前需要进行转换，比如通过<code>printf &quot;%x\n&quot; 十进制线程ID</code>或者<code>printf &quot;%d\n&quot; 十六进制线程ID</code>命令。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://www.10tiao.com/html/773/201805/2247487826/1.html">http://www.10tiao.com/html/773/201805/2247487826/1.html</a></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下金山快盘同步失败的可能原因</title>
    <url>/blog/2015/12/01/Linux%E4%B8%8B%E9%87%91%E5%B1%B1%E5%BF%AB%E7%9B%98%E5%90%8C%E6%AD%A5%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>Linux下金山快盘客户端经常出现同步失败错误，具体表现一般有：</p>
<ul>
<li>提示“同步文件失败”</li>
<li>一直处于“扫描更改”状态中</li>
</ul>
<h2 id="二、可能原因"><a href="#二、可能原因" class="headerlink" title="二、可能原因"></a><strong>二、可能原因</strong></h2><p>1、待同步的文件的文件名中含有英文冒号（允许中文冒号）<br>2、待同步的文件的文件名以空格开头（中文空格和英文空格是一致的，两者没有区别）<br>3、待同步的文件的文件名中含有英文双引号（即””，允许中文双引号“”）<br>4、待同步的本地文件的文件名与云端相应文件的文件名大小写不一致。有些同步过程中，这个不一致不会有什么影响；而在有些同步过程中，这个不一致会导致出现错误。可以在本地建立一个“a.txt”文件，然后同步，接着将其重命名为“A.txt”，再同步，可以发现云端相应的文件的文件名还是为“a.txt”。产生文件名大小写不一致的根本原因是“快盘服务是跨平台的，而在Windows下文件名是不区分大小写的”<br>5、一直处于“扫描更改”状态中有时候是由于同步文件过大造成的<br>6、缓存导致，清空“.klive”目录下的缓存文件，具体是“cache”，“cache.db”和“log”这3个文件</p>
<p><strong>备注：</strong><br>以上这些错误大部分都可以在“.klive&#x2F;log”目录下的日志文件中找到相应的错误日志记录，可以以快盘所在路径的某一部分作为搜索关键词来快速定位错误日志记录，比如快盘路径为“&#x2F;home&#x2F;dsl&#x2F;kuaipan”，那么在日志文件中搜索“home”等关键词可以快速定位到错误日志记录</p>
<br/>
参考文献：
[1]http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&tid=10173&highlight=%BD%F0%C9%BD%BF%EC%C5%CC
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>金山快盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下高效低系统资源占用清空目录</title>
    <url>/blog/2018/12/10/Linux%E4%B8%8B%E9%AB%98%E6%95%88%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%B8%85%E7%A9%BA%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>目标：Linux下需清空一个目录，该目录下含有大量文件。</p>
<p>假定待清空目录名为“&#x2F;data&#x2F;todeldata”。</p>
<h2 id="一、rm方式"><a href="#一、rm方式" class="headerlink" title="一、rm方式"></a><strong>一、rm方式</strong></h2><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf /data/todeldata</span><br></pre></td></tr></table></figure>

<p>机理分析：<br>0. 第一阶段，通过<code>getdirentries64</code>系统调用，分批读取目录（每次大约为4K），在内存中建立待删除文件列表<br>0. 第二阶段，通过<code>lstat64</code>系统调用确定所有文件的状态<br>0. 第三阶段，通过<code>unlink</code>系统调用执行实际删除</p>
<p>小结：整个过程做了大量的系统调用，尤其是<code>lstat64</code>和<code>unlink</code>系统调用。当目录下含有大量文件时，易导致系统卡死。</p>
<h2 id="二、rsync方式"><a href="#二、rsync方式" class="headerlink" title="二、rsync方式"></a><strong>二、rsync方式</strong></h2><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkdir an empty directory first</span><br><span class="line">mkdir /data/blank</span><br><span class="line"></span><br><span class="line">rsync --delete-before -d /data/blank/ /data/todeldata/</span><br></pre></td></tr></table></figure>

<p>机理分析：<br>0. 命令执行前期，获取一片共享内存，通过mmap方式加载目录信息。只做目录同步，不需要针对单个文件做<code>unlink</code>系统调用</p>
<p>小结：整个过程所做的系统调用很少，没有针对单个文件做<code>unlink</code>系统调用，而是批量做。</p>
<br/>
<font color='red'>全文总结：</font>未作深入分析，只是概要叙述，比如对于“没有针对单个文件做`unlink`系统调用，而是批量做”未作深入跟踪分析明确具体实现原理。

<br/>
参考文献：
[1]https://blog.liulantao.com/why-can-rsync-rapidly-delete-400000-files.html
[2]http://g33kinfo.com/info/archives/5630
[3]https://www.quora.com/What-does-rsync-do-that-makes-it-so-efficient-at-deleting-many-small-files
[4]https://www.slashroot.in/which-is-the-fastest-method-to-delete-files-in-linux
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下，使用云盘同步Google Chrome书签</title>
    <url>/blog/2015/10/31/Linux%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BA%91%E7%9B%98%E5%90%8C%E6%AD%A5Google-Chrome%E4%B9%A6%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>本人使用Linux操作系统，用的浏览器是Google Chrome。发现Chrome自带的书签同步功能同步书签会出现书签文件夹产生重复的情况，Xmarks插件也不是很合用。<br>另外还尝试了Delicious，UC云同步，印象笔记，有道笔记，百度云收藏等产品，发现都不是很合用。</p>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a><strong>二、分析</strong></h2><p>Google Chrome的所有书签数据以单一文件形式存放，如果可以使用云盘来同步该文件，就可以达到同步书签的目的。可选用的云盘有百度云盘，360云盘，金山快盘等，而在Linux上，金山快盘有官方客户端，因而选用金山快盘。</p>
<h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a><strong>三、解决方案</strong></h2><p>假定有两台Linux机子（OS1和OS2），其上都安装有金山快盘和Google Chrome。在OS1上，金山快盘的工作目录是pandir1，Google Chrome的书签数据文件所在目录是bookmarkdir1；在OS2上，金山快盘的工作目录是pandir2，Google Chrome的书签数据文件所在目录是bookmarkdir2。另外假定书签数据文件的名称为Bookmarks。<br>接下来根据上述背景进行说明。</p>
<h3 id="3-1、错误的解决方案"><a href="#3-1、错误的解决方案" class="headerlink" title="3.1、错误的解决方案"></a><strong>3.1、错误的解决方案</strong></h3><p>1、将初始的书签数据文件Bookmarks上传到金山快盘云服务器上，将其同步到OS1上的金山快盘工作目录pandir1中和同步到OS2上的金山快盘工作目录pandir2中，即现在在pandir1中和pandir2中都存在Bookmarks文件<br>2、进入OS1的Google Chrome书签数据文件所在目录bookmarkdir1，删除原有的书签数据文件，执行<code>ln pandir1/Bookmarks Bookmarks</code>命令，建立一个硬链接文件；在OS2上，也做类似操作，在bookmarkdir2中建立一个硬链接文件<br>3、原以为经过1和2步骤，OS1上的Google Chrome对书签的操作会保存到bookmarkdir1下的Bookmarks硬链接文件，也即保存到pandir1下的Bookmarks文件，这也就是金山快盘云服务器上的Bookmarks文件。对于OS2上的Google Chrome来说也是类似的。此时，OS1和OS2上的Google Chrome等价于操作同一个书签数据文件<br>4、其实，Google Chrome保存书签操作数据的具体步骤如下：[1]</p>
<ol>
<li>创建一个临时文件，将原有的书签数据和书签操作数据存入该临时文件</li>
<li>将原有的书签数据文件重命名为其他名称（本来的名称是Bookmarks)</li>
<li>将临时文件重命名为Bookmarks</li>
<li>删除原有的书签数据文件</li>
</ol>
<p>根据以上过程，可以发现Google Chrome在保存书签操作数据的时候，会删除在bookmarkdir1或者bookmarkdir2下的Bookmarks硬链接文件，而创建一个新的文件，这个新的文件跟pandir1或者pandir2下的Bookmarks文件没有任何关系，这就导致了“OS1和OS2上的Google Chrome等价于操作同一个书签数据文件”的说法是不成立的，也就说明了以上这种解决方案是错误的。</p>
<h3 id="3-2、正确的解决方案"><a href="#3-2、正确的解决方案" class="headerlink" title="3.2、正确的解决方案"></a><strong>3.2、正确的解决方案</strong></h3><p>在讲述正确的解决方案之前，先介绍金山快盘如何判断云服务器端的文件和本地端的文件是否是同一个文件。经过实验发现，关于这个问题，判断标准是“名称是否一致，文件类型等因素不在考虑范围之内”。<br>在这种情况下，假如在云服务器端有个A文件，本地端有个A文件，A文件是个硬连接文件（或者软符号链接文件），它具体指向本地端的另外一个地方的某个文件AA，此时云服务器端的A文件和本地端的AA文件保持同步，关于本地端的A文件和本地端的AA文件之间的链接关系无需金山快盘程序关心，而由本地文件系统处理。<br>1、将初始的书签数据文件Bookmarks上传到金山快盘云服务器上，将其同步到OS1上的金山快盘工作目录pandir1中和同步到OS2上的金山快盘工作目录pandir2中，即现在在pandir1中和pandir2中都存在Bookmarks文件<br>2、进入OS1的金山快盘工作目录pandir1，删除1步骤中得到的Bookmarks文件，执行<code>ln -s bookmarkdir1/Bookmarks Bookmarks</code>命令，建立一个软符号链接文件，该软符号链接文件指向的是OS1上Google Chrome的书签数据文件；在OS2上，也做类似操作，在pandir2中建立一个软符号链接文件<br>3、经过1和2，此时，OS1和OS2上的Google Chrome等价于操作同一个书签数据文件，即达到了我们的目标</p>
<p><strong>备注：</strong><br>1、默认情况下，在Linux上，Google Chrome的书签数据文件路径是<code>~/.config/google-chrome/Default/Bookmarks</code><br>2、使用以上解决方案需要遵循一个操作规范：在本地，每次操作书签数据文件之前，都要使用金山快盘进行更新得到最新的书签数据文件，在此基础上操作书签，在操作完成之后，需要使用金山快盘将最新的书签数据文件更新到云服务器端。只有这样子，书签数据文件的同步工作才能正常进行，而不会出现覆盖等现象<br>3、另外最重要的一点是要关闭Google Chrome自带的书签同步功能：打开chrome浏览器的设置选项，进入高级同步设置选项，勾选掉“书签”选项，点击确定，使得chrome浏览器自带的书签同步功能失效</p>
<br/>
参考文献：
[1]http://superuser.com/questions/993833/why-is-a-created-own-bookmarks-file-deleted-by-chrome/993845?noredirect=1#comment1372457_993845
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux文件权限</title>
    <url>/blog/2017/06/15/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a><strong>一、文件</strong></h2><p>Linux文件分为：一般文件（通常简称为文件）和目录。<br>文件由“Inode节点和Block节点集”构成。</p>
<h3 id="1-1、Inode节点"><a href="#1-1、Inode节点" class="headerlink" title="1.1、Inode节点"></a><strong>1.1、Inode节点</strong></h3><p>Inode节点存储文件的元数据，元数据主要用来进行文件控制。描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、The size of the file in bytes.</span><br><span class="line">2、Device ID (this identifies the device containing the file).</span><br><span class="line">3、The User ID of the file&#x27;s owner.</span><br><span class="line">4、The Group ID of the file.</span><br><span class="line">5、The file mode which determines the file type and how the file&#x27;s owner, its group, and others can access the file.</span><br><span class="line">6、Additional system and user flags to further protect the file (limit its use and modification).</span><br><span class="line">7、Timestamps telling when the inode itself was last modified (ctime, inode change time), the file content last modified (mtime, modification time), and last accessed (atime, access time).</span><br><span class="line">8、A link count telling how many hard links point to the inode.</span><br><span class="line">9、Pointers to the disk blocks that store the file&#x27;s contents (see inode pointer structure).</span><br></pre></td></tr></table></figure>

<p>有两个元数据需要进行强调。<br><strong>1、atime，mtime，ctime</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>atime</td>
<td>即“access time”，指的是最后访问Block节点中数据的时间，中文描述为“最近访问”</td>
</tr>
<tr>
<td>mtime</td>
<td>即“modification time”，指的是最后更改Block节点中数据的时间，中文描述为“最近更改”</td>
</tr>
<tr>
<td>ctime</td>
<td>即“inode change time”，指的是最后改动Inode节点中元数据的时间，中文描述为“最近改动”</td>
</tr>
</tbody></table>
<p>助记：只需记住“change-改动-i”，另外两个很容易推导<br><strong>2、权限</strong><br>用于配置不同用户或者用户组（文件所属用户，文件所属用户组，其他用户或者用户组）对文件的操作权限，其实质是对文件的Block节点内容的操作权限。</p>
<h3 id="1-2、Block节点"><a href="#1-2、Block节点" class="headerlink" title="1.2、Block节点"></a><strong>1.2、Block节点</strong></h3><p>对于一般文件，Block节点存储一般文件的具体数据；对于目录，Block节点存储多条<code>&lt;Filename,InodeId&gt;</code>形式的记录数据，其中Filename是目录下子文件的文件名，InodeId是相应Inode节点的Id。</p>
<h2 id="二、权限详解"><a href="#二、权限详解" class="headerlink" title="二、权限详解"></a><strong>二、权限详解</strong></h2><h3 id="2-1、权限含义"><a href="#2-1、权限含义" class="headerlink" title="2.1、权限含义"></a><strong>2.1、权限含义</strong></h3><p>文件一般有“r读取，w修改，x执行”三种权限，对于一般文件和目录来说，这3种权限的含义是不同的。</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>r读取权限含义</th>
<th>w修改权限含义</th>
<th>x执行权限含义</th>
</tr>
</thead>
<tbody><tr>
<td>一般文件</td>
<td>是否允许读取Block节点中的内容</td>
<td>是否允许修改Block节点中的内容</td>
<td>是否允许执行Block节点中的内容</td>
</tr>
<tr>
<td>目录</td>
<td>是否允许读取Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录中的Filename</td>
<td>是否允许增加，删除和修改Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录</td>
<td>是否允许读取Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录中的InodeId，并加载InodeId对应的Inode节点</td>
</tr>
</tbody></table>
<h3 id="2-2、权限应用场景"><a href="#2-2、权限应用场景" class="headerlink" title="2.2、权限应用场景"></a><strong>2.2、权限应用场景</strong></h3><p>由于操作文件的只能是进程，因此权限的应用场景是：进程欲操作文件，文件系统首先获取该进程的“&lt;进程有效用户，进程有效用户组&gt;”进程用户身份（在接下来的描述中，简称为“进程用户身份”），将其与该文件Inode节点元数据中的权限配置数据进行比对，获取到该进程对该文件所被允许的操作权限范围，假如欲进行的操作在允许的操作权限范围内，则顺利执行；否则，由于没有操作权限被禁止执行。<br>本文接下来的实验中，进程用户身份主要跟“文件所属用户”的权限配置数据进行比对，但是切勿忘记还可跟“文件所属用户组”和“其他用户或者用户组”的权限配置数据进行比对。<br>关于“进程用户身份”可详见<a href="/blog/2017/06/12/%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD/" title="进程用户身份">链接</a>。</p>
<h3 id="2-3、权限具体判定过程"><a href="#2-3、权限具体判定过程" class="headerlink" title="2.3、权限具体判定过程"></a><strong>2.3、权限具体判定过程</strong></h3><p>下面介绍权限具体判定过程，分为一般文件和目录两种情况。</p>
<h4 id="2-3-1、一般文件"><a href="#2-3-1、一般文件" class="headerlink" title="2.3.1、一般文件"></a><strong>2.3.1、一般文件</strong></h4><h5 id="2-3-1-1、r读取权限"><a href="#2-3-1-1、r读取权限" class="headerlink" title="2.3.1.1、r读取权限"></a><strong>2.3.1.1、r读取权限</strong></h5><p>进程读取一般文件内容的过程如下：</p>
<ol>
<li>文件系统首先获取该进程的进程用户身份，判断该进程用户身份对该文件所在的目录是否具有x权限，只有具有该x权限，才能加载该一般文件的Inode节点，并读取Inode节点上的元数据，包括权限配置数据</li>
<li>比对“进程用户身份”和“该一般文件的权限配置数据”，看是否具有对该一般文件的r读取权限，如果有，可读取；否则，不可读取</li>
</ol>
<p><strong>实验：</strong><br>有一个目录“b”，拥有者用户为“dsl”，其下有一个一般文件“a.txt”（内容为“hello world”），拥有者用户为“dsl”，以“dsl”用户执行<code>less b/a.txt</code>命令查看“b&#x2F;a.txt”内容，相应创建运行进程的进程用户身份中的“进程有效用户”为“dsl”。变化目录“b”和一般文件“a.txt”的权限配置数据，得到不同的命令执行结果，如下表。</p>
<table>
<thead>
<tr>
<th>目录“b”的权限配置数据</th>
<th>一般文件“a.txt”的权限配置数据</th>
<th>命令执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
<td><code>b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>000</td>
<td>400</td>
<td><code>b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>000</td>
<td><code>b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>400</td>
<td><code>hello world</code></td>
</tr>
</tbody></table>
<h5 id="2-3-1-2、w修改权限"><a href="#2-3-1-2、w修改权限" class="headerlink" title="2.3.1.2、w修改权限"></a><strong>2.3.1.2、w修改权限</strong></h5><p>进程修改一般文件内容的过程如下：</p>
<ol>
<li>文件系统首先获取该进程的进程用户身份，判断该进程用户身份对该文件所在的目录是否具有x权限，只有具有该x权限，才能加载该一般文件的Inode节点，并读取Inode节点上的元数据，包括权限配置数据</li>
<li>比对“进程用户身份”和“该一般文件的权限配置数据”，看是否具有对该一般文件的w修改权限，如果有，可修改；否则，不可修改</li>
</ol>
<p><strong>实验：</strong><br>有一个目录“b”，拥有者用户为“dsl”，其下有一个一般文件“a.txt”（内容为空），拥有者用户为“dsl”，以“dsl”用户执行<code>echo &quot;hello world&quot; &gt; b/a.txt</code>命令修改“b&#x2F;a.txt”内容，相应创建运行进程的进程用户身份中的“进程有效用户”为“dsl”。变化目录“b”和一般文件“a.txt”的权限配置数据，得到不同的命令执行结果，如下表。</p>
<table>
<thead>
<tr>
<th>目录“b”的权限配置数据</th>
<th>一般文件“a.txt”的权限配置数据</th>
<th>命令执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
<td><code>bash: b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>000</td>
<td>200</td>
<td><code>bash: b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>000</td>
<td><code>bash: b/a.txt: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>200</td>
<td><code>成功执行</code></td>
</tr>
</tbody></table>
<h5 id="2-3-1-3、x执行权限"><a href="#2-3-1-3、x执行权限" class="headerlink" title="2.3.1.3、x执行权限"></a><strong>2.3.1.3、x执行权限</strong></h5><p>进程执行一般文件内容的过程如下：</p>
<ol>
<li>文件系统首先获取该进程的进程用户身份，判断该进程用户身份对该文件所在的目录是否具有x权限，只有具有该x权限，才能加载该一般文件的Inode节点，并读取Inode节点上的元数据，包括权限配置数据</li>
<li>比对“进程用户身份”和“该一般文件的权限配置数据”，看是否具有对该一般文件的rx执行权限（必须先“r读取”才能“x执行”），如果有，可执行；否则，不可执行</li>
</ol>
<p><strong>实验：</strong><br>有一个目录“b”，拥有者用户为“dsl”，其下有一个一般文件“a.sh”（内容为“echo ‘hello world’”），拥有者用户为“dsl”，以“dsl”用户执行<code>/bin/bash b/a.sh</code>命令执行“b&#x2F;a.sh”内容，相应创建运行进程的进程用户身份中的“进程有效用户”为“dsl”。变化目录“b”和一般文件“a.sh”的权限配置数据，得到不同的命令执行结果，如下表。</p>
<table>
<thead>
<tr>
<th>目录“b”的权限配置数据</th>
<th>一般文件“a.sh”的权限配置数据</th>
<th>命令执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
<td><code>/bin/bash: b/a.sh: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>000</td>
<td><code>/bin/bash: b/a.sh: 权限不够</code></td>
</tr>
<tr>
<td>000</td>
<td>100</td>
<td><code>/bin/bash: b/a.sh: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td><code>/bin/bash: b/a.sh: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>500</td>
<td><code>hello world</code></td>
</tr>
</tbody></table>
<h4 id="2-3-2、目录"><a href="#2-3-2、目录" class="headerlink" title="2.3.2、目录"></a><strong>2.3.2、目录</strong></h4><h5 id="2-3-2-1、r读取权限"><a href="#2-3-2-1、r读取权限" class="headerlink" title="2.3.2.1、r读取权限"></a><strong>2.3.2.1、r读取权限</strong></h5><p>进程读取目录内容的过程如下：</p>
<ol>
<li>文件系统首先获取该进程的进程用户身份，判断该进程用户身份对该目录所在的目录是否具有x权限，只有具有该x权限，才能加载该目录的Inode节点，并读取Inode节点上的元数据，包括权限配置数据</li>
<li>比对“进程用户身份”和“该目录的权限配置数据”，看是否具有对该目录的r读取权限，如果有，可读取；否则，不可读取。<font color='red'>需要注意的是</font>，如果只拥有对目录的r读取权限，那么只能读取<code>&lt;Filename,InodeId&gt;</code>形式记录中的Filename，而不能读取InodeId，更不能进而加载InodeId对应的Inode节点</li>
</ol>
<p><strong>实验：</strong><br>有一个目录“b”，拥有者用户为“dsl”，其下有一个目录“a”，拥有者用户为“dsl”，目录“a”下有两个一般文件（分别为“c.txt”和“d.txt”）和一个目录（“e”），以“dsl”用户执行<code>ls b/a</code>命令查看“b&#x2F;a”目录下内容，相应创建运行进程的进程用户身份中的“进程有效用户”为“dsl”。变化目录“b”和目录“a”的权限配置数据，得到不同的命令执行结果，如下表。</p>
<table>
<thead>
<tr>
<th>目录“b”的权限配置数据</th>
<th>目录“a”的权限配置数据</th>
<th>命令执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
<td><code>ls: 无法访问&#39;b/a&#39;: 权限不够</code></td>
</tr>
<tr>
<td>000</td>
<td>400</td>
<td><code>ls: 无法访问&#39;b/a&#39;: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>000</td>
<td><code>ls: 无法打开目录&#39;b/a&#39;: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>400</td>
<td><code>ls: 无法访问&#39;b/a/d.txt&#39;: 权限不够</code><br/><code>ls: 无法访问&#39;b/a/e&#39;: 权限不够</code><br/><code>ls: 无法访问&#39;b/a/c.txt&#39;: 权限不够</code><br/><code>c.txt  d.txt  e</code></td>
</tr>
</tbody></table>
<h5 id="2-3-2-2、w修改权限"><a href="#2-3-2-2、w修改权限" class="headerlink" title="2.3.2.2、w修改权限"></a><strong>2.3.2.2、w修改权限</strong></h5><p>进程修改目录内容的过程如下：</p>
<ol>
<li>文件系统首先获取该进程的进程用户身份，判断该进程用户身份对该目录所在的目录是否具有x权限，只有具有该x权限，才能加载该目录的Inode节点，并读取Inode节点上的元数据，包括权限配置数据</li>
<li>比对“进程用户身份”和“该目录的权限配置数据”，看是否具有对该目录的wx权限，如果有，可修改；否则，不可修改。<font color='red'>需要注意的是</font>，如果只拥有对目录的w修改权限，不能实现修改</li>
</ol>
<p><strong>实验：</strong><br>有一个目录“b”，拥有者用户为“dsl”，其下有一个目录“a”，拥有者用户为“dsl”，目录“a”下有两个一般文件（分别为“c.txt”和“d.txt”）和一个目录（“e”），以“dsl”用户分别执行<code>touch b/a/f.txt</code>，<code>rm b/a/c.txt</code>和<code>mv b/a/d.txt b/a/g.txt</code>命令修改目录“b&#x2F;a”下内容，相应创建运行进程的进程用户身份中的“进程有效用户”为“dsl”。变化目录“b”和目录“a”的权限配置数据，得到不同的命令执行结果，如下表。</p>
<table>
<thead>
<tr>
<th>目录“b”的权限配置数据</th>
<th>目录“a”的权限配置数据</th>
<th><code>touch b/a/f.txt</code>命令执行结果</th>
<th><code>rm b/a/c.txt</code>命令执行结果</th>
<th><code>mv b/a/d.txt b/a/g.txt</code>命令执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
<td><code>touch: 无法创建&#39;b/a/f.txt&#39;: 权限不够</code></td>
<td><code>rm: 无法删除&#39;b/a/c.txt&#39;: 权限不够</code></td>
<td><code>mv: failed to access &#39;b/a/g.txt&#39;: 权限不够</code></td>
</tr>
<tr>
<td>000</td>
<td>300</td>
<td><code>touch: 无法创建&#39;b/a/f.txt&#39;: 权限不够</code></td>
<td><code>rm: 无法删除&#39;b/a/c.txt&#39;: 权限不够</code></td>
<td><code>mv: failed to access &#39;b/a/g.txt&#39;: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>000</td>
<td><code>touch: 无法创建&#39;b/a/f.txt&#39;: 权限不够</code></td>
<td><code>rm: 无法删除&#39;b/a/c.txt&#39;: 权限不够</code></td>
<td><code>mv: failed to access &#39;b/a/g.txt&#39;: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>200</td>
<td><code>touch: 无法创建&#39;b/a/f.txt&#39;: 权限不够</code></td>
<td><code>rm: 无法删除&#39;b/a/c.txt&#39;: 权限不够</code></td>
<td><code>mv: failed to access &#39;b/a/g.txt&#39;: 权限不够</code></td>
</tr>
<tr>
<td>100</td>
<td>300</td>
<td><code>成功执行</code></td>
<td><code>成功执行</code></td>
<td><code>成功执行</code></td>
</tr>
</tbody></table>
<p>备注：<br>对目录内容的修改本质上就是对<code>&lt;Filename,InodeId&gt;</code>形式记录的增加，删除和修改。要达到修改目录内容的目标，进程的进程用户身份不仅需要拥有对目录的w权限，也需要拥有对目录的x权限。原因描述如下：</p>
<ul>
<li>增加的情况，须加载Inode节点，修改元数据，比如“ctime”值，硬链接计数值</li>
<li>删除的情况，须加载Inode节点，修改元数据，比如硬链接计数值</li>
<li>修改的情况，实现方式为先“增加”，后“删除”（作者推测），因此须加载Inode节点</li>
</ul>
<h5 id="2-3-2-3、x执行权限"><a href="#2-3-2-3、x执行权限" class="headerlink" title="2.3.2.3、x执行权限"></a><strong>2.3.2.3、x执行权限</strong></h5><p>目录的x执行权限已在上述内容中进行描述，这里不再贅述。</p>
<h3 id="2-4、特殊权限"><a href="#2-4、特殊权限" class="headerlink" title="2.4、特殊权限"></a><strong>2.4、特殊权限</strong></h3><h4 id="2-4-1、SUID"><a href="#2-4-1、SUID" class="headerlink" title="2.4.1、SUID"></a><strong>2.4.1、SUID</strong></h4><h5 id="2-4-1-1、一般文件上设置SUID权限"><a href="#2-4-1-1、一般文件上设置SUID权限" class="headerlink" title="2.4.1.1、一般文件上设置SUID权限"></a><strong>2.4.1.1、一般文件上设置SUID权限</strong></h5><p>当设置了SUID权限的可执行文件被执行时，创建运行的进程的“进程有效用户”变为“该可执行文件的文件所属用户”，如果可执行文件的文件所属用户是“root”，那么创建运行的进程的“进程有效用户”是“root”。<br><strong>实验：</strong><br>比如有以下C源代码文件（文件名为“geteuid.c”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    //geteuid()方法能够得到进程有效用户的UID</span><br><span class="line">    printf(&quot;euser uid is:%d\n&quot;, geteuid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gcc -o geteuid geteuid.c</code>命令，编译得到一个二进制文件“geteuid”，将该二进制文件的文件所属用户设为“root”，权限配置数据为“4777”。当前用户为“dsl”，执行<code>./geteuid</code>命令，得到的打印结果如下，“0”UID对应的用户为“root”，从而得知“进程有效用户”为“root”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">euser uid is:0</span><br></pre></td></tr></table></figure>

<p>备注：<br><font color='red'>基于安全策略，在Linux中，只能对二进制文件设置SUID权限，而不能对包括脚本文件在内的其他可执行文件设置SUID权限。</font></p>
<h5 id="2-4-1-2、目录上设置SUID权限"><a href="#2-4-1-2、目录上设置SUID权限" class="headerlink" title="2.4.1.2、目录上设置SUID权限"></a><strong>2.4.1.2、目录上设置SUID权限</strong></h5><p>目录上设置SUID权限没有任何效果。</p>
<h4 id="2-4-2、SGIT"><a href="#2-4-2、SGIT" class="headerlink" title="2.4.2、SGIT"></a><strong>2.4.2、SGIT</strong></h4><h5 id="2-4-2-1、一般文件上设置SGIT权限"><a href="#2-4-2-1、一般文件上设置SGIT权限" class="headerlink" title="2.4.2.1、一般文件上设置SGIT权限"></a><strong>2.4.2.1、一般文件上设置SGIT权限</strong></h5><p>当设置了SGID权限的可执行文件被执行时，创建运行的进程的“进程有效用户组”变为“该可执行文件的文件所属用户组”，如果可执行文件的文件所属用户组是“root”，那么创建运行的进程的“进程有效用户组”是“root”。<br><strong>实验：</strong><br>比如有以下C源代码文件（文件名为“getegid.c”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    //getegid()方法能够得到进程有效用户组的GID</span><br><span class="line">    printf(&quot;egroup gid is:%d\n&quot;, getegid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gcc -o getegid getegid.c</code>命令，编译得到一个二进制文件“getegid”，将该二进制文件的文件所属用户组设为“root”，权限配置数据为“2777”。当前用户为“dsl”（对应的用户组为“dsl”），执行<code>./getegid</code>命令，得到的打印结果如下，“0”GID对应的用户组为“root”，从而得知“进程有效用户组”为“root”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egroup gid is:0</span><br></pre></td></tr></table></figure>
<h5 id="2-4-2-2、目录上设置SGIT权限"><a href="#2-4-2-2、目录上设置SGIT权限" class="headerlink" title="2.4.2.2、目录上设置SGIT权限"></a><strong>2.4.2.2、目录上设置SGIT权限</strong></h5><p>目录A被设置了SGIT权限之后，在A目录下创建生成的一般文件和目录的文件所属用户组跟A的文件所属用户组一致。<br><strong>实验：</strong><br>有一个目录“a”，文件所属用户为“dsl”，文件所属用户组为“root”，权限配置数据为“2777”。以“dsl”用户在目录“a”下创建一般文件“b.txt”和目录“c”。分别执行<code>stat b.txt</code>和<code>stat c</code>命令，得到如下两个结果片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件：&#x27;b.txt&#x27;</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：( 1000/     dsl)   Gid：(    0/    root)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件：&#x27;c&#x27;</span><br><span class="line">权限：(2775/drwxrwsr-x)  Uid：( 1000/     dsl)   Gid：(    0/    root)</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3、sticky-bit"><a href="#2-4-3、sticky-bit" class="headerlink" title="2.4.3、sticky-bit"></a><strong>2.4.3、sticky-bit</strong></h4><h5 id="2-4-3-1、一般文件上设置sticky-bit权限"><a href="#2-4-3-1、一般文件上设置sticky-bit权限" class="headerlink" title="2.4.3.1、一般文件上设置sticky-bit权限"></a><strong>2.4.3.1、一般文件上设置sticky-bit权限</strong></h5><p>When set, it instructed the operating system to retain the text segment of the program in swap space after the process exited. This speeds up subsequent executions by allowing the kernel to make a single operation of moving the program from swap to real memory.</p>
<h5 id="2-4-3-2、目录上设置sticky-bit权限"><a href="#2-4-3-2、目录上设置sticky-bit权限" class="headerlink" title="2.4.3.2、目录上设置sticky-bit权限"></a><strong>2.4.3.2、目录上设置sticky-bit权限</strong></h5><p>目录A被设置sticky-bit权限，在A目录下创建生成的一般文件和目录具有如下特殊性质：只有它们（一般文件和目录）的文件所属用户（即既不能是“文件所属用户组”，也不能是“其他用户和用户组”）和“root”用户有权删除它们，其他任何用户或者用户组即便拥有对A目录的wx权限，也不可以删除它们。<br>最现成的例子是“&#x2F;tmp”目录。“&#x2F;tmp”是所有用户和用户组共享的临时文件夹，所有用户和用户组都拥有wx权限，这就可能使得出现如下情形：假如A用户在“&#x2F;tmp”里创建了文件“a.file”，而B用户看了不爽，在“&#x2F;tmp”里把它给删了（因为拥有wx权限），导致给A用户带来巨大的损失。事实上以上操作并不会被允许，因为“&#x2F;tmp”目录被设置有sticky-bit权限，正如“drwxrwxrwt”权限配置数据中的最后一个“t”。<br><strong>实验：</strong><br>现有“testuser”和“dsl”用户，“testuser”用户在“&#x2F;tmp”目录下创建了一般文件“a.txt”和目录“b”，“dsl”用户不能删除上述两个文件（尝试删除时，出现如下两个提示），只有“testuser”用户或者“root”用户才能够删除上述两个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm：是否删除有写保护的普通空文件 &#x27;a.txt&#x27;？ yes</span><br><span class="line">rm: 无法删除&#x27;a.txt&#x27;: 不允许的操作</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm：是否删除有写保护的目录 &#x27;b&#x27;？ yes</span><br><span class="line">rm: 无法删除&#x27;b&#x27;: 不允许的操作</span><br></pre></td></tr></table></figure>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、延伸"><a href="#3-1、延伸" class="headerlink" title="3.1、延伸"></a><strong>3.1、延伸</strong></h3><h4 id="3-1-1、改变文件权限配置数据"><a href="#3-1-1、改变文件权限配置数据" class="headerlink" title="3.1.1、改变文件权限配置数据"></a><strong>3.1.1、改变文件权限配置数据</strong></h4><p>使用“chmod”命令可改变文件权限配置数据，使用要求：执行“chmod”命令创建运行进程的进程用户身份中的“进程有效用户”必须为“文件的文件所属用户”或者“root”，另外，改变文件权限配置数据即改变文件Inode节点上的元数据，因此首先须加载Inode节点，这点跟以上的描述是一致的。</p>
<h4 id="3-1-2、改变文件所属用户"><a href="#3-1-2、改变文件所属用户" class="headerlink" title="3.1.2、改变文件所属用户"></a><strong>3.1.2、改变文件所属用户</strong></h4><p>使用“chown”命令可改变文件的文件所属用户，使用要求：执行“chown”命令创建运行进程的进程用户身份中的“进程有效用户”必须为“root”，另外，改变文件所属用户即改变文件Inode节点上的元数据，因此首先须加载Inode节点，这点跟以上的描述是一致的。</p>
<h4 id="3-1-3、改变文件所属用户组"><a href="#3-1-3、改变文件所属用户组" class="headerlink" title="3.1.3、改变文件所属用户组"></a><strong>3.1.3、改变文件所属用户组</strong></h4><p>使用“chgrp”命令可改变文件的文件所属用户组，使用要求：执行“chgrp”命令创建运行进程的进程用户身份中的“进程有效用户”必须为“root”，另外，改变文件所属用户组即改变文件Inode节点上的元数据，因此首先须加载Inode节点，这点跟以上的描述是一致的。</p>
<h4 id="3-1-4、读取Inode节点信息"><a href="#3-1-4、读取Inode节点信息" class="headerlink" title="3.1.4、读取Inode节点信息"></a><strong>3.1.4、读取Inode节点信息</strong></h4><p>使用“stat”命令可读取Inode节点信息，使用要求：须加载Inode节点。</p>
<h4 id="3-1-5、修改Inode节点的“atime”和“mtime”值"><a href="#3-1-5、修改Inode节点的“atime”和“mtime”值" class="headerlink" title="3.1.5、修改Inode节点的“atime”和“mtime”值"></a><strong>3.1.5、修改Inode节点的“atime”和“mtime”值</strong></h4><p>使用“touch”命令可修改Inode节点的“atime”和“mtime”值（如果文件不存在，则首先创建文件），使用要求：须加载Inode节点。</p>
<h3 id="3-2、基于实现视角"><a href="#3-2、基于实现视角" class="headerlink" title="3.2、基于实现视角"></a><strong>3.2、基于实现视角</strong></h3><p>文件采用“Inode节点-Block节点体系”，操作系统提供有一系列针对该体系进行操作的原语，Shell命令（比如“ls，less，vim，chmod，chown，chgrp，stat，touch，rm，mv”等）调用这些操作原语对“Inode节点-Block节点体系”进行操作。示意图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170615-0-1.jpg"></p>
<p>这些操作原语的使用性质和要求会表现为Shell命令的使用性质和要求，比如上述介绍的权限机制。关于这些操作原语的概要介绍如下表。</p>
<table>
<thead>
<tr>
<th>操作原语名称</th>
<th>描述</th>
<th>使用性质和要求</th>
<th>调用这些操作原语的Shell命令</th>
</tr>
</thead>
<tbody><tr>
<td>“读取”原语</td>
<td>对于一般文件，读取Block节点中的内容；对于目录，读取Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录中的Filename</td>
<td>进程的“&lt;进程有效用户，进程有效用户组&gt;”进程用户身份具有“r读取”权限</td>
<td>less，vim等命令</td>
</tr>
<tr>
<td>“修改”原语</td>
<td>对于一般文件，修改Block节点中的内容；对于目录，增加，删除和修改Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录</td>
<td>进程的“&lt;进程有效用户，进程有效用户组&gt;”进程用户身份具有“w修改”权限</td>
<td>vim等命令</td>
</tr>
<tr>
<td>“执行”原语</td>
<td>对于一般文件，执行Block节点中的内容；对于目录，读取Block节点中<code>&lt;Filename,InodeId&gt;</code>形式记录中的InodeId，并加载InodeId对应的Inode节点</td>
<td>进程的“&lt;进程有效用户，进程有效用户组&gt;”进程用户身份具有“x执行”权限，另外如果为一般文件且设置有SUID权限（SGIT权限），则创建运行进程的“进程有效用户”变为“该可执行文件的文件所属用户”（创建运行进程的“进程有效用户组”变为“该可执行文件的文件所属用户组”）</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>“删除文件”原语</td>
<td>删除文件</td>
<td>进程的“&lt;进程有效用户，进程有效用户组&gt;”进程用户身份对所在目录具有“wx”权限，如果所在目录设置有sticky-bit权限，那么须额外满足：进程用户身份中的“进程有效用户”必须为“文件的文件所属用户”或者“root”</td>
<td>rm命令</td>
</tr>
<tr>
<td>“改变文件权限配置数据”原语</td>
<td>改变文件权限配置数据</td>
<td>进程用户身份中的“进程有效用户”必须为“文件的文件所属用户”或者“root”</td>
<td>chmod命令</td>
</tr>
<tr>
<td>“改变文件所属用户”原语</td>
<td>改变文件所属用户</td>
<td>进程用户身份中的“进程有效用户”必须为“root”</td>
<td>chown命令</td>
</tr>
<tr>
<td>“改变文件所属用户组”原语</td>
<td>改变文件所属用户组</td>
<td>进程用户身份中的“进程有效用户”必须为“root”</td>
<td>chgrp命令</td>
</tr>
<tr>
<td>“读取Inode节点信息”原语</td>
<td>读取Inode节点信息</td>
<td>能够加载Inode节点</td>
<td>stat，ls等命令</td>
</tr>
<tr>
<td>“修改Inode节点‘atime’和‘mtime’值”原语</td>
<td>修改Inode节点“atime”和“mtime”值</td>
<td>能够加载Inode节点</td>
<td>touch等命令</td>
</tr>
<tr>
<td>“修改Inode节点‘atime’值”原语</td>
<td>修改Inode节点“atime”值</td>
<td>能够加载Inode节点</td>
<td>less，vim等命令</td>
</tr>
<tr>
<td>“修改Inode节点‘mtime’值”原语</td>
<td>修改Inode节点“mtime”值</td>
<td>能够加载Inode节点</td>
<td>vim等命令</td>
</tr>
<tr>
<td>“修改Inode节点‘ctime’值”原语</td>
<td>修改Inode节点“ctime”值</td>
<td>能够加载Inode节点</td>
<td>vim等命令</td>
</tr>
</tbody></table>
<p>备注：<br>无需太深究这些操作原语的具体实现细节，比如前后两次使用“less或者vim”命令，第一次能够改变“atime”字段值，第二次不能改变“atime”字段值，推测在“修改Inode节点‘atime’值原语”的具体实现中应该有一套具体的修改机制。</p>
<h3 id="3-3、上帝用户——root"><a href="#3-3、上帝用户——root" class="headerlink" title="3.3、上帝用户——root"></a><strong>3.3、上帝用户——root</strong></h3><p><font color='red'>root用户是上帝用户，具有任意权限。</font>因此必能进行“加载Inode节点，增删改文件”等操作。</p>
<br/>
参考文献：
[1]http://en.wikipedia.org/wiki/Inode
[2]http://superuser.com/questions/520107/how-are-directory-structures-stored-in-unix-filesystem
[3]http://www.cyberciti.biz/faq/how-linux-file-permissions-work/
[4]http://haifux.org/lectures/84-sil/users-processes-files-and-permissions/users-perms-lec.html
[5]http://stackoverflow.com/questions/6305416/how-does-a-process-in-linux-decides-privileges-allotted-to-it
[6]http://unix.stackexchange.com/questions/364/allow-setuid-on-shell-scripts
[7]http://en.wikipedia.org/wiki/Setuid#setuid_and_setgid_on_directories
[8]http://en.wikipedia.org/wiki/Sticky_bit
[9]http://www.linuxquestions.org/questions/linux-software-2/rename-and-ctime-913753
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux文件系统之3种区块与4类文件</title>
    <url>/blog/2016/12/21/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8B3%E7%A7%8D%E5%8C%BA%E5%9D%97%E4%B8%8E4%E7%B1%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、3种区块"><a href="#一、3种区块" class="headerlink" title="一、3种区块"></a><strong>一、3种区块</strong></h2><p>Linux的文件系统中有3种区块：superblock，inode，block。<br><strong>superblock</strong><br>记录文件系统的整体信息，包括inode和block的总量，使用量，剩余量，文件系统的格式与相关信息等。<br><strong>inode</strong><br>记录文件的属性信息，包括权限，拥有者，所属组，修改时间等，并且保存真正存放数据的block序号。<br><strong>block</strong><br>存放具体数据，目录文件的block存放的是下面文件的&lt;文件名，inode序号&gt;。</p>
<h2 id="二、4类文件"><a href="#二、4类文件" class="headerlink" title="二、4类文件"></a><strong>二、4类文件</strong></h2><p>Linux的文件可分为4类：一般文件，目录文件，软符号链接文件与硬符号链接文件。</p>
<h2 id="三、3种区块与4类文件的联系"><a href="#三、3种区块与4类文件的联系" class="headerlink" title="三、3种区块与4类文件的联系"></a><strong>三、3种区块与4类文件的联系</strong></h2><p>接下来将以上3种区块与对这4类文件的操作联系起来。</p>
<h3 id="3-1、增加"><a href="#3-1、增加" class="headerlink" title="3.1、增加"></a><strong>3.1、增加</strong></h3><h4 id="3-1-1、对一般文件"><a href="#3-1-1、对一般文件" class="headerlink" title="3.1.1、对一般文件"></a><strong>3.1.1、对一般文件</strong></h4><p>分配一个inode区块，根据文件大小分配一定数量的block区块，inode区块保存这些block区块的序号。<br>在所在目录中对应的block区块中增加一行记录，有该文件的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-1-2、对目录文件"><a href="#3-1-2、对目录文件" class="headerlink" title="3.1.2、对目录文件"></a><strong>3.1.2、对目录文件</strong></h4><p>分配一个inode区块，一般分配一个block区块[如果目录下面文件过多，可以分配多个block区块]，inode区块保存这个block区块的序号。<br>在所在目录中对应的block区块中增加一行记录，有该目录文件的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-1-3、对软符号链接文件"><a href="#3-1-3、对软符号链接文件" class="headerlink" title="3.1.3、对软符号链接文件"></a><strong>3.1.3、对软符号链接文件</strong></h4><p>分配一个inode区块，没有block区块，inode区块有个软符号链接文件的特殊标识，并且保存有“链接到文件”的路径，这个路径必须得是绝对路径，否则可能出错，相当于Windows操作系统下的快捷方式。<br>在所在目录中对应的block区块中增加一行记录，有该文件的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-1-4、对硬符号链接文件"><a href="#3-1-4、对硬符号链接文件" class="headerlink" title="3.1.4、对硬符号链接文件"></a><strong>3.1.4、对硬符号链接文件</strong></h4><p>不分配inode区块，也不分配block区块，直接在所在目录中对应的block区块中增加一行记录，有“链接到文件”的&lt;文件名，inode序号&gt;。</p>
<h3 id="3-2、删除"><a href="#3-2、删除" class="headerlink" title="3.2、删除"></a><strong>3.2、删除</strong></h3><h4 id="3-2-1、对一般文件"><a href="#3-2-1、对一般文件" class="headerlink" title="3.2.1、对一般文件"></a><strong>3.2.1、对一般文件</strong></h4><p>回收inode和所有的block区块。<br>在所在目录对应的block区块中删除相应的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-2-2、对目录文件"><a href="#3-2-2、对目录文件" class="headerlink" title="3.2.2、对目录文件"></a><strong>3.2.2、对目录文件</strong></h4><p>回收inode和所有的block区块。<br>在所在目录对应的block区块中删除相应的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-2-3、对软符号链接文件"><a href="#3-2-3、对软符号链接文件" class="headerlink" title="3.2.3、对软符号链接文件"></a><strong>3.2.3、对软符号链接文件</strong></h4><p>回收inode区块。<br>在所在目录对应的block区块中删除相应的&lt;文件名，inode序号&gt;。</p>
<h4 id="3-2-4、对硬符号链接文件"><a href="#3-2-4、对硬符号链接文件" class="headerlink" title="3.2.4、对硬符号链接文件"></a><strong>3.2.4、对硬符号链接文件</strong></h4><p>在所在目录对应的block区块中删除相应的&lt;文件名，inode序号&gt;。</p>
<h3 id="3-3、修改"><a href="#3-3、修改" class="headerlink" title="3.3、修改"></a><strong>3.3、修改</strong></h3><h4 id="3-3-1、对一般文件"><a href="#3-3-1、对一般文件" class="headerlink" title="3.3.1、对一般文件"></a><strong>3.3.1、对一般文件</strong></h4><p>修改的是block里面的内容。</p>
<h4 id="3-3-2、对目录文件"><a href="#3-3-2、对目录文件" class="headerlink" title="3.3.2、对目录文件"></a><strong>3.3.2、对目录文件</strong></h4><p>修改的是block里面的内容。</p>
<h4 id="3-3-3、对软符号链接文件"><a href="#3-3-3、对软符号链接文件" class="headerlink" title="3.3.3、对软符号链接文件"></a><strong>3.3.3、对软符号链接文件</strong></h4><p>修改的是“链接到文件”的block里面的内容。</p>
<h4 id="3-3-4、对硬符号链接文件"><a href="#3-3-4、对硬符号链接文件" class="headerlink" title="3.3.4、对硬符号链接文件"></a><strong>3.3.4、对硬符号链接文件</strong></h4><p>修改的是“链接到文件”的block里面的内容。</p>
<h3 id="3-4、查看"><a href="#3-4、查看" class="headerlink" title="3.4、查看"></a><strong>3.4、查看</strong></h3><h4 id="3-4-1、对一般文件"><a href="#3-4-1、对一般文件" class="headerlink" title="3.4.1、对一般文件"></a><strong>3.4.1、对一般文件</strong></h4><p>查看的是block里面的内容。</p>
<h4 id="3-4-2、对目录文件"><a href="#3-4-2、对目录文件" class="headerlink" title="3.4.2、对目录文件"></a><strong>3.4.2、对目录文件</strong></h4><p>查看的是block里面的内容。</p>
<h4 id="3-4-3、对软符号链接文件"><a href="#3-4-3、对软符号链接文件" class="headerlink" title="3.4.3、对软符号链接文件"></a><strong>3.4.3、对软符号链接文件</strong></h4><p>查看的是“链接到文件”的block里面的内容。</p>
<h4 id="3-4-4、对硬符号链接文件"><a href="#3-4-4、对硬符号链接文件" class="headerlink" title="3.4.4、对硬符号链接文件"></a><strong>3.4.4、对硬符号链接文件</strong></h4><p>查看的是“链接到文件”的block里面的内容。</p>
<br/>
参考文献：
[1]《鸟哥的Linux私房菜：基础学习篇》
[2]http://roclinux.cn/?p=754
[3]https://www.nixtutor.com/freebsd/understanding-symbolic-links/
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux进程概述</title>
    <url>/blog/2018/09/24/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、Linux进程创建"><a href="#一、Linux进程创建" class="headerlink" title="一、Linux进程创建"></a><strong>一、Linux进程创建</strong></h2><p>可执行文件 ——&gt; 运行创建Linux进程。</p>
<h2 id="二、查看Linux进程信息"><a href="#二、查看Linux进程信息" class="headerlink" title="二、查看Linux进程信息"></a><strong>二、查看Linux进程信息</strong></h2><p>假设一个Linux进程的ID为“PID”，那么“&#x2F;proc&#x2F;PID”目录下存储有该进程的一些信息，比如“cwd（进程运行目录）”。</p>
<h2 id="三、与Linux进程交互的命令工具"><a href="#三、与Linux进程交互的命令工具" class="headerlink" title="三、与Linux进程交互的命令工具"></a><strong>三、与Linux进程交互的命令工具</strong></h2><p>与Linux进程交互的命令工具有：strace等。</p>
<h2 id="四、Linux进程运行监控与问题定位"><a href="#四、Linux进程运行监控与问题定位" class="headerlink" title="四、Linux进程运行监控与问题定位"></a><strong>四、Linux进程运行监控与问题定位</strong></h2><p>理论上，Linux进程的问题必可定位，不存在不可定位之问题。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux进程被系统杀死</title>
    <url>/blog/2018/09/25/Linux%E8%BF%9B%E7%A8%8B%E8%A2%AB%E7%B3%BB%E7%BB%9F%E6%9D%80%E6%AD%BB/</url>
    <content><![CDATA[<p>本文介绍一种Linux进程被系统杀死的情形，具体描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当系统内存资源耗尽或者濒临耗尽时，系统会根据某种策略选取一个Linux进程，将其杀死，然后释放其所占用内存资源</span><br></pre></td></tr></table></figure>
<p>系统的上述机制被称为“out-of-memory (OOM) killer”。<br><br/><br>可通过<code>dmesg -T | grep -E -i -B100 &#39;killed process&#39;</code>命令查看Linux进程被系统OOM killer杀死的日志记录。</p>
<br/>
**参考文献：**
[1]https://my.oschina.net/u/3345762/blog/1784199
[2]https://stackoverflow.com/questions/726690/what-killed-my-process-and-why
[3]https://askubuntu.com/questions/709336/how-to-find-out-why-process-was-killed-on-server
[4]https://lwn.net/Articles/317814/
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Lock接口</title>
    <url>/blog/2021/04/02/Lock%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>本文介绍J.U.C包中的Lock接口及其相关实现类。<br>本文的源码如无特别说明，都是基于JDK 1.8。</p>
<h2 id="一、引入背景"><a href="#一、引入背景" class="headerlink" title="一、引入背景"></a><strong>一、引入背景</strong></h2><p>在JDK 1.5之前，synchronized锁机制性能不好，且功能单一（“申请锁时不能响应中断”，“未提供‘尝试申请锁失败直接返回而不挂起’接口”，“不支持读写锁”，“不支持公平锁”，“不支持不可重入锁”等），故Java并发大神Doug Lea设计了Lock接口及其相关实现类——Lock接口，ReentrantLock类，ReentrantReadWriteLock类，它们在JDK 1.5被引入。</p>
<h2 id="二、J-U-C包中的Lock接口及其相关实现类"><a href="#二、J-U-C包中的Lock接口及其相关实现类" class="headerlink" title="二、J.U.C包中的Lock接口及其相关实现类"></a><strong>二、J.U.C包中的Lock接口及其相关实现类</strong></h2><p>Lock接口的所有方法描述如下：</p>
<ul>
<li><code>lock()</code>，申请锁，如果失败则挂起直到申请成功，过程中不可响应中断</li>
<li><code>lockInterruptibly()</code>，申请锁，如果失败则挂起直到申请成功，过程中可响应中断</li>
<li><code>tryLock()</code>，尝试申请锁，立即返回锁申请结果——成功&#x2F;失败</li>
<li><code>tryLock(long time, TimeUnit unit)</code>，尝试申请锁，至多等待设定的超时时间，在该过程中如果申请到锁则立即返回“成功”，否则等待设定的超时时间到期返回“失败”，过程中可响应中断</li>
<li><code>unlock()</code>，释放已申请到的锁</li>
<li><code>newCondition()</code>，创建生成一个与本Lock实例对象关联的Condition对象，在其上可调用<code>await()/awaitUninterruptibly()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>和<code>signal()/signalAll()</code>方法，提供一个线程之间协作的机制（可类比于Object类的<code>wait()/wait(long timeout)/wait(long timeout, int nanos)</code>和<code>notify()/notifyAll()</code>方法）。<font color='red'>需要注意的是，只有当实际锁是“排他锁”时，调用该方法才有意义</font>。关于Condition的实现子类详见AQS中的ConditionObject</li>
</ul>
<p>接下来主要介绍Lock接口的相关实现类。</p>
<h3 id="2-1、ReentrantLock锁"><a href="#2-1、ReentrantLock锁" class="headerlink" title="2.1、ReentrantLock锁"></a><strong>2.1、ReentrantLock锁</strong></h3><h4 id="2-1-1、基本介绍"><a href="#2-1-1、基本介绍" class="headerlink" title="2.1.1、基本介绍"></a><strong>2.1.1、基本介绍</strong></h4><p>ReentrantLock锁被设计作为synchronized锁的加强改进版。</p>
<p>最多加锁次数：2^31-1，因为是排他锁，所以该次数指的是最多重入次数。</p>
<p>其锁分类是：</p>
<ul>
<li>悲观锁</li>
<li>阻塞锁</li>
<li>创建时可选是“公平锁”还是“非公平锁”，默认是“非公平锁”</li>
<li>可重入锁</li>
<li>排他锁</li>
</ul>
<p>其常见使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockUseExample</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟运行signalExample()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">awaitExample</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟运行awaitExample()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalExample</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有点需要注意：</p>
<ol>
<li><code>tryLock()</code>方法的实现总是“非公平”的，不管创建ReentrantLock实例时选择的是“公平”还是“非公平”策略；<code>lock()</code>，<code>lockInterruptibly()</code>和<code>tryLock(long time, TimeUnit unit)</code>的实现遵从创建ReentrantLock实例时选择的“公平&#x2F;非公平”策略</li>
</ol>
<h4 id="2-1-2、源码实现"><a href="#2-1-2、源码实现" class="headerlink" title="2.1.2、源码实现"></a><strong>2.1.2、源码实现</strong></h4><p>ReentrantLock内部有一个AQS继承体系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        AQS</span><br><span class="line">         * </span><br><span class="line">         * </span><br><span class="line">        Sync</span><br><span class="line">       *    *</span><br><span class="line">      *       *</span><br><span class="line">FairSync    NonfairSync</span><br></pre></td></tr></table></figure>
<p>ReentrantLock类内有一个<code>ReentrantLock.Sync sync</code>实例成员变量，ReentrantLock类的所有具体实现都通过转发给<code>sync</code>实现，在创建类实例对象时，可选择<code>sync</code>具体是一个“ReentrantLock.FairSync”实例对象，还是一个“ReentrantLock.NonfairSync”实例对象，默认是一个“ReentrantLock.NonfairSync”实例对象，即“选择公平&#x2F;非公平策略，默认是非公平策略”。</p>
<p>根据源码推导ReentrantLock锁的锁分类：</p>
<ul>
<li>根据<a href="/blog/2021/04/02/AQS/" title="AQS">《AQS》</a>，我们知道，基于AQS实现的锁，天然就是“悲观锁”和“阻塞锁”</li>
<li>如果<code>sync</code>具体是一个“ReentrantLock.FairSync”实例对象，查看“ReentrantLock.FairSync”源码，可知是“公平锁”，“可重入锁”和“排他锁”；如果<code>sync</code>具体是一个“ReentrantLock.NonfairSync”实例对象，查看“ReentrantLock.NonfairSync”源码，可知是“非公平锁”，“可重入锁”和“排他锁”</li>
</ul>
<br/>

<p>我们知道synchronized锁存在一个happens-before规则——<code>对一个锁的解锁，happens-before于随后对这个锁的加锁</code>，那ReentrantLock锁满足该happens-before规则吗？答案是：是的。<br>接下来进行证明：基于一个ReentrantLock锁，其<code>sync</code>实例成员变量指向一个“ReentrantLock.FairSync”实例对象。假定有线程A和B（A和B不同线程，假如A和B是同一个线程，那么根据“程序顺序规则”该条happens-before规则，直接就能推导出目标结论），A执行“代码1”中的<code>lockA</code>方法，B执行“代码1”中的<code>lockB</code>方法，A已经获得锁正在执行解锁操作，B正在执行加锁操作。解锁操作细化见“代码2”，加锁操作细化见“代码3”。</p>
<p>代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockA</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockB</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;   <span class="comment">// 51</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 52</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 53</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// 511</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 512</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);  <span class="comment">// 513</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">// 61</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 611</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState(); <span class="comment">// 612</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B想要获取锁，必须是“&#x2F;&#x2F; 612处读取到&#x2F;&#x2F; 513处的最新state写入值（值为0）”，而state是一个volatile变量，根据volatile变量happens-before规则，有“&#x2F;&#x2F; 513 -&gt; &#x2F;&#x2F; 612”，再根据“程序顺序规则”和“传递性规则”，有“1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 511 -&gt; 512 -&gt; 513 -&gt; 612 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10”，其实在&#x2F;&#x2F; 513后面还有其他语句，比如“&#x2F;&#x2F; 52”，“&#x2F;&#x2F; 53”，在&#x2F;&#x2F; 612前面也有其他语句，比如“&#x2F;&#x2F; 611”，“acquireQueued方法中的其他语句，因为获取到锁的tryAcquire方法调用可能是在acquireQueued方法中触发的”，但是&#x2F;&#x2F; 512后面的语句和&#x2F;&#x2F; 612前面的语句并不会影响业务代码，因此我们在叙述ReentrantLock锁的happens-before规则时（关注Lock接口的lock和unlock方法级粒度），可“宏观近似”地认为有“1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10”，到此目标结论得证。</p>
<h4 id="2-1-3、与synchronized锁的比较"><a href="#2-1-3、与synchronized锁的比较" class="headerlink" title="2.1.3、与synchronized锁的比较"></a><strong>2.1.3、与synchronized锁的比较</strong></h4><p>比较维度有4个：锁分类、使用、源码实现和性能。</p>
<h5 id="2-1-3-1、锁分类"><a href="#2-1-3-1、锁分类" class="headerlink" title="2.1.3.1、锁分类"></a><strong>2.1.3.1、锁分类</strong></h5><table>
<thead>
<tr>
<th>锁</th>
<th>悲观锁 vs 乐观锁</th>
<th>阻塞锁 vs 非阻塞锁</th>
<th>公平锁 vs 非公平锁</th>
<th>可重入锁 vs 非可重入锁</th>
<th>共享锁 vs 排他锁</th>
</tr>
</thead>
<tbody><tr>
<td>synchronized锁</td>
<td>悲观锁</td>
<td>阻塞锁</td>
<td>非公平锁</td>
<td>可重入锁</td>
<td>排他锁</td>
</tr>
<tr>
<td>ReentrantLock锁</td>
<td>悲观锁</td>
<td>阻塞锁</td>
<td>可选是“公平锁”和“非公平锁”，默认是“非公平锁”</td>
<td>可重入锁</td>
<td>排他锁</td>
</tr>
</tbody></table>
<h5 id="2-1-3-2、使用"><a href="#2-1-3-2、使用" class="headerlink" title="2.1.3.2、使用"></a><strong>2.1.3.2、使用</strong></h5><p>ReentrantLock锁的常见使用示例如上，synchronized锁的常见使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedUseExample</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockExample</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟运行notifyExample()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟运行waitExample()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“使用”维度的比较描述：</p>
<ul>
<li>synchronized锁的使用形式相较更简单，自动进行锁释放；对于ReentrantLock锁，需要手动进行锁释放</li>
<li>从使用功能丰富的角度来说，ReentrantLock锁更胜一筹，除了以上常见接口，它还提供<code>lockInterruptibly()</code>，<code>tryLock()</code>和<code>tryLock(long time, TimeUnit unit)</code>等接口</li>
</ul>
<h5 id="2-1-3-3、源码实现"><a href="#2-1-3-3、源码实现" class="headerlink" title="2.1.3.3、源码实现"></a><strong>2.1.3.3、源码实现</strong></h5><p>ReentrantLock锁的源码实现可参见“2.1.2、源码实现”小节，synchronized锁的源码实现可参见<a href="/blog/2020/03/26/synchronized%E9%94%81%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/" title="synchronized锁内部实现">《synchronized锁内部实现》</a>。</p>
<p><strong>竞争申请锁的核心逻辑（假定现有T1和T2两个线程尝试竞争锁，两个线程足以代表两个以上的线程竞争情形）</strong>：</p>
<ul>
<li>ReentrantLock非公平锁：非公平竞争锁，失败排队。当锁申请等待队列不为空时，最多可能的竞争选手有：<code>T1</code>，<code>T2</code>和<code>被唤醒队列头节点所指向线程</code>；当锁申请等待队列为空时，最多可能的竞争选手有：<code>T1</code>和<code>T2</code></li>
<li>ReentrantLock公平锁：公平竞争锁，失败排队。当锁申请等待队列不为空时，最多可能的竞争选手有：<code>被唤醒队列头节点所指向线程</code>；当锁申请等待队列为空时，最多可能的竞争选手有：<code>T1</code>和<code>T2</code></li>
<li>synchronized锁：<ul>
<li>在轻度竞争环境中，竞争偏向锁或者轻量级锁</li>
<li>在重度竞争环境中，竞争重量级锁，非公平竞争重量级锁，失败排队。当锁申请等待队列不为空时，最多可能的竞争选手有：<code>T1</code>，<code>T2</code>，<code>被唤醒队列头节点所指向线程</code>和<code>_Responsible线程</code>[1]；当锁申请等待队列为空时，最多可能的竞争选手有：<code>T1</code>和<code>T2</code></li>
</ul>
</li>
</ul>
<h5 id="2-1-3-4、性能"><a href="#2-1-3-4、性能" class="headerlink" title="2.1.3.4、性能"></a><strong>2.1.3.4、性能</strong></h5><p>在JDK 1.5之前，synchronized锁的实现性能较差，这也是促进设计引入ReentrantLock锁的其中一个原因，但是随着JDK版本的发布提升，synchronized锁的实现性能不断得以提升改进，它与ReentrantLock锁的性能差距不断缩小，一个足以说明的例子是——“在JDK 1.8的ConcurrentHashMap实现中已经用synchronized替换ReentrantLock来完成分段加锁”。</p>
<p>性能实现的改进包括但不限于：</p>
<ul>
<li>synchronized锁的内部实现从“无锁、重量级锁”两种锁状态演进到“无锁、偏向锁、轻量级锁、重量级锁”4种锁状态</li>
<li>优化重量级锁的竞争策略</li>
</ul>
<p>synchronized锁与ReentrantLock锁的性能对比（分成“ReentrantLock非公平锁”，“ReentrantLock公平锁”和“synchronized锁”3类。另外需要注意的是：不明确JDK版本和锁竞争程度的性能对比毫无意义）：</p>
<ul>
<li>在JDK 1.5之前（包括JDK 1.5）：<ul>
<li>轻度竞争，一般是<code>ReentrantLock非公平锁 &gt; ReentrantLock公平锁 &gt; synchronized锁</code></li>
<li>重度竞争，一般是<code>ReentrantLock非公平锁 &gt; ReentrantLock公平锁 &gt; synchronized锁</code></li>
</ul>
</li>
<li>在JDK 1.8中<ul>
<li>轻度竞争，一般是<code>synchronized锁 &gt; ReentrantLock非公平锁 &gt; ReentrantLock公平锁</code></li>
<li>重度竞争，一般是<code>ReentrantLock非公平锁 &gt; synchronized锁 &gt; ReentrantLock公平锁</code></li>
</ul>
</li>
</ul>
<p>针对以上情况，进行一些说明（<font color='red'>自我理解</font>）：</p>
<ul>
<li>在轻度竞争情形中，从“JDK 1.5之前（包括JDK 1.5）”到“JDK 1.8”，synchronized锁的性能提升，可能是由于在JDK 1.6中引入了偏向锁和轻量级锁</li>
<li>在重度竞争情形中，从“JDK 1.5之前（包括JDK 1.5）”到“JDK 1.8”，synchronized锁的性能提升，应该不是由于偏向锁和轻量级锁的引入，因为此时占主导作用的是synchronized重量级锁，故大概率是由于优化了重量级锁的竞争策略——根据“2.1.3.3、源码实现”小节的确可发现，在JDK 1.8中，synchronized重量级锁的竞争策略已经优化到跟ReentrantLock非公平锁&#x2F;公平锁的竞争策略大同小异</li>
</ul>
<h3 id="2-2、ReentrantReadWriteLock锁"><a href="#2-2、ReentrantReadWriteLock锁" class="headerlink" title="2.2、ReentrantReadWriteLock锁"></a><strong>2.2、ReentrantReadWriteLock锁</strong></h3><h4 id="2-2-1、基本介绍"><a href="#2-2-1、基本介绍" class="headerlink" title="2.2.1、基本介绍"></a><strong>2.2.1、基本介绍</strong></h4><p>读写锁的设计目标应用场景是：读多写少，允许读读操作同时进行。</p>
<p>ReentrantReadWriteLock类其实本身并不继承实现Lock接口，其内部有两个Lock接口的继承实现类“ReentrantReadWriteLock.WriteLock”和“ReentrantReadWriteLock.ReadLock”，分别指代“写锁”和“读锁”。</p>
<p>“写锁”最多加锁次数：2^16-1，因为是排他锁，所以该次数指的是最多重入次数。<br>“读锁”最多加锁次数：2^16-1，因为是共享锁，所以该次数指的是最多“重入+非重入”次数。</p>
<p>上述“写锁”和“读锁”的锁分类如下表。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>悲观锁 vs 乐观锁</th>
<th>阻塞锁 vs 非阻塞锁</th>
<th>公平锁 vs 非公平锁</th>
<th>可重入锁 vs 非可重入锁</th>
<th>共享锁 vs 排他锁</th>
</tr>
</thead>
<tbody><tr>
<td>写锁</td>
<td>悲观锁</td>
<td>阻塞锁</td>
<td>创建时可选是“公平锁”和“非公平锁”，默认是“非公平锁”</td>
<td>可重入锁</td>
<td>排他锁</td>
</tr>
<tr>
<td>读锁</td>
<td>悲观锁</td>
<td>阻塞锁</td>
<td>创建时可选是“公平锁”和“非公平锁”，默认是“非公平锁”</td>
<td>可重入锁</td>
<td>共享锁</td>
</tr>
</tbody></table>
<p>其常见使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockUseExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行read()方法的线程跟执行write()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行write()方法的线程跟执行read()方法的线程不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几点补充说明：</p>
<ol>
<li>读锁调用<code>newCondition()</code>方法直接抛出<code>UnsupportedOperationException</code>异常，因为该方法只支持排他锁；写锁调用<code>newCondition()</code>方法成功创建一个Condition实例</li>
<li>读锁和写锁的<code>tryLock()</code>方法的实现总是“非公平”的，不管创建ReentrantReadWriteLock实例时选择的是“公平”还是“非公平”策略；<code>lock()</code>，<code>lockInterruptibly()</code>和<code>tryLock(long time, TimeUnit unit)</code>的实现遵从创建ReentrantReadWriteLock实例时选择的“公平&#x2F;非公平”策略</li>
<li>线程T1获取写锁后，在不释放写锁的情形下能够再获取读锁；反之，线程T1获取读锁后，在不释放读锁的情形下不能够再获取写锁。可查阅“ReentrantReadWriteLock.ReadLock”和“ReentrantReadWriteLock.WriteLock”的<code>lock()</code>方法实现源码，另外有如下“代码4”实验代码</li>
<li>基于第3点，介绍“锁降级”和“锁升级”。锁降级：T1获取写锁，然后获取读锁，再释放掉写锁，完成“写锁 -&gt; 读锁”的锁降级；不支持锁升级，因为获取读锁后不能再获取写锁</li>
<li>存在“写锁申请长时间饥饿”的情形，具体是<code>在非公平锁语境中，当前读锁被持有，“不断新产生的读锁申请”总是抢占“排队队列头节点的写锁申请”，导致该“写锁申请”长时间得不到满足</code>，解决方案是：针对上述情形，新产生的读锁申请不参与竞争，直接排队到末尾，详细可见“ReentrantReadWriteLock.NonfairSync”类的<code>readerShouldBlock()</code>方法源码</li>
</ol>
<p>代码4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockUseExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReadWriteLockUseExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteLockUseExample</span>();</span><br><span class="line"></span><br><span class="line">        example.lockWriteThenLockRead();</span><br><span class="line"></span><br><span class="line">        example.lockReadThenLockWrite();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockReadThenLockWrite</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockWriteThenLockRead</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下（main线程在打印“C”字符后申请读锁失败挂起）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2、源码实现"><a href="#2-2-2、源码实现" class="headerlink" title="2.2.2、源码实现"></a><strong>2.2.2、源码实现</strong></h4><p>ReentrantReadWriteLock内部有一个AQS继承体系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        AQS</span><br><span class="line">         * </span><br><span class="line">         * </span><br><span class="line">        Sync</span><br><span class="line">       *    *</span><br><span class="line">      *       *</span><br><span class="line">FairSync    NonfairSync</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock内部有一个Lock继承体系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        Lock</span><br><span class="line">       *    *</span><br><span class="line">      *       *</span><br><span class="line">ReadLock    WriteLock</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock类内有3个主要的实例成员变量：</p>
<ul>
<li><code>Sync sync</code>，在创建类实例对象时，可选择<code>sync</code>具体是一个“ReentrantReadWriteLock.FairSync”实例对象，还是一个“ReentrantReadWriteLock.NonfairSync”实例对象，默认是一个“ReentrantReadWriteLock.NonfairSync”实例对象，即“选择公平&#x2F;非公平策略，默认是非公平策略”</li>
<li><code>ReentrantReadWriteLock.ReadLock readerLock</code>，与<code>writerLock</code>共用<code>sync</code>，然后所有具体实现都通过转发给<code>sync</code>实现，<code>sync</code>中的<code>state</code>字段高16位分配给<code>readerLock</code></li>
<li><code>ReentrantReadWriteLock.WriteLock writerLock</code>，与<code>readerLock</code>共用<code>sync</code>，然后所有具体实现都通过转发给<code>sync</code>实现，<code>sync</code>中的<code>state</code>字段低16位分配给<code>writerLock</code></li>
</ul>
<p>根据源码推导ReentrantReadWriteLock.WriteLock锁的锁分类：</p>
<ul>
<li>根据<a href="/blog/2021/04/02/AQS/" title="AQS">《AQS》</a>，我们知道，基于AQS实现的锁，天然就是“悲观锁”和“阻塞锁”</li>
<li>如果<code>sync</code>具体是一个“ReentrantReadWriteLock.FairSync”实例对象，查看“ReentrantReadWriteLock.FairSync”源码，可知是“公平锁”，“可重入锁”和“排他锁”；如果<code>sync</code>具体是一个“ReentrantReadWriteLock.NonfairSync”实例对象，查看“ReentrantReadWriteLock.NonfairSync”源码，可知是“非公平锁”，“可重入锁”和“排他锁”</li>
</ul>
<p>根据源码推导ReentrantReadWriteLock.ReadLock锁的锁分类：</p>
<ul>
<li>根据<a href="/blog/2021/04/02/AQS/" title="AQS">《AQS》</a>，我们知道，基于AQS实现的锁，天然就是“悲观锁”和“阻塞锁”</li>
<li>如果<code>sync</code>具体是一个“ReentrantReadWriteLock.FairSync”实例对象，查看“ReentrantReadWriteLock.FairSync”源码，可知是“公平锁”，“可重入锁”和“共享锁”；如果<code>sync</code>具体是一个“ReentrantReadWriteLock.NonfairSync”实例对象，查看“ReentrantReadWriteLock.NonfairSync”源码，可知是“非公平锁”，“可重入锁”和“共享锁”</li>
</ul>
<p>我们知道synchronized锁存在一个happens-before规则——<code>对一个锁的解锁，happens-before于随后对这个锁的加锁</code>，那ReentrantReadWriteLock锁满足该happens-before规则吗？具体分为几种情况：</p>
<ul>
<li>对一个ReentrantReadWriteLock.WriteLock锁的解锁，happens-before于随后对“同一个写锁”或者“关联ReentrantReadWriteLock.ReadLock锁”的加锁</li>
<li>对一个ReentrantReadWriteLock.ReadLock锁的解锁，happens-before于随后对“关联ReentrantReadWriteLock.WriteLock锁”的加锁</li>
<li>“对一个ReentrantReadWriteLock.ReadLock锁的解锁”与“随后对同一个读锁的加锁”，如果是在同一线程，则根据“程序顺序规则”该条happens-before规则，有“对一个ReentrantReadWriteLock.ReadLock锁的解锁，happens-before于随后对同一个读锁的加锁”；否则，两者没有必然的happens-before关系</li>
</ul>
<p>具体证明可参见“2.1.2、源码实现”小节中对于ReentrantLock锁的happens-before规则证明。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2020/03/26/synchronized%E9%94%81%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/" title="synchronized锁内部实现">《synchronized锁内部实现》</a>中的“3.6、重量级锁”小节</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>MBR规范详解</title>
    <url>/blog/2015/06/25/MBR%E8%A7%84%E8%8C%83%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在本文中，MBR有两种含义：一是指MBR规范中的MBR；二是指对硬盘的第一个扇区的称呼。</p>
<h2 id="一、不同种类的boot-sector"><a href="#一、不同种类的boot-sector" class="headerlink" title="一、不同种类的boot sector"></a><strong>一、不同种类的boot sector</strong></h2><p>在硬盘已经被分区的前提下，boot sector可以分为以下3类：</p>
<ol>
<li>MBR：master boot record，硬盘的第一个扇区</li>
<li>VBR：volume boot record，主分区和逻辑分区的第一个扇区</li>
<li>EBR：extended boot record，扩展分区中保存有逻辑分区位置信息的扇区，多个EBR之间通过指针链接成一个链表，EBR可以存在于扩展分区中除了逻辑分区以外的所有的扇区中。对于EBR来说，第一个EBR处于扩展分区的第一个扇区，接下来的EBR没有“第一个扇区”的概念</li>
</ol>
<h2 id="二、MBR"><a href="#二、MBR" class="headerlink" title="二、MBR"></a><strong>二、MBR</strong></h2><p>MBR中具有两部分：分区信息（partion table）和引导代码（bootstrap code）。<br>现在常见的分区信息中每条分区记录有32位，那么最大支持空间是2TB。</p>
<p>经典的MBR规范中，它的结构如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20150625-0-1.png"></p>
<p>它的partion entry结构如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20150625-0-2.png"></p>
<p>由该partion entry可知，如果硬盘稍微大点，chs逻辑硬盘地址方案中的c值有可能就不能由现在分配的位数表达了。因而，在MBR规范中，直接舍弃“virtual CHS values逻辑硬盘地址方案”，而采用LBA方案。<br>4个partion entry可以指向主分区或者扩展分区，但是扩展分区至多一个。</p>
<h2 id="三、EBR"><a href="#三、EBR" class="headerlink" title="三、EBR"></a><strong>三、EBR</strong></h2><p>在扩展分区中，使用EBR来定位逻辑分区，它的结构如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20150625-0-3.png"></p>
<p>在其中，一般情况下，前446个字节，third entry和fourth entry中的值都为0。first entry指向属于该EBR的逻辑分区的位置；second entry指向下一个EBR的位置。</p>
<h2 id="四、VBR"><a href="#四、VBR" class="headerlink" title="四、VBR"></a><strong>四、VBR</strong></h2><p>主分区和逻辑分区的第一个扇区被称为VBR，在VBR中可以保存在本分区安装的操作系统的引导代码。</p>
<h2 id="五、开机加载流程"><a href="#五、开机加载流程" class="headerlink" title="五、开机加载流程"></a><strong>五、开机加载流程</strong></h2><h3 id="5-1、单操作系统"><a href="#5-1、单操作系统" class="headerlink" title="5.1、单操作系统"></a><strong>5.1、单操作系统</strong></h3><p><strong>1、需加载操作系统在主分区</strong></p>
<ol>
<li>首先BIOS加载MBR</li>
<li>执行MBR中的引导代码，这时候分为两种情况，一种是引导代码直接加载操作系统；另外一种是加载活动分区中的VBR，让其加载操作系统，在后者情形下，会发生如下这些步骤：<ol>
<li>读取MBR中的分区信息，确定活动分区（这里某条主分区的partion entry被标识为active）</li>
<li>加载活动主分区的VBR</li>
<li>执行VBR中的引导代码，加载操作系统</li>
</ol>
</li>
</ol>
<p><strong>2、需加载操作系统在逻辑分区</strong></p>
<ol>
<li>首先BIOS加载MBR</li>
<li>执行MBR中的引导代码，这时候分为两种情况，一种是引导代码直接加载操作系统；另外一种是加载活动分区中的VBR，让其加载操作系统，在后者情形下，会发生如下这些步骤：<ol>
<li>读取MBR中的分区信息，确定活动分区(这里扩展分区partion entry被标识为active）</li>
<li>加载扩展分区上的第一个扇区中的第一个EBR，根据这个EBR遍历EBR链接表，找到被标识为active的逻辑分区位置</li>
<li>加载活动逻辑分区的VBR</li>
<li>执行VBR中的引导代码，加载操作系统</li>
</ol>
</li>
</ol>
<h3 id="5-2、双操作系统"><a href="#5-2、双操作系统" class="headerlink" title="5.2、双操作系统"></a><strong>5.2、双操作系统</strong></h3><ol>
<li>首先BIOS加载MBR</li>
<li>执行MBR中的引导代码，给出可选择加载操作系统列表供用户选择</li>
<li>在用户选择加载某个操作系统后，MBR中的引导代码根据某个映射机制能够得到需加载操作系统所在的活动分区位置信息</li>
<li>加载活动分区的VBR</li>
<li>执行VBR中的引导代码，加载操作系统</li>
</ol>
<h2 id="六、MBR规范变种"><a href="#六、MBR规范变种" class="headerlink" title="六、MBR规范变种"></a><strong>六、MBR规范变种</strong></h2><p>现在出现了很多的MBR规范变种，主要原因有两个：</p>
<ul>
<li>随着时间的推移，为了提升MBR规范所拥有的能力，对原有MBR规范进行了改进</li>
<li>不同操作系统在支持MBR规范的时候，会增加特定于自身的一些限制，这些从某个角度来看，也是MBR规范的变种</li>
</ul>
<p>比如随着时间的推移，出现了如下形式的现代MBR结构：</p>
<p><img src="https://blog.dslztx.top/imgs/20150625-0-4.png"></p>
<p>又有Dos，OS&#x2F;2等操作系统只支持CHS寻址方案，因而对MBR规范增加了如下的限制，这使得也产生了MBR规范的变种[5]：</p>
<ul>
<li>MBR所处的柱面和第一个主分区的开始柱面都为0柱面，这些操作系统直接限制第一个主分区的起始扇区是0柱面第2个磁头上的第一个扇区，这浪费了0柱面第1个磁头上除了第一个扇区以外的所有扇区（0柱面第1个磁头上的第一个扇区是MBR所在扇区）</li>
<li>EBR所处的柱面和该EBR所对应的逻辑分区的开始柱面都为c柱面，这些操作系统直接限制逻辑分区的起始扇区是c柱面第2个磁头上的第一个扇区，这浪费了c柱面第1个磁头上除了第一个扇区以外的所有扇区（c柱面第1个磁头上的第一个扇区是EBR所在扇区）</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/Master_boot_record">https://en.wikipedia.org/wiki/Master_boot_record</a><br>[2]<a href="https://en.wikipedia.org/wiki/Volume_boot_record">https://en.wikipedia.org/wiki/Volume_boot_record</a><br>[3]<a href="https://en.wikipedia.org/wiki/Extended_boot_record#ask1.1">https://en.wikipedia.org/wiki/Extended_boot_record#ask1.1</a><br>[4]<a href="https://en.wikipedia.org/wiki/Boot_sector">https://en.wikipedia.org/wiki/Boot_sector</a><br>[5]man cfdisk</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MESI协议</title>
    <url>/blog/2019/06/10/MESI%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在多核CPU中，每个CPU核内都有高速缓存——L1高速缓存和L2高速缓存，由于这些高速缓存缓存相同主存，因此需要高速缓存一致性协议来确保高速缓存状态和操作的语义一致性；而L3高速缓存是属于多CPU核共享的，因此不存在一致性问题。</p>
<p>在众多的高速缓存一致性协议中，MESI协议是应用较为广泛的一种，本文接下来就主要介绍MESI协议。</p>
<p><font color='red'>需要说明的是，如无特别说明，接下来的“缓存”和“Cache”均代指“高速缓存”。</font></p>
<h2 id="一、MESI协议简介"><a href="#一、MESI协议简介" class="headerlink" title="一、MESI协议简介"></a><strong>一、MESI协议简介</strong></h2><p>MESI协议是众多高速缓存一致性协议中的一种，它支持的高速缓存写策略是：<font color='red'>Write Back（写回）</font>。</p>
<p>另外，需要提及的一点是：存在一个选择，具体是“当某个CPU核A需要访问的数据不在A内缓存，而另一个CPU核B内缓存存在所需数据，那么此时A是从B内缓存复制数据到本地缓存，还是从主存复制数据到本地缓存（后者显而易见会增加主存总线的锁住时间，采用前者可提高主存的存取速度）？”，对于这个选择，MESI协议本身并未作出规定，而是交由MESI协议的具体实现来决定。<font color='red'>我们这里以从主存复制为例进行说明。</font></p>
<h2 id="二、MESI协议——Cache-Line的4种状态"><a href="#二、MESI协议——Cache-Line的4种状态" class="headerlink" title="二、MESI协议——Cache Line的4种状态"></a><strong>二、MESI协议——Cache Line的4种状态</strong></h2><h3 id="2-1、4种Cache-Line状态"><a href="#2-1、4种Cache-Line状态" class="headerlink" title="2.1、4种Cache Line状态"></a><strong>2.1、4种Cache Line状态</strong></h3><p>MESI协议将Cache Line的状态分为4种，分别是：<code>modify-修改-M</code>、<code>exclusive-独占-E</code>、<code>shared-共享-S</code>和<code>invalid-失效-I</code>。4个状态需要2个标记比特位。<br>另外，根据<a href="/blog/2019/06/07/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" title="高速缓存">《高速缓存》</a>笔记可知，采用“Write Back（写回）”高速缓存写策略的Cache Line原就有2个标记比特位，分别是：<code>valid-是否有效</code>和<code>dirty-是否修改</code>。<br>综上，Cache Line现有4个标记比特位，特别需要强调的是：<font color='red'>“4个状态对应的2个标记比特位”与“另外2个标记比特位”存在耦合依赖关系，并非互相独立，这个关系描述详见表1</font>。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>MESI协议规定的4个状态</th>
<th>2个状态标记比特位值</th>
<th>valid标记比特位值</th>
<th>dirty标记比特位值</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>modify-M</code></td>
<td>00</td>
<td>0-有效</td>
<td>1-存在修改</td>
<td>该Cache Line有效，存在修改，与主存相应数据块不一致，且新于主存相应数据块。只有当前CPU核内的缓存加载了该Cache Line</td>
</tr>
<tr>
<td><code>exclusive-E</code></td>
<td>01</td>
<td>0-有效</td>
<td>0-不存在修改</td>
<td>该Cache Line有效，不存在修改，与主存相应数据块一致。只有当前CPU核内的缓存加载了该Cache Line</td>
</tr>
<tr>
<td><code>shared-S</code></td>
<td>10</td>
<td>0-有效</td>
<td>0-不存在修改</td>
<td>该Cache Line有效，不存在修改，与主存相应数据块一致。多于1个的CPU核（包括当前CPU核）内的缓存加载了该Cache Line。<font color='red'>实际中，可能由于替换，最终少于2个的CPU核内的缓存加载了该Cache Line</font></td>
</tr>
<tr>
<td><code>invalid-I</code></td>
<td>11</td>
<td>1-无效</td>
<td>0-不存在修改</td>
<td><font color='red'>该Cache Line无效</font></td>
</tr>
</tbody></table>
<br/>

<p><strong>备注</strong>：</p>
<ul>
<li>以上表中4个标记比特位的值只是为了便于示例说明，而不一定是实际值</li>
<li>一个Cache Line或者不加载，或者加载后处于上面4种状态之一的某种状态</li>
<li>处于无效状态的Cache Line需要重新加载，从这个角度来看，其等价于“未加载”</li>
<li>特别需要注意的是，当状态转换时，“valid标记比特位”和“dirty标记比特位”也需要作相应的修改，以保持正确的耦合依赖关系</li>
</ul>
<h3 id="2-2、合法的Cache-Line状态组合"><a href="#2-2、合法的Cache-Line状态组合" class="headerlink" title="2.2、合法的Cache Line状态组合"></a><strong>2.2、合法的Cache Line状态组合</strong></h3><p>在多CPU核情形中，对于同一个Cache Line，当被大于1个CPU核内的Cache加载时，从全局视角看，合法的Cache Line状态组合有：</p>
<ul>
<li><code>=1个M，&gt;=1个I</code>，此时如果发生Cache Line替换，则可能的合法状态组合有<code>&gt;=1个I</code>，<code>=1个M，&gt;=0个I</code>，<code>&gt;=0个I</code></li>
<li><code>=1个E，&gt;=1个I</code>，此时如果发生Cache Line替换，则可能的合法状态组合有<code>&gt;=1个I</code>，<code>=1个E，&gt;=0个I</code>，<code>&gt;=0个I</code></li>
<li><code>&gt;=2个S，&gt;=0个I</code>，此时如果发生Cache Line替换，则可能的合法状态组合有<code>&gt;=2个S，&gt;=0个I</code>，<code>&gt;=1个S，&gt;=0个I</code>，<code>&gt;=0个I</code></li>
<li><code>&gt;=2个I</code>，此时如果发生Cache Line替换，则可能的合法状态组合有<code>&gt;=1个I</code>，<code>&gt;=0个I</code></li>
</ul>
<h2 id="三、MESI协议——会引起Cache-Line状态转换的4种操作"><a href="#三、MESI协议——会引起Cache-Line状态转换的4种操作" class="headerlink" title="三、MESI协议——会引起Cache Line状态转换的4种操作"></a><strong>三、MESI协议——会引起Cache Line状态转换的4种操作</strong></h2><p>MESI协议将会引起Cache Line状态转换的操作分为4种：</p>
<ul>
<li><code>Local Read-LR</code>，读取本CPU核内缓存中的Cache Line</li>
<li><code>Local Write-LW</code>，写数据到本CPU核内缓存中的Cache Line</li>
<li><code>Remote Read-RR</code>，读取其他CPU核内缓存中的Cache Line</li>
<li><code>Remote Write-RW</code>，写数据到其他CPU核内缓存中的Cache Line</li>
</ul>
<h2 id="四、MESI协议——4种状态-会引起状态转换的4种操作-16种状态转换情形"><a href="#四、MESI协议——4种状态-会引起状态转换的4种操作-16种状态转换情形" class="headerlink" title="四、MESI协议——4种状态*会引起状态转换的4种操作&#x3D;16种状态转换情形"></a><strong>四、MESI协议——4种状态*会引起状态转换的4种操作&#x3D;16种状态转换情形</strong></h2><p>如上文所述，MESI协议中Cache Line的状态有4种，而会引起状态转换的操作也有4种，因此共有16种状态转换情形，接下来就主要介绍这16种状态转换情形，以进一步理解MESI协议。总的16种状态转换示意图如图1。<br>需要说明的是，为实现MESI协议，每个Cache控制器不仅知晓自己的操作和Cache Line状态，也知晓其他Cache控制器的操作和Cache Line状态。</p>
<p>为便于接下来的叙述方便，首先给出一些约定：</p>
<ul>
<li>分别以a和b指代不同CPU核内的Cache控制器，a和b加载同一个Cache Line A，可分别以“aA”和“bA”表示，“aA”和“bA”相同不代表它们在Cache中的位置一定一致（比如在组相联映射方案中，通过遍历组找到存放Cache Line的目标位置，而“aA”和“bA”对应的最终遍历到目标位置很有可能不同），而只是代表它们对应的主存数据块相同</li>
<li>“xA”表示由某个Cache控制器x加载的Cache Line A</li>
</ul>
<p>在接下来的叙述中，面向Cache Line A，执行LR和LW操作的Cache控制器是a，执行RR和RW操作的Cache控制器是b。</p>
<p>图1<sup>[1]</sup></p>
<p><img src="https://blog.dslztx.top/imgs/20190610-0-0.gif"></p>
<h3 id="4-1、M"><a href="#4-1、M" class="headerlink" title="4.1、M"></a><strong>4.1、M</strong></h3><ul>
<li>LR：根据所有包含<code>M</code>的合法Cache Line状态组合，无需向内存总线发送RR操作信号，直接读取aA，状态不变</li>
<li>LW：根据所有包含<code>M</code>的合法Cache Line状态组合，无需向内存总线发送RW操作信号，直接写数据到aA，状态不变</li>
<li>RR：当a监听到内存总线上有RR操作信号时，在b真正执行上述RR操作前，a首先将存在修改的aA写回主存，然后b再真正执行上述RR操作，此时aA和bA都为最新且一致，因此，需要将aA和bA的状态都设为<code>S</code></li>
<li>RW：当a监听到内存总线上有RW操作信号时，在b真正执行上述RW操作前，a首先将存在修改的aA写回主存，然后b再真正执行上述RW操作，此时aA的状态设为<code>I</code>，bA的状态设为<code>M</code></li>
</ul>
<h3 id="4-2、E"><a href="#4-2、E" class="headerlink" title="4.2、E"></a><strong>4.2、E</strong></h3><ul>
<li>LR：根据所有包含<code>E</code>的合法Cache Line状态组合，无需向内存总线发送RR操作信号，直接读取aA，状态不变</li>
<li>LW：根据所有包含<code>E</code>的合法Cache Line状态组合，无需向内存总线发送RW操作信号，直接写数据到aA，状态设为<code>M</code></li>
<li>RR：aA和bA的状态设为<code>S</code></li>
<li>RW：aA的状态设为<code>I</code>，bA的状态设为<code>M</code></li>
</ul>
<h3 id="4-3、S"><a href="#4-3、S" class="headerlink" title="4.3、S"></a><strong>4.3、S</strong></h3><ul>
<li>LR：根据所有包含<code>S</code>的合法Cache Line状态组合，无需向内存总线发送RR操作信号，直接读取aA，状态不变</li>
<li>LW：根据所有包含<code>S</code>的合法Cache Line状态组合，可能存在处于<code>S</code>状态的xA，因此需要向内存总线发送RW操作信号，直接写数据到aA，状态设为<code>M</code>，所有xA的状态设为<code>I</code></li>
<li>RR：aA和bA的状态设为<code>S</code></li>
<li>RW：aA的状态设为<code>I</code>，bA的状态设为<code>M</code></li>
</ul>
<h3 id="4-4、I"><a href="#4-4、I" class="headerlink" title="4.4、I"></a><strong>4.4、I</strong></h3><p>在继续之前，首先需要说明的是：1）对于一个Cache Line A，如果其未加载，那么就等价处于<code>I</code>状态；2）有效xA表示Cache Line A被加载，且状态不为<code>I</code>。</p>
<ul>
<li>LR：<ul>
<li>如果其他CPU核内Cache中不存在有效xA，显而易见的是，a无需向内存总线发送RR操作信号，它从主存重新加载aA，并则aA的状态设为<code>E</code></li>
<li>如果其他CPU核内Cache中存在有效xA，且状态为<code>S</code>，则a无需向内存总线发送RR操作信号，它从主存重新加载aA，aA的状态设为<code>S</code></li>
<li>如果其他CPU核内Cache中存在有效xA，且状态为<code>E</code>，则a需要向内存总线发送RR操作信号，它从主存重新加载aA，最终所有有效xA的状态设为<code>S</code>，aA的状态也设为<code>S</code></li>
<li>如果其他CPU核内Cache中存在有效xA，且状态为<code>M</code>，根据所有包含<code>M</code>的合法Cache Line状态组合可知，只可能存在一个状态为<code>M</code>的xA，假定该xA所在的Cache控制器为p，那么该xA又可被称为pA。此时a需要向内存总线发送RR操作信号，当p监听到内存总线上有RR操作信号时，p先将存在修改的pA写回主存，并将其状态设为<code>S</code>，随后a从主存重新加载aA，并则aA的状态设为<code>S</code></li>
</ul>
</li>
<li>LW：<ul>
<li>如果其他CPU核内Cache中不存在有效xA，显而易见的是，a无需向内存总线发送RW操作信号，它从主存重新加载aA，然后直接写数据到aA，并将aA的状态设为<code>M</code></li>
<li>如果其他CPU核内Cache中存在有效xA，且状态为<code>S</code>或者<code>E</code>，则a需要向内存总线发送RW操作信号，所有有效xA的状态设为<code>I</code>，a从主存重新加载aA，然后直接写数据到aA，并将aA的状态设为<code>M</code></li>
<li>如果其他CPU核内Cache中存在有效xA，且状态为<code>M</code>，根据所有包含<code>M</code>的合法Cache Line状态组合可知，只可能存在一个状态为<code>M</code>的xA，假定该xA所在的Cache控制器为p，那么该xA又可被称为pA。此时a需要向内存总线发送RW操作信号，当p监听到内存总线上有RW操作信号时，p先将存在修改的pA写回主存，并将其状态设为<code>I</code>，随后a从主存重新加载aA，然后直接写数据到aA，并将aA的状态设为<code>M</code></li>
</ul>
</li>
<li>RR：<ul>
<li>aA处于无效状态，其他CPU核内Cache控制器的读取操作与aA无关，因此状态不变</li>
</ul>
</li>
<li>RW：<ul>
<li>aA处于无效状态，其他CPU核内Cache控制器的写操作与aA无关，因此状态不变</li>
</ul>
</li>
</ul>
<h2 id="五、MESI协议实际运作举例"><a href="#五、MESI协议实际运作举例" class="headerlink" title="五、MESI协议实际运作举例"></a><strong>五、MESI协议实际运作举例</strong></h2><p>假定现有3个Cache控制器a，b，c，面向Cache Line A。</p>
<ol>
<li>a读取A，则a加载A，此时aA的状态为<code>E</code>，b和c未加载A</li>
<li>b读取A，则b加载A，此时aA和bA的状态为<code>S</code>，c未加载A</li>
<li>c写数据到A，则c加载A再写数据到cA，此时aA和bA的状态为<code>I</code>，cA的状态为<code>M</code></li>
<li>a读取A，aA和cA的状态为<code>S</code>，bA的状态仍为<code>I</code></li>
</ol>
<br/>

<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h2><p>[1]<a href="https://blog.csdn.net/muxiqingyang/article/details/6615199">https://blog.csdn.net/muxiqingyang/article/details/6615199</a><br>[2]<a href="https://blog.csdn.net/reliveIT/article/details/50450136">https://blog.csdn.net/reliveIT/article/details/50450136</a><br>[3]<a href="https://www.infoq.cn/article/cache-coherency-primer">https://www.infoq.cn/article/cache-coherency-primer</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL服务端本地进行root用户免密登录</title>
    <url>/blog/2018/11/27/MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%AC%E5%9C%B0%E8%BF%9B%E8%A1%8Croot%E7%94%A8%E6%88%B7%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>运行MySQL服务端的命令假定为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=/home/xxx/mysql/my.cnf ...</span><br></pre></td></tr></table></figure>

<p>那么，在该MySQL服务端本地机器上可通过如下命令进行root用户的免密登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql --defaults-file=/home/xxx/mysql/my.cnf -u root</span><br><span class="line">mysqladmin --defaults-file=/home/xxx/mysql/my.cnf -u root flush-hosts</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Nacos集群运维</title>
    <url>/blog/2023/02/02/Nacos%E9%9B%86%E7%BE%A4%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<p>本文基于Nacos 2.2.0版本。</p>
<p>Nacos集群有两类角色：1）注册中心；2）配置中心。</p>
<p>对应的，Nacos集群需要处理两类数据：</p>
<ul>
<li>微服务生产者和消费者的注册数据，比如“Dubbo生产者和消费者的注册信息”，注册数据具有易变性，无需持久化，设计直接存于内存</li>
<li>配置数据（Web管理页面<code>配置管理 -&gt; 配置列表</code>），比如“熔断降级规则数据”，配置数据支持以下两种方式存放<ul>
<li>内置数据库，本质仍在内存，未持久化</li>
<li>外置MySQL数据库，持久化</li>
</ul>
</li>
</ul>
<h2 id="一、集群部署"><a href="#一、集群部署" class="headerlink" title="一、集群部署"></a><strong>一、集群部署</strong></h2><p>待部署的集群选用外置MySQL数据库持久化存储配置数据。</p>
<h3 id="1-1、初始化MySQL表结构"><a href="#1-1、初始化MySQL表结构" class="headerlink" title="1.1、初始化MySQL表结构"></a><strong>1.1、初始化MySQL表结构</strong></h3><p>MySQL版本须大于5.6.5，否则下面的建表语句会失败。</p>
<p>具体步骤：</p>
<ol>
<li>建立一个独立的数据库供Nacos集群使用，比如“nacos”</li>
<li>在步骤1所建数据库中，执行<code>conf/mysql-schema.sql</code>脚本，初始化MySQL表结构</li>
</ol>
<h3 id="1-2、配置文件"><a href="#1-2、配置文件" class="headerlink" title="1.2、配置文件"></a><strong>1.2、配置文件</strong></h3><p><strong>1、<code>conf/cluster.conf</code></strong><br>形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#2023-02-01T14:15:58.204</span><br><span class="line">10.110.20.53:8848</span><br><span class="line">10.110.20.54:8848</span><br><span class="line">10.110.20.55:8848</span><br></pre></td></tr></table></figure>

<p><strong>2、<code>conf/application.properties</code></strong><br>显式指定本节点IP地址，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nacos.inetutils.ip-address=10.110.20.54</span><br></pre></td></tr></table></figure>

<p>配置使用外置MySQL数据库，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### If use MySQL as datasource:</span><br><span class="line"> spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">### Count of DB:</span><br><span class="line"> db.num=1</span><br><span class="line"></span><br><span class="line">### Connect URL of DB:</span><br><span class="line"> db.url.0=jdbc:mysql://10.110.6.189:4333/nacos2?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line"> db.user.0=root</span><br><span class="line"> db.password.0=root</span><br></pre></td></tr></table></figure>

<h3 id="1-3、脚本"><a href="#1-3、脚本" class="headerlink" title="1.3、脚本"></a><strong>1.3、脚本</strong></h3><p><strong>1、<code>bin/startup.sh</code></strong></p>
<ol>
<li>根据实际情况看是否需要显式指定<code>JAVA_HOME</code></li>
<li>设定JVM参数<code>-Xms4g -Xmx4g -Xmn2g </code></li>
</ol>
<h2 id="二、运维"><a href="#二、运维" class="headerlink" title="二、运维"></a><strong>二、运维</strong></h2><h3 id="2-1、启动与停止"><a href="#2-1、启动与停止" class="headerlink" title="2.1、启动与停止"></a><strong>2.1、启动与停止</strong></h3><p>启动：执行<code>startup.sh</code>脚本</p>
<p>停止：</p>
<ul>
<li>执行<code>kill -s TERM pid</code>命令</li>
<li>执行<code>shutdown.sh</code>脚本，查看脚本内容可知本质就是执行<code>kill -s TERM pid</code>命令</li>
</ul>
<h3 id="2-2、查看Nacos集群节点信息"><a href="#2-2、查看Nacos集群节点信息" class="headerlink" title="2.2、查看Nacos集群节点信息"></a><strong>2.2、查看Nacos集群节点信息</strong></h3><p>Web管理页面：<code>集群管理 -&gt; 节点列表</code>。</p>
<h3 id="2-3、配置数据导入与导出"><a href="#2-3、配置数据导入与导出" class="headerlink" title="2.3、配置数据导入与导出"></a><strong>2.3、配置数据导入与导出</strong></h3><p>配置数据支持导入与导出。</p>
<h3 id="2-4、运维经验"><a href="#2-4、运维经验" class="headerlink" title="2.4、运维经验"></a><strong>2.4、运维经验</strong></h3><p>运维的Nacos集群含有3个节点。</p>
<h4 id="2-4-1、Nacos-Client的连接机制"><a href="#2-4-1、Nacos-Client的连接机制" class="headerlink" title="2.4.1、Nacos Client的连接机制"></a><strong>2.4.1、Nacos Client的连接机制</strong></h4><p>Nacos Client会与3个Nacos节点都建立连接，一旦连接不上，便会不断重连，并报出不能连接Exception，如果结合Exception监控机制，便能及时监控到Nacos节点异常。</p>
<p><strong>[备注]</strong> ZooKeeper Client的连接机制是否类似？</p>
<h4 id="2-4-2、最彻底的集群重启方案"><a href="#2-4-2、最彻底的集群重启方案" class="headerlink" title="2.4.2、最彻底的集群重启方案"></a><strong>2.4.2、最彻底的集群重启方案</strong></h4><p>根据“2.4.1、Nacos Client的连接机制”可知，一旦Nacos Client失去与Nacos节点的连接，便会不断重连，因此当出现“DOWN节点重启失败”情况时，最彻底的集群重启方案是：</p>
<ol>
<li>停止所有Nacos节点</li>
<li>删除<code>data</code>目录，不会影响持久化存储的配置数据，重启Nacos节点后会自动重新构造</li>
<li>重启所有Nacos节点</li>
</ol>
<p>即相当于初始化重启Nacos集群。</p>
<p>通过以上方案彻底重启后，理论上Nacos Client便能重新建立连接，比如“Dubbo生产者和消费者信息得以重新注册”，但是生产环境如此操作具有巨大风险，安全稳妥的方案还是：</p>
<ol>
<li>另外搭建一个临时的Nacos集群B</li>
<li>Dubbo生产者双注册</li>
<li>Dubbo消费者使用B获取Dubbo生产者</li>
<li>重启原Nacos集群，Dubbo消费者再使用该Nacos集群获取Dubbo生产者</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://nacos.io/zh-cn/docs/deployment.html">https://nacos.io/zh-cn/docs/deployment.html</a><br>[2]<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Nacos</category>
      </categories>
  </entry>
  <entry>
    <title>OpenSSH中SFTP协议实现相关程序</title>
    <url>/blog/2015/08/23/OpenSSH%E4%B8%ADSFTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="一、OpenSSH中SFTP协议实现相关程序"><a href="#一、OpenSSH中SFTP协议实现相关程序" class="headerlink" title="一、OpenSSH中SFTP协议实现相关程序"></a><strong>一、OpenSSH中SFTP协议实现相关程序</strong></h2><p>OpenSSH中SFTP协议实现的相关程序有：sftp和sftp-server[2]。<br>sftp程序实现SFTP协议中的SFTP-Client，sftp-server实现SFTP协议中的SFTP-Server。</p>
<p><strong>备注</strong>：</p>
<ul>
<li>sftp程序路径为：<code>/usr/bin/sftp</code></li>
<li>sftp-server程序路径为：<code>/usr/lib/openssh/sftp-server</code></li>
</ul>
<h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a><strong>二、工作原理</strong></h2><p><strong>1、sftp-server是被触发运行</strong><br>sftp-server跟常见的Server不太一样，不是“持续运行，监听端口”的，而是被触发运行的（比如MySQL Server“持续运行，监听3306端口”）。具体是由SSH Server（在OpenSSH中是sshd程序）触发的。<br>其实可以在sshd程序使用的sshd_config文件中配置需要触发运行的“SFTP协议中SFTP-Server的具体实现程序”，默认配置的就是sftp-server这个实现程序，可以改成使用internal-sftp。[3]<br>当sshd程序刚开始运行的时候并不需要加载sftp-server这个程序，只有在向sshd程序发送sftp请求的时候才会去加载运行sftp-server程序，这个论述可以通过以下实验证明：<br>0. 直接加载运行sshd程序，不会产生sftp-server进程，然后向sshd发送sftp请求，发现产生了sftp-server进程<br>0. 如果首先将“&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;sftp-server”移除，然后重新加载运行sshd程序，发现不会产生任何错误，能够正常工作，也没有产生sftp-server进程，然后向sshd发送sftp请求，发现会出现如图1错误</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20150823-0-1.png"></p>
<p><strong>2、安全数据通道</strong><br>在sftp和sftp-server的程序实现中，安全的数据通道由SSH连接提供。<br><strong>3、整个SFTP连接示意图</strong><br>整个过程的示意图如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20150823-0-2.jpeg"></p>
<h2 id="三、用法介绍"><a href="#三、用法介绍" class="headerlink" title="三、用法介绍"></a><strong>三、用法介绍</strong></h2><h3 id="3-1、sftp-server程序"><a href="#3-1、sftp-server程序" class="headerlink" title="3.1、sftp-server程序"></a><strong>3.1、sftp-server程序</strong></h3><p>由sshd负责调用，一般不需要特殊配置。</p>
<h3 id="3-2、sftp程序"><a href="#3-2、sftp程序" class="headerlink" title="3.2、sftp程序"></a><strong>3.2、sftp程序</strong></h3><p>我们主要来介绍sftp程序的使用用法。<br>sftp是一个具有交互运行模式的命令，主要工作都可在交互运行模式中进行。</p>
<h4 id="3-2-1、进入交互运行模式"><a href="#3-2-1、进入交互运行模式" class="headerlink" title="3.2.1、进入交互运行模式"></a><strong>3.2.1、进入交互运行模式</strong></h4><p>进入交互运行模式：<code>sftp -i identify_file -P port user@remoteHost</code>。<br><strong>-i</strong>：选项值被直接传递给底层调用的ssh程序，作为ssh程序中“-i”选项的值<br><strong>-P</strong>：选项值被直接传递给底层调用的ssh程序，作为ssh程序中“-p”选项的值<br><strong>user</strong>：选项值被直接传递给底层调用的ssh程序，作为ssh程序中“-l”选项的值<br><strong>remoteHost</strong>：被直接传递给底层调用的ssh程序，等价于ssh程序中“hostname”</p>
<p>以上这些选项都可在ssh_config文件中配置，以“~&#x2F;.ssh&#x2F;config”文件为例，其中增加如下配置内容后，命令可简化为：<code>sftp RemoteHostAlias</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host RemoteHostAlias #指定配置匹配条件    </span><br><span class="line">    HostName remoteHost  </span><br><span class="line">    User user  </span><br><span class="line">    Port port  </span><br><span class="line">    IdentityFile identify_file   </span><br></pre></td></tr></table></figure>

<p>另外还有两个比较有用的选项：</p>
<ul>
<li><strong>-D sftp-server-path</strong>：表示不是由sshd进程打开sftp-server，而是直接根据sftp-server-path路径打开sftp-server。这样子得到的sftp-server进程的父进程是执行命令的bash进程；如果是由sshd进程打开sftp-server，那么得到的sftp-server进程的父进程是sshd进程</li>
<li><strong>-v</strong>：表示打印日志信息，这有助于我们进行调试，解决遇到的问题。“-v”选项越多，表示打印的日志信息越详细</li>
</ul>
<h4 id="3-2-2、交互模式中的命令"><a href="#3-2-2、交互模式中的命令" class="headerlink" title="3.2.2、交互模式中的命令"></a><strong>3.2.2、交互模式中的命令</strong></h4><p>进入交互模式中，可以运行一些文件管理命令，这些文件管理命令由sftp进程进行解析运行。sftp交互模式中的这些文件管理命令跟通常的文件管理命令“名称相近，用法相似”。<br>这些文件管理命令可以分为3个类别：<br><strong>1、针对远端主机来说</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">chgrp grp path[grp是数字形式]</span><br><span class="line">chmod mode path</span><br><span class="line">chown own path[own是数字形式]</span><br><span class="line">ln</span><br><span class="line">ls</span><br><span class="line">mkdir</span><br><span class="line">pwd</span><br><span class="line">rename</span><br><span class="line">rm</span><br><span class="line">rmdir</span><br></pre></td></tr></table></figure>
<p><strong>2、针对本地机器来说</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcd</span><br><span class="line">lls(支持的选项跟通常的ls命令一样)</span><br><span class="line">lmkdir</span><br><span class="line">lpwd</span><br></pre></td></tr></table></figure>
<p><strong>3、其他</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get -r：从远端主机复制文件到本地，加了r选项表示允许递归复制目录，不会解析遇到的软符号链接</span><br><span class="line">progress：切换是否显示进度条</span><br><span class="line">put -r：从本地复制文件到远端主机，加了r选项表示允许递归复制目录，不会解析遇到的软符号链接</span><br><span class="line">exit：退出</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man sftp<br>[2]man 8 sftp-server<br>[3]man 5 sshd_config</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>OpenSSH软件套装</title>
    <url>/blog/2017/02/15/OpenSSH%E8%BD%AF%E4%BB%B6%E5%A5%97%E8%A3%85/</url>
    <content><![CDATA[<p>OpenSSH是一个实现SSH协议的软件，它主要分为两个端：SSH Server和SSH Client。<br><font color='red'>约定：以下所指的“连接”都指“SSH连接”。</font></p>
<h2 id="一、SSH-Server"><a href="#一、SSH-Server" class="headerlink" title="一、SSH Server"></a><strong>一、SSH Server</strong></h2><p>用来提供SSH服务。<br>重要的有两个部件，分别是“sshd程序”和“sshd_config文件”。<br>“sshd程序”是SSH Server的“daemon程序”，“sshd_config文件”是“sshd程序”使用的配置文件。</p>
<h2 id="二、SSH-Client"><a href="#二、SSH-Client" class="headerlink" title="二、SSH Client"></a><strong>二、SSH Client</strong></h2><p>用来请求SSH服务。<br>重要的有两个部件，分别是“ssh程序”和“ssh_config文件”。<br>“ssh程序”是SSH Client的客户程序，“ssh_config文件”是“ssh程序”使用的配置文件。关于“ssh程序”，可见<a href="/blog/2017/02/15/ssh%E5%91%BD%E4%BB%A4/" title="ssh命令">《ssh命令》</a>。关于“ssh_config文件”，可见<a href="/blog/2017/02/15/ssh-config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" title="ssh_config配置文件">《ssh_config配置文件》</a>。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>另外，OpenSSH还有一个处理密钥相关内容的机制，在这个机制中主要有以下这些内容：</p>
<h3 id="3-1、“ssh-keygen程序”用于创建，管理，转换密钥"><a href="#3-1、“ssh-keygen程序”用于创建，管理，转换密钥" class="headerlink" title="3.1、“ssh-keygen程序”用于创建，管理，转换密钥"></a><strong>3.1、“ssh-keygen程序”用于创建，管理，转换密钥</strong></h3><p>“ssh-keygen程序”是用来创建，管理和转换密钥的工具。详细内容见<a href="/blog/2017/02/15/ssh-keygen%E5%91%BD%E4%BB%A4/" title="ssh-keygen命令">《ssh-keygen命令》</a>。</p>
<h3 id="3-2、配置密钥用于建立SSH连接"><a href="#3-2、配置密钥用于建立SSH连接" class="headerlink" title="3.2、配置密钥用于建立SSH连接"></a><strong>3.2、配置密钥用于建立SSH连接</strong></h3><p>为了让SSH Client能够以xxx用户身份连接到SSH Server，需要经过以下步骤：</p>
<ol>
<li>使用“ssh-keygen程序”创建公钥私钥对</li>
<li>将公钥的内容追加到SSH Server所在主机的“&#x2F;home&#x2F;xxx&#x2F;.ssh&#x2F;authorized_keys”文件中</li>
<li>将私钥分发给所有有权以xxx用户身份连接到SSH Server的SSH Client</li>
</ol>
<h3 id="3-3、管理可信任SSH-Server的Host-Key"><a href="#3-3、管理可信任SSH-Server的Host-Key" class="headerlink" title="3.3、管理可信任SSH Server的Host Key"></a><strong>3.3、管理可信任SSH Server的Host Key</strong></h3><p>当SSH Client连接SSH Server的时候，会将SSH Server所在主机的Host Key追加保存到SSH Client所在主机的“&#x2F;home&#x2F;xxx&#x2F;.ssh&#x2F;known_hosts”文件中，下次当该SSH Client再次连接同一个（IP地址或者域名一样）SSH Server的时候，会去判断两次连接中SSH Server所在主机的Host Key是否一致，如果不一致，很有可能存在中间人攻击。</p>
<h3 id="3-4、使用“ssh-agent程序”接管“公钥私钥验证匹配计算过程”"><a href="#3-4、使用“ssh-agent程序”接管“公钥私钥验证匹配计算过程”" class="headerlink" title="3.4、使用“ssh-agent程序”接管“公钥私钥验证匹配计算过程”"></a><strong>3.4、使用“ssh-agent程序”接管“公钥私钥验证匹配计算过程”</strong></h3><p>详见<a href="/blog/2017/02/14/ssh-add%E5%91%BD%E4%BB%A4/" title="ssh-add命令">《ssh-add命令》</a>和<a href="/blog/2017/02/14/ssh-agent%E5%91%BD%E4%BB%A4/" title="ssh-agent命令">《ssh-agent命令》</a>。</p>
<h2 id="四、以下是一些实践文章的链接"><a href="#四、以下是一些实践文章的链接" class="headerlink" title="四、以下是一些实践文章的链接"></a><strong>四、以下是一些实践文章的链接</strong></h2><ul>
<li><a href="/blog/2017/02/15/%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8CSSH-Server/" title="安装运行SSH Server">《安装运行SSH Server》</a></li>
<li><a href="/blog/2017/02/15/ssh-config%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/" title="ssh_config文件配置实例">《ssh_config文件配置实例》</a></li>
<li><a href="/blog/2017/02/15/ssh%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" title="ssh应用实例">《ssh应用实例》</a></li>
<li><a href="/blog/2017/02/15/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%9C%9F%E5%AE%9E%E5%BA%94%E7%94%A8/" title="ssh端口转发真实应用">《ssh端口转发真实应用》</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/">《实战SSH端口转发[转]》</a>（备份：<a href="http://blog.csdn.net/dslztx/article/details/46654383">《实战SSH端口转发[转]》</a>）</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>PPT制作心得</title>
    <url>/blog/2021/10/16/PPT%E5%88%B6%E4%BD%9C%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>PPT是工作中必不可少的一种展现形式。</p>
<p>制作PPT的几个心得：</p>
<ul>
<li>朴素PPT可以用<code>Markdown + Marp</code>方案制作，快速高效，但不具备“自由选用模板”、“自由布局元素”等灵活性；标准PPT可以用WPS或者Microsoft PowerPoint软件制作，相对低效，但具备“自由选用模板”、“自由布局元素”等灵活性</li>
<li>配色方案，可采用三角形配色方案[1]，比如<code>红：#fc8d59；黄：#ffffbf；绿：#91cf60</code></li>
<li>没必要纠结于模板，审美因人而异，只要设计视觉统一、给人轻松舒适的感觉就好</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zhuanlan.zhihu.com/p/34954098">https://zhuanlan.zhihu.com/p/34954098</a><br>[2]<a href="https://colorbrewer2.org/#type=sequential&scheme=Greens&n=3">https://colorbrewer2.org/#type=sequential&amp;scheme=Greens&amp;n=3</a></p>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
  </entry>
  <entry>
    <title>Pager程序</title>
    <url>/blog/2015/07/05/Pager%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="一、Pager程序定义"><a href="#一、Pager程序定义" class="headerlink" title="一、Pager程序定义"></a><strong>一、Pager程序定义</strong></h2><p>Pager程序是用来分屏查看文本内容的程序。</p>
<h2 id="二、常见的Pager程序"><a href="#二、常见的Pager程序" class="headerlink" title="二、常见的Pager程序"></a><strong>二、常见的Pager程序</strong></h2><ol>
<li>more</li>
<li>less</li>
<li>pg</li>
<li>most</li>
<li>bash中的Tab自动补全列表分屏查看由bash自己实现的Pager程序提供</li>
</ol>
<h2 id="三、关于Pager程序的几个问题"><a href="#三、关于Pager程序的几个问题" class="headerlink" title="三、关于Pager程序的几个问题"></a><strong>三、关于Pager程序的几个问题</strong></h2><ul>
<li>在Ubuntu 14.04中，less的实现非常完整复杂，more程序的功能其实是由less程序提供的</li>
<li>在Ubuntu 14.04中，提供了一个pager程序（这是狭义的pager，以上的是广义的pager），而这个pager程序其实最终是链接到less程序的</li>
<li>man命令指定的输出程序是pager，即意味着在Ubuntu 14.04中，man命令指定的输出程序最终是less。那么man命令输出中可使用的快捷键就是less程序中指定的快捷键</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/Terminal_pager">https://en.wikipedia.org/wiki/Terminal_pager</a></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Quoted-Printable编码</title>
    <url>/blog/2018/04/22/Quoted-Printable%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>核心原理是：编码时，一个字节被编码为如<code>=[0-9A-F][0-9A-F]</code>形式，每个字节有两个“4位比特”，每一个“4位比特”对应一个<code>[0-9A-F]</code>字符（即对应的十六进制字符）；解码时，逆向化过程。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a><strong>二、原理</strong></h2><h3 id="2-1、编码"><a href="#2-1、编码" class="headerlink" title="2.1、编码"></a><strong>2.1、编码</strong></h3><p>当“Media-Type”类型为“text”时，编码过程面对的是字符流，首先需根据某种编码方案获取字节流，编码方案比如有ASCII，GBK，UTF-8等；当“Media-Type”类型为“非text”时，编码过程面对的是字节流，无需额外操作。<br>接下来的描述中，以十六进制值形式代表字节。</p>
<h4 id="2-1-1、编码规则"><a href="#2-1-1、编码规则" class="headerlink" title="2.1.1、编码规则"></a><strong>2.1.1、编码规则</strong></h4><h5 id="2-1-1-1、规则1"><a href="#2-1-1-1、规则1" class="headerlink" title="2.1.1.1、规则1"></a><strong>2.1.1.1、规则1</strong></h5><p>编码时，一个字节被编码为如<code>=[0-9A-F][0-9A-F]</code>形式，每个字节有两个“4位比特”，每一个“4位比特”对应一个<code>[0-9A-F]</code>字符（即对应的十六进制字符）。<br><strong>实验：</strong></p>
<table>
<thead>
<tr>
<th>字节流</th>
<th>编码后结果字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0x01,0x09,0x0D,0x0A,0x1F,0x20,0x21,0x22,0x3D,0x40,0x41,0x7F</td>
<td><code>=01=09=0D=0A=1F=20=21=22=3D=40=41=7F</code></td>
</tr>
</tbody></table>
<p>备注：<br>“规则1”是默认编码规则，未在“规则2-6”中指明的情形都要按照“规则1”进行编码。</p>
<h5 id="2-1-1-2、规则2"><a href="#2-1-1-2、规则2" class="headerlink" title="2.1.1.2、规则2"></a><strong>2.1.1.2、规则2</strong></h5><p>位于“0x21-0x3C”和“0x3E-0x7E”范围之内的字节不按照“规则1”进行编码，而以对应的ASCII字符（此时的ASCII字符都属于“可打印字符”）作为编码后结果字符。<br><strong>实验：</strong></p>
<table>
<thead>
<tr>
<th>字节流</th>
<th>编码后结果字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0x01,0x09,0x0D,0x0A,0x1F,0x20,0x21,0x22,0x3D,0x40,0x41,0x7F</td>
<td><code>=01=09=0D=0A=1F=20!"=3D@A=7F</code></td>
</tr>
</tbody></table>
<h5 id="2-1-1-3、规则3"><a href="#2-1-1-3、规则3" class="headerlink" title="2.1.1.3、规则3"></a><strong>2.1.1.3、规则3</strong></h5><p>“0x09”和“0x20”这两个字节一般以对应的ASCII字符（“0x09”对应“TAB”字符，“0x20”对应“空格”字符）作为编码后结果字符，但当上述的编码后结果字符最终会位于编码后结果字符串的末尾时，这两个字节必须按照“规则1”进行编码。<br><strong>实验：</strong><br>参见“规则5”下实验。</p>
<h5 id="2-1-1-4、规则4"><a href="#2-1-1-4、规则4" class="headerlink" title="2.1.1.4、规则4"></a><strong>2.1.1.4、规则4</strong></h5><p>编码后结果字符串需经过一系列中间处理设备，为了更好的健壮性，推荐对于如下字节集合中的字节按照“规则1”进行编码，而不是遵循“规则2”：<br>字节集合：<code>0x21,0x22,0x23,0x24,0x40,0x5B,0x5C,0x5D,0x5E,0x60,0x7B,0x7C,0x7D,0x7E</code><br>与上面字节集合一一对应的ASCII字符集合：<code>!,",#,$,@,[,,],^,`,&#123;,|,&#125;,~</code><br><strong>实验：</strong></p>
<table>
<thead>
<tr>
<th>字节流</th>
<th>编码后结果字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0x01,0x09,0x0D,0x0A,0x1F,0x20,0x21,0x22,0x3D,0x40,0x41,0x7F</td>
<td><code>=01=09=0D=0A=1F=20=21=22=3D=40A=7F</code></td>
</tr>
</tbody></table>
<h5 id="2-1-1-5、规则5"><a href="#2-1-1-5、规则5" class="headerlink" title="2.1.1.5、规则5"></a><strong>2.1.1.5、规则5</strong></h5><p>编码后结果字符串的长度需要满足“小于等于76”，可使用单独的“&#x3D;”字符进行分割，此时的“&#x3D;”字符被称为“软换行符”。<br><strong>实验：</strong></p>
<table>
<thead>
<tr>
<th>字节流</th>
<th>编码后结果字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,<br/>0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,<br/>0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,<br/>0x75,0x76,0x77,0x78,0x79,0x7A,0x20,0x41,0x42,0x43,<br/>0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,<br/>0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,<br/>0x58,0x59,0x5A,0x30,0x31,0x32,0x33,0x34,0x35,0x36,<br/>0x37,0x38,0x39,0x61,0x62,0x20</td>
<td><code>0123456789abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789=<br/>ab=20</code></td>
</tr>
</tbody></table>
<p>备注：<br>上述实验中的字节流在实际实验中并没有换行，这里只是为了展示方便而进行了换行。</p>
<h5 id="2-1-1-6、规则6"><a href="#2-1-1-6、规则6" class="headerlink" title="2.1.1.6、规则6"></a><strong>2.1.1.6、规则6</strong></h5><p>有这样的一个基本背景：RFC2045规范针对“邮件”应用场景，一封“邮件”需要经过一系列中间处理设备，不同设备对“换行符”的定义不尽相同，因此，原始的“CRLF”字符对最后可能被转换成“CR”或者“LF”单个字符。<br>有如下具体规则：</p>
<ol>
<li>当邮件的“Media-Type”类型为“text”时，编码过程面对的是“字符流”，以字符流中的“CRLF”字符对为分界符进行分段，对每段字符流先获取字节流，再按照“规则1-5”进行编码</li>
<li>当邮件的“Media-Type”类型为“非text”时，编码过程面对的是“字节流”，无需特殊处理“0x0D,0x0A”字节对（与之相应的ASCII字符对即为“CRLF”），直接按照“规则1-5”进行编码</li>
</ol>
<p>具体原因如下：</p>
<ol>
<li>当邮件的“Media-Type”类型为“text”时，保留“CRLF”字符对可以减小编码后结果字符串的长度，减少传输内容，而且即便“CRLF”字符对最后被转换成“CR”或者“LF”单个字符也没有丢失有意义的数据</li>
<li>当邮件的“Media-Type”类型为“非text”时，如果特殊处理“0x0D,0x0A”字节对，将其编码成“CRLF”字符对，那么当“CRLF”字符对最后被转换成“CR”或者“LF”单个字符时，就会丢失有意义的数据</li>
</ol>
<h4 id="2-1-2、合法编码后结果字符串描述"><a href="#2-1-2、合法编码后结果字符串描述" class="headerlink" title="2.1.2、合法编码后结果字符串描述"></a><strong>2.1.2、合法编码后结果字符串描述</strong></h4><p><font color='red'>quoted-printable</font>&#x3D;<font color='red'>qp-line</font>*((<font color='red'>CRLF</font>)(<font color='red'>qp-line</font>))<br><font color='red'>qp-line</font>&#x3D;*((<font color='red'>qp-segment</font>)(<font color='red'>transport-padding</font>)(<font color='red'>CRLF</font>))(<font color='red'>qp-part</font>)(<font color='red'>transport-padding</font>)<br><font color='red'>qp-segment</font>&#x3D;(<font color='red'>qp-section</font>)*(<font color='red'>SPACE</font>&#x2F;<font color='red'>TAB</font>)”&#x3D;”  ;小于等于76个字符<br><font color='red'>qp-section</font>&#x3D;[*(<font color='red'>ptext</font>&#x2F;<font color='red'>SPACE</font>&#x2F;<font color='red'>TAB</font>)<font color='red'>ptext</font>]<br><font color='red'>ptext</font>&#x3D;<font color='red'>hex-octet</font>&#x2F;<font color='red'>safe-char</font><br><font color='red'>hex-octet</font>&#x3D;”&#x3D;”2(<font color='red'>DIGIT</font>&#x2F;“A”&#x2F;“B”&#x2F;“C”&#x2F;“D”&#x2F;“E”&#x2F;“F”)<br><font color='red'>safe-char</font>&#x3D;&lt; ASCII表中字符，<font color='red'>对应“规则2”，十六进制值范围为“0x21-0x3C”和“0x3E-0x7E”，对应“规则4”，再额外排除<code>!"#$@[\]^&#96;&#123;|&#125;~</code>字符集合</font> &gt;<br><font color='red'>transport-padding</font>&#x3D;*<font color='red'>LWSP-char</font><br><font color='red'>qp-part</font>&#x3D;<font color='red'>qp-section</font>  ;小于等于76个字符</p>
<h3 id="2-2、解码"><a href="#2-2、解码" class="headerlink" title="2.2、解码"></a><strong>2.2、解码</strong></h3><p>编码过程的逆向化过程。</p>
<br/>
参考文献：
[1]http://www.rfc-editor.org/rfc/rfc2045.txt
]]></content>
      <categories>
        <category>协议规范</category>
        <category>邮件解析</category>
      </categories>
  </entry>
  <entry>
    <title>RFC822</title>
    <url>/blog/2016/12/15/RFC822/</url>
    <content><![CDATA[<p>RFC822（Standard for ARPA Internet Text Messages）基于RFC733（Standard for the Format of ARPA Network Text Messages）。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、介绍</strong></h2><p>一封“消息（Message）”包括“信封（Envelope）”和“内容（Content）”，一般情况下，“信封（Envelope）”基于“内容（Content）”而生成。本文档只关注“内容（Content）”，而不涉及“信封（Envelope）”。<br><font color='red'>接下来如果未做特殊说明，“消息（Message）”就是指“内容（Content）”。</font><br><font color='red'>本文只约定“消息（Message）”在传输过程中的格式规范</font>，而不对“消息的存储格式”，“消息处理系统特征”，“消息处理系统用户接口特征”等作出限定。<br>“消息（Message）”只包含纯文本内容，而不包含其他多媒体形式内容，如图片，音频，视频等。数据压缩，传输存储效率等细节都不作考虑和限定。</p>
<h2 id="二、扩展的BNF"><a href="#二、扩展的BNF" class="headerlink" title="二、扩展的BNF"></a><strong>二、扩展的BNF</strong></h2><h3 id="2-1、“或者”符号"><a href="#2-1、“或者”符号" class="headerlink" title="2.1、“或者”符号"></a><strong>2.1、“或者”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a/b</span><br></pre></td></tr></table></figure>
<p><code>hello/world</code>匹配“hello”或者“world”。</p>
<h3 id="2-2、“整体”符号"><a href="#2-2、“整体”符号" class="headerlink" title="2.2、“整体”符号"></a><strong>2.2、“整体”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a b)</span><br></pre></td></tr></table></figure>
<p><code>(hello world)</code>匹配“hello world”。</p>
<h3 id="2-3、“重复”符号"><a href="#2-3、“重复”符号" class="headerlink" title="2.3、“重复”符号"></a><strong>2.3、“重复”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;l&gt;*&lt;m&gt;a</span><br></pre></td></tr></table></figure>
<p><code>1*5a</code>匹配“1-5个a”，<code>*a</code>匹配“0到无穷个a”，<code>1*a</code>匹配“1到无穷个a”，<code>*10</code>匹配“0到10个a”。</p>
<h3 id="2-4、“可选”符号"><a href="#2-4、“可选”符号" class="headerlink" title="2.4、“可选”符号"></a><strong>2.4、“可选”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a]</span><br></pre></td></tr></table></figure>
<p><code>[hello]</code>匹配“存在一个hello字符串”或者“不存在hello字符串”。</p>
<h3 id="2-5、“重复特定次数”符号"><a href="#2-5、“重复特定次数”符号" class="headerlink" title="2.5、“重复特定次数”符号"></a><strong>2.5、“重复特定次数”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;n&gt;a</span><br></pre></td></tr></table></figure>
<p>等价于<code>&lt;n&gt;*&lt;n&gt;a</code>。<code>1a</code>匹配“a”，<code>2a</code>匹配“aa”。</p>
<h3 id="2-6、“列表”符号"><a href="#2-6、“列表”符号" class="headerlink" title="2.6、“列表”符号"></a><strong>2.6、“列表”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;l&gt;#&lt;m&gt;a</span><br></pre></td></tr></table></figure>
<p><code>1#5a</code>匹配“1-5个a，a之间至少以1个逗号隔开”，<code>#a</code>匹配“0到无穷个a，a之间至少以1个逗号隔开”，<code>1#a</code>匹配“1到无穷个a，a之间至少以1个逗号隔开”，<code>#10a</code>匹配“0到10个a，a之间至少以1个逗号隔开”。</p>
<h3 id="2-7、“注释”符号"><a href="#2-7、“注释”符号" class="headerlink" title="2.7、“注释”符号"></a><strong>2.7、“注释”符号</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;a</span><br></pre></td></tr></table></figure>
<p><code>;hello</code>表示“hello”是注释字符串。</p>
<h2 id="三、消息（Message）的词法分析"><a href="#三、消息（Message）的词法分析" class="headerlink" title="三、消息（Message）的词法分析"></a><strong>三、消息（Message）的词法分析</strong></h2><h3 id="3-1、一般描述"><a href="#3-1、一般描述" class="headerlink" title="3.1、一般描述"></a><strong>3.1、一般描述</strong></h3><p>“消息（Message）”由“至少一个消息头字段（Header-Field）”和“可选的消息体（Body）”组成，中间以一个“空行”隔开。即：<br><font color='red'>Message</font>&#x3D;(1*(<font color='red'>Header-Field</font>))(<font color='red'>CRLF</font>)[<font color='red'>Body</font>]</p>
<h3 id="3-2、消息头字段（Header-Field）"><a href="#3-2、消息头字段（Header-Field）" class="headerlink" title="3.2、消息头字段（Header-Field）"></a><strong>3.2、消息头字段（Header-Field）</strong></h3><p>“消息头字段（Header-Field）”由“消息头字段名称（Field-Name）”和“可选的消息头字段体（Field-Body）”组成。即：<br><font color='red'>Header-Field</font>&#x3D;(<font color='red'>Field-Name</font>)”:”&#91;<font color='red'>Field-Body</font>&#93;(<font color='red'>CRLF</font>)<br><font color='red'>Field-Name</font>&#x3D;1*&lt; 由ASCII表中可打印字符组成（32-126），除了32（SPACE）和58（:） &gt;<br><font color='red'>Field-Body</font>&#x3D;&lt; <font color='red'>text</font> &gt;</p>
<h4 id="3-2-1、消息头字段（Header-Field）之分类"><a href="#3-2-1、消息头字段（Header-Field）之分类" class="headerlink" title="3.2.1、消息头字段（Header-Field）之分类"></a><strong>3.2.1、消息头字段（Header-Field）之分类</strong></h4><p>消息头字段（Header-Field）分为两类：“非结构化消息头字段”和“结构化消息头字段”。“结构化”类别跟“非结构化”类别相比，唯一的区别在于：前者的消息头字段体（Field-Body）可被解析为“<font color='red'>specials</font>，<font color='red'>quoted-string</font>，<font color='red'>domain-literal</font>，<font color='red'>comment</font>，<font color='red'>atom</font>”这5种组成成分。</p>
<h4 id="3-2-2、消息头字段（Header-Field）之折叠和展开"><a href="#3-2-2、消息头字段（Header-Field）之折叠和展开" class="headerlink" title="3.2.2、消息头字段（Header-Field）之折叠和展开"></a><strong>3.2.2、消息头字段（Header-Field）之折叠和展开</strong></h4><p><strong>1、折叠（Fold）</strong><br>为了可读性，消息头字段（Header-Field）的消息头字段体（Field-Body）可被“折叠”，具体规则如下：<br>使用(<font color='red'>CRLF</font>)(1*(<font color='red'>LWSP-char</font>))替换<font color='red'>linear-white-space</font>，由“3.2、消息头字段（Header-Field）”中的“<font color='red'>Field-Body</font>”的定义可知，此时的“<font color='red'>linear-white-space</font>”事实上等价于“1*(<font color='red'>LWSP-char</font>)”。<br><strong>2、展开（Unfold）</strong><br>消息头字段（Header-Field）的消息头字段体（Field-Body）中“折叠”的逆过程为“展开”，具体规则如下：<br>使用1(<font color='red'>LWSP-char</font>)替换(<font color='red'>CRLF</font>)(1(<font color='red'>LWSP-char</font>))。</p>
<h4 id="3-2-3、消息头字段（Header-Field）的消息头字段体（Field-Body）中的LWSP-char"><a href="#3-2-3、消息头字段（Header-Field）的消息头字段体（Field-Body）中的LWSP-char" class="headerlink" title="3.2.3、消息头字段（Header-Field）的消息头字段体（Field-Body）中的LWSP-char"></a><strong>3.2.3、消息头字段（Header-Field）的消息头字段体（Field-Body）中的<font color='red'>LWSP-char</font></strong></h4><p>消息头字段（Header-Field）的消息头字段体（Field-Body）中的<font color='red'>LWSP-char</font>没有任何意义，可被任意添加或者删减（除了<font color='red'>CRLF</font>后的<font color='red'>LWSP-char</font>不能被删除，因为这是“折叠”得到的）。<br>另外，有些地方规定只能有一个<font color='red'>LWSP-char</font>。</p>
<h3 id="3-3、消息体（Body）"><a href="#3-3、消息体（Body）" class="headerlink" title="3.3、消息体（Body）"></a><strong>3.3、消息体（Body）</strong></h3><p><font color='red'>Body</font>&#x3D;&lt; 由ASCII表中所有字符组成的字符串 &gt;</p>
<h3 id="3-4、词法分析记号"><a href="#3-4、词法分析记号" class="headerlink" title="3.4、词法分析记号"></a><strong>3.4、词法分析记号</strong></h3><table>
<thead>
<tr>
<th>记号</th>
<th>表示含义</th>
</tr>
</thead>
<tbody><tr>
<td><font color='red'>CHAR</font></td>
<td>&lt; ASCII表中任意字符，十进制范围0-127 &gt;</td>
</tr>
<tr>
<td><font color='red'>ALPHA</font></td>
<td>&lt; ASCII表中任意拉丁字符，十进制范围65-90&amp;97-122 &gt;</td>
</tr>
<tr>
<td><font color='red'>DIGIT</font></td>
<td>&lt; ASCII表中任意数字字符，十进制范围48-57 &gt;</td>
</tr>
<tr>
<td><font color='red'>CTL</font></td>
<td>&lt; ASCII表中控制字符和DEL字符，即“不可打印字符”，十进制范围0-31&amp;127 &gt;</td>
</tr>
<tr>
<td><font color='red'>CR</font></td>
<td>&lt; ASCII表中CR字符，十进制值为13 &gt;</td>
</tr>
<tr>
<td><font color='red'>LF</font></td>
<td>&lt; ASCII表中LF字符，十进制值为10 &gt;</td>
</tr>
<tr>
<td><font color='red'>SPACE</font></td>
<td>&lt; ASCII表中SPACE字符，十进制值为32 &gt;</td>
</tr>
<tr>
<td><font color='red'>HTAB</font></td>
<td>&lt; ASCII表中TAB字符，十进制值为9 &gt;</td>
</tr>
<tr>
<td><font color='red'>&lt;&#34;&gt;</font></td>
<td>&lt; ASCII表中双引号字符，十进制值为34 &gt;</td>
</tr>
<tr>
<td><font color='red'>CRLF</font></td>
<td>(<font color='red'>CR</font>)(<font color='red'>LF</font>)</td>
</tr>
<tr>
<td><font color='red'>LWSP-char</font></td>
<td><font color='red'>SPACE</font>&#x2F;<font color='red'>HTAB</font></td>
</tr>
<tr>
<td><font color='red'>linear-white-space</font></td>
<td>1*([<font color='red'>CRLF</font>]<font color='red'>LWSP-char</font>)</td>
</tr>
<tr>
<td><font color='red'>specials</font></td>
<td>“(“&#x2F;“)”&#x2F;“&lt;”&#x2F;“&gt;”&#x2F;“&#64;”&#x2F;“,”&#x2F;“;”&#x2F;“:”&#x2F;“\“&#x2F;<font color='red'>&lt;&#34;&gt;</font>&#x2F;“.”&#x2F;“[“&#x2F;“]”</td>
</tr>
<tr>
<td><font color='red'>delimiters</font></td>
<td><font color='red'>specials</font>&#x2F;<font color='red'>linear-white-space</font>&#x2F;<font color='red'>comment</font></td>
</tr>
<tr>
<td><font color='red'>text</font></td>
<td>&lt; 由任意ASCII表中字符（包括CR，LF）构成的字符串，除了CRLF &gt;</td>
</tr>
<tr>
<td><font color='red'>atom</font></td>
<td>&lt; 1*(任意ASCII表中字符，除了<font color='red'>specials</font>，<font color='red'>SPACE</font>，<font color='red'>CTL</font>) &gt;</td>
</tr>
<tr>
<td><font color='red'>quoted-string</font></td>
<td><font color='red'>&lt;&#34;&gt;</font>*(<font color='red'>qtext</font>&#x2F;<font color='red'>quoted-pair</font>)<font color='red'>&lt;&#34;&gt;</font></td>
</tr>
<tr>
<td><font color='red'>qtext</font></td>
<td>&lt; 由任意ASCII表中字符（除了<font color='red'>&lt;&#34;&gt;</font>，”\“和<font color='red'>CR</font>）构成的字符串，包括<font color='red'>linear-white-space</font> &gt;</td>
</tr>
<tr>
<td><font color='red'>domain-literal</font></td>
<td>“[“*(<font color='red'>dtext</font>&#x2F;<font color='red'>quoted-pair</font>)”]”</td>
</tr>
<tr>
<td><font color='red'>dtext</font></td>
<td>&lt; 由任意ASCII表中字符（除了”[“，”]”，”\“和<font color='red'>CR</font>）构成的字符串，包括<font color='red'>linear-white-space</font> &gt;</td>
</tr>
<tr>
<td><font color='red'>comment</font></td>
<td>“(“*(<font color='red'>ctext</font>&#x2F;<font color='red'>quoted-pair</font>&#x2F;<font color='red'>comment</font>)”)”</td>
</tr>
<tr>
<td><font color='red'>ctext</font></td>
<td>&lt; 由任意ASCII表中字符（除了”(“，”)”，”\“和<font color='red'>CR</font>）构成的字符串，包括<font color='red'>linear-white-space</font> &gt;</td>
</tr>
<tr>
<td><font color='red'>quoted-pair</font></td>
<td>“\“<font color='red'>CHAR</font></td>
</tr>
<tr>
<td><font color='red'>phrase</font></td>
<td>1*(<font color='red'>word</font>)</td>
</tr>
<tr>
<td><font color='red'>word</font></td>
<td><font color='red'>atom</font>&#x2F;<font color='red'>quoted-string</font></td>
</tr>
</tbody></table>
<p>备注：<br>1、当消息被传递给一个不遵循本协议的消息处理系统时，<font color='red'>comment</font>被替换成一个<font color='red'>SPACE</font><br>2、一般不区分大小写，除了以下这些词法单元：<font color='red'>text</font>，<font color='red'>qtext</font>，<font color='red'>dtext</font>，<font color='red'>ctext</font>，<font color='red'>quoted-pair</font>，<font color='red'>local-part</font>（其中的“Postmaster”作为特殊保留地址，不区分大小写）</p>
<h2 id="四、消息（Message）的详细规范"><a href="#四、消息（Message）的详细规范" class="headerlink" title="四、消息（Message）的详细规范"></a><strong>四、消息（Message）的详细规范</strong></h2><h3 id="4-1、详细规范"><a href="#4-1、详细规范" class="headerlink" title="4.1、详细规范"></a><strong>4.1、详细规范</strong></h3><p><font color='red'>Message</font>&#x3D;(1*(<font color='red'>Header-Field</font>))(<font color='red'>CRLF</font>)[<font color='red'>Body</font>]或者说<font color='red'>Message</font>&#x3D;(<font color='red'>fields</font>)(<font color='red'>CRLF</font>)[<font color='red'>Body</font>]<br><font color='red'>fields</font>&#x3D;(<font color='red'>dates</font>)(<font color='red'>source</font>)(1*<font color='red'>destination</font>)(*<font color='red'>optional-field</font>)</p>
<h4 id="4-1-1、dates"><a href="#4-1-1、dates" class="headerlink" title="4.1.1、dates"></a><strong>4.1.1、dates</strong></h4><p><font color='red'>dates</font>&#x3D;<font color='red'>orig-date</font>[<font color='red'>resent-date</font>]<br><font color='red'>orig-date</font>&#x3D;”Date””:”<font color='red'>date-time</font>(<font color='red'>CRLF</font>)<br><font color='red'>resent-date</font>&#x3D;”Resent-Date””:”<font color='red'>date-time</font>(<font color='red'>CRLF</font>)</p>
<h4 id="4-1-2、source"><a href="#4-1-2、source" class="headerlink" title="4.1.2、source"></a><strong>4.1.2、source</strong></h4><p><font color='red'>source</font>&#x3D;[<font color='red'>trace</font>]<font color='red'>originator</font>[<font color='red'>resent</font>]<br><font color='red'>trace</font>&#x3D;(<font color='red'>return</font>)(1*<font color='red'>received</font>)<br><font color='red'>return</font>&#x3D;”Return-path””:”<font color='red'>route-addr</font>(<font color='red'>CRLF</font>)<br><font color='red'>received</font>&#x3D;”Received””:”[“from”<font color='red'>domain</font>][“by”<font color='red'>domain</font>][“via”<font color='red'>atom</font>]&#40;*(“with”<font color='red'>atom</font>)&#41;[“id”<font color='red'>msg-id</font>][“for”<font color='red'>addr-spec</font>]”;”<font color='red'>date-time</font>(<font color='red'>CRLF</font>)<br><font color='red'>msg-id</font>&#x3D;”&lt;”<font color='red'>addr-spec</font>“&gt;”<br><font color='red'>originator</font>&#x3D;<font color='red'>authentic</font>[“Reply-To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)]<br><font color='red'>authentic</font>&#x3D;”From””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)&#x2F;(“Sender””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)”From””:”(1#<font color='red'>mailbox</font>)(<font color='red'>CRLF</font>))<br><font color='red'>resent</font>&#x3D;<font color='red'>resent-authentic</font>[“Resent-Reply-To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)]<br><font color='red'>resent-authentic</font>&#x3D;”Resent-From””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)&#x2F;(“Resent-Sender””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)”Resent-From””:”(1#<font color='red'>mailbox</font>)(<font color='red'>CRLF</font>))</p>
<h4 id="4-1-3、destination"><a href="#4-1-3、destination" class="headerlink" title="4.1.3、destination"></a><strong>4.1.3、destination</strong></h4><p><font color='red'>destination</font>&#x3D;”To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“cc””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-cc””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“bcc””:”(#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-bcc””:”(#<font color='red'>address</font>)(<font color='red'>CRLF</font>)</p>
<h4 id="4-1-4、optional-field"><a href="#4-1-4、optional-field" class="headerlink" title="4.1.4、optional-field"></a><strong>4.1.4、optional-field</strong></h4><p><font color='red'>optional-field</font>&#x3D;”Message-ID””:”<font color='red'>msg-id</font>(<font color='red'>CRLF</font>)&#x2F;“Resent-Message-ID””:”<font color='red'>msg-id</font>(<font color='red'>CRLF</font>)&#x2F;“In-Reply-To””:”(*(<font color='red'>phrase</font>&#x2F;<font color='red'>msg-id</font>))(<font color='red'>CRLF</font>)&#x2F;“References””:”(*(<font color='red'>phrase</font>&#x2F;<font color='red'>msg-id</font>))(<font color='red'>CRLF</font>)&#x2F;“Keywords””:”(#<font color='red'>phrase</font>)(<font color='red'>CRLF</font>)&#x2F;“Subject””:”(*<font color='red'>text</font>)(<font color='red'>CRLF</font>)&#x2F;“Comments””:”(*<font color='red'>text</font>)(<font color='red'>CRLF</font>)&#x2F;“Encrypted””:”(1#2<font color='red'>word</font>)(<font color='red'>CRLF</font>)&#x2F;<font color='red'>extension-field</font>&#x2F;<font color='red'>user-defined-field</font></p>
<h5 id="4-1-4-1、extension-field"><a href="#4-1-4-1、extension-field" class="headerlink" title="4.1.4.1、extension-field"></a><strong>4.1.4.1、extension-field</strong></h5><p><font color='red'>extension-field</font>&#x3D;&lt; 扩展注册的标准消息头字段（Header-Field），规定消息头字段名称（Field-Name）不能以“X-&#x2F;x-”字符串作为前缀 &gt; </p>
<h5 id="4-1-4-2、user-defined-field"><a href="#4-1-4-2、user-defined-field" class="headerlink" title="4.1.4.2、user-defined-field"></a><strong>4.1.4.2、user-defined-field</strong></h5><p><font color='red'>user-defined-field</font>&#x3D;&lt; 用户自定义完全私有的消息头字段（Header-Field），为了避免冲突，消息头字段名称（Field-Name）一般以“X-&#x2F;x-”字符串作为前缀 &gt;</p>
<h3 id="4-2、转发"><a href="#4-2、转发" class="headerlink" title="4.2、转发"></a><strong>4.2、转发</strong></h3><p>转发消息时会在不改变原有消息头字段（Header-Field）的基础上，增加一些以“Resent-”字符串作为前缀的消息头字段（Header-Field），这些消息头字段（Header-Field）的含义跟去掉“Resent-”字符串前缀对应的消息头字段（Header-Field）一致。</p>
<h3 id="4-3、再细化"><a href="#4-3、再细化" class="headerlink" title="4.3、再细化"></a><strong>4.3、再细化</strong></h3><h4 id="4-3-1、“Trace”族消息头字段"><a href="#4-3-1、“Trace”族消息头字段" class="headerlink" title="4.3.1、“Trace”族消息头字段"></a><strong>4.3.1、“Trace”族消息头字段</strong></h4><p>“Trace”族消息头字段主要由消息投递环节各个设备（除了发件人设备s）添加，用于记录路由信息。定义如下：<br><font color='red'>source</font>&#x3D;[<font color='red'>trace</font>]<font color='red'>originator</font>[<font color='red'>resent</font>]<br><font color='red'>trace</font>&#x3D;(<font color='red'>return</font>)(1*<font color='red'>received</font>)<br><font color='red'>return</font>&#x3D;”Return-path””:”<font color='red'>route-addr</font>(<font color='red'>CRLF</font>)<br><font color='red'>received</font>&#x3D;”Received””:”[“from”<font color='red'>domain</font>][“by”<font color='red'>domain</font>][“via”<font color='red'>atom</font>]&#40;*(“with”<font color='red'>atom</font>)&#41;[“id”<font color='red'>msg-id</font>][“for”<font color='red'>addr-spec</font>]”;”<font color='red'>date-time</font>(<font color='red'>CRLF</font>)<br><font color='red'>msg-id</font>&#x3D;”&lt;”<font color='red'>addr-spec</font>“&gt;”</p>
<h5 id="4-3-1-1、“Return-Path”消息头字段"><a href="#4-3-1-1、“Return-Path”消息头字段" class="headerlink" title="4.3.1.1、“Return-Path”消息头字段"></a><strong>4.3.1.1、“Return-Path”消息头字段</strong></h5><p>该消息头字段由消息投递环节最后一个设备（收件人设备e）添加，给出了确切地指向发件人的路由信息。类似的“Reply-To”消息头字段由发件人设备s添加，显式指定回复消息的接收者。<br>比如如下“Return-Path”字段值表示：消息反向依次经历“domain1，domain2，…，domainN”设备，消息发件人为“<a href="mailto:&#x64;&#x73;&#108;&#x7a;&#x74;&#120;&#64;&#100;&#x6f;&#109;&#97;&#105;&#110;&#46;&#x63;&#110;">&#x64;&#x73;&#108;&#x7a;&#x74;&#120;&#64;&#100;&#x6f;&#109;&#97;&#105;&#110;&#46;&#x63;&#110;</a>”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@domain1,@domain2,...,@domainN:dslztx@domain.cn</span><br></pre></td></tr></table></figure>
<h5 id="4-3-1-2、“Received”消息头字段"><a href="#4-3-1-2、“Received”消息头字段" class="headerlink" title="4.3.1.2、“Received”消息头字段"></a><strong>4.3.1.2、“Received”消息头字段</strong></h5><p>该消息头字段由消息投递环节的各个设备添加（除了发件人设备s），用于记录消息在两个设备间的传递过程。<br>“from”：来源设备的IP地址、域名或主机名。<br>“by”：当前设备的IP地址、域名或主机名。<br>“via”：使用的物理传输路径，比如“Arpanet”、“Phonenet”等，具体值在“Network Information Center”中注册。<br>“with”：使用的传输协议，比如“SMTP”、“ESMTP”、“X.25”等，具体值在“Network Information Center”中注册。<br>“id”：消息在当前设备中的唯一序列号。<br>“for”：消息的收件人地址（“原始形式”，在消息投递环节中，消息的收件人地址有可能被各个设备转变成各种扩展形式，比如“缩写形式”）。<br>紧随其后的时间戳是当前设备接收该消息的时间。</p>
<h4 id="4-3-2、“Originator”族消息头字段"><a href="#4-3-2、“Originator”族消息头字段" class="headerlink" title="4.3.2、“Originator”族消息头字段"></a><strong>4.3.2、“Originator”族消息头字段</strong></h4><p>“Originator”族消息头字段主要用于记录消息的发件人，也可用于显式指定回复消息的接收者。定义如下：<br><font color='red'>originator</font>&#x3D;<font color='red'>authentic</font>[“Reply-To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)]<br><font color='red'>authentic</font>&#x3D;”From””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)&#x2F;(“Sender””:”<font color='red'>mailbox</font>(<font color='red'>CRLF</font>)”From””:”(1#<font color='red'>mailbox</font>)(<font color='red'>CRLF</font>))</p>
<h5 id="4-3-2-1、“From-Resent-From”消息头字段"><a href="#4-3-2-1、“From-Resent-From”消息头字段" class="headerlink" title="4.3.2.1、“From&#x2F;Resent-From”消息头字段"></a><strong>4.3.2.1、“From&#x2F;Resent-From”消息头字段</strong></h5><p>消息的作者。比如“张三（From）”写了一封消息，交给“李四（Sender）”去发送，但是希望由“王五（Reply-To）”接收回复消息。</p>
<h5 id="4-3-2-2、“Sender-Resent-Sender”消息头字段"><a href="#4-3-2-2、“Sender-Resent-Sender”消息头字段" class="headerlink" title="4.3.2.2、“Sender&#x2F;Resent-Sender”消息头字段"></a><strong>4.3.2.2、“Sender&#x2F;Resent-Sender”消息头字段</strong></h5><p>消息的发送者。比如“张三（From）”写了一封消息，交给“李四（Sender）”去发送，但是希望由“王五（Reply-To）”接收回复消息。</p>
<h5 id="4-3-2-3、“Reply-To-Resent-Reply-To”消息头字段"><a href="#4-3-2-3、“Reply-To-Resent-Reply-To”消息头字段" class="headerlink" title="4.3.2.3、“Reply-To&#x2F;Resent-Reply-To”消息头字段"></a><strong>4.3.2.3、“Reply-To&#x2F;Resent-Reply-To”消息头字段</strong></h5><p>回复消息的接收者。比如“张三（From）”写了一封消息，交给“李四（Sender）”去发送，但是希望由“王五（Reply-To）”接收回复消息。</p>
<h4 id="4-3-3、“Destination”族消息头字段"><a href="#4-3-3、“Destination”族消息头字段" class="headerlink" title="4.3.3、“Destination”族消息头字段"></a><strong>4.3.3、“Destination”族消息头字段</strong></h4><p>“Destination”族消息头字段主要用于记录消息的收件人，可以指定多个。定义如下：<br><font color='red'>destination</font>&#x3D;”To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-To””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“cc””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-cc””:”(1#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“bcc””:”(#<font color='red'>address</font>)(<font color='red'>CRLF</font>)&#x2F;“Resent-bcc””:”(#<font color='red'>address</font>)(<font color='red'>CRLF</font>)</p>
<h5 id="4-3-3-1、“To-Resent-To”消息头字段"><a href="#4-3-3-1、“To-Resent-To”消息头字段" class="headerlink" title="4.3.3.1、“To&#x2F;Resent-To”消息头字段"></a><strong>4.3.3.1、“To&#x2F;Resent-To”消息头字段</strong></h5><p>消息的收件人。</p>
<h5 id="4-3-3-2、“Cc-Resent-Cc”消息头字段"><a href="#4-3-3-2、“Cc-Resent-Cc”消息头字段" class="headerlink" title="4.3.3.2、“Cc&#x2F;Resent-Cc”消息头字段"></a><strong>4.3.3.2、“Cc&#x2F;Resent-Cc”消息头字段</strong></h5><p>消息的抄送收件人。</p>
<h5 id="4-3-3-3、“Bcc-Resent-Bcc”消息头字段"><a href="#4-3-3-3、“Bcc-Resent-Bcc”消息头字段" class="headerlink" title="4.3.3.3、“Bcc&#x2F;Resent-Bcc”消息头字段"></a><strong>4.3.3.3、“Bcc&#x2F;Resent-Bcc”消息头字段</strong></h5><p>消息的密送收件人。密送收件人信息不会被任何收件人（包括“收件人”，“抄送收件人”和“密送收件人”）看到。</p>
<h4 id="4-3-4、“Optional”族消息头字段"><a href="#4-3-4、“Optional”族消息头字段" class="headerlink" title="4.3.4、“Optional”族消息头字段"></a><strong>4.3.4、“Optional”族消息头字段</strong></h4><p>“Optional”族消息头字段包括一些可选的消息头字段。</p>
<h5 id="4-3-4-1、“Message-ID-Resent-Message-ID”消息头字段"><a href="#4-3-4-1、“Message-ID-Resent-Message-ID”消息头字段" class="headerlink" title="4.3.4.1、“Message-ID&#x2F;Resent-Message-ID”消息头字段"></a><strong>4.3.4.1、“Message-ID&#x2F;Resent-Message-ID”消息头字段</strong></h5><p>用于记录在发件人设备s中该消息的唯一序列号。</p>
<h5 id="4-3-4-2、“In-Reply-To”消息头字段"><a href="#4-3-4-2、“In-Reply-To”消息头字段" class="headerlink" title="4.3.4.2、“In-Reply-To”消息头字段"></a><strong>4.3.4.2、“In-Reply-To”消息头字段</strong></h5><p>记录本消息（本消息是回复消息）所回复一系列消息的“Message-ID”值。</p>
<h5 id="4-3-4-3、“References”消息头字段"><a href="#4-3-4-3、“References”消息头字段" class="headerlink" title="4.3.4.3、“References”消息头字段"></a><strong>4.3.4.3、“References”消息头字段</strong></h5><p>记录本消息涉及到的一系列消息的“Message-ID”值。</p>
<h5 id="4-3-4-4、“Keywords”消息头字段"><a href="#4-3-4-4、“Keywords”消息头字段" class="headerlink" title="4.3.4.4、“Keywords”消息头字段"></a><strong>4.3.4.4、“Keywords”消息头字段</strong></h5><p>由逗号隔开的消息的关键词。</p>
<h5 id="4-3-4-5、“Subject”消息头字段"><a href="#4-3-4-5、“Subject”消息头字段" class="headerlink" title="4.3.4.5、“Subject”消息头字段"></a><strong>4.3.4.5、“Subject”消息头字段</strong></h5><p>消息的主题。</p>
<h5 id="4-3-4-6、“Comments”消息头字段"><a href="#4-3-4-6、“Comments”消息头字段" class="headerlink" title="4.3.4.6、“Comments”消息头字段"></a><strong>4.3.4.6、“Comments”消息头字段</strong></h5><p>消息的注释。</p>
<h5 id="4-3-4-7、“Encrypted”消息头字段"><a href="#4-3-4-7、“Encrypted”消息头字段" class="headerlink" title="4.3.4.7、“Encrypted”消息头字段"></a><strong>4.3.4.7、“Encrypted”消息头字段</strong></h5><p>如果“消息体（Body）”是加密的，本字段记录解密需要用到的信息。<font color='red'>该字段被废弃。</font></p>
<h4 id="4-3-5、“Extension-Field”族消息头字段"><a href="#4-3-5、“Extension-Field”族消息头字段" class="headerlink" title="4.3.5、“Extension-Field”族消息头字段"></a><strong>4.3.5、“Extension-Field”族消息头字段</strong></h4><p>扩展注册的标准消息头字段（Header-Field），规定消息头字段名称（Field-Name）不以“X-&#x2F;x-”字符串作为前缀，具体消息头字段名在“Network Information Center”中注册。</p>
<h4 id="4-3-6、“User-Defined-Field”族消息头字段"><a href="#4-3-6、“User-Defined-Field”族消息头字段" class="headerlink" title="4.3.6、“User-Defined-Field”族消息头字段"></a><strong>4.3.6、“User-Defined-Field”族消息头字段</strong></h4><p>用户自定义完全私有的消息头字段（Header-Field），为了不与其他标准消息头字段（包括基本标准消息头字段和扩展标准消息头字段）冲突，消息头字段名称（Field-Name）一般以“X-&#x2F;x-”字符串作为前缀，具体消息头字段名无需在“Network Information Center”中注册。</p>
<h2 id="五、日期和时间规范"><a href="#五、日期和时间规范" class="headerlink" title="五、日期和时间规范"></a><strong>五、日期和时间规范</strong></h2><h3 id="5-1、定义"><a href="#5-1、定义" class="headerlink" title="5.1、定义"></a><strong>5.1、定义</strong></h3><p><font color='red'>date-time</font>&#x3D;&#91;<font color='red'>day</font>“,”&#93;(<font color='red'>date</font>)(<font color='red'>time</font>)<br><font color='red'>day</font>&#x3D;”Mon”&#x2F;“Tue”&#x2F;“Wed”&#x2F;“Thu”&#x2F;“Fri”&#x2F;“Sat”&#x2F;“Sun”<br><font color='red'>date</font>&#x3D;(1*2<font color='red'>DIGIT</font>)(<font color='red'>month</font>)(2<font color='red'>DIGIT</font>)<br><font color='red'>month</font>&#x3D;”Jan”&#x2F;“Feb”&#x2F;“Mar”&#x2F;“Apr”&#x2F;“May”&#x2F;“Jun”&#x2F;“Jul”&#x2F;“Aug”&#x2F;“Sep”&#x2F;“Oct”&#x2F;“Nov”&#x2F;“Dec”<br><font color='red'>time</font>&#x3D;(<font color='red'>hour</font>)(<font color='red'>zone</font>)<br><font color='red'>hour</font>&#x3D;2<font color='red'>DIGIT</font>“:”2<font color='red'>DIGIT</font>[“:”2<font color='red'>DIGIT</font>]<br><font color='red'>zone</font>&#x3D;”UT”&#x2F;“GMT”&#x2F;“EST”&#x2F;“EDT”&#x2F;“CST”&#x2F;“CDT”&#x2F;“MST”&#x2F;“MDT”&#x2F;“PST”&#x2F;“PDT”&#x2F;1<font color='red'>ALPHA</font>&#x2F;((“+”&#x2F;“-“)4<font color='red'>DIGIT</font>)</p>
<h3 id="5-2、“zone”含义"><a href="#5-2、“zone”含义" class="headerlink" title="5.2、“zone”含义"></a><strong>5.2、“<font color='red'>zone</font>”含义</strong></h3><p>“UT”：表示“Universal Time”或者“Greenwich Mean Time”。<br>“GMT”：表示“Greenwich Mean Time”。<br>“EST&#x2F;EDT&#x2F;CST&#x2F;CDT&#x2F;MST&#x2F;MDT&#x2F;PST&#x2F;PDT”：表示北美时区标准。<br>“1<font color='red'>ALPHA</font>”：军事标准，“Z”表示“Universal Time”，“A”表示相对于“Universal Time”早1小时，“M”表示相对于“Universal Time”早12小时，“N”表示相对于“Universal Time”晚1小时，“Y”表示相对于“Universal Time”晚12小时等。<br>‘((“+”&#x2F;“-“)4<font color='red'>DIGIT</font>)’：与“UT”的偏移值。</p>
<h2 id="六、地址规范"><a href="#六、地址规范" class="headerlink" title="六、地址规范"></a><strong>六、地址规范</strong></h2><h3 id="6-1、定义"><a href="#6-1、定义" class="headerlink" title="6.1、定义"></a><strong>6.1、定义</strong></h3><p><font color='red'>address</font>&#x3D;<font color='red'>mailbox</font>&#x2F;<font color='red'>group</font><br><font color='red'>mailbox</font>&#x3D;<font color='red'>addr-spec</font>&#x2F;(<font color='red'>phrase</font>)(<font color='red'>route-addr</font>)<br><font color='red'>addr-spec</font>&#x3D;<font color='red'>local-part</font>“@”<font color='red'>domain</font><br><font color='red'>local-part</font>&#x3D;<font color='red'>word</font>*(“.”<font color='red'>word</font>)<br><font color='red'>domain</font>&#x3D;<font color='red'>sub-domain</font>*(“.”<font color='red'>sub-domain</font>)<br><font color='red'>sub-domain</font>&#x3D;<font color='red'>domain-ref</font>&#x2F;<font color='red'>domain-literal</font><br><font color='red'>domain-ref</font>&#x3D;<font color='red'>atom</font><br><font color='red'>route-addr</font>&#x3D;”&lt;”[<font color='red'>route</font>]<font color='red'>addr-spec</font>“&gt;”<br><font color='red'>route</font>&#x3D;1#(“@”<font color='red'>domain</font>)”:”<br><font color='red'>group</font>&#x3D;<font color='red'>phrase</font>“:”[#<font color='red'>mailbox</font>]”;”</p>
<h3 id="6-2、含义"><a href="#6-2、含义" class="headerlink" title="6.2、含义"></a><strong>6.2、含义</strong></h3><p><font color='red'>mailbox</font>举例如：“<a href="mailto:&#x47;&#x65;&#111;&#x72;&#x67;&#x65;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x47;&#x65;&#111;&#x72;&#x67;&#x65;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a>”，“George Jones&#60;Group@Host&#62;”等。</p>
<h4 id="6-2-1、Domain-Literial"><a href="#6-2-1、Domain-Literial" class="headerlink" title="6.2.1、Domain-Literial"></a><strong>6.2.1、Domain-Literial</strong></h4><p>表示“ARPA Internet”地址，由4部分组成，每一部分都是一个8比特整型数值，形如：[10.0.3.19]。<font color='red'>“Domain-Literial”的使用不再被鼓励。</font></p>
<h4 id="6-2-2、Postmaster-Domain"><a href="#6-2-2、Postmaster-Domain" class="headerlink" title="6.2.2、Postmaster@Domain"></a><strong>6.2.2、Postmaster@Domain</strong></h4><p>作为特殊保留地址（表示相应域名下管理员的地址），不区分大小写。</p>
<h2 id="七、字段添加过程"><a href="#七、字段添加过程" class="headerlink" title="七、字段添加过程"></a><strong>七、字段添加过程</strong></h2><p>一封消息从“生成”到“到达”收件人需要经历一系列设备，示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20161215-0-1.png"></p>
<p>与上述过程相对应的是“字段添加过程”，分为两种情况描述“字段添加过程”：“非转发”和“转发”。</p>
<h3 id="7-1、非转发"><a href="#7-1、非转发" class="headerlink" title="7.1、非转发"></a><strong>7.1、非转发</strong></h3><p><strong>1、发件人设备s</strong><br>生成消息的设备，添加以下字段：</p>
<ul>
<li>添加“Date”字段（设备自动生成），表示消息生成时间</li>
<li>添加“From”字段或者添加“From和Sender”字段（人工填写），前者表示“消息的作者”和“消息的发送者”都为“From”字段的值；后者表示“消息的作者”是“From”字段的值，“消息的发送者”为“Sender”字段的值</li>
<li>可选添加“Reply-To”字段（人工填写），表示显式指定回复消息的接收者，否则回复消息的接收者为“From”字段值（无论是否有“Sender”字段值）</li>
<li>至少添加一个“To&#x2F;cc&#x2F;bcc”字段（人工填写），“To”字段值为“消息收件人列表”，“cc”字段值为“消息抄送收件人列表”，“bcc”字段值为“消息密送收件人列表”，“消息收件人”，“消息抄送收件人”和“消息密送收件人”都看得到“To”字段值和“cc”字段值，不能看到“bcc”字段值</li>
<li>可选添加“Message-ID”字段（设备自动生成），表示消息在发件人设备s中的唯一序列号</li>
<li>可选添加“In-Reply-To”字段（设备自动生成），本消息（本消息是回复消息）所回复一系列消息的“Message-ID”字段值</li>
<li>可选添加“References”字段（设备自动生成），字段值表示本消息涉及的一系列消息的“Message-ID”字段值</li>
<li>可选添加“Keywords”字段（人工填写），字段值表示消息的关键词组合，由逗号隔开</li>
<li>可选添加“Subject”字段（人工填写），表示消息主题</li>
<li>可选添加“Comments”字段（人工填写），字段值表示消息的注释</li>
<li>可选添加“Encrypted”字段（设备自动生成），字段值给出关于解密<font color='red'>Body</font>内容所需要的信息，该字段被废弃</li>
</ul>
<p><strong>2、中间设备mX</strong><br>中间设备mX，添加以下字段：</p>
<ul>
<li>添加“Received”字段，记录消息在两个设备间的传递过程</li>
</ul>
<p><strong>3、收件人设备e</strong><br>收件人的设备，添加以下字段：</p>
<ul>
<li>添加“Received”字段，记录消息在两个设备间的传递过程</li>
<li>添加“Return-Path”字段，记录确切地指向发件人的路由信息</li>
</ul>
<h3 id="7-2、转发"><a href="#7-2、转发" class="headerlink" title="7.2、转发"></a><strong>7.2、转发</strong></h3><p>消息的原有字段不变，只是增加以“Resent-”字符串为前缀的字段。</p>
<h2 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a><strong>八、其他</strong></h2><p><a href="http://www.rfc-editor.org/rfc/rfc822.txt">RFC822文档</a>中有些内容前后不一致，甚至有些内容具有明显错误，本文内容跟其不完全一致。</p>
<br/>
**参考文献：**
[1]http://www.rfc-editor.org/rfc/rfc822.txt
[2]http://003317.blog.51cto.com/2005292/611104
[3]<a href="/blog/2018/04/20/ASCII%E7%BC%96%E7%A0%81/" title="ASCII编码">ASCII编码</a>
]]></content>
      <categories>
        <category>协议规范</category>
        <category>邮件解析</category>
      </categories>
  </entry>
  <entry>
    <title>RMI</title>
    <url>/blog/2017/04/26/RMI/</url>
    <content><![CDATA[<h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a><strong>一、含义</strong></h2><p>英文全称为“Java Remote Method Invocation”，即“Java远程方法调用”。RMI是一种用于实现远程方法调用的应用程序编程接口，它使得RMI Client上的Java程序能够远程调用RMI Server上Java对象的方法。</p>
<h2 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a><strong>二、详细介绍</strong></h2><p>RMI应用程序基本架构如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170426-0-1.jpg"></p>
<p>RMI应用程序数据流如下：</p>
<ol>
<li>运行Web Server服务</li>
<li>运行rmiregistry服务</li>
<li>运行RMI Server，生成一个Remote Object实例，使用自定义名称将其注册到rmiregistry服务中（具体实现细节是，在生成一个Remote Object实例之后，再生成一个代理类实例stub，stub内含有该Remote Object实例的引用，以及该RMI Server的主机地址和该Remote Object实例绑定到的端口号，使用自定义名称将stub注册到rmiregistry服务中）</li>
<li>运行RMI Client，根据名称，从rmiregistry服务中获取Remote Object实例的引用，通过该引用远程调用Remote Object实例上的方法（具体实现细节是，根据名称，从rmiregistry服务中获取代理类实例stub，根据其中的“RMI Server的主机地址”，定位到相应的RMI Server，进而根据“Remote Object实例绑定到的端口号”和“Remote Object实例引用”执行远程方法调用）</li>
</ol>
<p>在远程方法调用过程中，“RMI Server”和“RMI Client”作为主要角色，“Web Server”和“rmiregistry”作为辅助角色。rmiregistry服务类似于DNS服务，RMI Server使用名称向其注册代理类实例，RMI Client根据名称向其获取代理类实例。rmiregistry，RMI Server和RMI Client可访问Web Server，下载所需要而缺失的类定义。<br><font color='red'>RMI Server和RMI Client之间，RMI Server与rmiregistry之间，RMI Client与rmiregistry之间的数据交互（方法参数，方法返回值，代理类实例）要求数据“或为基本类型，或为可序列化对象类型”。</font></p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><h3 id="3-1、主机列表"><a href="#3-1、主机列表" class="headerlink" title="3.1、主机列表"></a><strong>3.1、主机列表</strong></h3><p>实验主机列表规划如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>内网地址</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>10.110.20.53</td>
<td>运行Web Server服务</td>
</tr>
<tr>
<td>10.110.20.61</td>
<td>运行rmiregistry服务</td>
</tr>
<tr>
<td>10.110.20.62</td>
<td>运行RMI Server</td>
</tr>
<tr>
<td>10.110.20.63</td>
<td>运行RMI Server</td>
</tr>
<tr>
<td>10.110.20.96</td>
<td>运行RMI Client</td>
</tr>
</tbody></table>
<h3 id="3-2、源代码"><a href="#3-2、源代码" class="headerlink" title="3.2、源代码"></a><strong>3.2、源代码</strong></h3><h4 id="3-2-1、公共接口部分"><a href="#3-2-1、公共接口部分" class="headerlink" title="3.2.1、公共接口部分"></a><strong>3.2.1、公共接口部分</strong></h4><p>Compute接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package compute;</span><br><span class="line"></span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remote Object需要继承实现Remote接口</span><br><span class="line"> */</span><br><span class="line">public interface Compute extends Remote &#123;</span><br><span class="line">    &lt;T&gt; T executeTask(Task&lt;T&gt; t) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package compute;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 任务接口</span><br><span class="line"> */</span><br><span class="line">public interface Task&lt;T&gt; &#123;</span><br><span class="line">    T execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2、RMI-Server部分"><a href="#3-2-2、RMI-Server部分" class="headerlink" title="3.2.2、RMI Server部分"></a><strong>3.2.2、RMI Server部分</strong></h4><p>ComputeEngine类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package engine;</span><br><span class="line"></span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line">import compute.Compute;</span><br><span class="line">import compute.Task;</span><br><span class="line"></span><br><span class="line">public class ComputeEngine implements Compute &#123;</span><br><span class="line"></span><br><span class="line">    public ComputeEngine() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T executeTask(Task&lt;T&gt; t) &#123;</span><br><span class="line">        return t.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (System.getSecurityManager() == null) &#123;</span><br><span class="line">            System.setSecurityManager(new SecurityManager());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (args[0].equals(&quot;server1&quot;)) &#123;</span><br><span class="line">                String name = &quot;Compute1&quot;;</span><br><span class="line"></span><br><span class="line">                // 生成一个Remote Object实例</span><br><span class="line">                Compute engine = new ComputeEngine();</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 1、传入Remote Object实例&lt;br/&gt;</span><br><span class="line">                 * 2、RMI Server主机地址可由程序自动获取（自动获取由于“内网地址和外网地址”之分偶尔会导致一些问题），也可通过“java.rmi.server.hostname”环境变量显式指定&lt;br/&gt;</span><br><span class="line">                 * 3、传入参数值0，表示随机选择一个端口用于绑定Remote Object实例&lt;br/&gt;</span><br><span class="line">                 * 4、基于以上3个数据，生成代理类实例stub</span><br><span class="line">                 */</span><br><span class="line">                Compute stub = (Compute) UnicastRemoteObject.exportObject(engine, 0);</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 1、通过“own.variable.registry.host”环境变量，获取rmiregistry服务地址&lt;br/&gt;</span><br><span class="line">                 * 2、使用默认端口1099连接rmiregistry服务&lt;br/&gt;</span><br><span class="line">                 * 3、使用“Compute1”名称将代理类实例stub注册到rmiregistry服务中</span><br><span class="line">                 */</span><br><span class="line">                Registry registry = LocateRegistry.getRegistry(System.getProperty(&quot;own.variable.registry.host&quot;));</span><br><span class="line">                registry.rebind(name, stub);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;ComputeEngine Server1 bound&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String name = &quot;Compute2&quot;;</span><br><span class="line"></span><br><span class="line">                // 生成一个Remote Object实例</span><br><span class="line">                Compute engine = new ComputeEngine();</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 1、传入Remote Object实例&lt;br/&gt;</span><br><span class="line">                 * 2、RMI Server主机地址可由程序自动获取（自动获取由于“内网地址和外网地址”之分偶尔会导致一些问题），也可通过“java.rmi.server.hostname”环境变量显式指定&lt;br/&gt;</span><br><span class="line">                 * 3、传入参数值0，表示随机选择一个端口用于绑定Remote Object实例&lt;br/&gt;</span><br><span class="line">                 * 4、基于以上3个数据，生成代理类实例stub</span><br><span class="line">                 */</span><br><span class="line">                Compute stub = (Compute) UnicastRemoteObject.exportObject(engine, 0);</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 1、通过“own.variable.registry.host”环境变量，获取rmiregistry服务地址&lt;br/&gt;</span><br><span class="line">                 * 2、使用默认端口1099连接rmiregistry服务&lt;br/&gt;</span><br><span class="line">                 * 3、使用“Compute2”名称将代理类实例stub注册到rmiregistry服务中</span><br><span class="line">                 */</span><br><span class="line">                Registry registry = LocateRegistry.getRegistry(System.getProperty(&quot;own.variable.registry.host&quot;));</span><br><span class="line">                registry.rebind(name, stub);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;ComputeEngine Server2 bound&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.err.println(&quot;ComputeEngine exception:&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3、RMI-Client部分"><a href="#3-2-3、RMI-Client部分" class="headerlink" title="3.2.3、RMI Client部分"></a><strong>3.2.3、RMI Client部分</strong></h4><p>Pi类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package client;</span><br><span class="line"></span><br><span class="line">import compute.Task;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">public class Pi implements Task&lt;BigDecimal&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 227L;</span><br><span class="line"></span><br><span class="line">    private static final BigDecimal FOUR = BigDecimal.valueOf(4);</span><br><span class="line"></span><br><span class="line">    private static final int roundingMode = BigDecimal.ROUND_HALF_EVEN;</span><br><span class="line"></span><br><span class="line">    private final int digits;</span><br><span class="line"></span><br><span class="line">    public Pi(int digits) &#123;</span><br><span class="line">        this.digits = digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BigDecimal execute() &#123;</span><br><span class="line">        return computePi(digits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BigDecimal computePi(int digits) &#123;</span><br><span class="line">        int scale = digits + 5;</span><br><span class="line">        BigDecimal arctan1_5 = arctan(5, scale);</span><br><span class="line">        BigDecimal arctan1_239 = arctan(239, scale);</span><br><span class="line">        BigDecimal pi = arctan1_5.multiply(FOUR).subtract(arctan1_239).multiply(FOUR);</span><br><span class="line">        return pi.setScale(digits, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BigDecimal arctan(int inverseX, int scale) &#123;</span><br><span class="line">        BigDecimal result, numer, term;</span><br><span class="line">        BigDecimal invX = BigDecimal.valueOf(inverseX);</span><br><span class="line">        BigDecimal invX2 = BigDecimal.valueOf(inverseX * inverseX);</span><br><span class="line"></span><br><span class="line">        numer = BigDecimal.ONE.divide(invX, scale, roundingMode);</span><br><span class="line"></span><br><span class="line">        result = numer;</span><br><span class="line">        int i = 1;</span><br><span class="line">        do &#123;</span><br><span class="line">            numer = numer.divide(invX2, scale, roundingMode);</span><br><span class="line">            int denom = 2 * i + 1;</span><br><span class="line">            term = numer.divide(BigDecimal.valueOf(denom), scale, roundingMode);</span><br><span class="line">            if ((i % 2) != 0) &#123;</span><br><span class="line">                result = result.subtract(term);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = result.add(term);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; while (term.compareTo(BigDecimal.ZERO) != 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ComputePi类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package client;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">import compute.Compute;</span><br><span class="line"></span><br><span class="line">public class ComputePi &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        if (System.getSecurityManager() == null) &#123;</span><br><span class="line">            System.setSecurityManager(new SecurityManager());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String name = &quot;Compute1&quot;;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 1、通过“own.variable.registry.host”环境变量，获取rmiregistry服务地址&lt;br/&gt;</span><br><span class="line">             * 2、使用默认端口1099连接rmiregistry服务&lt;br/&gt;</span><br><span class="line">             * 3、使用“Compute1”名称从rmiregistry服务中获取代理类实例stub</span><br><span class="line">             * */</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(System.getProperty(&quot;own.variable.registry.host&quot;));</span><br><span class="line"></span><br><span class="line">            Compute stub = (Compute) registry.lookup(name);</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 1、打印代理类实例实际类型&lt;br/&gt;</span><br><span class="line">             * 2、证明代理类实例属于“可序列化对象类型”</span><br><span class="line">             */</span><br><span class="line">            System.out.println(&quot;Proxy Class: &quot; + stub.getClass());</span><br><span class="line">            System.out.println(&quot;Prove implementing Serializable interface: &quot; + (stub instanceof Serializable));</span><br><span class="line"></span><br><span class="line">            Pi task = new Pi(4);</span><br><span class="line"></span><br><span class="line">            // 通过代理类实例stub，定位RMI Server，定位所引用的Remote Object实例，并执行远程方法调用</span><br><span class="line">            BigDecimal pi = stub.executeTask(task);</span><br><span class="line">            System.out.println(pi);</span><br><span class="line"></span><br><span class="line">            // 接下来是与上面类似的另外一个远程方法调用过程</span><br><span class="line"></span><br><span class="line">            name = &quot;Compute2&quot;;</span><br><span class="line"></span><br><span class="line">            stub = (Compute) registry.lookup(name);</span><br><span class="line"></span><br><span class="line">            task = new Pi(10);</span><br><span class="line"></span><br><span class="line">            BigDecimal pi2 = stub.executeTask(task);</span><br><span class="line"></span><br><span class="line">            System.out.println(pi2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.err.println(&quot;ComputePi exception:&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3、编译打包，部署，运行及结果"><a href="#3-3、编译打包，部署，运行及结果" class="headerlink" title="3.3、编译打包，部署，运行及结果"></a><strong>3.3、编译打包，部署，运行及结果</strong></h3><h4 id="3-3-1、编译打包"><a href="#3-3-1、编译打包" class="headerlink" title="3.3.1、编译打包"></a><strong>3.3.1、编译打包</strong></h4><p>执行以下命令编译打包公共接口部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac compute/Compute.java compute/Task.java</span><br><span class="line">jar cvf compute.jar compute/*.class</span><br></pre></td></tr></table></figure>
<p>执行以下命令编译RMI Server部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp compute.jar engine/ComputeEngine.java</span><br></pre></td></tr></table></figure>
<p>执行以下命令编译RMI Client部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp compute.jar client/ComputePi.java client/Pi.java</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2、部署"><a href="#3-3-2、部署" class="headerlink" title="3.3.2、部署"></a><strong>3.3.2、部署</strong></h4><p>部署Web Server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r compute.jar engine client 10.110.20.53:~/classes/</span><br></pre></td></tr></table></figure>
<p>部署RMI Server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r engine compute.jar 10.110.20.62:~/classes/</span><br><span class="line">scp -r engine compute.jar 10.110.20.63:~/classes/</span><br></pre></td></tr></table></figure>
<p>部署RMI Client：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r client compute.jar 10.110.20.96:~/classes/</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3、运行及结果"><a href="#3-3-3、运行及结果" class="headerlink" title="3.3.3、运行及结果"></a><strong>3.3.3、运行及结果</strong></h4><p><strong>1、Web Server服务运行及结果</strong><br>在“10.110.20.53”上通过以下命令开启一个简单HTTP Server服务（默认监听8000端口）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>
<p><strong>2、rmiregistry服务运行及结果</strong><br>在“10.110.20.61”上通过以下命令开启rmiregistry服务（默认监听1099端口），并指定Web Server下类定义资源的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmiregistry -J-Djava.rmi.server.codebase=http://10.110.20.53:8000/classes/compute.jar</span><br></pre></td></tr></table></figure>
<p><strong>3、RMI Server运行及结果</strong><br>在“10.110.20.62”上通过以下命令运行RMI Server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/classes</span><br><span class="line">java -cp &quot;.:compute.jar&quot; -Down.variable.registry.host=10.110.20.61 -Djava.rmi.server.codebase=http://10.110.20.53:8000/classes/ -Djava.security.policy=server.policy -Djava.rmi.server.hostname=10.110.20.62 engine.ComputeEngine &quot;server1&quot; </span><br></pre></td></tr></table></figure>
<p>同理，在“10.110.20.63”上通过以下命令运行RMI Server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/classes</span><br><span class="line">java -cp &quot;.:compute.jar&quot; -Down.variable.registry.host=10.110.20.61 -Djava.rmi.server.codebase=http://10.110.20.53:8000/classes/ -Djava.security.policy=server.policy -Djava.rmi.server.hostname=10.110.20.63 engine.ComputeEngine &quot;server2&quot;</span><br></pre></td></tr></table></figure>
<p>运行RMI Server，必须设置“java.rmi.server.codebase（指定Web Server下类定义资源的地址）”和“java.security.policy（指定安全访问策略）”环境变量，其他根据需要进行设置。<br>“server.policy”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4、RMI Client运行及结果</strong><br>在“10.110.20.96”上通过以下命令运行RMI Client：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/classes</span><br><span class="line">java -cp &quot;.:compute.jar&quot; -Down.variable.registry.host=10.110.20.61 -Djava.rmi.server.codebase=http://10.110.20.53:8000/classes/ -Djava.security.policy=client.policy client.ComputePi</span><br></pre></td></tr></table></figure>
<p>运行RMI Client，必须设置“java.rmi.server.codebase（指定Web Server下类定义资源的地址）”和“java.security.policy（指定安全访问策略）”环境变量，其他根据需要进行设置。<br>“client.policy”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最终打印如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy Class: class com.sun.proxy.$Proxy0</span><br><span class="line">Prove implementing Serializable interface: true</span><br><span class="line">3.1416</span><br><span class="line">3.1415926536</span><br></pre></td></tr></table></figure>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、RMI应用程序架构非常灵活"><a href="#4-1、RMI应用程序架构非常灵活" class="headerlink" title="4.1、RMI应用程序架构非常灵活"></a><strong>4.1、RMI应用程序架构非常灵活</strong></h3><p>图1只是给出了最基本的RMI应用程序的架构，事实上，RMI应用程序的架构非常灵活。一个RMI应用程序可包含多个Web Server，rmiregistry，RMI Client和RMI Server，只需要最终的架构能够正常工作即可。</p>
<h3 id="4-2、监听端口验证"><a href="#4-2、监听端口验证" class="headerlink" title="4.2、监听端口验证"></a><strong>4.2、监听端口验证</strong></h3><h4 id="4-2-1、Web-Server"><a href="#4-2-1、Web-Server" class="headerlink" title="4.2.1、Web Server"></a><strong>4.2.1、Web Server</strong></h4><p>在“10.110.20.53”上运行Web Server服务，执行<code>netstat -anp | grep &#39;8000&#39;</code>命令，可得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      27593/python</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2、rmiregistry"><a href="#4-2-2、rmiregistry" class="headerlink" title="4.2.2、rmiregistry"></a><strong>4.2.2、rmiregistry</strong></h4><p>在“10.110.20.61”上运行rmiregistry服务，执行<code>netstat -anp | grep &#39;1099&#39;</code>，可得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp6       0      0 :::1099                 :::*                    LISTEN      16289/rmiregistry</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3、RMI-Server"><a href="#4-2-3、RMI-Server" class="headerlink" title="4.2.3、RMI Server"></a><strong>4.2.3、RMI Server</strong></h4><p>在“10.110.20.62”和“10.110.20.63”上运行有RMI Server，RMI Server会监听用于绑定Remote Object实例的端口。<br>以“10.110.20.62”上的RMI Server为例，进行验证。<br>首先执行<code>jps</code>命令，得到RMI Server进程的进程ID，假定为7974。<br>接着执行<code>netstat -anp | grep &#39;7974&#39;</code>，可得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp6       0      0 :::56707                :::*                    LISTEN      7974/java</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8
[2]https://docs.oracle.com/javase/tutorial/rmi/overview.html
[3]http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python
[4]http://stackoverflow.com/questions/464687/running-rmi-server-classnotfound
[5]http://stackoverflow.com/questions/32913180/rmi-server-vs-rmi-registry
[6]http://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html
[7]http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/codebase.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Redis使用最佳实践</title>
    <url>/blog/2016/07/28/Redis%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、Redis-Cluster内尽量避免使用大Hash对象"><a href="#一、Redis-Cluster内尽量避免使用大Hash对象" class="headerlink" title="一、Redis Cluster内尽量避免使用大Hash对象"></a><strong>一、Redis Cluster内尽量避免使用大Hash对象</strong></h2><p>一个Hash对象对应一个key，在Redis Cluster内，该Hash对象会整体存储于某个节点上。因此，在Redis Cluster内，如果使用大Hash对象（即使用内存量巨大的Hash对象），会导致这部分内存不能均匀地分布于整个Redis Cluster。</p>
<h2 id="二、禁止一次性请求大量数据"><a href="#二、禁止一次性请求大量数据" class="headerlink" title="二、禁止一次性请求大量数据"></a><strong>二、禁止一次性请求大量数据</strong></h2><p>禁止一次性请求大量数据，否则会出现“Read timed out”。<br>出现“Read timed out”的原因是：在访问Redis请求时，本地会开启一个计时器，当超过设定的“超时时间”，还未收到请求返回结果，就会出现“Read timed out”。<br>一次性请求大量数据，从请求发出到收到返回结果会耗费很长时间，最终会导致出现“Read timed out”。<br>比如使用HMGET（时间复杂度为O(N)），HKEYS（时间复杂度为O(N)），HGETALL（时间复杂度为O(N)）等命令时，很容易出现一次性请求大量数据的情形，导致“Read timed out”。为了避免这种情况，可采用“分批请求数据（‘Pipelining HGET命令’或者‘分批传FIELDS给HMGET’）”，“使用替换命令（比如使用HSCAN代替HKEYS）”等方式来解决。</p>
<p>备注：<br>“Redis服务器存在性能问题，Redis服务器与本地之间存在网络问题”等也会导致出现“Read timed out”。</p>
<br/>
参考文献：
[1]http://redis.io/commands/scan
[2]https://www.javacodegeeks.com/2015/09/redis-clustering.html
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SFTP协议</title>
    <url>/blog/2015/05/18/SFTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、协议的含义"><a href="#一、协议的含义" class="headerlink" title="一、协议的含义"></a><strong>一、协议的含义</strong></h2><p>SFTP协议能够进行“远程文件获取，文件内容传输，文件管理”等操作，它的控制信号和数据信号的传输通过安全数据通道进行。一般情况下，这个安全数据通道由SSH连接提供，即SSH连接隧道作为安全数据通道。<br>跟只能进行简单文件内容传输的SCP协议相比，SFTP协议更像是一个远程文件系统协议。<br>SFTP协议工作于OSI七层体系的应用层。</p>
<h2 id="二、协议的原理"><a href="#二、协议的原理" class="headerlink" title="二、协议的原理"></a><strong>二、协议的原理</strong></h2><p>SFTP协议分为两个端，分别是SFTP　Client和SFTP Server。SFTP Client和SFTP Server之间的控制信号和文件内容的传输得通过安全数据通道进行，安全数据通道可由“Transport Layer Security（TLS）”，“SSH”等协议提供，一般情况下是由SSH协议提供。<br>一旦SFTP Client和SFTP Server之间的连接得以建立，就可以通过二者之间的控制信号和文件内容的传输实现远程文件系统的功能。</p>
<h2 id="三、协议的实现"><a href="#三、协议的实现" class="headerlink" title="三、协议的实现"></a><strong>三、协议的实现</strong></h2><p>Linux下的OpenSSH中包含了实现SFTP协议的相关程序，具体可见<a href="/blog/2015/08/23/OpenSSH%E4%B8%ADSFTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3%E7%A8%8B%E5%BA%8F/" title="OpenSSH中SFTP协议实现相关程序">《OpenSSH中SFTP协议实现相关程序》</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol">https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol</a></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>SSH协议</title>
    <url>/blog/2017/02/15/SSH%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>SSH是客户端和服务器之间一个安全的会话协议，现有SSH-1和SSH-2这两个协议版本。处于OSI七层体系中的应用层。SSH协议被设计用来替代Telnet，rsh，rexec等协议。</p>
<h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a><strong>二、应用场景</strong></h2><p>SSH最常见的应用场景是客户端通过SSH连接到服务器建立一个安全会话，然后可以进行用户登录和远程执行命令等操作。<br>另外一个非常有用的应用场景是“其他应用将SSH建立的安全会话作为数据传输通道（又称为隧道）”，其他应用使用隧道的好处主要有：加密数据内容（加密数据内容，防止被窃听；另外GFW屏蔽访问策略集中有一项策略是分析传输数据内容中是否含有非法关键词，如果传输数据被加密，该策略就会失效），突破防火墙（应用A和应用B之间有防火墙C，C屏蔽了A和B直接连接需要的端口，而开放了SSH连接需要的端口，因而通过SSH隧道可以实现A和B之间的连接）</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a><strong>三、协议实现</strong></h2><p>当下，OpenSSH是最流行的SSH协议实现软件，支持SSH-1和SSH-2。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>SSH连接由SSH Client请求建立，一旦SSH连接得以建立，使用该SSH连接的数据通信请求可以由SSH Client发起，也可以由SSH Server发起。<br>由SSH Client发起数据通信请求比较常见，无需多言；仔细想想，由SSH Server发起数据通信请求也比较好理解，SSH Server管理着所有已建立的SSH连接，自然有能力使用某个选定的SSH连接发起数据通信请求，甚至使用所有的SSH连接群发消息。<br>举例说明：<br>服务器A（运行Linux）上运行着SSH Server，现在本地机器（运行Linux）通过SSH Client请求建立了两个SSH连接，相应的就有两个命令行窗口被打开，分别是C1和C2，假如在C1窗口中执行“wall hello”命令，那么在C2窗口中也会打印“hello”这个消息。这就证明了上述论述是正确的。</p>
<br/>
参考文献：
[1]https://en.wikipedia.org/wiki/Secure_Shell
[2]https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B
]]></content>
      <categories>
        <category>协议规范</category>
      </categories>
  </entry>
  <entry>
    <title>ScheduledThreadPoolExecutor</title>
    <url>/blog/2021/05/14/ScheduledThreadPoolExecutor/</url>
    <content><![CDATA[<p>ScheduledThreadPoolExecutor类是ThreadPoolExecutor类的子类，是一个“使用线程池调度执行所提交‘一次性时延’或者‘周期性’任务”的执行器，可简称“STPE”。</p>
<p>在JDK中，执行“一次性时延”或者“周期性”任务的组件还有Timer类，STPE跟Timer的主要对比如下：</p>
<ul>
<li>前者支持多线程，后者固定单线程。当配置前者只有1个线程，主要功能跟Timer是等价的</li>
<li>前者支持多种时间单位，后者只支持“日期时间”和“毫秒”</li>
</ul>
<p>STPE继承类图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210514-0-0.svg"></p>
<h2 id="一、核心原理"><a href="#一、核心原理" class="headerlink" title="一、核心原理"></a><strong>一、核心原理</strong></h2><p>查看ScheduledThreadPoolExecutor类源码，理解其核心原理。带有笔者注释的版本见<a href="https://github.com/dslztx/jdk8_study/blob/master/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java">链接</a>。</p>
<h3 id="1-0、三种任务"><a href="#1-0、三种任务" class="headerlink" title="1.0、三种任务"></a><strong>1.0、三种任务</strong></h3><p>在STPE中，任务的表示类为<code>ScheduledFutureTask</code>，其详细介绍可见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>。</p>
<p>ScheduledFutureTask类中有两个字段：</p>
<ul>
<li><code>long time</code>，单位为纳秒，表示任务的计划执行时间。需要注意的是，它表示“计划执行时间”与“本JVM进程基准时间”之间的差值，而不是跟<code>System.currentTimeMillis()</code>一样以<code>midnight, January 1, 1970 UTC</code>为基准时间，不同JVM进程的基准时间可能不同，一个JVM进程的生命周期内基准时间不变</li>
<li><code>long period</code>，单位为纳秒，用以区分3种任务类型<ul>
<li><code>period=0</code>，一次性时延任务</li>
<li><code>period&gt;0</code>，周期性固定间隔任务</li>
<li><code>period&lt;0</code>，周期性固定时延任务</li>
</ul>
</li>
</ul>
<p>关于3种类型任务的介绍：</p>
<ul>
<li>一次性时延任务：执行一次就结束</li>
<li>周期性固定间隔任务：本次执行完后将该任务再次加入workQueue，设置<code>time=time+period</code></li>
<li>周期性固定时延任务：本次执行完后将该任务再次加入workQueue，设置<code>time=System.nanoTime()+(-period)</code>（<code>System.nanoTime()</code>表示“当前时间”与“本JVM进程基准时间”之间的差值，单位为纳秒）</li>
</ul>
<p>ScheduledFutureTask类的<code>run()</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">periodic</span> <span class="operator">=</span> isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="built_in">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="built_in">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 周期性任务执行如果返回false，这个周期性任务也不加回去了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//outerTask也不能指向别的任务，不然setNextRunTime()这个time值白设置了</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="literal">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canRunInCurrentRunState</span><span class="params">(<span class="type">boolean</span> periodic)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ?</span><br><span class="line">                               continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">                               executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isRunningOrShutdown</span><span class="params">(<span class="type">boolean</span> shutdownOK)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">    <span class="keyword">return</span> rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于以上<code>run()</code>方法源码的几点说明：</p>
<ol>
<li>以上源码中展示了3种类型任务的执行</li>
<li>对于周期性任务，通过<code>time=time+period</code>或者<code>time=System.nanoTime()+(-period)</code>更新<code>time</code>值，看似有运算溢出可能，实则几乎不可能，因为<code>Long.MAX_VALUE - System.nanoTime()</code>差值十分大</li>
<li>跟TPE中的任务执行不同，此处在任务执行时会再去结合执行器的状态，判断本任务是否需要执行，即<code>canRunInCurrentRunState(boolean periodic)</code>语句，该语句的含义如下：<ul>
<li>当执行器状态<code>=RUNNING</code>，返回<code>true</code></li>
<li>当执行器状态<code>&gt;=STOP</code>，返回<code>false</code></li>
<li>当执行器状态<code>=SHUTDOWN</code>，此时如果是周期性任务，结果跟<code>成员变量continueExistingPeriodicTasksAfterShutdown值（默认为false）</code>一致；如果不是周期性任务，结果跟<code>成员变量executeExistingDelayedTasksAfterShutdown值（默认为true）</code>一致</li>
</ul>
</li>
</ol>
<h3 id="1-1、执行器状态和Worker数量上限表示值"><a href="#1-1、执行器状态和Worker数量上限表示值" class="headerlink" title="1.1、执行器状态和Worker数量上限表示值"></a><strong>1.1、执行器状态和Worker数量上限表示值</strong></h3><p>跟父类差异点：</p>
<ul>
<li>SHUTDOWN，值为<code>0&lt;&lt;29</code>，即<code>000,[29个0]</code>，继续执行“Worker中当前正在执行的任务”和“<font color='red'>筛选过的workQueue中的任务（这个筛选过程在<code>onShutDown()</code>方法中实现，详细见“2.3、关闭执行器”小节）</font>”，禁止新提交任务，当所有Worker都退出后，经历<code>TIDYING -&gt; TERMINATED</code></li>
</ul>
<p>另外，根据上面叙述可知，以ScheduledFutureTask表示的任务在执行<code>run()</code>方法时会使用<code>canRunInCurrentRunState(boolean periodic)</code>方法判断“本任务在当前执行器状态下是否能够执行”，但是对于触发执行器状态改变的线程来说，的确是<code>继续执行“Worker中当前正在执行的任务”</code>，即上面<code>继续执行“Worker中当前正在执行的任务”</code>叙述没有错</p>
<h3 id="1-2、任务队列"><a href="#1-2、任务队列" class="headerlink" title="1.2、任务队列"></a><strong>1.2、任务队列</strong></h3><p>STPE实例对象的<code>workQueue</code>隐式指定——<code>workQueue = new DelayedWorkQueue()</code>。</p>
<p>DelayWorkQueue类的特点如下：</p>
<ul>
<li>无界队列，虽然实际上限为<code>Integer.MAX_VALUE</code>，这么设计的原因在于：新提交的“一次性时延”或者“周期性”任务如果计划执行时间还未到不能直接交给Worker执行，只能插入到队列，故队列应该是无界的</li>
<li>Worker每次获取任务时，获取到的任务须满足“计划执行时间在队列中最小，且小于等于当前时间（当两个任务的计划执行时间一致时，先提交任务优先级高）”，DelayWorkQueue队列内部通过维护一个堆数据结构实现了上述需求</li>
</ul>
<h3 id="1-3、拒绝执行策略"><a href="#1-3、拒绝执行策略" class="headerlink" title="1.3、拒绝执行策略"></a><strong>1.3、拒绝执行策略</strong></h3><p>跟父类相同！</p>
<h3 id="1-4、线程工厂方法类"><a href="#1-4、线程工厂方法类" class="headerlink" title="1.4、线程工厂方法类"></a><strong>1.4、线程工厂方法类</strong></h3><p>跟父类相同！</p>
<h3 id="1-5、Worker"><a href="#1-5、Worker" class="headerlink" title="1.5、Worker"></a><strong>1.5、Worker</strong></h3><h4 id="1-5-1、基本"><a href="#1-5-1、基本" class="headerlink" title="1.5.1、基本"></a><strong>1.5.1、基本</strong></h4><p>跟父类相同！</p>
<h4 id="1-5-2、运转"><a href="#1-5-2、运转" class="headerlink" title="1.5.2、运转"></a><strong>1.5.2、运转</strong></h4><p><code>runWorker(Worker w)</code>方法的核心逻辑是：不断获取任务调度执行。</p>
<p>任务来源只有1个：</p>
<ul>
<li>调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到任务时挂起</li>
</ul>
<p>父类中Worker运转的任务来源还有另外一个——<code>创建生成Worker实例时传递的初始任务</code>，但是在这里，任务的计划执行时间很可能还未到，故直接排除掉这种任务来源。</p>
<h4 id="1-5-3、退出机制"><a href="#1-5-3、退出机制" class="headerlink" title="1.5.3、退出机制"></a><strong>1.5.3、退出机制</strong></h4><p>有3种退出机制：</p>
<ol>
<li>退出机制1：任务执行过程中抛出未被内部catch住的异常，导致Worker退出</li>
<li>退出机制2：一般情况下，调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到时恒挂起。但是当<code>Worker数量&gt;corePoolSize || 成员变量allowCoreThreadTimeOut=true</code>条件判断语句返回结果为<code>true</code>时：<ul>
<li><code>成员变量keepAliveTime&gt;0</code>，尝试从workQueue队列获取任务，挂起成员变量keepAliveTime指定时间，如果过期仍未获取到任务，则<code>getTask()</code>方法返回<code>NULL</code>，继而导致Worker退出</li>
<li><code>成员变量keepAliveTime=0</code>，尝试从workQueue队列获取任务，不进行挂起，<code>getTask()</code>方法直接返回<code>NULL</code>，继而导致Worker退出</li>
</ul>
</li>
<li>退出机制3：一般情况下，调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到时恒挂起。但是当<code>执行器的状态&gt;=STOP || (执行器的状态=SHUTDOWN &amp;&amp; workQueue为空)</code>，此时调用<code>getTask()</code>方法会直接返回<code>NULL</code>，继而导致Worker退出</li>
</ol>
<p><font color='red'>需要注意的是</font>：每次Worker退出都会去调用<code>tryTerminate()</code>方法，查看执行器是否能够进入<code>TERMINATED</code>状态。</p>
<p>以上跟父类相同，跟父类不同的是：在STPE中，对于<code>Worker数量&gt;corePoolSize</code>条件不可能成立，详见“1.5.5、数量”，而根据STPE JavaDoc中如下片段可知，成员变量“allowCoreThreadTimeOut”也不被推荐设置成<code>true</code>，故“退出机制2”可认为无效。</p>
<blockquote>
<p>Additionally, it is almost never a good idea to set {@code corePoolSize} to zero or use {@code allowCoreThreadTimeOut} because this may leave the pool without threads to handle tasks once they become eligible to run.</p>
</blockquote>
<h4 id="1-5-4、中断"><a href="#1-5-4、中断" class="headerlink" title="1.5.4、中断"></a><strong>1.5.4、中断</strong></h4><p>跟父类相同！</p>
<h4 id="1-5-5、数量"><a href="#1-5-5、数量" class="headerlink" title="1.5.5、数量"></a><strong>1.5.5、数量</strong></h4><h5 id="1-5-5-1、执行器状态-RUNNING"><a href="#1-5-5-1、执行器状态-RUNNING" class="headerlink" title="1.5.5.1、执行器状态&#x3D;RUNNING"></a><strong>1.5.5.1、执行器状态&#x3D;RUNNING</strong></h5><p><strong>影响Worker数量之提交任务</strong>：</p>
<ul>
<li>对于新提交的任务，立即无条件插入到workQueue队列</li>
<li>Worker数量的变化趋势：最开始也即没有提交任何任务时，此时<code>Worker数量=0</code>，随着任务的提交，线性递增Worker数量直到<code>Worker数量=corePoolSize</code>，此后Worker数量不会再增加</li>
</ul>
<p><font color='red'>注意以上跟父类有很大的不同！</font></p>
<p><strong>影响Worker数量之Worker退出</strong>：</p>
<ol>
<li>退出机制1</li>
</ol>
<h5 id="1-5-5-2、执行器状态-SHUTDOWN"><a href="#1-5-5-2、执行器状态-SHUTDOWN" class="headerlink" title="1.5.5.2、执行器状态&gt;&#x3D;SHUTDOWN"></a><strong>1.5.5.2、执行器状态&gt;&#x3D;SHUTDOWN</strong></h5><p><strong>影响Worker数量之提交任务</strong>：禁止提交，触发“拒绝执行策略”。</p>
<p><strong>影响Worker数量之Worker退出</strong>：</p>
<ol>
<li>退出机制1</li>
<li>退出机制3</li>
</ol>
<h2 id="二、具体动作"><a href="#二、具体动作" class="headerlink" title="二、具体动作"></a><strong>二、具体动作</strong></h2><h3 id="2-1、构造STPE"><a href="#2-1、构造STPE" class="headerlink" title="2.1、构造STPE"></a><strong>2.1、构造STPE</strong></h3><p>构造方法涉及到的所有参数如下：</p>
<ul>
<li><code>int corePoolSize</code>，对应成员变量<code>int corePoolSize</code></li>
<li><code>ThreadFactory threadFactory</code>，对应成员变量<code>ThreadFactory threadFactory</code></li>
<li><code>RejectedExecutionHandler handler</code>，对应成员变量<code>RejectedExecutionHandler handler</code></li>
</ul>
<p>跟父类的构造方法最多支持7个传入参数相比，少了4个传入参数，对应的成员变量直接隐式指定：</p>
<ul>
<li><code>成员变量workQueue=new DelayedWorkQueue()</code>，根据STPE的定义，存放任务的workQueue需要是一个优先级队列，参见“1.2、任务队列”小节</li>
<li><code>成员变量maximumPoolSize=Integer.MAX_VALUE</code>，根据“1.5.5.1、执行器状态&#x3D;RUNNING”小节，Worker数量不会大于<code>corePoolSize</code>，这里设置<code>maximumPoolSize=Integer.MAX_VALUE</code>纯粹只是在满足字段大小语义（<code>maximumPoolSize&gt;corePoolSize</code>）的前提下而取用了一个特殊大值<code>Integer.MAX_VALUE</code></li>
<li><code>成员变量keepAliveTime=0</code>，根据“1.5.3、退出机制”小节可知，“退出机制2”可认为无效，故自然可认为成员变量“keepAliveTime”的设置无实际效果，这里只是取了一个特殊值0而已</li>
</ul>
<p>上述成员变量在STPE实例构造完成后都可被动态修改，除了<code>BlockingQueue&lt;Runnable&gt; workQueue</code>成员变量，<font color='red'>但是不推荐进行动态修改，特别是动态改变原隐式指定的成员变量更是违反设计</font>。</p>
<h3 id="2-2、提交任务"><a href="#2-2、提交任务" class="headerlink" title="2.2、提交任务"></a><strong>2.2、提交任务</strong></h3><h4 id="2-2-1、继承自TPE类的方法"><a href="#2-2-1、继承自TPE类的方法" class="headerlink" title="2.2.1、继承自TPE类的方法"></a><strong>2.2.1、继承自TPE类的方法</strong></h4><p>继承自TPE类的方法，分为两类：</p>
<ol>
<li>只提交任务，不关注执行结果，不能对执行过程进行控制：<ul>
<li><code>public void execute(Runnable command)</code>，执行<code>command</code>实例对象的<code>run()</code>方法，不关注执行结果，其实也没有执行结果，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
</ul>
</li>
<li>提交任务后，通过Future可获取执行结果，也可对执行过程进行控制（关于Future，Runnable，Callable的关系可详见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>）：<ul>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>，执行<code>task</code>实例对象的<code>call()</code>方法，获取的执行结果为<code>call()</code>方法的执行结果</li>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>，执行<code>task</code>实例对象的<code>run()</code>方法，获取的执行结果为预设的执行结果NULL，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>，执行<code>task</code>实例对象的<code>run()</code>方法，获取的执行结果为预设的执行结果result，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
</ul>
</li>
</ol>
<p>在STPE类中为了实现上的统一（比如“加入workQueue队列的任务实际类型可以统一”），对以上4个方法进行了覆盖实现，覆盖实现只是简单转发调用了“2.2.2、STPE类增加的方法”小节中的方法。</p>
<h4 id="2-2-2、STPE类增加的方法"><a href="#2-2-2、STPE类增加的方法" class="headerlink" title="2.2.2、STPE类增加的方法"></a><strong>2.2.2、STPE类增加的方法</strong></h4><p>STPE类中增加了4个提交任务的方法，这几个方法的性质都是“提交任务后，通过ScheduledFuture可获取执行结果，可对执行过程进行控制，也能获得计划执行时间与当前时间的纳秒时间差值（关于ScheduledFuture，Runnable，Callable的关系可详见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>）”：</p>
<ul>
<li><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code>，一次性时延任务，计划执行时间为<code>当前时间加上“delay”和“unit”联合指定的差值</code>，执行<code>command</code>实例对象的<code>run()</code>方法，获取的执行结果为预设值NULL，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
<li><code>public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>，一次性时延任务，计划执行时间为<code>当前时间加上“delay”和“unit”联合指定的差值</code>，执行<code>callable</code>实例对象的<code>call()</code>方法，获取的执行结果为<code>call()</code>方法的执行结果</li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>，周期性固定间隔任务，首次计划执行时间为P——<code>当前时间加上“initialDelay”和“unit”联合指定的差值</code>，后续的计划执行时间为<code>P+N*(“period”和“unit”联合指定的固定间隔时间)</code>，每次执行时，执行<code>command</code>实例对象的<code>run()</code>方法，<font color='red'>无谓获取执行结果，具体可参见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>博文中“1.2.2、核心方法”小节下的“2、runAndReset()”内容</font></li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>，周期性固定时延任务，首次计划执行时间为P——<code>当前时间加上“initialDelay”和“unit”联合指定的差值</code>，后续的计划执行时间为<code>前一次执行完成时间+“delay”和“unit”联合指定的固定时延时间</code>，每次执行时，执行<code>command</code>实例对象的<code>run()</code>方法，<font color='red'>无谓获取执行结果，具体可参见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>博文中“1.2.2、核心方法”小节下的“2、runAndReset()”内容</font></li>
</ul>
<h3 id="2-3、关闭执行器"><a href="#2-3、关闭执行器" class="headerlink" title="2.3、关闭执行器"></a><strong>2.3、关闭执行器</strong></h3><p>有两个关闭方法：<code>shutdown()</code>和<code>shutdownNow()</code>。<br><strong>1、shutdown()</strong><br>调用TPE的<code>shutdown()</code>。</p>
<p>唯一的一点变化是TPE中的<code>onShutDown()</code>方法是空实现，在STPE中覆盖实现了该方法，现在该方法的逻辑是：在当前执行器状态为<code>SHUTDOWN</code>的前提下，根据<code>成员变量continueExistingPeriodicTasksAfterShutdown（默认为false）</code>和<code>成员变量executeExistingDelayedTasksAfterShutdown（默认为true）</code>的值从workQueue队列中筛选掉一些任务，该筛选逻辑跟“1.0、三种任务”小节中“当执行器状态<code>=SHUTDOWN</code>，此时如果是周期性任务…”部分逻辑一致，本质也是对其的呼应——既然后续<code>run()</code>方法运行时会有对这个任务的筛选，这里就提前进行筛选。</p>
<p><strong>2、shutdownNow()</strong><br>调用TPE的<code>shutdownNow()</code>。</p>
<h2 id="三、监控"><a href="#三、监控" class="headerlink" title="三、监控"></a><strong>三、监控</strong></h2><p>跟父类相同！</p>
<h2 id="四、最佳实践"><a href="#四、最佳实践" class="headerlink" title="四、最佳实践"></a><strong>四、最佳实践</strong></h2><h3 id="4-1、核心Worker数量"><a href="#4-1、核心Worker数量" class="headerlink" title="4.1、核心Worker数量"></a><strong>4.1、核心Worker数量</strong></h3><p>跟父类相同！</p>
<h3 id="4-2、一般情况下只需关注执行器的RUNNING状态"><a href="#4-2、一般情况下只需关注执行器的RUNNING状态" class="headerlink" title="4.2、一般情况下只需关注执行器的RUNNING状态"></a><strong>4.2、一般情况下只需关注执行器的<code>RUNNING</code>状态</strong></h3><p>跟父类相同！</p>
<h3 id="4-3、STPE中任务的“计划执行时间”与“实际执行时间”"><a href="#4-3、STPE中任务的“计划执行时间”与“实际执行时间”" class="headerlink" title="4.3、STPE中任务的“计划执行时间”与“实际执行时间”"></a><strong>4.3、STPE中任务的“计划执行时间”与“实际执行时间”</strong></h3><p>在TPE中任务没有“计划执行时间”概念，故什么时候实际调度执行都没有关系；但在STPE中任务有“计划执行时间”概念，此时如果“实际调度执行时间”大大超过“计划执行时间”（两个时间如果相差不大，则认为处于可接受范围），有违背业务需求之嫌，故对于在STPE中提交的任务要求执行时间不可过久，否则极易导致后续没有空闲Worker调度执行到期的任务T，而最终使得T的“实际调度执行时间”大大超过“计划执行时间”。</p>
<h3 id="4-4、一个happens-before关系"><a href="#4-4、一个happens-before关系" class="headerlink" title="4.4、一个happens-before关系"></a><strong>4.4、一个happens-before关系</strong></h3><p>存在一个happens-before关系：一个周期性任务，前一次执行happens-before于后一次执行。JavaDoc原叙述为：<code>Successive executions of a task scheduled via scheduleAtFixedRate or scheduleWithFixedDelay do not overlap. While different executions may be performed by different threads, the effects of prior executions happen-before those of subsequent ones.</code></p>
<p>接下来进行证明。</p>
<p>查看周期性任务执行的外围方法<code>runAndReset()</code>的源代码，其中&#x2F;&#x2F;2处是真实业务执行逻辑调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAndReset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))    <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.call(); <span class="comment">// don&#x27;t set result                          //2</span></span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;                                                 <span class="comment">//3</span></span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体证明过程：以volatile变量<code>runner</code>为基点，根据分析可知，“后一次执行的&#x2F;&#x2F;1处”必得读取到“前一次执行的&#x2F;&#x2F;3处对runner写入的NULL值”，符合happens-before规则——“volatile变量规则”，结合happens-before规则——“程序顺序规则”和“传递性规则”，有：前一次执行的&#x2F;&#x2F;1 -hb-&gt; 前一次执行的&#x2F;&#x2F;2 -hb-&gt; 前一次执行的&#x2F;&#x2F;3 -hb-&gt; 后一次执行的&#x2F;&#x2F;1-hb-&gt; 后一次执行的&#x2F;&#x2F;2，到此得证。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Socks协议</title>
    <url>/blog/2024/02/06/Socks%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>利用Socks协议，可以使得两个节点之间的连接通过一个中转节点中转，从而可以加密数据，穿越防火墙的限制。<br>Socks协议中有两种身份：Socks Client和Socks Server。<br>Socks协议工作在OSI七层体系的第5层——会话层。</p>
<h2 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a><strong>二、基本原理</strong></h2><p>现在有A和B两个节点，A节点上运行Socks Client实现程序，B节点上运行Socks Server实现程序。<br>现在A想要请求网络服务，可以将该请求传递给A上的Socks Client，然后Socks Client与Socks Server建立数据连接，该连接可以使用选定的加密算法进行加密，接着Socks Client可以将A的网络服务请求传递给Socks Server，最后由Socks Server代为进行网络服务请求，并将得到的请求结果数据原路返回给A。</p>
<p>注意：在以上过程中，只有Socks Client和Socks Server之间的连接可以采用选定的加密算法进行加密。</p>
<h2 id="三、用途"><a href="#三、用途" class="headerlink" title="三、用途"></a><strong>三、用途</strong></h2><p>正如基本概念中所述，使用Socks协议可以达到“加密数据，穿越防火墙”的目标。比如以下两种情形。</p>
<h3 id="3-1、情形1"><a href="#3-1、情形1" class="headerlink" title="3.1、情形1"></a><strong>3.1、情形1</strong></h3><p>现在有A，B两个节点，另有防火墙C，A处于C内，B处于C外，C能够监听与A进行的连接，如果连接中出现特定的关键词，C能够将该连接断开。<br>现在A想要突破防火墙C的限制，使得可以与B进行连接，传输任意数据，但是A与B的连接不能加密。</p>
<p>采用Socks协议的具体方案如下：</p>
<ol>
<li>另外搭设一个节点D，D必须在C外</li>
<li>D上运行Socks Server实现程序，A上运行Socks Client实现程序。现在A与B的连接通过D进行，具体是A对B的连接请求被传递给A上的Socks Client，然后Socks Client与D上的Socks Server连接，Socks Server再代为请求与B进行连接，由于A上的Socks Client与D上的Socks Server之间的连接可被Socks协议加密算法加密，因而防火墙C就不能够检查关键词是否存在，也就不能够断开A与D的连接，自然也就不能断开A与B通过D而得到的连接</li>
</ol>
<h3 id="3-2、情形2"><a href="#3-2、情形2" class="headerlink" title="3.2、情形2"></a><strong>3.2、情形2</strong></h3><p>现在有A，B两个节点，另有防火墙C，A处于C内，B处于C外，C中把B加入了黑名单，使得在C内的A不能够访问B。<br>现在A想要突破防火墙C的限制，使得可以与B进行连接。</p>
<p>采用Socks协议的具体方案如下：</p>
<ol>
<li>另外搭设一个节点D，D必须在C外，且要求满足D节点不在C的黑名单内</li>
<li>D上运行Socks Server实现程序，A上运行Socks Client实现程序。现在A与B的连接通过D进行，具体是A对B的连接请求被传递给A上的Socks Client，然后Socks Client与D上的Socks Server连接，Socks Server再代为请求与B进行连接，由于D不在C的黑名单内，A与D可进行连接，从而A就可通过D与B连接</li>
</ol>
<h2 id="四、协议实现"><a href="#四、协议实现" class="headerlink" title="四、协议实现"></a><strong>四、协议实现</strong></h2><h3 id="4-1、Socks-Server的实现程序"><a href="#4-1、Socks-Server的实现程序" class="headerlink" title="4.1、Socks Server的实现程序"></a><strong>4.1、Socks Server的实现程序</strong></h3><ul>
<li>Antinat</li>
<li>Dante</li>
<li>Srelay</li>
<li>SS5</li>
<li>Sun Java System Web Proxy Server</li>
<li>WinGate</li>
<li>OpenSSH中的sshd实现程序</li>
<li>ShadowSocks中的server实现程序</li>
</ul>
<h3 id="4-2、Socks-Client的实现程序"><a href="#4-2、Socks-Client的实现程序" class="headerlink" title="4.2、Socks Client的实现程序"></a><strong>4.2、Socks Client的实现程序</strong></h3><ul>
<li>OpenSSH中的ssh实现程序</li>
<li>Putty</li>
<li>ShadowSocks中的client实现程序</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/SOCKS">https://en.wikipedia.org/wiki/SOCKS</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>Socks协议实现</title>
    <url>/blog/2024/02/06/Socks%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>如<a href="/blog/2024/02/06/Socks%E5%8D%8F%E8%AE%AE/" title="Socks协议">《Socks协议》</a>所述，实现Socks协议的软件有很多，本文主要介绍OpenSSH和ShadowSocks。</p>
<h2 id="一、OpenSSH"><a href="#一、OpenSSH" class="headerlink" title="一、OpenSSH"></a><strong>一、OpenSSH</strong></h2><p>OpenSSH中的ssh程序和sshd程序不仅分别实现了ssh协议的SSH Client和SSH Server，还分别实现了Socks协议的Socks Client和Socks Server。<br>当使用ssh程序的动态转发功能时，使用的就是Socks协议，此时ssh程序作为Socks Client，sshd程序作为Socks Server。</p>
<h2 id="二、ShadowSocks"><a href="#二、ShadowSocks" class="headerlink" title="二、ShadowSocks"></a><strong>二、ShadowSocks</strong></h2><p>ShadowSocks软件特定实现了Socks协议，其中包含ShadowSocks Client和ShadowSocks Server，分别实现了Socks协议的Socks Client和Socks Server。</p>
<h2 id="三、两种实现的比较"><a href="#三、两种实现的比较" class="headerlink" title="三、两种实现的比较"></a><strong>三、两种实现的比较</strong></h2><table>
<thead>
<tr>
<th>实现方案</th>
<th>常用的连接建立方式需要的参数</th>
<th>上网速度</th>
<th>抗干扰性</th>
</tr>
</thead>
<tbody><tr>
<td>OpenSSH</td>
<td>1、Socks Server所在的机器的地址，即sshd程序所在的机器的地址<br/>2、Socks Server监听的端口号，即sshd程序监听的端口号<br/>3、合法帐号<br/>4、合法私钥</td>
<td>跟ShadowSocks相差无几</td>
<td>Socks Client和Socks Server之间的连接隧道只创建一次，一旦被创建后，就通过控制信息来维持该隧道，遭到干扰而使得连接隧道被断开后，该连接隧道不会被自动再次创建</td>
</tr>
<tr>
<td>ShadowSocks</td>
<td>1、Socks Server所在的机器的地址，即ShadowsSocks Server程序所在的机器的地址<br/>2、Socks Server监听的端口号，即ShadowsSocks Server程序监听的端口号<br/>3、合法密码<br/>4、Socks连接加密方式</td>
<td>跟OpenSSH相差无几</td>
<td>Socks Client和Socks Server之间的连接隧道允许被多次按需创建，一旦有数据传输需求，就可以创建连接隧道，遭到干扰而使得连接隧道被断开后，该连接隧道可以自动再次被创建</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.yaoblog.info/?p=7411">https://www.yaoblog.info/?p=7411</a><br>[2]<a href="http://ilovetile.com/3423">http://ilovetile.com/3423</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>Storm统计最佳实践</title>
    <url>/blog/2016/07/27/Storm%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、统计类型"><a href="#一、统计类型" class="headerlink" title="一、统计类型"></a><strong>一、统计类型</strong></h2><p>Storm统计问题有两种类型：时间点统计和窗口统计。<br>时间点统计：需要的是某一时间点的统计量，比如某秒钟，某分钟，某小时，某天的统计量。<br>窗口统计：需要的是某一窗口的统计量，比如最近5分钟，最近1小时，最近一天的统计量。</p>
<h2 id="二、最佳实践之统计技术"><a href="#二、最佳实践之统计技术" class="headerlink" title="二、最佳实践之统计技术"></a><strong>二、最佳实践之统计技术</strong></h2><h3 id="2-1、统计数据缓存技术"><a href="#2-1、统计数据缓存技术" class="headerlink" title="2.1、统计数据缓存技术"></a><strong>2.1、统计数据缓存技术</strong></h3><p>Storm统计面对的是流式数据，为了减小对Redis&#x2F;Mysql等存放统计的中间结果或者最终结果的数据库的压力，可以缓存一定时间的统计数据，比如1分钟，这些缓存的统计数据最终被一次性处理。</p>
<h3 id="2-2、时间戳迁移技术"><a href="#2-2、时间戳迁移技术" class="headerlink" title="2.2、时间戳迁移技术"></a><strong>2.2、时间戳迁移技术</strong></h3><p>引入“2.1、统计数据缓存技术”之后，不得不面对的一个问题是：本属于某个时间点统计量的统计数据可能由于缓存的存在，过了该时间点之后，才被更新到该时间点统计量。比如现有一个“2016072719”时间点统计量，201607271959分钟的统计数据由于缓存的存在，直到201607272001分钟才被更新到“2016072719”时间点统计量，这意味着在“201607272000”到“201607272001”分钟时间区间内，“2016072719”时间点统计量是“缺失”的。<br>“时间戳迁移技术”的原理是：往前迁移统计数据的时间戳，也即针对“缓存造成的时间滞后”现象，“将计就计”。比如在以上例子中，如果采用“往前迁移2分钟”技术，那么201607271959分钟的统计数据的时间戳为“201607272001”，此时，该份统计数据归属于“2016072720”时间点统计量，因而“2016072719”时间点统计量不再有处于“缺失”状态的时间区间。</p>
<h3 id="2-3、减少访问Redis次数"><a href="#2-3、减少访问Redis次数" class="headerlink" title="2.3、减少访问Redis次数"></a><strong>2.3、减少访问Redis次数</strong></h3><p>访问Redis非常耗费时间，需要不断优化，从而使得尽量减少对Redis的访问次数。减少访问Mysql等数据库次数的技术的思想是类似的。</p>
<h4 id="2-3-1、仔细设计存储结构"><a href="#2-3-1、仔细设计存储结构" class="headerlink" title="2.3.1、仔细设计存储结构"></a><strong>2.3.1、仔细设计存储结构</strong></h4><p>根据应用场景，仔细设计存储结构，可以有效减少访问Redis次数。<br>比如：<br>1、需要统计某个key在1440分钟内出现的总次数。一种存储结构方案是：键为“key+分钟后缀”，值为“该key相应分钟内的出现次数”，那么下次统计该key在1440分钟内出现的总次数时，需要访问1440次Redis（虽然可以采用Pipeline机制，但还是需要“1440&#x2F;N”次，其中“N”表示每累计到“N”条命令就请求一次Redis，如果下次统计区间长度从“1440”变为“2880”，那么就需要“2880&#x2F;N”次）；另外一种存储结构方案是：键为“key”，值为“分钟1：相应分钟出现次数1；分钟2：相应分钟出现次数2；分钟3：相应分钟出现次数3；…”（分隔符是自定义的），那么下次统计该key在1440分钟内出现的总次数时，只需要访问1次Redis。<br>2、需要统计某个key在1440分钟内维度1下不同元素数量，维度2下不同元素数量，维度3下不同元素数量。一种存储结构方案是：键为“key+维度标识符+分钟后缀”，值为“一个Set集合，保存该key相应分钟相应维度下的不同元素集合”，那么下次统计时，需要访问“1440*3”次Redis；另外一种存储结构方案是：键为“key”，值为“分钟1：相应分钟维度1下不同元素集合；相应分钟维度2下不同元素集合；相应分钟维度3下不同元素集合#分钟2：相应分钟维度1下不同元素集合；相应分钟维度2下不同元素集合；相应分钟维度3下不同元素集合#分钟3：相应分钟维度1下不同元素集合；相应分钟维度2下不同元素集合；相应分钟维度3下不同元素集合#…”（分钟间分隔符，不同维度间分隔符和集合元素间分隔符是自定义的），那么下次统计时，只需要访问1次Redis。</p>
<h4 id="2-3-2、本地进行缓存"><a href="#2-3-2、本地进行缓存" class="headerlink" title="2.3.2、本地进行缓存"></a><strong>2.3.2、本地进行缓存</strong></h4><p>本地进行缓存，从而使得本来需要访问Redis才能获取的数据，可以直接从本地缓存获取。</p>
<h3 id="2-4、窗口统计中，待排除时间点数据获取技术"><a href="#2-4、窗口统计中，待排除时间点数据获取技术" class="headerlink" title="2.4、窗口统计中，待排除时间点数据获取技术"></a><strong>2.4、窗口统计中，待排除时间点数据获取技术</strong></h3><p>在窗口统计中，如何获取待排除时间点数据？比如在以5分钟为窗口长度的一个窗口统计中，每次更新，都需要获取当前最新分钟的key集合和前第6分钟的key集合，这两分钟的key集合并集是待更新key集合。<br>有两种方案。</p>
<h4 id="2-4-1、缓存方案"><a href="#2-4-1、缓存方案" class="headerlink" title="2.4.1、缓存方案"></a><strong>2.4.1、缓存方案</strong></h4><p>在当前任务中保存最近6分钟数据，那么下次需要当前最新分钟的key集合和前第6分钟的key集合时，能够直接获取到。</p>
<h4 id="2-4-2、分发方案"><a href="#2-4-2、分发方案" class="headerlink" title="2.4.2、分发方案"></a><strong>2.4.2、分发方案</strong></h4><p>独立运行一个任务，从Redis&#x2F;Mysql等数据库中获取前第6分钟的数据，然后使用Storm Topology的流机制进行数据分发。以上方案的正确性得到保证的前提是：有一个Bolt（称为B），另外有两个对象（称为A和C，A和C或者都为Bolt，或者一个为Spout，另外一个为Bolt）向B分发数据，且采用相同分发机制，比如都根据“Key”进行“fieldsGrouping”，那么A和C数据流中具有相同“Key”值的数据应该在B的同一个任务中。而在Storm Topology中，以上这点是能够得到保证的。</p>
<h2 id="三、最佳实践之统计原则"><a href="#三、最佳实践之统计原则" class="headerlink" title="三、最佳实践之统计原则"></a><strong>三、最佳实践之统计原则</strong></h2><h3 id="3-1、数据丢失"><a href="#3-1、数据丢失" class="headerlink" title="3.1、数据丢失"></a><strong>3.1、数据丢失</strong></h3><p>Redis&#x2F;Mysql等存放统计的中间结果或者最终结果的数据库中存放的数据，在正常情况下，被认为不会丢失；Storm Topology非常容易挂掉或者重启，因而，在Storm Topology运行时，内存中存放的数据被认为很容易就丢失掉。</p>
<h3 id="3-2、窗口统计中，使用“全量更新”，禁用“增量更新”"><a href="#3-2、窗口统计中，使用“全量更新”，禁用“增量更新”" class="headerlink" title="3.2、窗口统计中，使用“全量更新”，禁用“增量更新”"></a><strong>3.2、窗口统计中，使用“全量更新”，禁用“增量更新”</strong></h3><p>在窗口统计中，计算某个key的最新值，有两种方案：使用“全量更新”和使用“增量更新”。“全量更新”就是，对于某个key，获取该key窗口中所有时间点的值，累加起来；“增量更新”就是，对于某个key，获取该key窗口中最新一个时间点的值a，最老一个时间点的值b以及该key上一个窗口统计值c，那么该key最新窗口统计值为<code>c+a-b</code>。<br>接下来是两个方案的比较：<br>1、“增量更新”方案非常容易受到干扰，比如获取“a，b，c”这3个值时，任意一个值获取失败，都会导致最新窗口统计值计算失败，<font color='red'>而且更重要的是，当前的错误会一直向后传导。</font><br>2、“全量更新”方案虽然也非常容易受到干扰，<font color='red'>但是当前错误不会向后传导。</font><br>综上，在窗口统计中，应该使用“全量更新”，禁用“增量更新”。</p>
]]></content>
      <categories>
        <category>大数据平台</category>
        <category>Storm</category>
      </categories>
      <tags>
        <tag>Storm统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Surfingkeys快捷键</title>
    <url>/blog/2018/05/30/Surfingkeys%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>Surfingkeys是Chrome浏览器的一个扩展插件，它使得在大多数情况下，我们得以以快捷键的方式与Chrome浏览器进行交互。但是需要注意的是，在有些情形下，它不能正常工作，因此，需要辅以Chrome浏览器的自身快捷键。<br>通过如下配置自定义“J，K”两个快捷键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapkey(&#x27;K&#x27;, &#x27;#2Scroll a page up&#x27;, Normal.scroll.bind(Normal, &quot;pageUp&quot;), &#123;repeatIgnore: true&#125;);</span><br><span class="line">mapkey(&#x27;J&#x27;, &#x27;#2Scroll a page down&#x27;, Normal.scroll.bind(Normal, &quot;pageDown&quot;), &#123;repeatIgnore: true&#125;);</span><br></pre></td></tr></table></figure>
<p>使用快捷键<code>?</code>可打开Surfingkeys帮助页。</p>
<h2 id="一、鼠标点击"><a href="#一、鼠标点击" class="headerlink" title="一、鼠标点击"></a><strong>一、鼠标点击</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>f</td>
<td>在当前标签页打开链接，如果拨号键有重叠按SHIFT，按下拨号键的大写字母形式，可强制在新标签页打开链接</td>
</tr>
<tr>
<td>cf</td>
<td>在新标签页打开多个链接</td>
</tr>
<tr>
<td>gi</td>
<td>跳到第一个输入框</td>
</tr>
<tr>
<td>i</td>
<td>选择输入框</td>
</tr>
</tbody></table>
<h2 id="二、滚动页面-元素"><a href="#二、滚动页面-元素" class="headerlink" title="二、滚动页面&#x2F;元素"></a><strong>二、滚动页面&#x2F;元素</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>j</td>
<td>向下滚动</td>
</tr>
<tr>
<td>k</td>
<td>向上滚动</td>
</tr>
<tr>
<td>J</td>
<td>向下滚动一页，<font color='red'>自定义</font></td>
</tr>
<tr>
<td>K</td>
<td>向上滚动一页，<font color='red'>自定义</font></td>
</tr>
<tr>
<td>G</td>
<td>滚到最下边</td>
</tr>
<tr>
<td>gg</td>
<td>滚到最上边</td>
</tr>
<tr>
<td>h</td>
<td>向左滚动</td>
</tr>
<tr>
<td>l</td>
<td>向右滚动</td>
</tr>
<tr>
<td>0</td>
<td>滚到最左边</td>
</tr>
<tr>
<td>$</td>
<td>滚到最右边</td>
</tr>
<tr>
<td>cs</td>
<td>切换滚动目标</td>
</tr>
<tr>
<td>cS</td>
<td>重置滚动目标</td>
</tr>
<tr>
<td>w</td>
<td>切换frames</td>
</tr>
</tbody></table>
<h2 id="三、标签页"><a href="#三、标签页" class="headerlink" title="三、标签页"></a><strong>三、标签页</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>g0</td>
<td>跳到第一个标签页</td>
</tr>
<tr>
<td>g$</td>
<td>跳到最后一个标签页</td>
</tr>
<tr>
<td>x</td>
<td>关闭当前标签页</td>
</tr>
<tr>
<td>X</td>
<td>恢复刚关闭的标签页</td>
</tr>
<tr>
<td>gx0</td>
<td>关闭左侧所有标签页</td>
</tr>
<tr>
<td>gx$</td>
<td>关闭右侧所有标签页</td>
</tr>
<tr>
<td>yt</td>
<td>复制当前标签页</td>
</tr>
</tbody></table>
<h2 id="四、网页浏览"><a href="#四、网页浏览" class="headerlink" title="四、网页浏览"></a><strong>四、网页浏览</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>su</td>
<td>用VIM编辑器编辑当前地址，按下<code>:w</code>在新标签页打开编辑后地址，按下<code>:q</code>不打开编辑后地址</td>
</tr>
<tr>
<td>S</td>
<td>后退</td>
</tr>
<tr>
<td>D</td>
<td>前进</td>
</tr>
<tr>
<td>r</td>
<td>刷新当前标签页</td>
</tr>
<tr>
<td>B</td>
<td>基于标签页访问历史，后退一个标签页</td>
</tr>
<tr>
<td>F</td>
<td>基于标签页访问历史，前进一个标签页</td>
</tr>
</tbody></table>
<h2 id="五、搜索选中文本"><a href="#五、搜索选中文本" class="headerlink" title="五、搜索选中文本"></a><strong>五、搜索选中文本</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sg</td>
<td>用谷歌搜索选中文本，在新标签页打开</td>
</tr>
</tbody></table>
<h2 id="六、剪贴板"><a href="#六、剪贴板" class="headerlink" title="六、剪贴板"></a><strong>六、剪贴板</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cc</td>
<td>在新标签页打开选中的网址或系统剪贴板里的网址</td>
</tr>
<tr>
<td>ya</td>
<td>复制链接元素链接</td>
</tr>
<tr>
<td>yd</td>
<td>复制当前正在下载的链接</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前地址</td>
</tr>
<tr>
<td>yg</td>
<td>截屏</td>
</tr>
<tr>
<td>yG</td>
<td>截长屏，当存在滚动条时，“yg”和“yG”体现区别</td>
</tr>
<tr>
<td>yS</td>
<td>截屏当前滚动对象</td>
</tr>
<tr>
<td>ymv</td>
<td>选择复制多个指定文本</td>
</tr>
<tr>
<td>ymc</td>
<td>复制表格的多列</td>
</tr>
</tbody></table>
<h2 id="七、搜索栏"><a href="#七、搜索栏" class="headerlink" title="七、搜索栏"></a><strong>七、搜索栏</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>go</td>
<td>在当前标签页打开网页。输入关键词，在候选数据源（包括“最近关闭，书签，访问历史记录”数据）中选择匹配项可直接打开，否则用谷歌搜索关键词</td>
</tr>
<tr>
<td>t</td>
<td>在新标签页打开网页。输入关键词，在候选数据源（包括“最近关闭，书签，访问历史记录”数据）中选择匹配项可直接打开，否则用谷歌搜索关键词</td>
</tr>
<tr>
<td>b</td>
<td>遍历书签</td>
</tr>
<tr>
<td>&#60;Ctrl-.&#62;</td>
<td>显示下一页搜索结果，针对<code>go</code>，<code>t</code>和<code>b</code>快捷键情境</td>
</tr>
<tr>
<td>&#60;Ctrl-,&#62;</td>
<td>显示上一页搜索结果，针对<code>go</code>，<code>t</code>和<code>b</code>快捷键情境</td>
</tr>
<tr>
<td>向下方向键&#x2F;&#60;Tab&#62;</td>
<td>切到下一个匹配项，针对<code>go</code>，<code>t</code>和<code>b</code>快捷键情境</td>
</tr>
<tr>
<td>向上方向键&#x2F;&#60;Shift-Tab&#62;</td>
<td>切回上一个匹配项，针对<code>go</code>，<code>t</code>和<code>b</code>快捷键情境</td>
</tr>
<tr>
<td>Q</td>
<td>打开搜索栏查单词</td>
</tr>
<tr>
<td>ab</td>
<td>保存当前页面作为书签</td>
</tr>
<tr>
<td>;db</td>
<td>从书签删除当前网址</td>
</tr>
</tbody></table>
<h2 id="八、可视模式"><a href="#八、可视模式" class="headerlink" title="八、可视模式"></a><strong>八、可视模式</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>切换可视模式</td>
</tr>
<tr>
<td>0</td>
<td>跳到行首</td>
</tr>
<tr>
<td>$</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>l</td>
<td>前进一个字符</td>
</tr>
<tr>
<td>h</td>
<td>后退一个字符</td>
</tr>
<tr>
<td>j</td>
<td>下一行</td>
</tr>
<tr>
<td>k</td>
<td>上一行</td>
</tr>
<tr>
<td>)</td>
<td>前进一个句子</td>
</tr>
<tr>
<td>(</td>
<td>后退一个句子</td>
</tr>
<tr>
<td>}</td>
<td>前进一个段落</td>
</tr>
<tr>
<td>{</td>
<td>后退一个段落</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>在当前页查找</td>
</tr>
<tr>
<td>*</td>
<td>在当前页查找选中文本</td>
</tr>
<tr>
<td>n</td>
<td>下一处查找命中</td>
</tr>
<tr>
<td>N</td>
<td>上一处查找命中</td>
</tr>
<tr>
<td>&#60;Enter&#62;</td>
<td>点击光标下的元素，<font color='red'>很好的“f”和“cf”快捷键的补充机制</font></td>
</tr>
</tbody></table>
<h2 id="九、Chrome内置功能"><a href="#九、Chrome内置功能" class="headerlink" title="九、Chrome内置功能"></a><strong>九、Chrome内置功能</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>;j</td>
<td>关闭下载完毕的提示框，如果下载未完成，则取消下载，<font color='red'>并且会清空下载管理器内容</font></td>
</tr>
<tr>
<td>gb</td>
<td>打开书签管理器</td>
</tr>
<tr>
<td>gd</td>
<td>打开下载管理器</td>
</tr>
<tr>
<td>gs</td>
<td>查看网页源码</td>
</tr>
</tbody></table>
<h2 id="十、类Vim书签"><a href="#十、类Vim书签" class="headerlink" title="十、类Vim书签"></a><strong>十、类Vim书签</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>定义类Vim书签。如果定义书签名称位于<code>a-z</code>范围内，那么书签有效作用域限于定义所处标签页；如果定义书签名称位于<code>A-Z0-9</code>范围内，那么书签有效作用域跨标签页</td>
</tr>
<tr>
<td>‘</td>
<td>跳转到类Vim书签。如果定义书签名称位于<code>a-z</code>范围内，那么跳转到书签定义所对应页面位置；如果定义书签名称位于<code>A-Z0-9</code>范围内，那么在当前标签页打开书签定义所对应页面</td>
</tr>
</tbody></table>
<p><strong>备注：</strong><br>基于使用简化考虑，只考虑<code>a-zA-Z0-9</code>类Vim书签名称</p>
<h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a><strong>十一、其他</strong></h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>;s</td>
<td>在“Chrome浏览器内置PDF阅读器”与“Surfingkeys PDF阅读器”间切换</td>
</tr>
<tr>
<td>&#60;Alt-s&#62;</td>
<td>在当前网站开关Surfingkeys</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]参考“在网页按下‘?’字符打开的默认快捷键表”
[2]https://github.com/brookhong/surfingkeys
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Terminal，Tmux和Shell三角关系</title>
    <url>/blog/2018/05/31/Terminal%EF%BC%8CTmux%E5%92%8CShell%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>本博文属于自我理解性质，请知悉。</p>
<h2 id="一、Terminal"><a href="#一、Terminal" class="headerlink" title="一、Terminal"></a><strong>一、Terminal</strong></h2><p>一个Terminal进程主要提供一个窗口，有些支持多标签页，允许存在多个独立的Terminal进程，跟Chrome进程类似。Terminal作为独立的应用程序，有自己的快捷键体系，可参见<a href="/blog/2018/05/31/Gnome-Terminal%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Gnome Terminal快捷键">Gnome Terminal快捷键</a>（Gnome Terminal是Terminal的一种）。</p>
<h2 id="二、Tmux"><a href="#二、Tmux" class="headerlink" title="二、Tmux"></a><strong>二、Tmux</strong></h2><p>Tmux是分屏软件的一种（比如还有Screen）。Tmux基于Terminal，对Terminal的独立窗口或者标签页窗口进行分屏操作，获得Tmux窗口或者窗格。Tmux作为独立的应用程序，有自己的快捷键体系，可参见<a href="/blog/2018/05/30/Tmux%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Tmux快捷键">Tmux快捷键</a>。</p>
<h2 id="三、Shell"><a href="#三、Shell" class="headerlink" title="三、Shell"></a><strong>三、Shell</strong></h2><p>Shell作为壳程序，形式上寄生于Terminal的独立窗口或者标签页窗口，Tmux的窗口或者窗格，但是内容上却是核心基石，没有Shell，Terminal和Tmux都没有存在的意义。Shell作为独立的应用程序，有自己的快捷键体系，可参见<a href="/blog/2018/05/31/Bash-Shell%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Bash Shell快捷键">Bash Shell快捷键</a>（Bash Shell是Shell的一种）。</p>
<p><font color='red'>归纳总结</font>，Terminal，Tmux，Shell三者紧密相连（使用Shell的<code>Ctrl+d</code>快捷键或者<code>exit</code>命令退出Shell，就会自动退出Terminal的独立窗口或者标签页窗口，Tmux的窗口或者窗格。<font color='red'>从另外一个角度陈述，Terminal的独立窗口或者标签页窗口，Tmux的窗口或者窗格都不能脱离Shell单独存在</font>），很难（比如很难区分某个快捷键到底是属于Terminal、Tmux还是Shell）也没有必要对三者进行明确的隔离区分。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadPoolExecutor</title>
    <url>/blog/2021/05/13/ThreadPoolExecutor/</url>
    <content><![CDATA[<p>ThreadPoolExecutor类，是一个“使用线程池调度执行所提交任务”的执行器，可简称“TPE”，它在日常工作中经常被用到，十分重要。</p>
<p>TPE继承类图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210513-0-1.svg"></p>
<h2 id="一、核心原理"><a href="#一、核心原理" class="headerlink" title="一、核心原理"></a><strong>一、核心原理</strong></h2><p>查看ThreadPoolExecutor类源码，理解其核心原理。带有笔者注释的版本见<a href="https://github.com/dslztx/jdk8_study/blob/master/src/main/java/java/util/concurrent/ThreadPoolExecutor.java">链接</a>。</p>
<h3 id="1-1、执行器状态和Worker数量上限"><a href="#1-1、执行器状态和Worker数量上限" class="headerlink" title="1.1、执行器状态和Worker数量上限"></a><strong>1.1、执行器状态和Worker数量上限</strong></h3><p>存在成员变量<code>AtomicInteger ctl</code>，其对应的整型值有32位比特，分段表示不同的含义：</p>
<ul>
<li>低29位，记录执行器当前Worker数量，因此，Worker数量的上限值为<code>(1&lt;&lt;29)-1</code></li>
<li>高3位，记录执行器的状态（根据以下状态值，可知有<code>RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED</code>）<ul>
<li>RUNNING，值为<code>-1&lt;&lt;29</code>，即<code>111,[29个0]</code>，正常运行态</li>
<li>SHUTDOWN，值为<code>0&lt;&lt;29</code>，即<code>000,[29个0]</code>，继续执行“Worker中当前正在执行的任务”和“workQueue中的任务”，禁止新提交任务，当所有Worker都退出后，经历<code>TIDYING -&gt; TERMINATED</code></li>
<li>STOP，值为<code>1&lt;&lt;29</code>，即<code>001,[29个0]</code>，给所有Worker中正在执行的任务发出中断信号（当然，正在执行的任务如何响应该中断信号由其自身决定，可以不响应的[1]），“workQueue中的任务”被立即提取出来返回给调用者（即，这些任务不会再被执行），禁止新提交任务，当所有Worker都退出后，经历<code>TIDYING -&gt; TERMINATED</code></li>
<li>TIDYING，值为<code>2&lt;&lt;29</code>，即<code>010,[29个0]</code>，一个临时的中间状态</li>
<li>TERMINATED，值为<code>3&lt;&lt;29</code>，即<code>011,[29个0]</code>，执行器成功关闭，Worker数量为0，workQueue为空</li>
</ul>
</li>
</ul>
<h3 id="1-2、任务队列"><a href="#1-2、任务队列" class="headerlink" title="1.2、任务队列"></a><strong>1.2、任务队列</strong></h3><p>存在成员变量<code>BlockingQueue&lt;Runnable&gt; workQueue</code>：表示任务队列，当<code>Worker数量=corePoolSize</code>时，新提交的任务被插入到该队列，一般是有界队列，否则当提交任务过多时，会导致内存OOM，而且超大无界队列尾部的任务长时间得不到执行一般也非所欲，宁可及早发现。</p>
<p>JDK 1.8中<code>BlockingQueue</code>的实现子类详见<a href="/blog/2021/08/11/%E5%B9%B6%E5%8F%91Queue/" title="并发Queue">《并发Queue》</a>中的阻塞队列。</p>
<h3 id="1-3、拒绝执行策略"><a href="#1-3、拒绝执行策略" class="headerlink" title="1.3、拒绝执行策略"></a><strong>1.3、拒绝执行策略</strong></h3><p>存在成员变量<code>RejectedExecutionHandler handler</code>：表示拒绝执行策略类。</p>
<p>有4种拒绝执行策略：</p>
<ul>
<li>AbortPolicy：抛出<code>RejectedExecutionException</code>异常。<font color='red'>默认策略</font></li>
<li>DiscardPolicy：直接忽略</li>
<li>CallerRunsPolicy：当执行器状态为<code>RUNNING</code>时，由提交任务的线程自身去执行；否则，直接忽略</li>
<li>DiscardOldestPolicy：当执行器状态为<code>RUNNING</code>时，丢弃workQueue队列队首任务，然后再重新提交任务；否则，直接忽略</li>
</ul>
<h3 id="1-4、线程工厂方法类"><a href="#1-4、线程工厂方法类" class="headerlink" title="1.4、线程工厂方法类"></a><strong>1.4、线程工厂方法类</strong></h3><p>存在成员变量<code>ThreadFactory threadFactory</code>：新增一个Worker时，会用该工厂方法类创建一个新的绑定到该Worker的Thread实例，具体通过其内的<code>Thread newThread(Runnable r)</code>方法进行创建，推荐提供一个自定义实现的ThreadFactory子类，覆盖实现<code>Thread newThread(Runnable r)</code>方法，使创建得到的Thread实例名字具备强可读性，便于后续排查问题。</p>
<p>默认的线程工厂方法类是<code>Executors.defaultThreadFactory()</code>，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() + <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个比较好的线程工厂方法类是<code>com.alibaba.csp.sentinel.concurrent.NamedThreadFactory</code>，其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NamedThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamedThreadFactory</span><span class="params">(String namePrefix, <span class="type">boolean</span> daemon)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadNumber = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.daemon = daemon;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="built_in">this</span>.group = s != <span class="literal">null</span> ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="built_in">this</span>.namePrefix = namePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamedThreadFactory</span><span class="params">(String namePrefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(namePrefix, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>.group, r, <span class="built_in">this</span>.namePrefix + <span class="string">&quot;-thread-&quot;</span> + <span class="built_in">this</span>.threadNumber.getAndIncrement(), <span class="number">0L</span>);</span><br><span class="line">        t.setDaemon(<span class="built_in">this</span>.daemon);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5、Worker"><a href="#1-5、Worker" class="headerlink" title="1.5、Worker"></a><strong>1.5、Worker</strong></h3><h4 id="1-5-1、基本"><a href="#1-5-1、基本" class="headerlink" title="1.5.1、基本"></a><strong>1.5.1、基本</strong></h4><p>TPE中的执行实体是Worker，关于该类有以下几点说明：</p>
<ul>
<li>继承实现AQS接口，实现了非可重入的排他锁逻辑</li>
<li>继承自Runnable接口，故是一个执行实体，它的<code>run()</code>方法转发调用外围TPE实例的<code>runWorker(Worker w)</code>方法</li>
<li>每个Worker对应一个Thread，在该Thread中执行该Worker，Worker内有一个实例成员变量<code>final Thread thread</code>指向该Thread，虽然这个不是必需的，因为在Worker运行过程中可通过<code>Thread.currentThread()</code>语句获取到该Thread</li>
</ul>
<p><font color='red'>需要注意的是</font>：我们常说线程数量，而不是Worker数量，这两者本质是等价的。</p>
<h4 id="1-5-2、运转"><a href="#1-5-2、运转" class="headerlink" title="1.5.2、运转"></a><strong>1.5.2、运转</strong></h4><p><code>runWorker(Worker w)</code>方法的核心逻辑是：不断获取任务调度执行。</p>
<p>任务来源有两个：</p>
<ul>
<li>创建生成Worker实例时传递的初始任务（可以为空），该任务被获取执行最多一次</li>
<li>调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到任务时挂起</li>
</ul>
<h4 id="1-5-3、退出机制"><a href="#1-5-3、退出机制" class="headerlink" title="1.5.3、退出机制"></a><strong>1.5.3、退出机制</strong></h4><p>有3种退出机制：</p>
<ol>
<li>退出机制1：任务执行过程中抛出未被内部catch住的异常，导致Worker退出</li>
<li>退出机制2：一般情况下，调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到时恒挂起。但是当<code>Worker数量&gt;corePoolSize || 成员变量allowCoreThreadTimeOut=true</code>条件判断语句返回结果为<code>true</code>时：<ul>
<li><code>成员变量keepAliveTime&gt;0</code>，尝试从workQueue队列获取任务，挂起成员变量keepAliveTime指定时间，如果过期仍未获取到任务，则<code>getTask()</code>方法返回<code>NULL</code>，继而导致Worker退出</li>
<li><code>成员变量keepAliveTime=0</code>，尝试从workQueue队列获取任务，不进行挂起，<code>getTask()</code>方法直接返回<code>NULL</code>，继而导致Worker退出</li>
</ul>
</li>
<li>退出机制3：一般情况下，调用<code>getTask()</code>方法从workQueue队列获取任务，获取不到时恒挂起。但是当<code>执行器的状态&gt;=STOP || (执行器的状态=SHUTDOWN &amp;&amp; workQueue为空)</code>，此时调用<code>getTask()</code>方法会直接返回<code>NULL</code>，继而导致Worker退出</li>
</ol>
<p><font color='red'>需要注意的是</font>：每次Worker退出都会去调用<code>tryTerminate()</code>方法，查看执行器是否能够进入<code>TERMINATED</code>状态。</p>
<h4 id="1-5-4、中断"><a href="#1-5-4、中断" class="headerlink" title="1.5.4、中断"></a><strong>1.5.4、中断</strong></h4><p>根据[1]知道，对于中断信号如何响应处理，由具体程序具体决定，可以不响应处理的。 </p>
<h5 id="1-5-4-1、Worker运转过程中的中断信号处理点"><a href="#1-5-4-1、Worker运转过程中的中断信号处理点" class="headerlink" title="1.5.4.1、Worker运转过程中的中断信号处理点"></a><strong>1.5.4.1、Worker运转过程中的中断信号处理点</strong></h5><p>Worker运转过程中有3个中断信号处理点（其中一个是“<font color='red'>潜在可能点</font>”）：<br><strong>点1</strong>：<code>getTask()</code>方法中的<code>workQueue.poll</code>或者<code>workQueue.take</code>语句，即中断获取任务的挂起，<code>workQueue.poll</code>或者<code>workQueue.take</code>语句响应中断，抛出<code>InterruptedException</code>异常，复位中断标志位，接着进入下一轮循环：首先判断是否满足直接返回NULL的条件（此时，触发Worker的“退出机制2”或者“退出机制3”），不满足则继续调用<code>workQueue.poll</code>或者<code>workQueue.take</code>语句进行获取任务的挂起<br><strong>点2</strong>：<code>runWorker()</code>方法中的如下源码，它表示的含义是：当执行器的状态&gt;&#x3D;STOP时，如果已有中断信号则传递下去，否则自中断产生一个中断信号；否则，即执行器的状态&#60;STOP时，对已有的中断标志位进行复位<br><strong>点3</strong>：真正的任务执行过程中，即<code>task.run()</code>执行过程中，它是<font color='red'>潜在可能点，即对中断信号是否处理是未定的</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br></pre></td></tr></table></figure>

<h5 id="1-5-4-2、中断信号来源"><a href="#1-5-4-2、中断信号来源" class="headerlink" title="1.5.4.2、中断信号来源"></a><strong>1.5.4.2、中断信号来源</strong></h5><p>对于针对Worker运转的中断信号来源，这里介绍的来自于TPE内部逻辑，而不考虑其他的（比如“在<code>task.run()</code>自中断”，“以任意可行的方式获取Worker对应的Thread实例，在其上调用<code>interrupt()</code>方法”等）。</p>
<p>在继续介绍之前，首先介绍“Idle Worker”的概念：查看源码1中的<code>w.lock()</code>和源码2中的<code>w.tryLock()</code>语句，可知“Idle Worker”就是还未获取到任务的Worker。</p>
<p>源码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自于TPE内部逻辑的中断信号：</p>
<ul>
<li>调用<code>shutdown()</code>方法，其内部调用<code>interruptIdleWorkers()</code>方法，它会给所有“Idle Worker”发送中断信号（此时执行器状态为<code>SHUTDOWN</code>），该中断信号只能被“点1”或者“点2（存在一种进入‘点2’的并发情形）”响应处理，而不能到达“点3”</li>
<li>调用<code>shutdownNow()</code>方法，其内部调用<code>interruptWorkers()</code>方法，它会给所有“Worker”发送中断信号（此时执行器状态为<code>STOP</code>），该中断信号可能被“点1”或者“点2”或者“点3”响应处理，或者继续存在</li>
<li>如果执行器的状态&gt;&#x3D;STOP，且当下没有中断信号，那么在“点2”处自中断，产生一个中断信号，该中断信号可能被“点3”响应处理，或者继续存在</li>
</ul>
<h4 id="1-5-5、数量"><a href="#1-5-5、数量" class="headerlink" title="1.5.5、数量"></a><strong>1.5.5、数量</strong></h4><h5 id="1-5-5-1、执行器状态-RUNNING"><a href="#1-5-5-1、执行器状态-RUNNING" class="headerlink" title="1.5.5.1、执行器状态&#x3D;RUNNING"></a><strong>1.5.5.1、执行器状态&#x3D;RUNNING</strong></h5><p><strong>影响Worker数量之提交任务</strong>：</p>
<ol>
<li>最开始也即没有提交任何任务时，此时<code>Worker数量=0</code>，随着任务的提交，线性递增Worker数量直到<code>Worker数量=corePoolSize</code>，在本阶段，当有新的提交任务时，直接新增一个Worker，而不管已有Worker是否空闲</li>
<li>在<code>Worker数量=corePoolSize</code>时，继续提交任务，那么新提交的任务会被插入到workQueue队列，<font color='red'>当workQueue队列是无界队列时，永远不可能进入阶段3和阶段4，但一般workQueue为有界队列</font></li>
<li>当<code>Worker数量=corePoolSize</code>，workQueue队列为有界队列且队列已满，此时继续提交任务，新增一个Worker，直到<code>Worker数量=maximumPoolSize</code></li>
<li>当<code>Worker数量=maximumPoolSize</code>，workQueue队列为有界队列且队列已满，此时继续提交任务，触发“拒绝执行策略”</li>
</ol>
<p>以上步骤示意图见图2。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20210513-0-2.png"></p>
<p><strong>影响Worker数量之Worker退出</strong>：</p>
<ol>
<li>退出机制1</li>
<li>退出机制2</li>
</ol>
<h5 id="1-5-5-2、执行器状态-SHUTDOWN"><a href="#1-5-5-2、执行器状态-SHUTDOWN" class="headerlink" title="1.5.5.2、执行器状态&gt;&#x3D;SHUTDOWN"></a><strong>1.5.5.2、执行器状态&gt;&#x3D;SHUTDOWN</strong></h5><p><strong>影响Worker数量之提交任务</strong>：禁止提交，触发“拒绝执行策略”。</p>
<p><strong>影响Worker数量之Worker退出</strong>：</p>
<ol>
<li>退出机制1</li>
<li>退出机制2</li>
<li>退出机制3</li>
</ol>
<h2 id="二、具体动作"><a href="#二、具体动作" class="headerlink" title="二、具体动作"></a><strong>二、具体动作</strong></h2><h3 id="2-1、构造TPE"><a href="#2-1、构造TPE" class="headerlink" title="2.1、构造TPE"></a><strong>2.1、构造TPE</strong></h3><p>构造TPE实例的构造方法涉及到的所有参数如下：</p>
<ul>
<li><code>int corePoolSize</code>，对应成员变量<code>int corePoolSize</code></li>
<li><code>int maximumPoolSize</code>，对应成员变量<code>int maximumPoolSize</code></li>
<li><code>long keepAliveTime</code>和<code>TimeUnit unit</code>，对应成员变量<code>long keepAliveTime</code></li>
<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>，对应成员变量<code>BlockingQueue&lt;Runnable&gt; workQueue</code></li>
<li><code>ThreadFactory threadFactory</code>，对应成员变量<code>ThreadFactory threadFactory</code></li>
<li><code>RejectedExecutionHandler handler</code>，对应成员变量<code>RejectedExecutionHandler handler</code></li>
</ul>
<p>上述成员变量在TPE实例构造完成后都可被动态修改，除了<code>BlockingQueue&lt;Runnable&gt; workQueue</code>成员变量，<font color='red'>但是不推荐进行动态修改</font>。</p>
<h3 id="2-2、提交任务"><a href="#2-2、提交任务" class="headerlink" title="2.2、提交任务"></a><strong>2.2、提交任务</strong></h3><p>分为两类：</p>
<ol>
<li>只提交任务，不关注执行结果，不能对执行过程进行控制：<ul>
<li><code>public void execute(Runnable command)</code>，执行<code>command</code>实例对象的<code>run()</code>方法，不关注执行结果，其实也没有执行结果，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
</ul>
</li>
<li>提交任务后，通过Future可获取执行结果，也可对执行过程进行控制（关于Future，Runnable，Callable的关系可详见<a href="/blog/2021/05/16/FutureTask%E5%92%8CScheduledFutureTask/" title="FutureTask和ScheduledFutureTask">《FutureTask和ScheduledFutureTask》</a>）：<ul>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>，执行<code>task</code>实例对象的<code>call()</code>方法，获取的执行结果为<code>call()</code>方法的执行结果</li>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>，执行<code>task</code>实例对象的<code>run()</code>方法，获取的执行结果为预设的执行结果NULL，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
<li><code>public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>，执行<code>task</code>实例对象的<code>run()</code>方法，获取的执行结果为预设的执行结果result，因为Runnable实例的<code>run()</code>方法并没有执行结果</li>
</ul>
</li>
</ol>
<h3 id="2-3、关闭执行器"><a href="#2-3、关闭执行器" class="headerlink" title="2.3、关闭执行器"></a><strong>2.3、关闭执行器</strong></h3><p>有两个关闭方法：<code>shutdown()</code>和<code>shutdownNow()</code>。<br><strong>1、shutdown()</strong><br>方法体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);                               <span class="comment">//1</span></span><br><span class="line">        interruptIdleWorkers();                                  <span class="comment">//2</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor    //3</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();                                              <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<ul>
<li>&#x2F;&#x2F;1，将执行器状态变为<code>SHUTDOWN</code></li>
<li>&#x2F;&#x2F;2，给“Idle Worker”发中断信号，详见“1.5.4.2、中断信号来源”小节</li>
<li>&#x2F;&#x2F;3，空实现</li>
<li>&#x2F;&#x2F;4，<code>tryTerminate()</code>，查看执行器是否能够进入<code>TERMINATED</code>状态。Worker退出的时候也会调用该方法</li>
</ul>
<p><strong>2、shutdownNow()</strong><br>方法体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);                            <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        interruptWorkers();                               <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        tasks = drainQueue();                             <span class="comment">//3</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();                                       <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<ul>
<li>&#x2F;&#x2F;1，将执行器状态变为<code>STOP</code></li>
<li>&#x2F;&#x2F;2，给所有Worker发中断信号，详见“1.5.4.2、中断信号来源”小节</li>
<li>&#x2F;&#x2F;3，把workQueue中的任务直接返回给调用者，并将其清空</li>
<li>&#x2F;&#x2F;4，<code>tryTerminate()</code>，查看执行器是否能够进入<code>TERMINATED</code>状态。Worker退出的时候也会调用该方法</li>
</ul>
<h2 id="三、监控"><a href="#三、监控" class="headerlink" title="三、监控"></a><strong>三、监控</strong></h2><p>TPE类提供了很多监控API（需要注意的是，在并发语境中，API调用返回的是某个并发瞬时值），如果需要可以实现一个异步监控任务对执行器的状态进行监控：</p>
<ul>
<li><code>int getCorePoolSize()</code>：设置的核心Worker数量，即成员变量<code>corePoolSize</code>值</li>
<li><code>int getMaximumPoolSize()</code>：设置的最大Worker数量，即成员变量<code>maximumPoolSize</code>值</li>
<li><code>int getLargestPoolSize()</code>：历史峰值Worker数量</li>
<li><code>int getPoolSize()</code>：当前Worker数量，需要注意的是，当<code>执行器状态&gt;=TIDYING</code>时，返回0</li>
<li><code>int getActiveCount()</code>：当前活跃Worker（即正在执行任务的Worker）数量</li>
<li><code>long getCompletedTaskCount()</code>：已经完成的任务总数</li>
<li><code>long getTaskCount</code>：是“已经完成的任务总数”，“正在执行的任务总数”和“workQueue队列中的任务总数”三部分之和</li>
</ul>
<h2 id="四、最佳实践"><a href="#四、最佳实践" class="headerlink" title="四、最佳实践"></a><strong>四、最佳实践</strong></h2><h3 id="4-1、核心Worker数量"><a href="#4-1、核心Worker数量" class="headerlink" title="4.1、核心Worker数量"></a><strong>4.1、核心Worker数量</strong></h3><p>我们知道，“核心Worker数量”与“核心线程数量”等价。</p>
<p>核心线程数量根据执行的任务是属于“CPU密集型”还是“IO密集型”进行配置：</p>
<ul>
<li>CPU密集型。执行CPU密集型任务的线程大部分时间处于<code>RUNNING</code>状态[1]，因此只有在真正的多核CPU上才可能得到加速，在单核CPU上并不能得到很大的加速，一般公式为：<code>核心线程数量=CPU核数+1</code></li>
<li>IO密集型。执行IO密集型任务的线程大部分时间处于<code>IO_WAIT</code>状态[1]，处于<code>IO_WAIT</code>状态时未占用CPU资源，相应的CPU资源资源可分配给其他线程，因此对于IO密集型任务，可配置远大于CPU核数的线程数，一般公式为：<code>核心线程数量=CPU核数*2</code></li>
</ul>
<p><strong>备注</strong>：可通过<code>Runtime.getRuntime().availableProcessors()</code>语句获取CPU核数</p>
<h3 id="4-2、一般情况下只需关注执行器的RUNNING状态"><a href="#4-2、一般情况下只需关注执行器的RUNNING状态" class="headerlink" title="4.2、一般情况下只需关注执行器的RUNNING状态"></a><strong>4.2、一般情况下只需关注执行器的<code>RUNNING</code>状态</strong></h3><p>一般情况下只需关注执行器的<code>RUNNING</code>状态，无需关注其他状态，理解处于<code>RUNNING</code>状态的执行器内部运转还是较为简单的。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a><br>[2]<a href="https://www.cnblogs.com/andy-songwei/p/10784049.html">https://www.cnblogs.com/andy-songwei/p/10784049.html</a><br>[3]<a href="https://www.hollischuang.com/archives/6338">https://www.hollischuang.com/archives/6338</a><br>[4]<a href="https://www.jianshu.com/p/3001431f1b0a">https://www.jianshu.com/p/3001431f1b0a</a><br>[5]<a href="https://mp.weixin.qq.com/s/axWymUaYaARtvsYqvfyTtw">https://mp.weixin.qq.com/s/axWymUaYaARtvsYqvfyTtw</a><br>[6]<a href="https://www.cnblogs.com/thisiswhy/p/12690630.html">https://www.cnblogs.com/thisiswhy/p/12690630.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Thunderbird快捷键</title>
    <url>/blog/2018/05/30/Thunderbird%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>安装“Nostalgy”插件，从而获得使用快捷键“快速定位邮箱文件夹，在邮箱文件夹间快速复制和移动消息”的能力。</p>
<h2 id="一、Nostalgy插件提供快捷键"><a href="#一、Nostalgy插件提供快捷键" class="headerlink" title="一、Nostalgy插件提供快捷键"></a><strong>一、Nostalgy插件提供快捷键</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>快速定位到指定邮箱文件夹</td>
<td>g</td>
</tr>
<tr>
<td>快速移动选中消息到指定邮箱文件夹</td>
<td>s</td>
</tr>
<tr>
<td>快速复制选中消息到指定邮箱文件夹</td>
<td>c</td>
</tr>
</tbody></table>
<h2 id="二、消息查"><a href="#二、消息查" class="headerlink" title="二、消息查"></a><strong>二、消息查</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>定位到下一个消息，可以查看选中消息概要信息</td>
<td>向下方向键</td>
</tr>
<tr>
<td>定位到上一个消息，可以查看选中消息概要信息</td>
<td>向上方向键</td>
</tr>
<tr>
<td>在新窗口或标签页中打开消息</td>
<td>Enter</td>
</tr>
<tr>
<td>查看源码</td>
<td>Ctrl+u</td>
</tr>
<tr>
<td>获取当前账户的新消息</td>
<td>F5</td>
</tr>
<tr>
<td>获取全部账户的新消息</td>
<td>Shift+F5</td>
</tr>
<tr>
<td>搜索全部消息（在全部账户中全文搜索）</td>
<td>Ctrl+k</td>
</tr>
<tr>
<td>快速过滤（在当前文件夹中搜索）</td>
<td>Ctrl+Shift+k</td>
</tr>
<tr>
<td>搜索消息（高级搜索）</td>
<td>Ctrl+Shift+f</td>
</tr>
</tbody></table>
<h2 id="三、消息删"><a href="#三、消息删" class="headerlink" title="三、消息删"></a><strong>三、消息删</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>删除选中消息</td>
<td>Del</td>
</tr>
<tr>
<td>彻底删除选中消息</td>
<td>Shift+Del</td>
</tr>
</tbody></table>
<h2 id="四、消息增"><a href="#四、消息增" class="headerlink" title="四、消息增"></a><strong>四、消息增</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>新建消息</td>
<td>Ctrl+n</td>
</tr>
<tr>
<td>回复发件人</td>
<td>Ctrl+r</td>
</tr>
<tr>
<td>全部回复（发件人和所有收件人）</td>
<td>Ctrl+Shift+r</td>
</tr>
<tr>
<td>转发</td>
<td>Ctrl+l</td>
</tr>
<tr>
<td>保存草稿</td>
<td>Ctrl+s</td>
</tr>
<tr>
<td>立即发送</td>
<td>Ctrl+Enter</td>
</tr>
<tr>
<td>下一个控件（循环）</td>
<td>Ctrl+Tab</td>
</tr>
</tbody></table>
<h2 id="五、标签页和窗口"><a href="#五、标签页和窗口" class="headerlink" title="五、标签页和窗口"></a><strong>五、标签页和窗口</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>下一个标签页</td>
<td>Ctrl+PageDown</td>
</tr>
<tr>
<td>上一个标签页</td>
<td>Ctrl+PageUp</td>
</tr>
<tr>
<td>关闭窗口或标签页</td>
<td>Ctrl+w</td>
</tr>
<tr>
<td>恢复上次关闭的标签页</td>
<td>Ctrl+Shift+t</td>
</tr>
<tr>
<td>退出Thunderbird</td>
<td>Ctrl+q</td>
</tr>
</tbody></table>
<h2 id="六、通讯录"><a href="#六、通讯录" class="headerlink" title="六、通讯录"></a><strong>六、通讯录</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>打开通讯录</td>
<td>Ctrl+Shift+b</td>
</tr>
<tr>
<td>新建联系人</td>
<td>Ctrl+n</td>
</tr>
<tr>
<td>给选中的联系人写消息</td>
<td>Ctrl+m</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]https://support.mozilla.org/zh-CN/kb/Thunderbird%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Thunderbird</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux快捷键</title>
    <url>/blog/2018/05/30/Tmux%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>通过<code>tmux new-session或者tmux</code>命令创建一个Tmux会话，由于作者的使用模式是“一个Tmux窗口，多个Tmux窗格”，因此通过“退出所有Tmux窗格和唯一的Tmux窗口”的形式来退出上述Tmux会话。<br>当只有一个窗格时，窗口即窗格，窗格即窗口。<br>作者具体的Tmux配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 改变Tmux快捷键前缀</span><br><span class="line">unbind C-b</span><br><span class="line">set -g prefix C-f</span><br><span class="line"></span><br><span class="line"># 分别重定义定位到上、下、左、右侧窗格的快捷键主键</span><br><span class="line">bind-key k select-pane -U</span><br><span class="line">bind-key j select-pane -D</span><br><span class="line">bind-key h select-pane -L</span><br><span class="line">bind-key l select-pane -R</span><br><span class="line"></span><br><span class="line"># 定义在复制模式下，按下“v”字符开始选取待复制内容</span><br><span class="line">bind-key -t vi-copy &#x27;v&#x27; begin-selection</span><br><span class="line"></span><br><span class="line"># 定义按下“y”字符将复制模式下待复制内容复制到Tmux内存</span><br><span class="line">bind-key -t vi-copy &#x27;y&#x27; copy-selection</span><br><span class="line"></span><br><span class="line"># 定义按下“快捷键前缀+p”从Tmux内存中复制粘贴“复制模式下待复制内容”到本地，由于跟Tmux内存交互，需要在Tmux程序作用域内</span><br><span class="line">bind p paste-buffer</span><br><span class="line"></span><br><span class="line"># 定义按下“Y”字符将复制模式下待复制内容复制到X System内存（放在X System内存的优势在于非Tmux程序也可以复制粘贴）</span><br><span class="line">bind-key -t vi-copy &#x27;Y&#x27; copy-pipe &#x27;xclip -i -selection clipboard&#x27;</span><br><span class="line"></span><br><span class="line"># 定义按下“快捷键前缀+P”从X System内存中复制粘贴“复制模式下待复制内容”到本地</span><br><span class="line">bind-key &#x27;P&#x27; run-shell &quot;tmux set-buffer \&quot;$(xclip -o -selection clipboard)\&quot;; tmux paste-buffer&quot;</span><br></pre></td></tr></table></figure>
<h2 id="一、窗口和窗格"><a href="#一、窗口和窗格" class="headerlink" title="一、窗口和窗格"></a><strong>一、窗口和窗格</strong></h2><table>
<thead>
<tr>
<th>描述</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>垂直分隔窗口，得到左右两个窗格</td>
<td>PREFIX+%</td>
</tr>
<tr>
<td>水平分隔窗口，得到上下两个窗格</td>
<td>PREFIX+”</td>
</tr>
<tr>
<td>退出窗格</td>
<td><code>Ctrl+d</code>快捷键或者<code>exit</code>命令，这两者本质上是Shell的快捷键和命令，不属于Tmux</td>
</tr>
<tr>
<td>强制关闭窗格</td>
<td>PREFIX+x</td>
</tr>
<tr>
<td>定位到左侧窗格（循环）</td>
<td>PREFIX+h</td>
</tr>
<tr>
<td>定位到右侧窗格（循环）</td>
<td>PREFIX+l</td>
</tr>
<tr>
<td>定位到上侧窗格（循环）</td>
<td>PREFIX+k</td>
</tr>
<tr>
<td>定位到下侧窗格（循环）</td>
<td>PREFIX+j</td>
</tr>
<tr>
<td>向上移动窗格</td>
<td>PREFIX+{</td>
</tr>
<tr>
<td>向下移动窗格</td>
<td>PREFIX+}</td>
</tr>
<tr>
<td>重新布局窗格</td>
<td>PREFIX+<code>Shift+Space</code></td>
</tr>
<tr>
<td>快速跳到相应窗格</td>
<td>PREFIX+f q，然后按下相应的数字（只能是0-9）</td>
</tr>
</tbody></table>
<h2 id="二、Tmux复制模式"><a href="#二、Tmux复制模式" class="headerlink" title="二、Tmux复制模式"></a><strong>二、Tmux复制模式</strong></h2><p>按下<code>PREFIX+[</code>快捷键进入复制模式，在复制模式下按下<code>q</code>字符退出复制模式。<br>复制模式类似于Vim的普通模式，键盘操作风格也类似，在复制模式下，按下<code>v</code>字符，进行待复制内容的选取，类似于进入Vim的可视模式，键盘操作风格也类似。<br><font color='red'>需要注意的是，上述键盘操作风格可通过配置修改成非Vim风格。</font><br>待复制内容选取完成后，根据上述配置文件说明可知，有两种情形，详细描述可见图1和图2。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180530-0-1.svg"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20180530-0-2.svg"></p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04设置LC_CTYPE错误</title>
    <url>/blog/2017/08/01/Ubuntu-16-04%E8%AE%BE%E7%BD%AELC-CTYPE%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>作者的Ubuntu 16.04已经在“系统设置–语言支持”中安装了“汉语”。</p>
<h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a><strong>一、问题背景</strong></h2><p>在应用中，需要将“LC_CTYPE”环境变量值设为“zh_CN.gbk”，执行<code>export LC_CTYPE=zh_CN.gbk</code>命令，出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash: 警告: setlocale: LC_CTYPE: 无法改变区域选项 (zh_CN.gbk): 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a><strong>二、问题原因</strong></h2><p>以上错误提示系统不支持“zh_CN.gbk”语言模块，执行<code>locale -a</code>命令查看系统支持的语言模块，果然不包含“zh_CN.gbk”。具体结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">en_AG</span><br><span class="line">en_AG.utf8</span><br><span class="line">en_AU.utf8</span><br><span class="line">en_BW.utf8</span><br><span class="line">en_CA.utf8</span><br><span class="line">en_DK.utf8</span><br><span class="line">en_GB.utf8</span><br><span class="line">en_HK.utf8</span><br><span class="line">en_IE.utf8</span><br><span class="line">en_IN</span><br><span class="line">en_IN.utf8</span><br><span class="line">en_NG</span><br><span class="line">en_NG.utf8</span><br><span class="line">en_NZ.utf8</span><br><span class="line">en_PH.utf8</span><br><span class="line">en_SG.utf8</span><br><span class="line">en_US.utf8</span><br><span class="line">en_ZA.utf8</span><br><span class="line">en_ZM</span><br><span class="line">en_ZM.utf8</span><br><span class="line">en_ZW.utf8</span><br><span class="line">POSIX</span><br><span class="line">zh_CN.utf8</span><br><span class="line">zh_SG.utf8</span><br></pre></td></tr></table></figure>
<h2 id="三、问题解决"><a href="#三、问题解决" class="headerlink" title="三、问题解决"></a><strong>三、问题解决</strong></h2><p>执行<code>sudo locale-gen &quot;zh_CN.gbk&quot;</code>命令，安装“zh_CN.gbk”语言模块，安装完成后再执行<code>locale -a</code>命令，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">en_AG</span><br><span class="line">en_AG.utf8</span><br><span class="line">en_AU.utf8</span><br><span class="line">en_BW.utf8</span><br><span class="line">en_CA.utf8</span><br><span class="line">en_DK.utf8</span><br><span class="line">en_GB.utf8</span><br><span class="line">en_HK.utf8</span><br><span class="line">en_IE.utf8</span><br><span class="line">en_IN</span><br><span class="line">en_IN.utf8</span><br><span class="line">en_NG</span><br><span class="line">en_NG.utf8</span><br><span class="line">en_NZ.utf8</span><br><span class="line">en_PH.utf8</span><br><span class="line">en_SG.utf8</span><br><span class="line">en_US.utf8</span><br><span class="line">en_ZA.utf8</span><br><span class="line">en_ZM</span><br><span class="line">en_ZM.utf8</span><br><span class="line">en_ZW.utf8</span><br><span class="line">POSIX</span><br><span class="line">zh_CN.gbk</span><br><span class="line">zh_CN.utf8</span><br><span class="line">zh_SG.utf8</span><br></pre></td></tr></table></figure>
<p>根据以上结果可知系统已经支持“zh_CN.gbk”语言模块，此时执行<code>export LC_CTYPE=zh_CN.gbk</code>命令不再报错。</p>
<br/>
参看文献：
[1]https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue
[2]man locale-gen
[3]man locale.gen
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu Shell下使用sz/rz命令传输文件</title>
    <url>/blog/2017/02/16/Ubuntu-Shell%E4%B8%8B%E4%BD%BF%E7%94%A8sz-rz%E5%91%BD%E4%BB%A4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a><strong>一、环境配置</strong></h2><h3 id="1-1、安装lrzsz软件包"><a href="#1-1、安装lrzsz软件包" class="headerlink" title="1.1、安装lrzsz软件包"></a><strong>1.1、安装lrzsz软件包</strong></h3><p>sz和rz命令在lrzsz软件包中，通过以下命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lrzsz</span><br></pre></td></tr></table></figure>
<h3 id="1-2、安装GNU-screen软件包"><a href="#1-2、安装GNU-screen软件包" class="headerlink" title="1.2、安装GNU screen软件包"></a><strong>1.2、安装GNU screen软件包</strong></h3><p>在Windows操作系统环境下的Xshell等程序中执行“sz&#x2F;rz”命令，会自动弹出一个图形界面窗口（是对ZMODEM协议信号捕获事件的响应），用于选取“从服务器接收文件传输目的路径&#x2F;待发送到服务器的文件路径”。<br>而在Ubuntu Shell下，可通过GNU screen软件包下的screen命令环境捕获ZMODEM协议信号，从而实现选取“从服务器接收文件传输目的路径&#x2F;待发送到服务器的文件路径”。</p>
<h2 id="二、实际操作"><a href="#二、实际操作" class="headerlink" title="二、实际操作"></a><strong>二、实际操作</strong></h2><h3 id="2-1、发送文件到服务器"><a href="#2-1、发送文件到服务器" class="headerlink" title="2.1、发送文件到服务器"></a><strong>2.1、发送文件到服务器</strong></h3><p>1、打开一个Shell<br>2、执行<code>screen</code>命令，进入screen命令环境<br>3、按下<code>Ctrl+a</code>组合键，然后再输入<code>:zmodem catch</code>命令，设置screen命令环境捕获ZMODEM协议信号<br>4、在以上screen命令环境下与服务器建立SSH连接<br>5、执行<code>rz</code>命令，ZMODEM协议信号被screen命令环境捕获，出现如图1所示待补全命令，待补全部分为“待发送到服务器的文件路径”<br>6、输入“待发送到服务器的文件路径”，成功发送文件到服务器当前所处目录下</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170216-0-1.png"></p>
<h3 id="2-2、从服务器接收文件"><a href="#2-2、从服务器接收文件" class="headerlink" title="2.2、从服务器接收文件"></a><strong>2.2、从服务器接收文件</strong></h3><p>1、打开一个Shell<br>2、执行<code>screen</code>命令，进入screen命令环境<br>3、按下<code>Ctrl+a</code>组合键，然后再输入<code>:zmodem catch</code>命令，设置screen命令环境捕获ZMODEM协议信号<br>4、在以上screen命令环境下与服务器建立SSH连接<br>5、执行<code>sz 文件路径</code>命令，ZMODEM协议信号被screen命令环境捕获，出现如图2所示可直接执行命令<br>6、图2所示命令执行后，服务器的文件被传输到本地，自动置于用户主目录下</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170216-0-2.png"></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>在screen命令环境下，按下<code>Ctrl+a</code>组合键，然后再输入<code>:encoding enc</code>命令，可以设定环境编码格式。</p>
<br/>
参考文献：
[1]http://uhle.blog.163.com/blog/static/194117144201121044756789/
[2]http://adammonsen.com/post/256
[3]https://www.gnu.org/software/screen/manual/screen.html
[4]https://www.gnu.org/software/screen/manual/screen.html#Character-Processing
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu下使用7z命令差异备份数据</title>
    <url>/blog/2016/08/27/Ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A87z%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="一、7z命令介绍与安装"><a href="#一、7z命令介绍与安装" class="headerlink" title="一、7z命令介绍与安装"></a><strong>一、7z命令介绍与安装</strong></h2><p>使用7z命令可以创建压缩文件。Ubuntu下安装7z命令的命令行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install p7zip-full</span><br></pre></td></tr></table></figure>
<h2 id="二、3种备份数据方式"><a href="#二、3种备份数据方式" class="headerlink" title="二、3种备份数据方式"></a><strong>二、3种备份数据方式</strong></h2><p>存在3种备份数据的方式：完全备份（full backup），差异备份（differential backup）和增量备份（incremental backup）。3种备份数据的方式比较如表1所示。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>完全备份</td>
<td>备份全部数据</td>
<td>无</td>
<td>耗时</td>
</tr>
<tr>
<td>差异备份</td>
<td>备份当前数据与上一次<font color='red'>完全备份</font>数据之间的差异</td>
<td>还原数据只需要上一次完全备份数据和最新一次差异备份数据</td>
<td>相对于增量备份，差异备份耗时长</td>
</tr>
<tr>
<td>增量备份</td>
<td>备份当前数据与上一次<font color='red'>备份（可以是完全备份，差异备份，增量备份）</font>数据之间的差异</td>
<td>相对于差异备份，增量备份耗时短</td>
<td>还原数据需要上一次的完全备份数据以及在之后的所有增量备份数据</td>
</tr>
</tbody></table>
<h2 id="三、Ubuntu下使用7z命令差异备份数据"><a href="#三、Ubuntu下使用7z命令差异备份数据" class="headerlink" title="三、Ubuntu下使用7z命令差异备份数据"></a><strong>三、Ubuntu下使用7z命令差异备份数据</strong></h2><p>根据7z命令使用文档，可知使用7z命令可以创建压缩文件和差异压缩文件，借助于上述功能，我们可使用7z命令差异备份数据，此时，“压缩”不是目的，“备份”才是目的。<br>假定现在需要备份“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下的数据。</p>
<h3 id="3-1、完全备份数据"><a href="#3-1、完全备份数据" class="headerlink" title="3.1、完全备份数据"></a><strong>3.1、完全备份数据</strong></h3><h4 id="3-1-1、命令"><a href="#3-1-1、命令" class="headerlink" title="3.1.1、命令"></a><strong>3.1.1、命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z a /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</span><br></pre></td></tr></table></figure>
<p>以上命令表示完全备份“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下的数据，最终的完全备份数据文件路径为“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”。</p>
<h4 id="3-1-2、解释"><a href="#3-1-2、解释" class="headerlink" title="3.1.2、解释"></a><strong>3.1.2、解释</strong></h4><h5 id="3-1-2-1、“a”选项"><a href="#3-1-2-1、“a”选项" class="headerlink" title="3.1.2.1、“a”选项"></a><strong>3.1.2.1、“a”选项</strong></h5><p>表示创建一个压缩文件。</p>
<h3 id="3-2、差异备份数据"><a href="#3-2、差异备份数据" class="headerlink" title="3.2、差异备份数据"></a><strong>3.2、差异备份数据</strong></h3><h4 id="3-2-1、命令"><a href="#3-2-1、命令" class="headerlink" title="3.2.1、命令"></a><strong>3.2.1、命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z u /home/dsl/Desktop/b.7z /home/dsl/Desktop/a -u- -up0q3r2x1y2z0w2\!/home/dsl/Desktop/update.7z</span><br></pre></td></tr></table></figure>
<p>以上命令表示差异备份“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下的数据，所基于的完全备份数据文件路径为“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”，最终的差异备份数据文件路径为“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;update.7z”。</p>
<h4 id="3-2-2、解释"><a href="#3-2-2、解释" class="headerlink" title="3.2.2、解释"></a><strong>3.2.2、解释</strong></h4><h5 id="3-2-2-1、“u”选项"><a href="#3-2-2-1、“u”选项" class="headerlink" title="3.2.2.1、“u”选项"></a><strong>3.2.2.1、“u”选项</strong></h5><p>表示创建保存差异化数据的压缩文件。</p>
<h5 id="3-2-2-2、“-u-”选项"><a href="#3-2-2-2、“-u-”选项" class="headerlink" title="3.2.2.2、“-u-”选项"></a><strong>3.2.2.2、“-u-”选项</strong></h5><p>表示不改变“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”压缩文件的内容。</p>
<h5 id="3-2-2-3、“-up0q3r2x1y2z0w2”选项"><a href="#3-2-2-3、“-up0q3r2x1y2z0w2”选项" class="headerlink" title="3.2.2.3、“-up0q3r2x1y2z0w2”选项"></a><strong>3.2.2.3、“-up0q3r2x1y2z0w2”选项</strong></h5><p>“-u”选项后面跟随用于创建保存差异化数据的压缩文件的策略。“pqrxyzw”选项字符的含义见表2，“0123”值字符的含义见表3。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>选项字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>p</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下有相应文件，但是相应文件路径不匹配“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a&#x2F;*.sh”（为便于描述，以“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a&#x2F;*.sh”替换命令中的“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”）</td>
</tr>
<tr>
<td>q</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下有相应文件，在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下没有相应文件</td>
</tr>
<tr>
<td>r</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下没有相应文件，在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下有相应文件</td>
</tr>
<tr>
<td>x</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”和“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下都有相应文件，“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下相应文件与“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下相应文件mtime时间戳不一致，前者较新</td>
</tr>
<tr>
<td>y</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”和“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下都有相应文件，“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下相应文件与“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下相应文件mtime时间戳不一致，前者较旧</td>
</tr>
<tr>
<td>z</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”和“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下都有相应文件，“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下相应文件与“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下相应文件完全一致</td>
</tr>
<tr>
<td>w</td>
<td>命中文件路径：在“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”和“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下都有相应文件，“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下相应文件与“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下相应文件mtime时间戳一致，两者文件大小不一致</td>
</tr>
</tbody></table>
<p>表3</p>
<table>
<thead>
<tr>
<th>值字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>忽略相应文件路径，在还原数据时，效果等价于“1”值字符</td>
</tr>
<tr>
<td>1</td>
<td>复制“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”下相应文件路径对应的文件到差异备份数据文件</td>
</tr>
<tr>
<td>2</td>
<td>复制“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”下相应文件路径对应的文件到差异备份数据文件</td>
</tr>
<tr>
<td>3</td>
<td>在差异备份数据文件中标记相应文件路径对应的文件为删除态，在还原数据时，上述文件最终会被删除。<font color='red'>该“值字符”只被“7z”压缩文件格式支持</font></td>
</tr>
</tbody></table>
<h5 id="3-2-2-4、“-”选项"><a href="#3-2-2-4、“-”选项" class="headerlink" title="3.2.2.4、“\!”选项"></a><strong>3.2.2.4、“\!”选项</strong></h5><p>表示后面跟随差异备份数据文件路径，“\”字符表示转义控制字符，“\!”字符串表示转义得到“!”字符。</p>
<h3 id="3-3、还原数据"><a href="#3-3、还原数据" class="headerlink" title="3.3、还原数据"></a><strong>3.3、还原数据</strong></h3><h4 id="3-3-1、命令"><a href="#3-3-1、命令" class="headerlink" title="3.3.1、命令"></a><strong>3.3.1、命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x /home/dsl/Desktop/b.7z</span><br><span class="line">7z x /home/dsl/Desktop/update.7z</span><br></pre></td></tr></table></figure>
<p>先还原完全备份数据，再还原差异备份数据，最终得到最新的完整数据。</p>
<h2 id="四、实验"><a href="#四、实验" class="headerlink" title="四、实验"></a><strong>四、实验</strong></h2><h3 id="4-1、实验1"><a href="#4-1、实验1" class="headerlink" title="4.1、实验1"></a><strong>4.1、实验1</strong></h3><p>“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下文件结构如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-1.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old g</span><br></pre></td></tr></table></figure>
<p>执行以下命令指定“d”，“e”和“g”这3个文件的mtime时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch d --date=&#x27;2004-02-29 16:21:42&#x27;</span><br><span class="line">touch e --date=&#x27;2004-02-29 16:21:42&#x27;</span><br><span class="line">touch g --date=&#x27;2004-02-29 16:21:42&#x27;</span><br></pre></td></tr></table></figure>
<p>接着执行<code>7z a /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</code>命令，得到完全备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”。<br>然后修改“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下数据，修改后文件结构如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-2.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容修改后分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new g not equal size</span><br></pre></td></tr></table></figure>
<p>执行以下命令指定“d”，“e”和“g”这3个文件的mtime时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch d --date=&#x27;2004-01-29 16:21:42&#x27;</span><br><span class="line">touch e --date=&#x27;2004-03-29 16:21:42&#x27;</span><br><span class="line">touch g --date=&#x27;2004-02-29 16:21:42&#x27;</span><br></pre></td></tr></table></figure>
<p>执行<code>7z u /home/dsl/Desktop/b.7z /home/dsl/Desktop/a -u- -up0q3r2x1y2z0w2\!/home/dsl/Desktop/update.7z</code>命令，得到差异备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;update.7z”。<br>复制“b.7z”和“update.7z”两个文件到“&#x2F;home&#x2F;dsl&#x2F;tmp2”目录下，执行以下命令还原数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x b.7z</span><br><span class="line">7z x update.7z</span><br></pre></td></tr></table></figure>
<p>还原得到a目录，其中文件结构如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-3.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new g not equal size</span><br></pre></td></tr></table></figure>
<h3 id="4-2、实验2"><a href="#4-2、实验2" class="headerlink" title="4.2、实验2"></a><strong>4.2、实验2</strong></h3><p>“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下文件结构如图4所示。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-4.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old g</span><br></pre></td></tr></table></figure>
<p>执行以下命令指定“d”，“e”和“g”这3个文件的mtime时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch d --date=&#x27;2004-02-29 16:21:42&#x27;</span><br><span class="line">touch e --date=&#x27;2004-02-29 16:21:42&#x27;</span><br><span class="line">touch g --date=&#x27;2004-02-29 16:21:42&#x27;</span><br></pre></td></tr></table></figure>
<p>接着执行<code>7z a /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</code>命令，得到完全备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”。<br>然后修改“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下数据，修改后文件结构如图5所示。</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-5.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容修改后分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new g not equal size</span><br></pre></td></tr></table></figure>
<p>执行以下命令指定“d”，“e”和“g”这3个文件的mtime时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch d --date=&#x27;2004-01-29 16:21:42&#x27;</span><br><span class="line">touch e --date=&#x27;2004-03-29 16:21:42&#x27;</span><br><span class="line">touch g --date=&#x27;2004-02-29 16:21:42&#x27;</span><br></pre></td></tr></table></figure>
<p>执行<code>7z u /home/dsl/Desktop/b.7z /home/dsl/Desktop/a -u- -up0q1r0x2y1z0w1\!/home/dsl/Desktop/update.7z</code>命令，得到差异备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;update.7z”。<br>复制“b.7z”和“update.7z”两个文件到“&#x2F;home&#x2F;dsl&#x2F;tmp2”目录下，执行以下命令还原数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x b.7z</span><br><span class="line">7z x update.7z</span><br></pre></td></tr></table></figure>
<p>还原得到a目录，其中文件结构如图6所示。</p>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-6.png"></p>
<p>其中，“d”，“e”和“g”这3个文件的内容分别如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">old g</span><br></pre></td></tr></table></figure>
<h3 id="4-3、实验3"><a href="#4-3、实验3" class="headerlink" title="4.3、实验3"></a><strong>4.3、实验3</strong></h3><p>“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a”目录下文件结构如图7所示。</p>
<p>图7</p>
<p><img src="https://blog.dslztx.top/imgs/20160827-0-7.png"></p>
<p>接着执行<code>7z a /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</code>命令，得到完全备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;b.7z”。<br>执行<code>7z u /home/dsl/Desktop/b.7z /home/dsl/Desktop/a/* -u- -up3q0r0x0y0z0w0\!/home/dsl/Desktop/update.7z</code>命令，得到差异备份数据文件“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;update.7z”。<br>复制“b.7z”和“update.7z”两个文件到“&#x2F;home&#x2F;dsl&#x2F;tmp2”目录下，执行以下命令还原数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z x b.7z</span><br><span class="line">7z x update.7z</span><br></pre></td></tr></table></figure>
<p>还原无法得到a目录，这是由于a目录路径不匹配“&#x2F;home&#x2F;dsl&#x2F;Desktop&#x2F;a&#x2F;*”，而现在有配置“p3”，因此最后a目录被删除。</p>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a><strong>五、其他</strong></h2><h3 id="5-1、保存软符号链接指向文件内容"><a href="#5-1、保存软符号链接指向文件内容" class="headerlink" title="5.1、保存软符号链接指向文件内容"></a><strong>5.1、保存软符号链接指向文件内容</strong></h3><p>如果在备份时，需要保存软符号链接指向文件内容，而不是软符号链接文件自身，那么可以使用“-l”选项。具体是将以上的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z a /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</span><br><span class="line">7z u /home/dsl/Desktop/b.7z /home/dsl/Desktop/a -u- -up0q3r2x1y2z0w2\!/home/dsl/Desktop/update.7z</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z a -l /home/dsl/Desktop/b.7z /home/dsl/Desktop/a</span><br><span class="line">7z u -l /home/dsl/Desktop/b.7z /home/dsl/Desktop/a -u- -up0q3r2x1y2z0w2\!/home/dsl/Desktop/update.7z</span><br></pre></td></tr></table></figure>
<p><font color='red'>需要特别注意的是：启用“-l”选项之后，有可能由于“指向文件不合理的软符号链接”的存在，而在备份时出现死循环。</font></p>
<br/>
参考文献：
[1]http://infosec.blog.51cto.com/226250/66478
[2]http://a32.me/2010/08/7zip-differential-backup-linux-windows/
[3]man 7z
[4]/usr/share/doc/p7zip-full/DOCS/MANUAL/index.htm
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下反编译JAR包获取源代码包</title>
    <url>/blog/2017/06/09/Ubuntu%E4%B8%8B%E5%8F%8D%E7%BC%96%E8%AF%91JAR%E5%8C%85%E8%8E%B7%E5%8F%96%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85/</url>
    <content><![CDATA[<p>有诸多候选工具：JAD，JD-GUI，FernFlower，Procyon，Krakatau等[1]。FernFlower是自Intellij Idea 14以后版本的默认反编译工具，因此作者选择FernFlower作为完成本文任务的工具。</p>
<h2 id="一、获取工具"><a href="#一、获取工具" class="headerlink" title="一、获取工具"></a><strong>一、获取工具</strong></h2><p>有两种途径获取工具。需要注意的是，通过两种途径获取到的工具基于相同主线源代码。</p>
<h3 id="1-1、途径1"><a href="#1-1、途径1" class="headerlink" title="1.1、途径1"></a><strong>1.1、途径1</strong></h3><p>在Intellij Idea安装目录的“plugins&#x2F;java-decompiler&#x2F;lib”子路径下，获取“java-decompiler.jar”JAR包，该JAR包就是FernFlower工具包。</p>
<h3 id="1-2、途径2"><a href="#1-2、途径2" class="headerlink" title="1.2、途径2"></a><strong>1.2、途径2</strong></h3><p>从<a href="https://github.com/fesh0r/fernflower">这里</a>获取FernFlower工具包的源代码，自行编译，获取得到的JAR包名称为“fernflower.jar”。</p>
<h2 id="二、使用工具"><a href="#二、使用工具" class="headerlink" title="二、使用工具"></a><strong>二、使用工具</strong></h2><p>在<a href="https://github.com/fesh0r/fernflower">这里</a>给出了工具使用说明，由于通过两种途径获取到的工具基于相同主线源代码，因此，工具使用说明也是通用的。<br>结合[3][4][5]，最终工具使用脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">Jar=java-decompiler.jar</span><br><span class="line">#Jar=fernflower.jar</span><br><span class="line">ToDecompileJar=$1</span><br><span class="line">TargetDir=$2</span><br><span class="line"></span><br><span class="line">java -cp $Jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -hdc=0 -dgs=1 -rsy=1 -rbr=1 -lit=1 -nls=1 -mpm=60 $ToDecompileJar $TargetDir</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://reverseengineering.stackexchange.com/questions/1370/what-is-a-good-java-decompiler-and-deobfuscator
[2]https://github.com/fesh0r/fernflower
[3]https://gist.github.com/mslinn/0e6fe9a2504a54e74e8c
[4]https://stackoverflow.com/questions/28389006/how-to-decompile-to-java-files-intellij-idea
[5]https://github.com/JetBrains/intellij-community/blob/master/plugins/java-decompiler/plugin/src/org/jetbrains/java/decompiler/IdeaDecompiler.kt
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu下安装和使用百度云盘bypy客户端</title>
    <url>/blog/2015/11/01/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98bypy%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="一、安装百度云盘bypy客户端"><a href="#一、安装百度云盘bypy客户端" class="headerlink" title="一、安装百度云盘bypy客户端"></a><strong>一、安装百度云盘bypy客户端</strong></h2><p>百度云盘bypy客户端是由第三方开发的，并不是官方客户端。<br>安装百度云盘bypy客户端的具体步骤如下：</p>
<ol>
<li>通过<code>sudo apt-get install python</code>命令安装Python</li>
<li>通过<code>sudo apt-get install python-requests</code>命令安装python-requests库</li>
<li>通过<code>git clone https://github.com/houtianze/bypy</code>命令将bypy客户端下载到本地</li>
</ol>
<p>现在可使用相应目录下的“bypy.py”脚本使用百度云盘bypy客户端。</p>
<h2 id="二、使用百度云盘bypy客户端"><a href="#二、使用百度云盘bypy客户端" class="headerlink" title="二、使用百度云盘bypy客户端"></a><strong>二、使用百度云盘bypy客户端</strong></h2><p>可使用<code>bypy.py help</code>命令查阅使用百度云盘bypy客户端的帮助文档。接下来主要介绍使用百度云盘bypy客户端上传本地的数据到百度云盘和从百度云盘下载数据到本地。<br>需要注意的是，第一次运行任意bypy命令会要求进行授权，复制提示中的链接可以得到一个授权码，复制输入授权码，在确认之后就能完成授权。<br>假定“bypy.py”脚本的具体路径为“&#x2F;home&#x2F;dsl&#x2F;bypy&#x2F;bypy.py”。</p>
<h3 id="2-1、上传本地的数据到百度云盘"><a href="#2-1、上传本地的数据到百度云盘" class="headerlink" title="2.1、上传本地的数据到百度云盘"></a><strong>2.1、上传本地的数据到百度云盘</strong></h3><p>命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/dsl/bypy/bypy.py syncup . / true</span><br></pre></td></tr></table></figure>
<p>它表示将当前目录下的所有数据上传到百度云盘的“apps&#x2F;bypy”目录下，上传过程中采用增量上传的方式，而且百度云盘上多余的文件会被删除。<br>在实际应用中，为便于事后分析，需要将命令执行结果重定向到文件，因此以上命令更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/dsl/bypy/bypy.py syncup . / true &gt;&gt; /home/dsl/bypy.out</span><br></pre></td></tr></table></figure>
<p>执行以上命令，却发现得到如图1所示异常。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20151101-0-1.png"></p>
<p>这是Python 2.x系列版本的bug，解决方案是将命令改为<code>PYTHONIOENCODING=UTF-8 /home/dsl/bypy/bypy.py syncup . / true &gt;&gt; /home/dsl/bypy.out</code>。<br>假设需要经常上传“&#x2F;home&#x2F;dsl&#x2F;bigdisk&#x2F;KuaiPan2”目录下的数据到百度云盘，为了方便，我们可以根据上述命令编写一个Shell脚本，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd /home/dsl/bigdisk/KuaiPan2</span><br><span class="line">PYTHONIOENCODING=UTF-8 /home/dsl/bypy/bypy.py -v syncup . / true &gt;&gt; /home/dsl/bypy.out</span><br></pre></td></tr></table></figure>
<p>在上面命令中加上“-v”选项是为了方便查看命令执行进度。</p>
<h3 id="2-2、下载百度云盘的数据到本地"><a href="#2-2、下载百度云盘的数据到本地" class="headerlink" title="2.2、下载百度云盘的数据到本地"></a><strong>2.2、下载百度云盘的数据到本地</strong></h3><p>命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/dsl/bypy/bypy.py syncdown / . true</span><br></pre></td></tr></table></figure>
<p>它表示将百度云盘的“apps&#x2F;bypy”目录下的数据下载到当前目录，下载过程中采用增量下载的方式，而且当前目录下多余的文件会被删除。<br>其他讨论类似于“2.1、上传本地的数据到百度云盘”，这里不再赘述。</p>
<h2 id="三、安装和使用过程注意事项"><a href="#三、安装和使用过程注意事项" class="headerlink" title="三、安装和使用过程注意事项"></a><strong>三、安装和使用过程注意事项</strong></h2><h3 id="3-1、百度云盘不区分大小写"><a href="#3-1、百度云盘不区分大小写" class="headerlink" title="3.1、百度云盘不区分大小写###"></a><strong>3.1、百度云盘不区分大小写</strong>###</h3><p>由于百度云盘是跨平台的，因此不区分大小写。如果在本地有“web”和“Web”两个目录，“web”目录下有“1.txt”文件，“Web”目录下有“2.txt”文件，执行上传命令后，在百度云盘上只有“web”（或者“Web”）目录，其中的文件为“1.txt”和“2.txt”。</p>
<br/>
参考文献：
[1]https://github.com/houtianze/bypy
[2]http://chase-seibert.github.io/blog/2014/01/12/python-unicode-console-output.html
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>百度云盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下安装和卸载软件的3种方式</title>
    <url>/blog/2020/10/12/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、3种方式"><a href="#一、3种方式" class="headerlink" title="一、3种方式"></a><strong>一、3种方式</strong></h2><h3 id="1-1、apt-get"><a href="#1-1、apt-get" class="headerlink" title="1.1、apt-get"></a><strong>1.1、apt-get</strong></h3><table>
<thead>
<tr>
<th>步骤</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>前导步骤</td>
<td><code>sudo apt-get update</code>（更新索引）</td>
</tr>
<tr>
<td>安装</td>
<td><code>sudo apt-get install xxx</code>（xxx指代待安装包名）</td>
</tr>
<tr>
<td>卸载</td>
<td><code>sudo apt-get purge xxx</code>（xxx指代安装时的包名）<br/><code>sudo apt-get autoremove</code>（很有可能一些依赖包从此不再需要，自动删除）</td>
</tr>
</tbody></table>
<h3 id="1-2、dpkg"><a href="#1-2、dpkg" class="headerlink" title="1.2、dpkg"></a><strong>1.2、dpkg</strong></h3><table>
<thead>
<tr>
<th>步骤</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>安装</td>
<td><code>sudo dpkg -i xxx.deb</code>（xxx.deb指代待安装Deb包名）<br/><code>sudo apt-get -f install</code>（很有可能一些依赖包并未安装，自动安装）</td>
</tr>
<tr>
<td>卸载</td>
<td><code>sudo dpkg-query -W &quot;*chrome*&quot;</code>（由于安装后得到的DPKG包名一般与安装时候的Deb包名不同，在卸载的时候首先要找到相应的DPKG包名，以chrome浏览器为例）<br/><code>sudo dpkg -P google-chrome-stable</code>（1步骤中找到的DPKG包名）<br/><code>sudo apt-get autoremove</code>（很有可能一些依赖包从此不再需要，自动删除）</td>
</tr>
</tbody></table>
<h3 id="1-3、从源码编译安装"><a href="#1-3、从源码编译安装" class="headerlink" title="1.3、从源码编译安装"></a><strong>1.3、从源码编译安装</strong></h3><table>
<thead>
<tr>
<th>步骤</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>安装（3步曲）</td>
<td><code>./configure</code><br/><code>make</code><br/><code>make install</code></td>
</tr>
<tr>
<td>卸载</td>
<td><code>make uninstall</code>（卸载时的源码目录所在路径与安装时的源码目录所在路径不同，不影响最终结果）</td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ul>
<li>如果安装到目标目录需要是”root”权限才能操作，那么以上4个命令中，分别加上”sudo”</li>
</ul>
<h2 id="二、3种方式比较"><a href="#二、3种方式比较" class="headerlink" title="二、3种方式比较"></a><strong>二、3种方式比较</strong></h2><p>接下来对这3种软件安装方式进行比较：</p>
<ul>
<li>方便性角度。从方便性角度来看，“apt-get机制”最优，“dpkg机制”次之，“从源码编译安装机制”最末。“apt-get机制”已经预先解决依赖问题，“从源码编译安装机制”需要我们自己解决依赖问题</li>
<li>可定制性角度。从可定制性角度来看，“从源码编译安装机制”最优，“dpkg机制”次之，“apt-get机制”最末。“从源码编译安装机制”允许我们自定义安装参数，“apt-get机制”几乎完全采用默认的安装参数</li>
<li>安装用户所需权限角度。从安装用户所需权限角度来看，“从源码编译安装机制”所需权限可以是最小，“dpkg机制”次之，“apt-get机制”所需权限最大。在我们不拥有较高权限（比如<code>root</code>权限）的情况下，只能采用“从源码编译安装机制”</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu下每日更新导致APT机制锁冲突</title>
    <url>/blog/2017/08/27/Ubuntu%E4%B8%8B%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4APT%E6%9C%BA%E5%88%B6%E9%94%81%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>每天第一次开机运行Ubuntu，系统会自动执行<code>/bin/sh /usr/lib/apt/apt.systemd.daily</code>进程，此时APT机制锁已被它获取，如果我们再手动执行<code>apt-get</code>相关命令就会出现如下错误（即获取APT机制锁冲突）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</span><br></pre></td></tr></table></figure>
<h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a><strong>二、解决方案</strong></h2><p>查看“&#x2F;usr&#x2F;lib&#x2F;apt&#x2F;apt.systemd.daily”文件，发现有很多变量影响“是否每天自动执行<code>/bin/sh /usr/lib/apt/apt.systemd.daily</code>进程”。但是经过实验，发现最简单直观的解决方案还是：将“系统设置——软件和更新——更新——自动检查更新”选项值设为“从不”。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu桌面版关闭GUI环境</title>
    <url>/blog/2017/08/27/Ubuntu%E6%A1%8C%E9%9D%A2%E7%89%88%E5%85%B3%E9%97%ADGUI%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>有个需求，希望能够关闭Ubuntu桌面版的GUI环境。</p>
<h2 id="一、持久关闭"><a href="#一、持久关闭" class="headerlink" title="一、持久关闭"></a><strong>一、持久关闭</strong></h2><p>执行以下命令，持久关闭Ubuntu桌面版的GUI环境（通过<code>Ctrl+Alt+F1-F6</code>快捷键进入命令行界面）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
<p>执行以下命令，持久开启Ubuntu桌面版的GUI环境（通过<code>Ctrl+Alt+F7</code>快捷键进入GUI界面）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>
<h2 id="二、临时关闭"><a href="#二、临时关闭" class="headerlink" title="二、临时关闭"></a><strong>二、临时关闭</strong></h2><p>执行以下命令，临时关闭Ubuntu桌面版的GUI环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service lightdm stop</span><br></pre></td></tr></table></figure>
<p>执行以下命令，临时开启Ubuntu桌面版的GUI环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service lightdm start</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://askubuntu.com/questions/800239/how-to-disable-lightdmdisplay-manager-on-ubuntu-16-0-4-lts
[2]https://askubuntu.com/questions/365719/i-have-to-restart-lightdm-after-run
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Unable to locate Spring NamespaceHandler for XML schema namespace</title>
    <url>/blog/2019/02/20/Unable-to-locate-Spring-NamespaceHandler-for-XML-schema-namespace/</url>
    <content><![CDATA[<p>使用“assembly”插件构建一个胖JAR包，加载该胖JAR包执行后，出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace [http://www.springframework.org/schema/p]</span><br></pre></td></tr></table></figure>
<p>一般出现<code>Unable to locate Spring NamespaceHandler for XML schema namespace</code>错误的原因是缺少对相应Spring 包（比如“spring-core”）的依赖，但是这里经过确认，所有需要的Spring包都被正确依赖。<br>根据[1]可知，使用“assembly”插件构建胖JAR包时，目标胖JAR包中“META-INF”子目录下的“spring.schemas”和“spring.handlers”文件内容可能由于“互相覆盖”而缺失所需的Spring相关内容并最终导致出现<code>Unable to locate Spring NamespaceHandler for XML schema namespace</code>错误，验证我们这里所生成胖JAR包内上述两个文件的内容，发现果然缺失了所需的Spring相关内容。</p>
<p>“spring.schemas”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.alibaba.com/schema/stat.xsd=META-INF/stat.xsd</span><br></pre></td></tr></table></figure>
<p>“spring.handlers”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.alibaba.com/schema/stat=com.alibaba.druid.support.spring.stat.config.DruidStatNamespaceHandler</span><br></pre></td></tr></table></figure>
<br/>
接下来使用“shade”插件构建胖JAR包，<font color='red'>且配置目标胖JAR包中“META-INF”子目录下“spring.schemas”和“spring.handlers”文件的生成策略是“合并”而非“互相覆盖”</font>，具体插件配置如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">        &lt;goals&gt;</span><br><span class="line">          &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">        &lt;/goals&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;transformers&gt;</span><br><span class="line">            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">              &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;</span><br><span class="line">            &lt;/transformer&gt;</span><br><span class="line">            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">              &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;</span><br><span class="line">            &lt;/transformer&gt;</span><br><span class="line">          &lt;/transformers&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
构建新胖JAR包，现在构建得胖JAR包中“META-INF”子目录下的“spring.schemas”和“spring.handlers”文件内容正确保留了所需的Spring相关内容，加载该胖JAR包执行不再出现`Unable to locate Spring NamespaceHandler for XML schema namespace`错误。

<p>“spring.schemas”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.alibaba.com/schema/stat.xsd=META-INF/stat.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans-2.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans.xsd=org/springframework/beans/factory/xml/spring-beans-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/tool/spring-tool-2.0.xsd=org/springframework/beans/factory/xml/spring-tool-2.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/tool/spring-tool-2.5.xsd=org/springframework/beans/factory/xml/spring-tool-2.5.xsd</span><br><span class="line">http\://www.springframework.org/schema/tool/spring-tool-3.0.xsd=org/springframework/beans/factory/xml/spring-tool-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/tool/spring-tool.xsd=org/springframework/beans/factory/xml/spring-tool-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/util/spring-util-2.0.xsd=org/springframework/beans/factory/xml/spring-util-2.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/util/spring-util-2.5.xsd=org/springframework/beans/factory/xml/spring-util-2.5.xsd</span><br><span class="line">http\://www.springframework.org/schema/util/spring-util-3.0.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/util/spring-util.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd</span><br><span class="line">...（篇幅所限，以上只是部分文件内容）</span><br></pre></td></tr></table></figure>
<p>“spring.handlers”文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.alibaba.com/schema/stat=com.alibaba.druid.support.spring.stat.config.DruidStatNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure>

<br/>
**参考文献：**
[1]https://stackoverflow.com/questions/31892587/spring-4-2-dependancy-injection-http-www-springframework-org-schema-p-erro
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Unsafe类</title>
    <url>/blog/2020/07/29/Unsafe%E7%B1%BB/</url>
    <content><![CDATA[<p>本文介绍<code>sun.misc.Unsafe</code>类，它是实现Java并发包的基石类之一。<br>分4个类别进行介绍：</p>
<ul>
<li>CAS操作</li>
<li><code>put*Volatile</code>和<code>get*Volatile</code></li>
<li><code>put*</code>和<code>get*</code></li>
<li><code>putOrderedInt</code>，<code>putOrderedLong</code>，<code>putOrderedObject</code></li>
</ul>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><h3 id="1-1、volatile变量内存语义"><a href="#1-1、volatile变量内存语义" class="headerlink" title="1.1、volatile变量内存语义"></a><strong>1.1、volatile变量内存语义</strong></h3><p>参见<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>，主要包括3个方面：</p>
<ul>
<li>volatile变量的简单读写操作是原子的</li>
<li>具有volatile变量写语义，即“对变量的写对后续的读立即可见”</li>
<li>满足volatile变量happens-before规则</li>
</ul>
<h3 id="1-2、以“直接操作变量内存地址”形式操作变量"><a href="#1-2、以“直接操作变量内存地址”形式操作变量" class="headerlink" title="1.2、以“直接操作变量内存地址”形式操作变量"></a><strong>1.2、以“直接操作变量内存地址”形式操作变量</strong></h3><p>本文所述方法以“直接操作变量内存地址”形式操作变量，跟“一般直白”形式操作变量不同。</p>
<p>对于是否有volatile变量内存语义，两者的区别是：</p>
<ul>
<li>对于“一般直白”形式，以变量是否由volatile修饰决定，比如“代码片段1中的&#x2F;&#x2F;1和&#x2F;&#x2F;2分别具有volatile变量内存语义，&#x2F;&#x2F;3和&#x2F;&#x2F;4不具有volatile变量内存语义”</li>
<li>对于“直接操作变量内存地址”形式，不能感知是否由volatile修饰，<font color='red'>故不能以变量是否由volatile修饰决定</font>，只能以“方法设计意图是否提供volatile变量内存语义”决定，比如“代码片段2中&#x2F;&#x2F;3和&#x2F;&#x2F;4分别具有volatile变量内存语义，&#x2F;&#x2F;1和&#x2F;&#x2F;2不具有volatile变量内存语义”</li>
</ul>
<p>代码片段1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;          <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;        <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;          <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;        <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码片段2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueAOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueBOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueAOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">            valueBOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getInt(<span class="built_in">this</span>, valueAOffset);           <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        unsafe.putInt(<span class="built_in">this</span>, valueAOffset, a);               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(<span class="built_in">this</span>, valueBOffset);   <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        unsafe.putIntVolatile(<span class="built_in">this</span>, valueBOffset, b);       <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、几种操作形式得到的volatile变量内存语义是等价和可互操作的"><a href="#1-3、几种操作形式得到的volatile变量内存语义是等价和可互操作的" class="headerlink" title="1.3、几种操作形式得到的volatile变量内存语义是等价和可互操作的"></a><strong>1.3、几种操作形式得到的volatile变量内存语义是等价和可互操作的</strong></h3><p>几种操作形式得到的volatile变量内存语义是等价和可互操作的，操作形式有：</p>
<ul>
<li>以“一般直白”形式进行volatile变量操作</li>
<li>本文所指的3个CAS操作<br>-<code>put*Volatile</code>和<code>get*Volatile</code>方法</li>
</ul>
<h2 id="二、CAS操作"><a href="#二、CAS操作" class="headerlink" title="二、CAS操作"></a><strong>二、CAS操作</strong></h2><p>有3个CAS操作：<code>compareAndSwapInt</code>，<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>。<br>上述CAS操作，具有volatile变量内存语义，即：</p>
<ul>
<li>3个方法是原子的</li>
<li>具有volatile变量写语义，即“对变量的写对后续的读立即可见”</li>
<li>能够满足volatile变量happens-before规则</li>
</ul>
<br/>

<p>接下来证明CAS操作具有volatile变量内存语义。以<code>compareAndSwapInt</code>方法为例，在X86指令架构中，跟踪其本地实现源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">        <span class="comment">/* 省略一堆代码... */</span></span><br><span class="line">        &#123; CC <span class="string">&quot;compareAndSwapInt&quot;</span>,  CC <span class="string">&quot;(&quot;</span>OBJ <span class="string">&quot;J&quot;</span> <span class="string">&quot;I&quot;</span> <span class="string">&quot;I&quot;</span> <span class="string">&quot;)Z&quot;</span>, <span class="built_in">FN_PTR</span>( Unsafe_CompareAndSwapInt )  &#125;,</span><br><span class="line">        &#123; CC <span class="string">&quot;compareAndSwapLong&quot;</span>, CC <span class="string">&quot;(&quot;</span>OBJ <span class="string">&quot;J&quot;</span> <span class="string">&quot;J&quot;</span> <span class="string">&quot;J&quot;</span> <span class="string">&quot;)Z&quot;</span>, <span class="built_in">FN_PTR</span>( Unsafe_CompareAndSwapLong ) &#125;,</span><br><span class="line">        <span class="comment">/* 省略一堆代码... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Unsafe_CompareAndSwapInt</span>( JNIEnv * env, jobject unsafe, jobject obj, jlong offset, jint e, jint x ) ) &#123;</span><br><span class="line">        <span class="built_in">UnsafeWrapper</span>( <span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span> );</span><br><span class="line">        oop     p       = JNIHandles::<span class="built_in">resolve</span>( obj );</span><br><span class="line">        jint    * addr  = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>( p, offset );</span><br><span class="line">        <span class="keyword">return</span>( (jint) (Atomic::<span class="built_in">cmpxchg</span>( x, addr, e ) ) == e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span><span class="params">( jint exchange_value, <span class="keyword">volatile</span> jint*     dest, jint compare_value )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">        <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP( % <span class="number">4</span> ) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                          : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                          : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>(exchange_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知在执行<code>compareAndSwapInt</code>方法时，最后会执行到<code>LOCK_IF_MP( % 4 ) &quot;cmpxchgl %1,(%3)&quot;</code>语句，其中<code>LOCK_IF_MP( % 4 )</code>表示在单CPU且单核的环境中，可以优化不加<code>LOCK指令前缀</code>；否则就需要加<code>LOCK指令前缀</code>以确保<code>cmpxchgl</code>的原子性，而<code>cmpxchgl</code>表示一个属于<code>CMPXCHG</code>家族的CAS操作指令，它的末尾<code>l</code>表示操作数长度为4。</p>
<p><strong>如果是单核情形</strong>，如上所述——优化不加<code>LOCK指令前缀</code>，接下来证明的确实现volatile变量内存语义：</p>
<ul>
<li>在单核情形中，<code>cmpxchgl</code>指令本身是原子的</li>
<li>在单核情形中，对变量的写对后续的读立即可见</li>
<li>根据<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>，为实现volatile变量happens-before规则，还需按照方案1添加内存屏障，但是在X86指令架构中，上述内存屏障对应的重排序情形不被允许，故不需要按照方案1添加内存屏障</li>
</ul>
<p><strong>如果是多核情形</strong>，加上<code>LOCK指令前缀</code>，接下来证明的确实现volatile变量内存语义：</p>
<ul>
<li>在多核情形中，<code>LOCK + cmpxchgl</code>是原子的</li>
<li>在多核情形中，<code>LOCK指令前缀</code>使得“刷新缓存到内存”和“使缓存失效”，故“对变量的写对后续的读立即可见”</li>
<li>根据<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>，为实现volatile变量happens-before规则，还需按照方案1添加内存屏障，但是在X86指令架构中，上述内存屏障对应的重排序情形不被允许，故不需要按照方案1添加内存屏障；即便不是这样，<code>LOCK指令前缀</code>使得<code>禁止重排序</code>，也就等价于已按照方案1添加内存屏障</li>
</ul>
<br/>

<p>方案1：</p>
<ul>
<li>在每个volatile写操作的前面插入一个LoadStore内存屏障</li>
<li>在每个volatile写操作的前面插入一个StoreStore内存屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad内存屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore内存屏障</li>
</ul>
<h2 id="三、put-Volatile和get-Volatile"><a href="#三、put-Volatile和get-Volatile" class="headerlink" title="三、put*Volatile和get*Volatile"></a><strong>三、<code>put*Volatile</code>和<code>get*Volatile</code></strong></h2><p>我们知道，在Java中有8个基本类型和1个引用类型，因此有9个相应的<code>put*Volatile</code>和<code>get*Volatile</code>方法。</p>
<p>9个相应的<code>put*Volatile</code>方法：</p>
<ul>
<li>putBooleanVolatile</li>
<li>putByteVolatile</li>
<li>putCharVolatile</li>
<li>putShortVolatile</li>
<li>putIntVolatile</li>
<li>putFloatVolatile</li>
<li>putLongVolatile</li>
<li>putDoubleVolatile</li>
<li>putObjectVolatile</li>
</ul>
<p>9个相应的<code>get*Volatile</code>方法：</p>
<ul>
<li>getBooleanVolatile</li>
<li>getByteVolatile</li>
<li>getCharVolatile</li>
<li>getShortVolatile</li>
<li>getIntVolatile</li>
<li>getFloatVolatile</li>
<li>getLongVolatile</li>
<li>getDoubleVolatile</li>
<li>getObjectVolatile</li>
</ul>
<p>上述方法，具有volatile变量内存语义（证明过程略），即：</p>
<ul>
<li><code>put*Volatile</code>方法是原子的，具有volatile变量写语义，能够满足volatile变量happens-before规则</li>
<li><code>get*Volatile</code>方法是原子的，具有volatile变量读语义，能够满足volatile变量happens-before规则</li>
</ul>
<h2 id="四、put-和get"><a href="#四、put-和get" class="headerlink" title="四、put*和get*"></a><strong>四、<code>put*</code>和<code>get*</code></strong></h2><p>我们知道，在Java中有8个基本类型和1个引用类型，因此有9个相应的<code>put*</code>和<code>get*</code>方法。</p>
<p>9个相应的<code>put*</code>方法：</p>
<ul>
<li>putBoolean</li>
<li>putByte</li>
<li>putChar</li>
<li>putShort</li>
<li>putInt</li>
<li>putFloat</li>
<li>putLong</li>
<li>putDouble</li>
<li>putObject</li>
</ul>
<p>9个相应的<code>get*</code>方法：</p>
<ul>
<li>getBoolean</li>
<li>getByte</li>
<li>getChar</li>
<li>getShort</li>
<li>getInt</li>
<li>getFloat</li>
<li>getLong</li>
<li>getDouble</li>
<li>getObject</li>
</ul>
<p>上述方法，不具有volatile变量内存语义（证明过程略），具体是：</p>
<ul>
<li>操作不一定是原子的</li>
<li>对变量的写操作不具有volatile变量写语义，而只是普通的变量写语义</li>
<li>不满足volatile变量happens-before规则</li>
</ul>
<h2 id="五、putOrderedInt，putOrderedLong和putOrderedObject"><a href="#五、putOrderedInt，putOrderedLong和putOrderedObject" class="headerlink" title="五、putOrderedInt，putOrderedLong和putOrderedObject"></a><strong>五、<code>putOrderedInt</code>，<code>putOrderedLong</code>和<code>putOrderedObject</code></strong></h2><p>有3个方法：<code>putOrderedInt</code>，<code>putOrderedLong</code>和<code>putOrderedObject</code>。</p>
<p>上述方法与“volatile变量内存语义”的契合情况描述如下：</p>
<ul>
<li>对于写操作是原子的</li>
<li>对变量的写操作不具有volatile变量写语义，即“对变量的写不能对后续的读立即可见”。具有volatile变量写语义的操作（上文中的“以‘一般直白形式’写volatile变量”，“3个CAS操作中的写部分”，“<code>put*Volatile</code>方法”）在实现写时为使具有volatile变量写语义，需要添加一个绑定型内存屏障，该绑定型内存屏障用来使得“刷新缓存到内存，并使相应的缓存失效”，而<code>putOrderedInt/putOrderedLong/putOrderedObject</code>方法没有添加该绑定型内存屏障，故不具有volatile变量写语义。当然有失必有得，后者相对于前者有更好的写性能，这也是后者被设计出来的原因，后者常见的一个应用场景是“一系列写操作之后，统一作一个可见性确保操作，再一个读取操作”</li>
<li>根据<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a>博文中“二、实现概述”小节内容我们知道，为实现<code>volatile变量happens-before规则——“对一个volatile域的写，happens-before于任意后续对这个volatile域的读”</code>，需要满足“实现volatile关键词内存语义”下的第2和第3个条件，但是从实际使用该happens-before规则的角度——<code>如果“对这个volatile域的读”，能够读到“对该volatile域的写”，那么“对这个volatile域的读”就是“后续”的</code>，只需要满足第3个条件即可，前者需要满足第2个条件是因为“否则后续的读不保证能读到前面的写”，我们称前者为“狭义的volatile变量happens-before规则”，后者为“广义的volatile变量happens-before规则”。在这里，以上3个方法在写操作前会插入一个LoadStore和一个StoreStore内存屏障，因此如果配对“具有volatile变量读语义的操作”就能应用“广义的volatile变量happens-before规则”</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>关于以上“广义的volatile变量happens-before规则”的论述，属于笔者的自我理解，如有错误敬请指教。Stack Overflow上这个<a href="https://stackoverflow.com/questions/7557156/atomicxxx-lazyset-in-terms-of-happens-before-edges">回答</a>中认为以上3个方法不满足“volatile变量happens-before规则”，是因为他们所指的是“狭义的volatile变量happens-before规则”，故需要写入具有volatile变量写语义，而以上3个方法不具有volatile变量写语义</li>
<li>支持笔者自我理解的证据有：<ul>
<li>查看JDK 16中Unsafe类源码，<code>putOrderedObject</code>方法的JavaDoc中有一句——<code>Corresponds to C11 atomic_store_explicit(..., memory_order_release)</code>，再结合下述资料即可证明论述（当然这里同时也证明了上述3个方法的写操作是原子的）：<a href="http://www.cplusplus.com/reference/atomic/atomic_store_explicit/">资料1</a>，<a href="http://www.cplusplus.com/reference/atomic/memory_order/">资料2</a>，<a href="https://m.php.cn/manual/view/34181.html">资料3</a>，<a href="https://zhuanlan.zhihu.com/p/45566448">资料4</a></li>
<li>查看JDK 16中FutureTask类源码，<code>set</code>方法实现中转发调用VarHandle类的<code>setRelease</code>方法（在JDK 1.8中是转发调用Unsafe类的<code>putOrderedInt</code>方法，自然可推断两个方法是等价的），<code>setRelease</code>方法的JavaDoc中有一句——<code>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with &#123;@code memory_order_release&#125; ordering.</code>，结合以上第1点，论述得证</li>
</ul>
</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://psy-lob-saw.blogspot.com/2012/12/atomiclazyset-is-performance-win-for.html">http://psy-lob-saw.blogspot.com/2012/12/atomiclazyset-is-performance-win-for.html</a><br>[2]<a href="https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set">https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set</a><br>[3]<a href="http://ifeve.com/how-does-atomiclong-lazyset-work/">http://ifeve.com/how-does-atomiclong-lazyset-work/</a><br>[4]<a href="https://stackoverflow.com/questions/58185339/does-storestore-memory-barrier-in-java-forbid-the-read-write-reordering">https://stackoverflow.com/questions/58185339/does-storestore-memory-barrier-in-java-forbid-the-read-write-reordering</a><br>[5]<a href="https://github.com/fengjiachun/doc/blob/master/concurrent/%E6%B5%85%E6%9E%90JUC%E4%B8%ADAtomic%20class%E7%9A%84lazySet.md">https://github.com/fengjiachun/doc/blob/master/concurrent/%E6%B5%85%E6%9E%90JUC%E4%B8%ADAtomic%20class%E7%9A%84lazySet.md</a><br>[6]<a href="https://blog.csdn.net/u010597819/article/details/113922471">https://blog.csdn.net/u010597819/article/details/113922471</a><br>[7]<a href="/blog/2019/12/17/happens-before%E8%A7%84%E5%88%99/" title="happens-before规则">《happens-before规则》</a><br>[8]<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>Version Control With Git</title>
    <url>/blog/2017/03/10/Version-Control-With-Git/</url>
    <content><![CDATA[<p>1、<a href="/blog/2017/03/09/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E4%BB%8B%E7%BB%8D/" title="《Version Control With Git》介绍">《Version Control With Git》介绍</a><br/>2、<a href="/blog/2017/03/10/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E5%AE%89%E8%A3%85Git/" title="《Version Control With Git》安装Git">《Version Control With Git》安装Git</a><br/>3、<a href="/blog/2017/03/20/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E5%85%A5%E9%97%A8/" title="《Version Control With Git》入门">《Version Control With Git》入门</a><br/>4、<a href="/blog/2017/03/29/%E3%80%8AVersion-Control-With-Git%E3%80%8BGit%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="《Version Control With Git》Git库的基础数据结构">《Version Control With Git》Git库的基础数据结构</a></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>YGC次数多时间长</title>
    <url>/blog/2018/11/07/YGC%E6%AC%A1%E6%95%B0%E5%A4%9A%E6%97%B6%E9%97%B4%E9%95%BF/</url>
    <content><![CDATA[<h2 id="一、现象"><a href="#一、现象" class="headerlink" title="一、现象"></a><strong>一、现象</strong></h2><p>以完全相同的启动脚本（除了堆内存JVM参数之外，其他JVM参数未指定）运行完全相同的应用程序分别在A和B服务器上，A上JDK环境是OpenJDK 1.7，B上JDK环境是Oracle JDK 1.6，两应用程序的请求量也几乎相同，系统资源也可确保不是瓶颈所在。<br>通过JVM进程监控系统发现：A上的应用程序YGC次数多时间长。</p>
<h2 id="二、诊断与解决"><a href="#二、诊断与解决" class="headerlink" title="二、诊断与解决"></a><strong>二、诊断与解决</strong></h2><p>YGC跟年轻代相关，通过<code>jstat -gccapacity JVM进程ID</code>命令分别查看A和B上应用程序的相关容量值。<br>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A上应用程序：</span><br><span class="line"></span><br><span class="line">NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC</span><br><span class="line">1107520.0 1107520.0 1107520.0 110720.0 110720.0 886080.0  7281088.0  7281088.0  7281088.0  7281088.0  21248.0 169984.0  21248.0  21248.0   3805     0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B上应用程序：</span><br><span class="line"></span><br><span class="line">NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC</span><br><span class="line">1398080.0 2796160.0 1398080.0 67008.0 65152.0 1265920.0  2796224.0  5592448.0  2796224.0  2796224.0  21248.0  86016.0  21248.0  21248.0    516     0</span><br></pre></td></tr></table></figure>

<p>可发现：A上年轻代容量（<code>1107520</code>）小于B上年轻代容量（<code>1398080</code>），最主要的是A上“Eden&#x2F;Survivor”比值（<code>886080/110720</code>约等于8）大大小于B上该比值（<code>1265920/65152</code>约等于19）。<br>A上“Eden&#x2F;Survivor”比值接近于“SurvivorRatio”这个JVM参数的默认值，应该是由该JVM参数控制；B上“Eden&#x2F;Survivor”比值应该不是由该JVM参数控制，而应该是经过动态调整得到的，故而可以定位到“UseAdaptiveSizePolicy”JVM参数。</p>
<p>通过<code>jinfo -flag UseAdaptiveSizePolicy JVM进程ID</code>命令，可发现A上如预期果然未开启“UseAdaptiveSizePolicy”JVM参数，B上如预期默认开启了“UseAdaptiveSizePolicy”JVM参数，<font color='red'>这个差异很明显是不同JDK环境造成的</font>。</p>
<p>因此，具体解决方案有两个：</p>
<ul>
<li>统一JDK环境，将A上的OpenJDK 1.7改为Oracle JDK 1.6</li>
<li>A上应用程序手动开启“UseAdaptiveSizePolicy”JVM参数</li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Vim快捷键</title>
    <url>/blog/2018/06/01/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>Vim教程博大精深，本文更多属于自我理解性质，请悉知。<br>Vim的学习曲线非常陡峭，作者认为“面向操作学习Vim”是科学合适的学习途径，能够降低学习Vim的难度。具体来说，“Vim操作”被设计有详细用法，详细用法中涉及到了“适用模式，是否支持重复执行N次操作，限定范围形式，是否支持文本对象”等内容，<font color='red'>“Vim操作”是核心，它串联了这些内容，跟学习使用Linux中“Linux命令”是核心一样</font>。<br>可通过<code>:help topic</code>查看关于某个“topic”的帮助内容。</p>
<h2 id="一、操作"><a href="#一、操作" class="headerlink" title="一、操作"></a><strong>一、操作</strong></h2><h3 id="1-1、模式切换"><a href="#1-1、模式切换" class="headerlink" title="1.1、模式切换"></a><strong>1.1、模式切换</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>从普通模式切入插入模式，在当前光标处插入</td>
</tr>
<tr>
<td>A</td>
<td>从普通模式切入插入模式，在当前行行尾插入</td>
</tr>
<tr>
<td>v</td>
<td>从普通模式切入可视模式，按照字符选取</td>
</tr>
<tr>
<td>V</td>
<td>从普通模式切入可视模式，按照行选取</td>
</tr>
<tr>
<td>连续按Esc一次或者两次</td>
<td>从插入模式、命令模式、可视模式切回普通模式</td>
</tr>
</tbody></table>
<h3 id="1-2、移动"><a href="#1-2、移动" class="headerlink" title="1.2、移动"></a><strong>1.2、移动</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>定位到文件头部</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>G</td>
<td>定位到文件尾部</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>NG</td>
<td>定位到第N行</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>0</td>
<td>定位到行首</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>^</td>
<td>定位到行首第一个非空字符</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>$</td>
<td>定位到行尾</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>h</td>
<td>左移一个字符</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>l</td>
<td>右移一个字符</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>k</td>
<td>上移一个字符</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>j</td>
<td>下移一个字符</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>f&#60;X&#62;</td>
<td>快速定位到本行当前光标右侧第一个X字符处</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>F&#60;X&#62;</td>
<td>快速定位到本行当前光标左侧第一个X字符处</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>t&#60;X&#62;</td>
<td>快速定位到本行当前光标右侧第一个X字符处左侧</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>T&#60;X&#62;</td>
<td>快速定位到本行当前光标左侧第一个X字符处右侧</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>w</td>
<td>右移一个单词，停在单词头</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>e</td>
<td>右移一个单词，停在单词尾</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>b</td>
<td>左移一个单词，停在单词头</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>%</td>
<td>定位到匹配的括号处（包括“花括号{}，圆括号()，方括号[]”，不包括“尖括号&lt;&gt;”）</td>
<td>普通模式，可视模式</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>]m</td>
<td>快速定位到下一个方法的“{”字符处（方法体使用“{}”字符对定义）</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>[m</td>
<td>快速定位到上一个方法的“{”字符处（方法体使用“{}”字符对定义）</td>
<td>普通模式，可视模式</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向下移动一页，即PageDown</td>
<td>普通模式，可视模式</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>向上移动一页，即PageUp</td>
<td>普通模式，可视模式</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
</tbody></table>
<h3 id="1-3、编辑"><a href="#1-3、编辑" class="headerlink" title="1.3、编辑"></a><strong>1.3、编辑</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>撤销操作</td>
<td>普通模式，可视模式（撤销选取并返回普通模式）</td>
<td>[普通]支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>反撤销操作</td>
<td>普通模式</td>
<td>[普通]支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
<td>普通模式</td>
<td>[普通]支持</td>
<td>[普通]不支持</td>
<td>[普通]不支持</td>
</tr>
<tr>
<td>d</td>
<td>删除字符</td>
<td>普通模式，可视模式（删除选取内容并退回到普通模式），命令模式</td>
<td>[普通]不支持<br/>[可视]不支持<br/>[命令]不支持</td>
<td>[普通]操作End<br/>[可视]不支持<br/>[命令]Range操作</td>
<td>[普通]支持<br/>[可视]不支持<br/>[命令]不支持</td>
</tr>
<tr>
<td>x（即“dl”）</td>
<td>删除字符</td>
<td>普通模式，可视模式（删除选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
<td>普通模式，可视模式（复制选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>y</td>
<td>复制字符</td>
<td>普通模式，可视模式（复制选取内容并退回到普通模式），命令模式</td>
<td>[普通]不支持<br/>[可视]不支持<br/>[命令]不支持</td>
<td>[普通]操作End<br/>[可视]不支持<br/>[命令]Range操作<br/></td>
<td>[普通]支持<br/>[可视]不支持<br/>[命令]不支持</td>
</tr>
<tr>
<td>p</td>
<td>在光标后粘贴</td>
<td>普通模式，可视模式（替换选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>r</td>
<td>替换字符</td>
<td>普通模式，可视模式（替换选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>~</td>
<td>字母大小写互换</td>
<td>普通模式，可视模式（转换选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]不支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>gu</td>
<td>切换字母为小写</td>
<td>普通模式，可视模式（转换选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]不支持</td>
<td>[普通]操作End<br/>[可视]不支持</td>
<td>[普通]支持<br/>[可视]不支持</td>
</tr>
<tr>
<td>gU</td>
<td>切换字母为大写</td>
<td>普通模式，可视模式（转换选取内容并退回到普通模式）</td>
<td>[普通]支持<br/>[可视]不支持</td>
<td>[普通]操作End<br/>[可视]不支持</td>
<td>[普通]支持<br/>[可视]不支持</td>
</tr>
</tbody></table>
<h3 id="1-4、查找替换"><a href="#1-4、查找替换" class="headerlink" title="1.4、查找替换"></a><strong>1.4、查找替换</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>查找</td>
<td>命令模式</td>
<td>[命令]不支持</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>?</td>
<td>反向查找</td>
<td>命令模式</td>
<td>[命令]不支持</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>n</td>
<td>下一个查找命中</td>
<td>普通模式</td>
<td>[普通]支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>N</td>
<td>下一个反向查找命中</td>
<td>普通模式</td>
<td>[普通]支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>&#42;和#</td>
<td>基于光标当前所在的单词作匹配，移动光标到下一个（或上一个）匹配单词（&#42;是下一个，#是上一个，支持循环）</td>
<td>普通模式</td>
<td>[普通]支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>:%s&#x2F;from&#x2F;to&#x2F;gc</td>
<td>全局替换，替换前询问</td>
<td>命令模式</td>
<td>[命令]不支持</td>
<td>[命令]Range操作</td>
<td>[命令]未探究</td>
</tr>
</tbody></table>
<h3 id="1-5、书签跳转"><a href="#1-5、书签跳转" class="headerlink" title="1.5、书签跳转"></a><strong>1.5、书签跳转</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>m&#60;NAME&#62;</td>
<td>定义名为“NAME”的书签</td>
<td>普通模式，可视模式</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>‘&#60;NAME&#62;</td>
<td>跳转到名为“NAME”的书签指向行</td>
<td>普通模式，可视模式</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>&#96;&#60;NAME&#62;</td>
<td>跳转到名为“NAME”的书签指向字符</td>
<td>普通模式，可视模式</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>:marks</td>
<td>查看所有书签</td>
<td>命令模式</td>
<td>[命令]不支持</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
</tbody></table>
<p><strong>备注：</strong><br>名为<code>a-z</code>的书签不支持跨文件跳转，名为<code>A-Z</code>的书签支持跨文件跳转，其他名称的书签不作探究。</p>
<h3 id="1-6、文本对象操作"><a href="#1-6、文本对象操作" class="headerlink" title="1.6、文本对象操作"></a><strong>1.6、文本对象操作</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
</tr>
</thead>
<tbody><tr>
<td>aw</td>
<td>选取一个单词</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如daw）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>as</td>
<td>选取一个句子</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如das）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>ap</td>
<td>选取一个段落</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如dap）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a]</td>
<td>选取一个[]结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da]）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a)</td>
<td>选取一个()结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da)）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a}</td>
<td>选取一个{}结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da}）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a&gt;</td>
<td>选取一个&lt;&gt;结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da&gt;）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>at</td>
<td>选取一个&#60;xxx&#62;&#60;&#x2F;xxx&#62;结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如dat）</td>
<td>[普通]支持<br/>[可视]支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a”</td>
<td>选取一个””结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da”）</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a’</td>
<td>选取一个’’结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da’）</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
<tr>
<td>a&#96;</td>
<td>选取一个&#96;&#96;结构</td>
<td>可视模式，普通模式中置于另外一个操作后面（比如da&#96;）</td>
<td>[普通]不支持<br/>[可视]不支持</td>
<td>[普通]未探究<br/>[可视]未探究</td>
</tr>
</tbody></table>
<p>备注：<br>另外还有“i(w,s,p,],),},&gt;,t,”,’,&#96;)”，它与“a(w,s,p,],),},&gt;,t,”,’,&#96;)”大同小异。</p>
<h3 id="1-7、文件"><a href="#1-7、文件" class="headerlink" title="1.7、文件"></a><strong>1.7、文件</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:w!</td>
<td>强制保存</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并退出</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
</tbody></table>
<h3 id="1-8、环境"><a href="#1-8、环境" class="headerlink" title="1.8、环境"></a><strong>1.8、环境</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>:set number&#47;nonumber</td>
<td>显示&#x2F;取消显示行号</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:set list&#47;nolist</td>
<td>显示&#x2F;取消显示特殊字符</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:set ic&#47;noic</td>
<td>在查找时，不区分&#x2F;区分字母大小写</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
</tbody></table>
<h3 id="1-9、功能"><a href="#1-9、功能" class="headerlink" title="1.9、功能"></a><strong>1.9、功能</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>简单描述</th>
<th>适用模式</th>
<th>是否支持重复执行N次操作</th>
<th>限定范围形式</th>
<th>是否支持文本对象</th>
</tr>
</thead>
<tbody><tr>
<td>ga</td>
<td>显示光标所在字母的ASCII编码值，表示形式有十进制，十六进制和八进制</td>
<td>普通模式</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>Ctrl+p或者Ctrl+n</td>
<td>在插入模式下，在你输入单词的开头字符后，通过<code>Ctrl+p</code>或者<code>Ctrl+n</code>快捷键可获得自动补全选项（自动补全数据基于所在文件生成）</td>
<td>插入模式</td>
<td>[插入]未探究</td>
<td>[插入]未探究</td>
<td>[插入]未探究</td>
</tr>
<tr>
<td>gt</td>
<td>跳转到右侧一个标签页</td>
<td>普通模式</td>
<td>[普通]不支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>gT</td>
<td>跳转到左侧一个标签页</td>
<td>普通模式</td>
<td>[普通]不支持</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
<tr>
<td>:sp</td>
<td>水平分割</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:vsp</td>
<td>垂直分割</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>:q</td>
<td>在分屏环境中，退出当前分屏</td>
<td>命令模式</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
<td>[命令]未探究</td>
</tr>
<tr>
<td>Ctrl+w h&#47;l&#47;k&#47;j</td>
<td>分别表示跳到左侧&#47;右侧&#47;上侧&#47;下侧分屏</td>
<td>普通模式</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
<td>[普通]未探究</td>
</tr>
</tbody></table>
<h3 id="1-10、限定范围操作"><a href="#1-10、限定范围操作" class="headerlink" title="1.10、限定范围操作"></a><strong>1.10、限定范围操作</strong></h3><h4 id="1-10-1、“Range操作”形式"><a href="#1-10-1、“Range操作”形式" class="headerlink" title="1.10.1、“Range操作”形式"></a><strong>1.10.1、“Range操作”形式</strong></h4><p>“Range”表示一个行范围，可以是单行。表示由“数字，特殊字符，书签，查找结果”元素构成。<br>示例如下。</p>
<table>
<thead>
<tr>
<th>行范围</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>21</td>
<td>行21</td>
<td><code>:21s/old/new/g</code></td>
</tr>
<tr>
<td>1</td>
<td>行1</td>
<td><code>:1s/old/new/g</code></td>
</tr>
<tr>
<td>$</td>
<td>最后一行（注意，虽为同一个字符，上述体系中“$”表示最后一个字符，这里体系中“$”表示最后一行）</td>
<td><code>:$s/old/new/g</code></td>
</tr>
<tr>
<td>.</td>
<td>当前行</td>
<td><code>:.w single.txt</code>（把当前行的内容写到文件“single.txt”）</td>
</tr>
<tr>
<td>%</td>
<td>所有行，等价于“1,$”</td>
<td><code>:%s/old/new/g</code></td>
</tr>
<tr>
<td>21,25</td>
<td>行21到行25</td>
<td><code>:21,25s/old/new/g</code></td>
</tr>
<tr>
<td>21,$</td>
<td>行21到最后一行</td>
<td><code>:21,$s/old/new/g</code></td>
</tr>
<tr>
<td>.,$</td>
<td>当前行到最后一行</td>
<td><code>:.,$s/old/new/g</code></td>
</tr>
<tr>
<td>.+1,$</td>
<td>当前行的下一行到最后一行</td>
<td><code>:.+1,$s/old/new/g</code></td>
</tr>
<tr>
<td>.,.+5</td>
<td>当前行到第6行</td>
<td><code>:.,.+5s/old/new/g</code></td>
</tr>
<tr>
<td>‘&#60;,’&#62;</td>
<td>选取行范围（本质上也是书签指定的行范围，详细可参见“2.1、模式”小节）</td>
<td><code>:&#39;&lt;,&#39;&gt;s/old/new/g</code></td>
</tr>
<tr>
<td>‘a,’b</td>
<td>书签a到书签b指定的行范围</td>
<td><code>:&#39;a,&#39;bd</code></td>
</tr>
<tr>
<td>.,’b</td>
<td>当前行到书签b指定的行范围</td>
<td><code>:.,&#39;bd</code></td>
</tr>
<tr>
<td>.,&#x2F;BODY&#x2F;</td>
<td>当前行到接下来第一次包含“BODY”的行范围</td>
<td><code>.,/BODY/d</code></td>
</tr>
</tbody></table>
<h4 id="1-10-2、“操作End”形式"><a href="#1-10-2、“操作End”形式" class="headerlink" title="1.10.2、“操作End”形式"></a><strong>1.10.2、“操作End”形式</strong></h4><p>“End”表示操作范围的一端，另外一端为当前光标所在位置。当“End”表示“行”范畴时，范围为“行到行”；当“End”表示“字符”范畴时，范围为“字符到字符”。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y0：从行首开始复制（字符范畴）</span><br><span class="line">y$：复制到行尾（字符范畴）</span><br><span class="line">d0：删除到行首（字符范畴）</span><br><span class="line">d$：删除到行尾（字符范畴）</span><br><span class="line">guG：小写化从当前行到文件最后一行之间的所有字母（行范畴）</span><br><span class="line">gUgg：大写化从文件第一行到当前行之间的所有字母（行范畴）</span><br><span class="line">ggguG：小写化文章中所有字符（行范畴）</span><br><span class="line">gggUG：大写化文章中所有字符（行范畴）</span><br></pre></td></tr></table></figure>
<p><font color='red'>特别需要注意的是：</font><br>1、“ggguG”和“gggUG”逻辑上都分为两部分：gg和guG（gUG），而不是一个独立的整体从而被进一步误以为出现了“Start操作End”的限定范围操作形式<br>2、书签跳转语境中，“&#96;a”是字符范畴，“’a”是行范畴</p>
<h3 id="1-11、跳转操作"><a href="#1-11、跳转操作" class="headerlink" title="1.11、跳转操作"></a><strong>1.11、跳转操作</strong></h3><p>跳转行为包括：gg，G，NG，书签跳转等。<br>可通过<code>:jumps</code>查看跳转记录列表，小三角所指跳转记录表示当前所处跳转记录，如果小三角所指跳转记录为空行，表示还未有跳转记录。<br>Ctrl+o是跳转回退，相应的小三角往上移动，Ctrl+i是跳转前进，相应的小三角往下移动。</p>
<h3 id="1-12、宏操作"><a href="#1-12、宏操作" class="headerlink" title="1.12、宏操作"></a><strong>1.12、宏操作</strong></h3><p>录制宏：录制一系列动作，以备重复执行。<br>录制宏具体步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按下q&#123;0-9a-zA-Z&quot;&#125;开始录制，&#123;0-9a-zA-Z&quot;&#125;为宏录制目的寄存器名字</span><br><span class="line">按下q完成录制</span><br></pre></td></tr></table></figure>
<p>通过<code>@&#123;0-9a-zA-Z&quot;&#125;</code>执行指定宏，支持“重复执行N次操作”。</p>
<h2 id="二、几个概念"><a href="#二、几个概念" class="headerlink" title="二、几个概念"></a><strong>二、几个概念</strong></h2><h3 id="2-1、模式"><a href="#2-1、模式" class="headerlink" title="2.1、模式"></a><strong>2.1、模式</strong></h3><p>Vim编辑器提供多种模式，常见的模式有4种：普通模式，可视模式，插入模式，命令模式。</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>普通模式</td>
<td>日常模式</td>
</tr>
<tr>
<td>可视模式</td>
<td>主要用于选取内容供后续操作，选取完成后本质上是划定了一个限定范围</td>
</tr>
<tr>
<td>插入模式</td>
<td>主要用于插入数据</td>
</tr>
<tr>
<td>命令模式</td>
<td>主要用于执行命令</td>
</tr>
</tbody></table>
<p>备注：<br>1、本质上，<font color='red'>可视模式中选取时定义了两个特殊的书签</font>，书签表示位置范围对应于选取限定范围，这两个特殊书签分别为：“&lt;”和“&gt;”，“&lt;”对应于“限定范围开头”，“&gt;”对应于“限定范围结尾”，因此<code>&#39;&lt;</code>和<code>&#39;&gt;</code>分别指向限定范围第一行和最后一行，<code>&#96;<</code>和<code>&#96;></code>分别指向限定范围开头字符和结尾字符</p>
<h3 id="2-2、重复执行N次操作"><a href="#2-2、重复执行N次操作" class="headerlink" title="2.2、重复执行N次操作"></a><strong>2.2、重复执行N次操作</strong></h3><p>在操作前辅以一个表示数字的“N”，表示“重复执行N次操作”。<font color='red'>需要注意的是，“NG”中的“N”并不是这个含义。</font><br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4h：执行4次h操作，即向左移动4个字符</span><br><span class="line">4yy：执行4次yy操作，表示复制从当前行开始的4行</span><br><span class="line">4dd：执行4次dd操作，表示删除从当前行开始的4行</span><br><span class="line">4p：执行4次p操作，表示复制粘贴4次</span><br></pre></td></tr></table></figure>
<h2 id="五、常见需求实现"><a href="#五、常见需求实现" class="headerlink" title="五、常见需求实现"></a><strong>五、常见需求实现</strong></h2><h3 id="5-1、快速选中Java方法"><a href="#5-1、快速选中Java方法" class="headerlink" title="5.1、快速选中Java方法"></a><strong>5.1、快速选中Java方法</strong></h3><p>快速选中Java方法步骤描述如下：<br>1、光标定位到方法定义首行，即具有方法名称的行<br>2、按下<code>^</code>字符，定位到所在行行首第一个非空字符<br>3、按下<code>v</code>字符，进入可视模式<br>4、按下<code>/&#123;&lt;Enter&gt;</code>字符组合，查找到第一个“{”字符<br>5、按下<code>%</code>字符，查找到与上述“{”字符匹配的“}”字符，完成选中</p>
<p>根据上述描述，我们可在“.vimrc”配置文件中，通过如下语句配置快捷键“cm”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap cm ^v/&#123;&lt;CR&gt;%</span><br></pre></td></tr></table></figure>
<h3 id="5-2、Java源文件中快速定位到类名"><a href="#5-2、Java源文件中快速定位到类名" class="headerlink" title="5.2、Java源文件中快速定位到类名"></a><strong>5.2、Java源文件中快速定位到类名</strong></h3><p>Java源文件中快速定位到类名步骤描述如下：<br>1、按下<code>gg</code>，光标定位到文件首行<br>2、按下<code>/^public&lt;Enter&gt;</code>字符组合，查找到第一个“public”字符串，且该字符串位于行首<br>3、按下<code>f&#123;</code>字符组合，找到右侧第一个“{”字符<br>4、按下<code>?class\|interface\|enum&lt;Enter&gt;</code>字符组合，向后找第一个“class&#x2F;interface&#x2F;enum”字符串<br>5、按下<code>w</code>字符，定位到右侧类名</p>
<p>根据上述描述，我们可在“.vimrc”配置文件中，通过如下语句配置快捷键“cc”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap cc gg/^public&lt;CR&gt;f&#123;?class&lt;Bslash&gt;&lt;BAR&gt;interface&lt;Bslash&gt;&lt;BAR&gt;enum&lt;CR&gt;w</span><br></pre></td></tr></table></figure>
<h3 id="5-3、去掉Windows文件中的-M符号"><a href="#5-3、去掉Windows文件中的-M符号" class="headerlink" title="5.3、去掉Windows文件中的^M符号"></a><strong>5.3、去掉Windows文件中的^M符号</strong></h3><p>去掉Windows文件中的“^M”符号的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s/^M//g</span><br></pre></td></tr></table></figure>
<p>如果想生成“^M”符号，可用<code>Ctrl-v Ctrl-m</code>命令。</p>
<h3 id="5-4、剪切"><a href="#5-4、剪切" class="headerlink" title="5.4、剪切"></a><strong>5.4、剪切</strong></h3><p>进入可视模式后，选取内容，按下<code>x</code>或者<code>d</code>字符，然后在目的地按下<code>p</code>字符完成剪切，以上过程能够完成剪切的根本原因是：<code>x</code>和<code>d</code>操作在删除内容之前会在寄存器复制一份内容，<code>p</code>操作会从寄存器复制粘贴内容。</p>
<h3 id="5-5、g命令"><a href="#5-5、g命令" class="headerlink" title="5.5、g命令"></a><strong>5.5、g命令</strong></h3><p>删除所有以“#”字符开头的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^#/d</span><br></pre></td></tr></table></figure>
<p>删除所有空行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^$/d</span><br></pre></td></tr></table></figure>

<br/>
**参考文献：**
[1]:help mark-motions
[2]:help text-objects
[3]:help q
[4]:help jumps
[5]:help various-motions
[6]https://zh.wikipedia.org/wiki/Vim
[7]http://vim.wikia.com/wiki/Ranges
[8]http://www.cnblogs.com/abeen/archive/2010/07/28/1786594.html
[9]https://www.maketecheasier.com/vim-keyboard-shortcuts-cheatsheet/
[10]https://www.fprintf.net/vimCheatSheet.html
[11]https://gist.github.com/awidegreen/3854277
[12]https://coolshell.cn/articles/5426.html
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper官方文档</title>
    <url>/blog/2017/08/30/ZooKeeper%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="一、ZooKeeper-Overview"><a href="#一、ZooKeeper-Overview" class="headerlink" title="一、ZooKeeper Overview"></a><strong>一、ZooKeeper Overview</strong></h2><ol start="0">
<li><a href="/blog/2017/09/05/ZooKeeper%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E7%AE%80%E4%BB%8B/" title="ZooKeeper官方文档之简介">Overview</a></li>
<li><a href="/blog/2017/09/06/ZooKeeper%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" title="ZooKeeper官方文档之入门指南">Getting Started</a></li>
<li><del>Release Notes</del></li>
</ol>
<h2 id="二、Developers"><a href="#二、Developers" class="headerlink" title="二、Developers"></a><strong>二、Developers</strong></h2><ol start="0">
<li>API Docs</li>
<li>Programmer’s Guide</li>
<li>ZooKeeper Java Example</li>
<li>Barrier and Queue Tutorial</li>
<li>ZooKeeper Recipes</li>
</ol>
<h2 id="三、Administrators-Operators"><a href="#三、Administrators-Operators" class="headerlink" title="三、Administrators &amp; Operators"></a><strong>三、Administrators &amp; Operators</strong></h2><ol start="0">
<li>Administrator’s Guide</li>
<li>Quota Guide</li>
<li>JMX</li>
<li>Hierarchical quorums</li>
<li>Observers</li>
</ol>
<h2 id="四、Contributors"><a href="#四、Contributors" class="headerlink" title="四、Contributors"></a><strong>四、Contributors</strong></h2><ol start="0">
<li>ZooKeeper Internals</li>
</ol>
<h2 id="五、Miscellaneous-ZooKeeper-Documentation"><a href="#五、Miscellaneous-ZooKeeper-Documentation" class="headerlink" title="五、Miscellaneous ZooKeeper Documentation"></a><strong>五、Miscellaneous ZooKeeper Documentation</strong></h2><ol start="0">
<li>Wiki</li>
<li>FAQ</li>
</ol>
<h2 id="六、BookKeeper-Documentation"><a href="#六、BookKeeper-Documentation" class="headerlink" title="六、BookKeeper Documentation"></a><strong>六、BookKeeper Documentation</strong></h2><ol start="0">
<li>henn, what’s it again?</li>
<li>Ok, now how do I try it out</li>
<li>Awesome, but how do I integrate it with my app?</li>
<li>Can I stream bytes instead of entries?</li>
</ol>
<br/>
文档地址：https://zookeeper.apache.org/doc/r3.4.10/
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>ZooKeeper官方文档之入门指南</title>
    <url>/blog/2017/09/06/ZooKeeper%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、搭建ZooKeeper集群"><a href="#一、搭建ZooKeeper集群" class="headerlink" title="一、搭建ZooKeeper集群"></a><strong>一、搭建ZooKeeper集群</strong></h2><p>搭建ZooKeeper集群需满足“ZooKeeper集群内ZooKeeper Server数量大于等于3，且为奇数”。以3个ZooKeeper Server搭建ZooKeeper集群为例进行说明。<br>现有服务器A，B，C，由于在A，B，C上的搭建过程一般情况下完全一致，所以，接下来只列出在A上的搭建过程（在B和C上复制搭建过程后，即完成整个ZooKeeper集群的搭建）。<br>搭建过程：</p>
<ol>
<li>从官网下载ZooKeeper包</li>
<li>解压ZooKeeper包，以“DIR”指代解压后的目录</li>
<li>在“DIR&#x2F;conf”目录下创建配置文件“zoo.cfg”，其内容如“配置文件1”所示</li>
<li>执行<code>DIR/bin/zkServer.sh start</code>命令，运行A上的ZooKeeper Server</li>
</ol>
<p>配置文件1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.1=A:2888:3888</span><br><span class="line">server.2=B:2888:3888</span><br><span class="line">server.3=C:2888:3888</span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/var/lib/zookeeper/data</span><br><span class="line">dataLogDir=/var/lib/zookeeper/transaction</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br></pre></td></tr></table></figure>

<p>配置文件中的参数说明见下表。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>server.N</td>
<td>参数中“N”表示指代ZooKeeper Server的唯一标识数字，该值跟数据目录下“myid”文件中的值一一对应。参数值中的配置都针对该ZooKeeper Server而言，参数值形式如<code>服务器地址:端口1:端口2</code>，“服务器地址”为运行ZooKeeper Server的服务器地址，“端口1”用于集群内ZooKeeper Server之间的通信，“端口2”用于集群内的Leader ZooKeeper Server选举过程</td>
</tr>
<tr>
<td>clientPort</td>
<td>客户端请求监听端口号</td>
</tr>
<tr>
<td>dataDir</td>
<td>数据存放目录，其下的“myid”文件中存放指代本ZooKeeper Server的唯一标识数字</td>
</tr>
<tr>
<td>dataLogDir</td>
<td>事务日志存放目录，默认即“dataDir”指代的数据存放目录。当“dataLogDir”取与“dataDir”不同目录时，有利于降低集群延迟</td>
</tr>
<tr>
<td>tickTime</td>
<td>基本时间单元，单位毫秒。控制心跳和超时，比如默认最小的会话超时时间为<code>2*tickTime</code></td>
</tr>
<tr>
<td>initLimit</td>
<td>Follower ZooKeeper Server与Leader ZooKeeper Server建立初始化连接的超时时间，实际时间值为<code>initLimit*tickTime</code></td>
</tr>
<tr>
<td>syncLimit</td>
<td>Follower ZooKeeper Server与Leader ZooKeeper Server建立连接后连接断开的超时时间，实际时间值为<code>syncLimit*tickTime</code></td>
</tr>
</tbody></table>
<h2 id="二、客户端连接ZooKeeper集群"><a href="#二、客户端连接ZooKeeper集群" class="headerlink" title="二、客户端连接ZooKeeper集群"></a><strong>二、客户端连接ZooKeeper集群</strong></h2><p>执行如下命令开启一个与ZooKeeper集群建立连接的命令行客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIR/bin/zkCli.sh -server ZooKeeper集群中某个ZooKeeper Server所在的服务器地址:相应的客户端请求监听端口号（即“clientPort”参数配置值）</span><br></pre></td></tr></table></figure>
<p>在命令行客户端中可执行“create，delete，set，get，ls”等命令操纵ZooKeeper Server的数据模型。</p>
<br/>
文档地址：https://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>ZooKeeper</category>
      </categories>
  </entry>
  <entry>
    <title>ZooKeeper官方文档之简介</title>
    <url>/blog/2017/09/05/ZooKeeper%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>ZooKeeper是一个为分布式应用程序提供协调服务的基础框架。</p>
<h2 id="二、数据模型"><a href="#二、数据模型" class="headerlink" title="二、数据模型"></a><strong>二、数据模型</strong></h2><p>被ZooKeeper Server操纵的数据模型为一棵树，该树形如Linux文件系统下的“文件-目录树”，树中节点以“从根节点到该节点的完整路径”为表示，节点分为“znode节点”和“非znode节点”，“znode节点”存储数据，“非znode节点”不存储数据，需要注意的是，一旦“非znode节点”存储数据就成为“znode节点”，“znode节点”一旦清空数据就成为“非znode节点”，即两者并没有本质的区别。<br>具体如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170905-0-1.png"></p>
<h2 id="三、原生提供操作保证"><a href="#三、原生提供操作保证" class="headerlink" title="三、原生提供操作保证"></a><strong>三、原生提供操作保证</strong></h2><p>ZooKeeper Server原生提供如下操作保证：</p>
<ul>
<li>顺序一致性。对ZooKeeper Server数据模型的操作满足“先操作先应用，后操作后应用”的性质 </li>
<li>原子性。对ZooKeeper Server数据模型的操作（包括读取）满足“要么完全成功，要么完全失败”的性质</li>
<li>单一系统视图。客户端连接集群中任意一个ZooKeeper Server获取到的数据模型是完全一致的</li>
<li>可靠性。对ZooKeeper Server数据模型的更新操作会被持久保存，直到被下一次更新操作覆盖</li>
<li>时间窗口下的最新同步。客户端至多等待一个时间窗口便能获取最新同步的ZooKeeper Server数据模型</li>
</ul>
<h2 id="四、集群"><a href="#四、集群" class="headerlink" title="四、集群"></a><strong>四、集群</strong></h2><p>ZooKeeper集群由多台ZooKeeper Server构成，一个ZooKeeper Server指代一个ZooKeeper Server进程，多个ZooKeeper Server可运行于同一台服务器，也可运行于多台服务器，客户端以连接集群中任意一台ZooKeeper Server的形式连接该集群。如图2。<br>ZooKeeper集群中的ZooKeeper Server分为两种角色：Leader和Follower。关于这两种角色的详细描述见本系列的后续博文。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170905-0-2.png"></p>
<h2 id="五、性能和高可用实验"><a href="#五、性能和高可用实验" class="headerlink" title="五、性能和高可用实验"></a><strong>五、性能和高可用实验</strong></h2><h3 id="5-1、性能实验"><a href="#5-1、性能实验" class="headerlink" title="5.1、性能实验"></a><strong>5.1、性能实验</strong></h3><p><strong>1、实验描述</strong><br>ZooKeeper集群的大小分别为：3，5，7，9，13。对于特定大小的ZooKeeper集群，不断改变<code>读请求次数/读写请求总次数</code>比重值，测定相应比重下的<code>处理请求数/秒</code>值。<br>另外，实验中的ZooKeeper Server版本为“3.2”，运行ZooKeeper Server的服务器的CPU为“dual 2Ghz Xeon”，具有两个<code>SATA 15K RPM drives</code>，运行将近910个客户端发出读写请求。<br><strong>2、实验结果</strong><br>见图3。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20170905-0-3.jpg"></p>
<p><strong>3、实验结论</strong><br>应用场景的<code>读请求次数/读写请求总次数</code>比重值越大，ZooKeeper集群每秒能够处理的请求越多。</p>
<h3 id="5-2、高可用实验"><a href="#5-2、高可用实验" class="headerlink" title="5.2、高可用实验"></a><strong>5.2、高可用实验</strong></h3><p><strong>1、实验描述</strong><br>ZooKeeper集群的大小为7，即含有7个ZooKeeper Server，<code>读请求次数/读写请求总次数</code>比重值固定为30%。实验中的ZooKeeper Server版本为“3.2”，运行ZooKeeper Server的服务器的CPU为“dual 2Ghz Xeon”，具有两个<code>SATA 15K RPM drives</code>，运行将近910个客户端发出读写请求。<br>测定依次出现以下5种情形时，<code>处理请求数/秒</code>值的变化情况：</p>
<ol>
<li>一个Follower ZooKeeper Server挂掉，然后恢复</li>
<li>另外一个Follower ZooKeeper Server挂掉，然后恢复</li>
<li>Leader ZooKeeper Server挂掉</li>
<li>两个Follower ZooKeeper Server都挂掉，然后都恢复</li>
<li>另外一个Leader ZooKeeper Server挂掉</li>
</ol>
<p><strong>2、实验结果</strong><br>见图4，图中标号跟上述5种情形的标号一一对应。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20170905-0-4.jpg"></p>
<p><strong>3、实验结论</strong><br>主要结论有两点：1）在Follower ZooKeeper Server的挂掉然后迅速恢复情形中，<code>处理请求数/秒</code>未产生较大波动；2）在Leader ZooKeeper Server的挂掉情形中，在重新选举Leader ZooKeeper Server的时间区间内，<code>处理请求数/秒</code>大幅度降低，但是一旦选举完成，<code>处理请求数/秒</code>即迅速恢复到正常水平值，另外可发现，Leader ZooKeeper Server的重新选举过程能够非常快地完成。</p>
<br/>
文档地址：https://zookeeper.apache.org/doc/r3.4.10/zookeeperOver.html
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>ZooKeeper</category>
      </categories>
  </entry>
  <entry>
    <title>basename命令</title>
    <url>/blog/2016/12/30/basename%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basename NAME [SUFFIX]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与示例"><a href="#二、含义与示例" class="headerlink" title="二、含义与示例"></a><strong>二、含义与示例</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>对于给定的文件路径，除去前导的父目录路径，如果指定了“SUFFIX”，那么也除去“SUFFIX”指定的后缀，把最终剩余部分打印出来。</p>
<h3 id="2-2、示例"><a href="#2-2、示例" class="headerlink" title="2.2、示例"></a><strong>2.2、示例</strong></h3><p>现有以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basename include/stdio.h .h</span><br></pre></td></tr></table></figure>
<p>对于给定的文件路径“include&#x2F;stdio.h”，除去前导的父目录路径“include&#x2F;”，得到“stdio.h”，命令还指定了“SUFFIX&#x3D;.h”，那么再除去“.h”后缀，得到“stdio”，因此最后打印“stdio”。</p>
<br/>
参考文献：
[1]man basename
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>cat命令</title>
    <url>/blog/2016/10/20/cat%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [FILE1] [FILE2]...</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>拼接文件内容，输出到标准输出中。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“FILE1 FILE2”：指定参与拼接文件路径，如果为“-”，表示从标准输入读取拼接数据。</p>
<br/>
参考文献：
[1]man cat
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>chgrp命令</title>
    <url>/blog/2016/12/30/chgrp%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp [-R] GROUP FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>将“FILE”文件的用户组更改为“GROUP”。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-R”：递归更改。</p>
<br/>
参考文献：
[1]man chgrp
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>chmod命令</title>
    <url>/blog/2016/12/14/chmod%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R xxxx FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>设置文件或者目录的权限属性。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“R”：递归设置目录下文件和目录的权限属性。<br>“xxxx”：有4个<code>x</code>，每个<code>x</code>的值为<code>0-7</code>，如果少于4个，那么默认在前面用<code>0</code>补全，即<code>77</code>等价于<code>0077</code>。为了简单起见，我们每次使用的时候，都指定4个<code>x</code>。</p>
<ul>
<li>第一个<code>x</code>：设置“SUID(4)，SGID(2)，STICKY(1)”权限</li>
<li>第二个<code>x</code>：设置文件属主的“r读权限(4)，w写权限(2)，x执行权限(1)”</li>
<li>第三个<code>x</code>：设置文件所属组的“r读权限(4)，w写权限(2)，x执行权限(1)”</li>
<li>第四个<code>x</code>：设置其他用户的“r读权限(4)，w写权限(2)，x执行权限(1)”</li>
</ul>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、SUID，SGID，STICKY"><a href="#3-1、SUID，SGID，STICKY" class="headerlink" title="3.1、SUID，SGID，STICKY"></a><strong>3.1、SUID，SGID，STICKY</strong></h3><p>1、设置了SUID，会把文件属主的<code>rwx</code>权限中的<code>x</code>替换为<code>s</code>[文件属主具有<code>x</code>权限]或者<code>S</code>[文件属主不具有<code>x</code>权限]；<br>2、设置了SGID，会把文件所属组的<code>rwx</code>权限中的<code>x</code>替换为<code>s</code>[文件所属组具有<code>x</code>权限]或者<code>S</code>[文件所属组不具有<code>x</code>权限]；<br>3、设置了STICKY，会把其他用户的<code>rwx</code>权限中的<code>x</code>替换为<code>t</code>[其他用户具有<code>x</code>权限]或者<code>T</code>[其他用户不具有<code>x</code>权限]。</p>
<h3 id="3-2、另外一个问题"><a href="#3-2、另外一个问题" class="headerlink" title="3.2、另外一个问题"></a><strong>3.2、另外一个问题</strong></h3><p>1、在清除文件的SUID，SGID，STICKY权限的时候，可以使用<code>chmod 0xxx</code>的形式<br>2、在清除目录的SUID，SGID权限的时候，不可以使用<code>chmod 0xxx</code>的形式，原因如下[1]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">These convenience mechanisms rely on the set-user-ID and set-group-ID bits of directories.  If commands like `chmod` and `mkdir` routinely cleared these bits on directories, the mechanisms would be less convenient and it would be harder to share files.  Therefore, a command like `chmod` does not affect the set-user-ID or set-group-ID bits of a directory unless the user specifically mentions them in a symbolic mode, or uses an operator numeric mode such as `=755`, or sets them in a numeric mode, or clears them in a numeric mode that has five or more octal digits.</span><br></pre></td></tr></table></figure>
<p>在[1]中同时提到了一个解决方案，就是在原先的4个<code>x</code>的基础上，再加一个或多个前置<code>x</code>，我们取1位0好了，即<code>0xxxx</code>的形式。</p>
<p><font color='red'>综上，我们统一使用<code>0xxxx</code>（指定5位）来设置文件属主，文件所属组，其他用户的rwx权限和SUID，SGID，STICKY权限。</font></p>
<br/>
参考文献：
[1]info chmod--27.5 Directories and the Set-User-ID and Set-Group-ID Bits
[2]man chmod
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>chown命令</title>
    <url>/blog/2016/12/08/chown%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [-R] OWNER FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>将“FILE”所指代文件的所有者改变为“OWNER”。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“R”：递归改变。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>comm命令</title>
    <url>/blog/2016/05/26/comm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comm FILE1 FILE2</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>对于两个<font color='red'>已排序</font>的文件，逐行比对。<br>打印结果有3列：第1列，只属于“FILE1”的行；第2列，只属于“FILE2”的行；第3列，既属于“FILE1”，又属于“FILE2”的行。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“FILE1，FILE2”：指代已排序文件“FILE1”和“FILE2”</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、“LC-COLLATE”等环境变量"><a href="#3-1、“LC-COLLATE”等环境变量" class="headerlink" title="3.1、“LC_COLLATE”等环境变量"></a><strong>3.1、“LC_COLLATE”等环境变量</strong></h3><p>由于涉及到两个字符串的比较等，故而程序实现中使用“LC_COLLATE”等环境变量，最终结果受到“LC_COLLATE”等环境变量的控制。</p>
<h3 id="3-2、排序策略"><a href="#3-2、排序策略" class="headerlink" title="3.2、排序策略"></a><strong>3.2、排序策略</strong></h3><p>comm命令实现设定的排序策略是“按照字典序排序”。两个已排序文件使用的排序策略组合共有3种情况。</p>
<h4 id="3-2-1、情况1"><a href="#3-2-1、情况1" class="headerlink" title="3.2.1、情况1"></a><strong>3.2.1、情况1</strong></h4><p>一个排序文件按照字典序排序，另外一个排序文件按照非字典序（其他排序策略）排序。显而易见，在这种情况下，comm命令的执行结果会比较奇怪。</p>
<h4 id="3-2-2、情况2"><a href="#3-2-2、情况2" class="headerlink" title="3.2.2、情况2"></a><strong>3.2.2、情况2</strong></h4><p>两个排序文件都按照同一个排序策略（非字典序）排序，这种情况下，comm命令的执行结果还是不能达到我们的预期。<br>接下来通过例子说明，有文件“c.txt”和“d.txt”，内容分别如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">001</span><br><span class="line">02</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">001</span><br><span class="line">02</span><br><span class="line">5</span><br><span class="line">06</span><br><span class="line">007</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>即已按照“数值大小”排序，执行“逐行比对”过程，我们的预期结果是：“3”只属于“c.txt”，“5，06，007”只属于“d.txt”，“001，02，10”共属于两个文件。</p>
<p>现在执行<code>comm c.txt d.txt</code>命令，得到如图1所示结果，不能达到预期。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160526-0-1.png"></p>
<p>执行<code>comm --nocheck-order c.txt d.txt</code>命令，得到如图2所示结果，也不能达到预期。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160526-0-2.png"></p>
<h4 id="3-2-3、情况3"><a href="#3-2-3、情况3" class="headerlink" title="3.2.3、情况3"></a><strong>3.2.3、情况3</strong></h4><p>两个文件都已按照字典序排序，这符合comm命令实现的设定，comm命令的执行结果能够达到预期。执行下述命令，得到如图3所示结果，结果符合预期。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort c.txt &gt; cc.txt</span><br><span class="line">sort d.txt &gt; dd.txt</span><br><span class="line">comm cc.txt dd.txt</span><br></pre></td></tr></table></figure>

<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160526-0-3.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man comm</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>convmv命令</title>
    <url>/blog/2016/10/20/convmv%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">convmv -f SrcEncoding -t DestEncoding -r --notest File/Dir </span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>改变文件“File”或者目录“Dir”下所有文件的文件名的编码方案，从“SrcEncoding”编码方案转到“DestEncoding”编码方案 。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-f”：源编码方案。<br>“-t”：目标编码方案。<br>“-r”：对目录下子目录递归处理。<br>“–notest”：真正执行转变操作，默认只是打印转变前后信息，而不真正执行转变操作。</p>
<br/>
参考文献：
[1]man convmv
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>cp命令</title>
    <url>/blog/2016/10/18/cp%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r --backup=numbered --strip-trailing-slashes SOURCE DEST</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><h4 id="2-1-1、含义1"><a href="#2-1-1、含义1" class="headerlink" title="2.1.1、含义1"></a><strong>2.1.1、含义1</strong></h4><p>复制SOURCE所表示的源文件到目的目录DEST：即DEST的最后一个符号是“&#x2F;”，该目录将作为复制后文件的父目录。这种情况下，需要指定复制后文件的位置，不需要指定复制后文件的文件名。</p>
<h4 id="2-1-2、含义2"><a href="#2-1-2、含义2" class="headerlink" title="2.1.2、含义2"></a><strong>2.1.2、含义2</strong></h4><p>复制SOURCE所表示的源文件，使复制后文件的最终路径是DEST：即DEST的最后一个符号不是“&#x2F;”，该DEST将作为复制后文件最后的表示路径。这种情况下，既需要指定复制后文件的位置，也需要指定复制后文件的文件名。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-r”：表示递归复制目录下文件。<br>“–backup&#x3D;numbered”：表示启用备份机制，在复制源文件的时候，如果在目的路径上已经存在同名的文件，不会删除同名文件，而是改变其名字。注意，配置该参数，只会对一般文件启用备份机制，不会对目录启用备份机制。<br>“–strip-trailing-slashes”：如果SOURCE的最后一个符号是“&#x2F;”，那么去除掉它。需要注意的是，在SOURCE中最后的“&#x2F;”符号，本就是没有意义的。</p>
<br/>
参考文献：
[1]man cp
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab命令</title>
    <url>/blog/2016/10/12/crontab%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><p>列出当前用户的定时任务配置列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<p>编辑当前用户的定时任务配置列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p><font color='red'>备注：</font><br>不同用户有不同的定时任务配置列表。</p>
<h2 id="二、定时任务配置语法"><a href="#二、定时任务配置语法" class="headerlink" title="二、定时任务配置语法"></a><strong>二、定时任务配置语法</strong></h2><h3 id="2-1、注释语句"><a href="#2-1、注释语句" class="headerlink" title="2.1、注释语句"></a><strong>2.1、注释语句</strong></h3><p>注释语句形式如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（前导内容，可以是空格符，TAB符；或者无前导内容）#注释语句正文内容\n</span><br></pre></td></tr></table></figure>
<h3 id="2-2、定时任务配置语句"><a href="#2-2、定时任务配置语句" class="headerlink" title="2.2、定时任务配置语句"></a><strong>2.2、定时任务配置语句</strong></h3><p>定时任务配置语句形式如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（前导内容，可以是空格符，TAB符；或者无前导内容）定时时间配置（“定时时间配置”和“具体执行命令”之间以空格符或者TAB符隔开）具体执行命令\n</span><br></pre></td></tr></table></figure>
<h4 id="2-2-1、定时时间配置"><a href="#2-2-1、定时时间配置" class="headerlink" title="2.2.1、定时时间配置"></a><strong>2.2.1、定时时间配置</strong></h4><p>形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分钟 小时 月语境中的日 月 星期语境中的日（字段间以空格符或者TAB符隔开）</span><br></pre></td></tr></table></figure>
<p>以上5个字段的可取值范围描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>可取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>小时</td>
<td>0-23</td>
</tr>
<tr>
<td>月语境中的日</td>
<td>1-31</td>
</tr>
<tr>
<td>月</td>
<td>1-12</td>
</tr>
<tr>
<td>星期语境中的日</td>
<td>0-7（0和7都表示星期日）</td>
</tr>
</tbody></table>
<p>以上5个字段的值设置形式有4种：单值（比如“0”，“5”，“31”），范围（比如“0-59”，“1-31”，“0-6”），列表（比如“1,2,5”，“0-4,8-12”），通配符“*”（等价于相应字段可取值范围全集，比如对应于“分钟”字段，等价于“0-59”）。<br>另外可以在“范围”和“通配符”这两种值设置形式中设定“取值间隔”，比如“0-59&#x2F;2”，“*&#x2F;2”。<br>以上5个字段中有两个“日”，那么当前时间匹配这两个“日”中的哪一个时，配置的定时任务能够得到执行？针对这个问题，有以下规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果存在一个“日”的值设置形式为“通配符”，那么这两个“日”的关系是“与”关系，即当前时间只有同时匹配这两个“日”时，配置的定时任务才会得到执行；</span><br><span class="line">否则，这两个“日”的关系是“或”关系，即当前时间只要匹配这两个“日”中任意一个时，配置的定时任务便会得到执行</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、具体执行命令"><a href="#2-2-2、具体执行命令" class="headerlink" title="2.2.2、具体执行命令"></a><strong>2.2.2、具体执行命令</strong></h4><p>配置“具体执行命令”。</p>
<br/>
参考文献：
[1]man 1 crontab
[2]man 5 crontab
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>cut命令</title>
    <url>/blog/2016/11/18/cut%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut [--delimiter=DELIM] [--complement] [-c | -f] RANGE [FILE]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><h4 id="2-1-1、选择“-c”选项"><a href="#2-1-1、选择“-c”选项" class="headerlink" title="2.1.1、选择“-c”选项"></a><strong>2.1.1、选择“-c”选项</strong></h4><p>未加“–complement”选项，表示打印“FILE”每行“RANGE”范围内的字符；加“–complement”选项，表示打印“FILE”每行“RANGE”范围外的字符，即是前者的补集。</p>
<h4 id="2-1-2、选择“-f”选项"><a href="#2-1-2、选择“-f”选项" class="headerlink" title="2.1.2、选择“-f”选项"></a><strong>2.1.2、选择“-f”选项</strong></h4><p>默认使用“TAB”字符作为字段分隔符，如果使用“–delimiter&#x3D;DELIM”选项，那么使用“DELIM”字符作为字段分隔符。<br>未加“–complement”选项，表示打印“FILE”每行“RANGE”范围内的字段；加“–complement”选项，表示打印“FILE”每行“RANGE”范围外的字段，即是前者的补集。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“–delimiter&#x3D;DELIM”：使用“DELIM”字符作为字段分隔符。<font color='red'>需要注意的是，“DELIM”表示单字符，而不能是字符串。</font><br>“–complement”：表示打印“RANGE”范围外的内容。<br>“-c RANGE”：表示打印“RANGE”范围内的字符。<br>“-f RANGE”：表示打印“RANGE”范围内的字段。</p>
<h2 id="三、“RANGE”构成"><a href="#三、“RANGE”构成" class="headerlink" title="三、“RANGE”构成"></a><strong>三、“RANGE”构成</strong></h2><p>“RANGE”有以下4种基本构成元素。<br><strong>1、N</strong><br>表示第N个字符或者字段，从1开始计数。<br><strong>2、N-</strong><br>表示“第N个”到“行尾”范围内的字符或者字段，从1开始计数。<br><strong>3、N-M</strong><br>表示“第N个”到“第M个”范围内的字符或者字段，从1开始计数。<br><strong>4、-M</strong><br>表示“行首”到“第M个”范围内的字符或者字段，从1开始计数。</p>
<h2 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a><strong>四、一些例子</strong></h2><p>以文件“a.txt”为实验素材，“a.txt”的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello (前面是一个空格字符)world</span><br><span class="line">hello	(前面是一个TAB字符)world</span><br><span class="line">29817 29611 18:48 S ?        /opt/google/chrome/chrome</span><br></pre></td></tr></table></figure>
<h3 id="4-1、例子1"><a href="#4-1、例子1" class="headerlink" title="4.1、例子1"></a><strong>4.1、例子1</strong></h3><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -c 1-5 a.txt</span><br></pre></td></tr></table></figure>
<p>得到如图1所示结果。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20161118-0-1.png" alt="这里写图片描述"></p>
<h3 id="4-2、例子2"><a href="#4-2、例子2" class="headerlink" title="4.2、例子2"></a><strong>4.2、例子2</strong></h3><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -f 1 a.txt</span><br></pre></td></tr></table></figure>
<p>得到如图2所示结果，注意默认是以“TAB”字符作为字段分隔符，只有第二行存在一个“TAB”字符。</p>
<p>图2<br><img src="https://blog.dslztx.top/imgs/20161118-0-2.png" alt="这里写图片描述"></p>
<h3 id="4-3、例子3"><a href="#4-3、例子3" class="headerlink" title="4.3、例子3"></a><strong>4.3、例子3</strong></h3><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut --delimiter=&#x27; &#x27; -f 1 a.txt</span><br></pre></td></tr></table></figure>
<p>得到如图3所示结果，注意现在是以“空格”字符作为字段分隔符，第一行和第三行都存在着“空格”字符。</p>
<p>图3<br><img src="https://blog.dslztx.top/imgs/20161118-0-3.png" alt="这里写图片描述"></p>
<h3 id="4-4、例子4"><a href="#4-4、例子4" class="headerlink" title="4.4、例子4"></a><strong>4.4、例子4</strong></h3><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut --complement -c 1-5 a.txt</span><br></pre></td></tr></table></figure>
<p>得到如图4所示结果。</p>
<p>图4<br><img src="https://blog.dslztx.top/imgs/20161118-0-4.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>df命令</title>
    <url>/blog/2016/12/28/df%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df [-i] [-h] [FILE]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>打印“FILE”文件所在文件系统的容量使用情况；如果“FILE”参数未指定，则打印所有文件系统的容量使用情况。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-i”：加上“-i”选项，打印文件系统中Inode节点集合容量的使用情况；否则，打印文件系统中Block节点集合容量的使用情况。<br>“-h”：以人类可读形式展现容量。<br>“FILE”：位于目标文件系统上的文件，如果“FILE”参数未指定，则打印所有文件系统的容量使用情况。</p>
<h2 id="三、“-i”和“-h”选项"><a href="#三、“-i”和“-h”选项" class="headerlink" title="三、“-i”和“-h”选项"></a><strong>三、“-i”和“-h”选项</strong></h2><p>文件系统容量分为：Block节点集合容量和Inode节点集合容量。</p>
<h3 id="3-1、Block节点集合容量"><a href="#3-1、Block节点集合容量" class="headerlink" title="3.1、Block节点集合容量"></a><strong>3.1、Block节点集合容量</strong></h3><p>默认情况下打印文件系统上Block节点集合容量的情况。</p>
<h4 id="3-1-1、不加“-h”选项"><a href="#3-1-1、不加“-h”选项" class="headerlink" title="3.1.1、不加“-h”选项"></a><strong>3.1.1、不加“-h”选项</strong></h4><p>示例如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20161228-0-1.png"></p>
<p>“1K-blocks”中的“1K”表示“以1K字节大小作为基本统计单元”，其中的“block”不是指代“Inode&#x2F;Block节点体系”中的“Block节点”，而只是“基本统计单元”的含义。值<code>19478204</code>表示“基本统计单元总数量为19478204个”，即容量约为<code>18G</code>（“19478204*1K&#x2F;1024&#x2F;1024&#x2F;1024”约等于“18G”）。<br>“已用”表示已使用基本统计单元数量。<br>“可用”表示可使用基本统计单元数量。<br>“已用%”表示“已使用基本统计单元数量”与“基本统计单元总数量”的比值。</p>
<h4 id="3-1-2、加“-h”选项"><a href="#3-1-2、加“-h”选项" class="headerlink" title="3.1.2、加“-h”选项"></a><strong>3.1.2、加“-h”选项</strong></h4><p>加“-h”选项，以人类可读形式展现容量。示例如图2。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20161228-0-2.png"></p>
<p>“容量”表示容量总大小。<br>“已用”表示已使用容量。<br>“可用”表示可使用容量。<br>“已用%”表示“已使用容量”与“容量总大小”的比值。</p>
<h3 id="3-2、Inode节点集合容量"><a href="#3-2、Inode节点集合容量" class="headerlink" title="3.2、Inode节点集合容量"></a><strong>3.2、Inode节点集合容量</strong></h3><p>加上“-i”选项打印Inode节点集合容量的情况。</p>
<h4 id="3-2-1、不加“-h”选项"><a href="#3-2-1、不加“-h”选项" class="headerlink" title="3.2.1、不加“-h”选项"></a><strong>3.2.1、不加“-h”选项</strong></h4><p>示例如图3。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20161228-0-3.png"></p>
<p>“Inode”表示Inode节点总数量。<br>“已用(I)”表示已使用Inode节点数量。<br>“可用(I)”表示可使用Inode节点数量。<br>“已用(I)%”表示“已使用Inode节点数量”与“Inode节点总数量”的比值。</p>
<h4 id="3-2-2、加“-h”选项"><a href="#3-2-2、加“-h”选项" class="headerlink" title="3.2.2、加“-h”选项"></a><strong>3.2.2、加“-h”选项</strong></h4><p>加“-h”选项，以人类可读形式展现容量。示例如图4。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20161228-0-4.png"></p>
<p>“Inode”表示Inode节点总数量，以人类可读形式展现。<br>“已用(I)”表示已使用Inode节点数量，以人类可读形式展现。<br>“可用(I)”表示可使用Inode节点数量，以人类可读形式展现。<br>“已用(I)%”表示“已使用Inode节点数量”与“Inode节点总数量”的比值。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、几个等式的不成立"><a href="#4-1、几个等式的不成立" class="headerlink" title="4.1、几个等式的不成立"></a><strong>4.1、几个等式的不成立</strong></h3><p>需要注意的是，打印信息中，几个理论上应该成立的等式并不成立：<code>1K-blocks=已用+可用</code>，<code>已用%=已用/1K-blocks*100%</code>，<code>容量=已用+可用</code>，<code>已用%=已用/容量*100%</code>，<code>Inode=已用(I)+可用(I)</code>和<code>已用(I)%=已用(I)/Inode*100%</code>。<font color='red'>作者不知道具体实现细节，因此不知道具体原因。</font></p>
<h3 id="4-2、“df”命令与“ls，stat，du”命令的差异"><a href="#4-2、“df”命令与“ls，stat，du”命令的差异" class="headerlink" title="4.2、“df”命令与“ls，stat，du”命令的差异"></a><strong>4.2、“df”命令与“ls，stat，du”命令的差异</strong></h3><p><code>df</code>命令与<code>ls，stat，du</code>命令的差异：</p>
<ul>
<li><code>df</code>命令面向文件系统，<code>ls，stat，du</code>命令面向文件（包括“一般文件”和“目录文件”）</li>
<li>在Block节点集合容量的范畴下，<code>ls，stat，du</code>命令统计“一般文件”的容量是基于“使用大小”的，统计“目录文件”的容量是基于“占用大小”的；<code>df</code>命令的统计是基于“占用大小”的（关于文件的“使用大小”和“占用大小”可见<a href="/blog/2016/10/18/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E2%80%9C%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D%E5%92%8C%E2%80%9C%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D/" title="Ext文件系统中，文件的“占用大小”和“使用大小”">《Ext文件系统中，文件的“占用大小”和“使用大小”》</a>）</li>
<li><code>df</code>命令跟<code>ls，stat，du</code>命令不一样，加上“-h”选项并不会产生“计算误差”，因为在<code>df</code>命令中，加上“-h”选项导致的转换是在最终统计后直接进行的</li>
</ul>
<br/>
参考文献：
[1]man df
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>dirname命令</title>
    <url>/blog/2016/12/30/dirname%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname NAME</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与示例"><a href="#二、含义与示例" class="headerlink" title="二、含义与示例"></a><strong>二、含义与示例</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>对于给定的文件路径：</p>
<ul>
<li>如果文件路径中包含“&#x2F;”符号，除去最后一部分名称内容，接着除去<font color='red'>冗余的</font>“&#x2F;”符号，打印最终剩余部分内容</li>
<li>如果文件路径中不包含“&#x2F;”符号，最后打印“.”</li>
</ul>
<h3 id="2-2、示例"><a href="#2-2、示例" class="headerlink" title="2.2、示例"></a><strong>2.2、示例</strong></h3><h4 id="2-2-1、示例1"><a href="#2-2-1、示例1" class="headerlink" title="2.2.1、示例1"></a><strong>2.2.1、示例1</strong></h4><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname /home/dsl/Desktop/a.out</span><br></pre></td></tr></table></figure>
<p>得到以下打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/dsl/Desktop</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、示例2"><a href="#2-2-2、示例2" class="headerlink" title="2.2.2、示例2"></a><strong>2.2.2、示例2</strong></h4><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname /home</span><br></pre></td></tr></table></figure>
<p>得到以下打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3、示例3"><a href="#2-2-3、示例3" class="headerlink" title="2.2.3、示例3"></a><strong>2.2.3、示例3</strong></h4><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname home</span><br></pre></td></tr></table></figure>
<p>得到以下打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man dirname
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>du命令</title>
    <url>/blog/2016/12/22/du%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du --apparent-size -sh 文件路径（文件可以是目录，也可以是一般文件）</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>当文件为“一般文件”时，计算该文件的“使用大小”；当文件为“目录”时，计算“该目录自身的占用大小+目录下所有子文件（递归进行）的大小”之和。递归计算时，“一般文件”的大小还是“使用大小”，“目录”的大小还是“占用大小”（关于文件的“使用大小”和“占用大小”可见<a href="/blog/2016/10/18/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E2%80%9C%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D%E5%92%8C%E2%80%9C%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D/" title="Ext文件系统中，文件的“占用大小”和“使用大小”">《Ext文件系统中，文件的“占用大小”和“使用大小”》</a>）。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“–apparent-size”：加上该选项，计算时，“一般文件”的大小为“使用大小”，“目录”的大小为“占用大小”。<br>“-s”：当“du”命令的操作对象是一个目录时，不打印该目录下子文件的大小，只打印目录总大小。<br>“-h”：以人类可读形式打印文件大小。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、“du”命令的按字节统计工作方式"><a href="#3-1、“du”命令的按字节统计工作方式" class="headerlink" title="3.1、“du”命令的按字节统计工作方式"></a><strong>3.1、“du”命令的按字节统计工作方式</strong></h3><p>加上“–block-size&#x3D;1”选项，可使用“du”命令的按字节统计工作方式。</p>
<h4 id="3-1-1、一般文件"><a href="#3-1-1、一般文件" class="headerlink" title="3.1.1、一般文件"></a><strong>3.1.1、一般文件</strong></h4><p>有一个一般文件“file.md”，分别执行<code>ls -l file.md</code>和<code>du --apparent-size --block-size=1 file.md</code>命令，得到如下两个执行结果，可知两个计算文件大小的命令结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 dsl dsl 34998 12月 22 21:32 file.md</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">34998	file.md</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2、目录"><a href="#3-1-2、目录" class="headerlink" title="3.1.2、目录"></a><strong>3.1.2、目录</strong></h4><p>有一个空目录“sizedir”，分别执行<code>ls -l</code>和<code>du --apparent-size --block-size=1 sizedir</code>命令，得到如下两个执行结果，可知两个计算文件大小的命令结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxrwxr-x  2 dsl dsl 4096 12月 22 22:49 sizedir</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4096	sizedir</span><br></pre></td></tr></table></figure>
<h3 id="3-2、加上“h”选项后的计算误差"><a href="#3-2、加上“h”选项后的计算误差" class="headerlink" title="3.2、加上“h”选项后的计算误差"></a><strong>3.2、加上“h”选项后的计算误差</strong></h3><p>跟<a href="/blog/2016/10/18/ls%E5%91%BD%E4%BB%A4/" title="ls命令">《ls命令》</a>文章内“三、其他”小节描述的一样，加上“h”选项后，计算大小时，会有计算误差产生。</p>
<h4 id="3-2-1、一般文件"><a href="#3-2-1、一般文件" class="headerlink" title="3.2.1、一般文件"></a><strong>3.2.1、一般文件</strong></h4><p>分别执行<code>ls -lh file.md</code>和<code>du --apparent-size -h file.md</code>命令，得到如下两个执行结果，可知两个计算文件大小的命令结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 dsl dsl 35K 12月 22 21:32 file.md</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35K	file.md</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2、目录"><a href="#3-2-2、目录" class="headerlink" title="3.2.2、目录"></a><strong>3.2.2、目录</strong></h4><p>分别执行<code>ls -lh</code>和<code>du --apparent-size -h sizedir</code>命令，得到如下两个执行结果，可知两个计算文件大小的命令结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxrwxr-x 2 dsl dsl 4.0K 12月 22 23:18 sizedir</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.0K	sizedir</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man du
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>file命令</title>
    <url>/blog/2016/12/30/file%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file -i FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>打印“FILE”文件的类型和编码格式。需要注意的是，没有命令能够确切知道文件的编码格式，而只能是推测，因此通过本命令得到的文件编码格式不一定是正确的。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-i”：表示以“Mime-Type”形式打印文件的类型和编码格式。</p>
<br/>
参考文献：
[1]man file
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>finally语句不被执行的几种情形</title>
    <url>/blog/2018/08/29/finally%E8%AF%AD%E5%8F%A5%E4%B8%8D%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%BD%A2/</url>
    <content><![CDATA[<p>一般情形下，“try-catch-finally语句结构”中的“finally语句”始终会被执行。<br>以下列出几种“finally语句”不被执行的情形：</p>
<ul>
<li>所有非后台线程运行结束，Java进程直接退出</li>
<li>执行<code>System.exit()</code>语句，Java进程直接退出</li>
<li>Java进程直接被操作系统杀死</li>
</ul>
<p>可以发现，上述几种不被执行的情形本质上都是“Java进程由于某种原因直接退出而未能来得及执行finally语句”。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>final修饰符</title>
    <url>/blog/2018/02/27/final%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a><strong>一、含义</strong></h2><p>final修饰符能够修饰“类，变量，方法”。</p>
<h3 id="1-1、类"><a href="#1-1、类" class="headerlink" title="1.1、类"></a><strong>1.1、类</strong></h3><p>final修饰符修饰“类”，表示该类不允许被继承，因此“类”只能是“具体类，枚举”，而不能是“抽象类，接口，注解”。</p>
<h3 id="1-2、变量"><a href="#1-2、变量" class="headerlink" title="1.2、变量"></a><strong>1.2、变量</strong></h3><p>final修饰符修饰“变量”，表示变量在被使用前必须“被显式初始化，且只能被显式初始化一次”。<br><font color='red'>“只能被显式初始化一次”的含义：</font>如果是基本类型变量，只能被显式初始化一次，不能进行第二次显式初始化，即第一次显式初始化后变量值保持不变；如果是引用类型变量，只能被显式初始化一次，不能进行第二次显式初始化，即第一次显式初始化后变量值保持不变，但是需要注意的是，引用类型变量所指对象的内容是允许被改变的。<br>“变量”分为3种：“字段，方法形式参数变量，局部变量”。</p>
<h4 id="1-2-1、字段"><a href="#1-2-1、字段" class="headerlink" title="1.2.1、字段"></a><strong>1.2.1、字段</strong></h4><p>字段的“默认初始化”不被认为是“显式初始化”，只有“定义初始化，实例初始化语句初始化，构造器初始化”（针对普通字段）和“定义初始化，静态初始化语句初始化”（针对静态字段）才被认为是“显式初始化”。</p>
<h4 id="1-2-2、方法形式参数变量"><a href="#1-2-2、方法形式参数变量" class="headerlink" title="1.2.2、方法形式参数变量"></a><strong>1.2.2、方法形式参数变量</strong></h4><p>方法形式参数变量的初始化天然的是“显式初始化”，因为不存在“默认初始化”。</p>
<h4 id="1-2-3、局部变量"><a href="#1-2-3、局部变量" class="headerlink" title="1.2.3、局部变量"></a><strong>1.2.3、局部变量</strong></h4><p>局部变量的初始化天然的是“显式初始化”，因为不存在“默认初始化”。</p>
<h3 id="1-3、方法"><a href="#1-3、方法" class="headerlink" title="1.3、方法"></a><strong>1.3、方法</strong></h3><p>final修饰符修饰“方法”，表示该方法不允许被覆盖，因此显而易见的是：final修饰符不能跟abstract修饰符共用。</p>
<h2 id="二、编译期常量"><a href="#二、编译期常量" class="headerlink" title="二、编译期常量"></a><strong>二、编译期常量</strong></h2><p>字段或者局部变量（<font color='red'>方法形式参数变量不能进行定义初始化，因此天然不满足成为编译期常量的基本条件</font>）只有满足以下两个条件时才能被称为“编译期常量”：</p>
<ol>
<li>由final修饰符修饰 </li>
<li>字段或者局部变量为“基本类型或者String类型”，进行“<font color='red'>定义初始化</font>”，且在定义初始化时使用“确切的值”进行赋值，而不需要通过间接的运算（虚拟机会对满足条件的<code>+，-，*，/</code>等运算进行编译期优化，具体的条件描述笔者不知，可认为这些经过编译期优化的<code>+，-，*，/</code>等运算不属于上述“间接的运算”）</li>
</ol>
<p>本质上，“类”只包括“具体类和接口”，为进行完备介绍，分别以具体类和接口中的编译期常量进行举例说明。</p>
<p><font color='red'>备注</font>：<br>接口中的字段默认由“public static final”修饰符组合修饰。</p>
<h3 id="2-1、编译期常量识别和混淆"><a href="#2-1、编译期常量识别和混淆" class="headerlink" title="2.1、编译期常量识别和混淆"></a><strong>2.1、编译期常量识别和混淆</strong></h3><p>以下示例代码给出了几个“编译期常量”和“易被混淆为编译期常量”的例子。</p>
<p>具体类中的编译期常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompileConstantExampleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> rand.nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量，编译期优化：编译时完成拼接</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">h</span> <span class="operator">=</span> <span class="string">&quot;wor&quot;</span> + <span class="string">&quot;ld&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">q</span> <span class="operator">=</span> d + <span class="string">&quot; beautiful&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">10</span> - <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">20</span> / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span> + rand.nextInt(<span class="number">10</span>) + <span class="string">&quot;ld&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    j = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非编译期常量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    k = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(CompileConstantExampleClass.b);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.d);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.f);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.h);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.i);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.k);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.p);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.q);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.r);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.s);</span><br><span class="line">    System.out.println(CompileConstantExampleClass.t);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompileConstantExampleClass</span> <span class="variable">compileConstantExampleClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompileConstantExampleClass</span>();</span><br><span class="line">    System.out.println(compileConstantExampleClass.a);</span><br><span class="line">    System.out.println(compileConstantExampleClass.c);</span><br><span class="line">    System.out.println(compileConstantExampleClass.e);</span><br><span class="line">    System.out.println(compileConstantExampleClass.g);</span><br><span class="line">    System.out.println(compileConstantExampleClass.j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rand.nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> <span class="string">&quot;hell&quot;</span> + rand.nextInt(<span class="number">10</span>) + <span class="string">&quot;o&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    System.out.println(m);</span><br><span class="line">    System.out.println(n);</span><br><span class="line">    System.out.println(o);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的编译期常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompileConstantExampleInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> rand.nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span> + rand.nextInt(<span class="number">10</span>) + <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(CompileConstantExampleInterface.a);</span><br><span class="line">    System.out.println(CompileConstantExampleInterface.b);</span><br><span class="line">    System.out.println(CompileConstantExampleInterface.c);</span><br><span class="line">    System.out.println(CompileConstantExampleInterface.d);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、编译期常量访问"><a href="#2-2、编译期常量访问" class="headerlink" title="2.2、编译期常量访问"></a><strong>2.2、编译期常量访问</strong></h3><p>根据<a href="/blog/2018/01/07/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%A4%8D%E7%94%A8%E7%B1%BB/" title="Java编程思想#复用类">Java编程思想#复用类</a>可知，第一次访问类的“静态字段”会触发执行“类对象初始化”，但是有个例外：如果“静态字段”是“编译期常量”，则第一次访问该“静态字段”并不会触发执行“类对象初始化”。<br>具体原因：虚拟机会对访问“编译期常量”的源代码进行编译期优化，优化后等效于“直接配定相应常量值，而不再引用原字段或者局部变量”，因此自然不会触发执行“类对象初始化”。<br>以下示例代码给出了几个例子。</p>
<p>具体类中的编译期常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;触发类对象初始化的标志&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> <span class="string">&quot;wor&quot;</span> + <span class="string">&quot;ld&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompileConstantInClass</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次只访问A中一个字段，进行验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    System.out.println(A.a);</span></span><br><span class="line"><span class="comment">//    System.out.println(A.b);</span></span><br><span class="line"><span class="comment">//    System.out.println(A.c);</span></span><br><span class="line"><span class="comment">//    System.out.println(A.d);</span></span><br><span class="line">    System.out.println(A.e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的编译期常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> C.f();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> rand.nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;调用C类的f()方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompileConstantInInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次只访问B中一个字段，进行验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    System.out.println(B.a);</span></span><br><span class="line"><span class="comment">//    System.out.println(B.b);</span></span><br><span class="line"><span class="comment">//    System.out.println(B.c);</span></span><br><span class="line">    System.out.println(B.d);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
**备注：**
可借助`javap -c`命令进行编译期常量的相关验证。
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令</title>
    <url>/blog/2018/04/07/find%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find path [-maxdepth N] test</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>在指定路径下，找到符合条件的文件和目录。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“path”：表示查找范围的路径。<br>“-maxdepth N”：表示查找的最深深度为N层。<br>“test”：需要满足的条件。</p>
<h2 id="三、常用的test"><a href="#三、常用的test" class="headerlink" title="三、常用的test"></a><strong>三、常用的test</strong></h2><h3 id="3-1、关于文件时间的几个test"><a href="#3-1、关于文件时间的几个test" class="headerlink" title="3.1、关于文件时间的几个test"></a><strong>3.1、关于文件时间的几个test</strong></h3><p>介绍关于文件时间的几个test，见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>test</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-amin n</td>
<td>以最后访问文件block节点中数据的时间为判断依据，以多少个分钟为单位</td>
</tr>
<tr>
<td>-atime n</td>
<td>以最后访问文件block节点中数据的时间为判断依据，以多少个24小时为单位</td>
</tr>
<tr>
<td>-cmin n</td>
<td>以最后修改文件inode节点中数据的时间为判断依据，以多少个分钟为单位</td>
</tr>
<tr>
<td>-ctime n</td>
<td>以最后修改文件inode节点中数据的时间为判断依据，以多少个24小时为单位</td>
</tr>
<tr>
<td>-mmin n</td>
<td>以最后修改文件block节点中数据的时间为判断依据，以多少个分钟为单位</td>
</tr>
<tr>
<td>-mtime n</td>
<td>以最后修改文件block节点中数据的时间为判断依据，以多少个24小时为单位</td>
</tr>
</tbody></table>
<p><strong>一点说明：</strong><br>1、在以上6个选项中，数字“n”有3种形式，分别是：n，+n，-n</p>
<p>为了更加透彻完整地理解，可以查看FindUtils包中的“find命令”源代码，经过查看<a href="http://download.csdn.net/detail/dslztx/8789297">源代码</a>（主要是“pred.c”文件中的<code>pred_timewindow</code>函数），可以归纳得到如下结论。<br>在以下描述中，系统当前时间（NowTime）和文件相应维度的时间（FileTime）都表示成以秒为单位；在以“多少个分钟”为单位的选项中，<code>UNIT=60</code>（1分钟有60秒），在以“多少个24小时”为单位的选项中，<code>UNIT=24*60*3600</code>（24小时有24*60*3600秒）；加了“-daystart”选项后，NowTime就变为当日午夜时间。</p>
<h4 id="3-1-1、以“多少个分钟”为单位的选项"><a href="#3-1-1、以“多少个分钟”为单位的选项" class="headerlink" title="3.1.1、以“多少个分钟”为单位的选项"></a><strong>3.1.1、以“多少个分钟”为单位的选项</strong></h4><p>“n”和“-n”的情况具有一定的重复区域，即某个时刻“n”能够找到某个文件，“-n”也能够找到相同的文件。<br>1、第一种情况“n”为“n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &gt;= (n-1)*UNIT &amp;&amp; NowTime-FileTime &lt; n*UNIT</span><br></pre></td></tr></table></figure>
<p>2、第二种情况“n”为“+n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &gt; n*UNIT</span><br></pre></td></tr></table></figure>
<p>3、第三种情况“n”为“-n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &lt; n*UNIT</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2、以“多少个24小时”为单位的选项"><a href="#3-1-2、以“多少个24小时”为单位的选项" class="headerlink" title="3.1.2、以“多少个24小时”为单位的选项"></a><strong>3.1.2、以“多少个24小时”为单位的选项</strong></h4><p>1、第一种情况“n”为“n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &gt;= n*UNIT &amp;&amp; NowTime-FileTime &lt; (n+1)*UNIT</span><br></pre></td></tr></table></figure>
<p>2、第二种情况“n”为“+n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &gt; (n+1)*UNIT</span><br></pre></td></tr></table></figure>
<p>3、第三种情况“n”为“-n”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NowTime-FileTime &lt; n*UNIT</span><br></pre></td></tr></table></figure>
<p>注意，这里没有“n+1”，避免了“n”和“-n”情况的重复区域。</p>
<h4 id="3-1-3、举例说明"><a href="#3-1-3、举例说明" class="headerlink" title="3.1.3、举例说明"></a><strong>3.1.3、举例说明</strong></h4><p>假设系统当前时间为<code>2015-06-09 13:35:50</code>。<br><strong>1、例子1</strong><br>那么<code>find . -amin 10</code>命令，查找的文件的“atime”范围：<code>2015-06-09 13:25:51 -- 2015-06-09 13:26:50</code>。<br><strong>2、例子2</strong><br>那么<code>find . -amin -10</code>命令，查找的文件的“atime”范围：<code>2015-06-09 &gt; 13:25:50</code>（因此，<code>2015-06-09 13:26:30</code>既能通过<code>-amin 10</code>得到，也能通过<code>-amin -10</code>得到）。<br><strong>3、例子3</strong><br>那么<code>find . -amin +10</code>命令，查找的文件的“atime”范围：<code>2015-06-09 &lt; 13:25:50</code>。<br><strong>4、例子4</strong><br>那么<code>find . -atime 5</code>命令，查找的文件的“atime”范围：<code>2015-06-03 13:35:51 -- 2015-06-04 13:35:50</code>。<br><strong>5、例子5</strong><br>那么<code>find . -atime -5</code>命令，查找的文件的“atime”范围：<code>2015-06-04 &gt; 13:35:50</code>。<br><strong>6、例子6</strong><br>那么<code>find . -atime +5</code>命令，查找的文件的“atime”范围：<code>2015-06-03 &lt; 13:35:50</code>。</p>
<h3 id="3-2、关于文件权限的test"><a href="#3-2、关于文件权限的test" class="headerlink" title="3.2、关于文件权限的test"></a><strong>3.2、关于文件权限的test</strong></h3><p>介绍如表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>test</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-perm mode</td>
<td>目标文件的权限跟“mode”一致</td>
</tr>
<tr>
<td>-perm -mode</td>
<td>目标文件的权限包含了“mode”</td>
</tr>
<tr>
<td>-perm &#x2F;mode</td>
<td>目标文件的权限跟“mode”有交集</td>
</tr>
</tbody></table>
<h3 id="3-3、关于文件类型的test"><a href="#3-3、关于文件类型的test" class="headerlink" title="3.3、关于文件类型的test"></a><strong>3.3、关于文件类型的test</strong></h3><p>关于文件类型的test为“-type c”，其中“c”表示文件类型特征码，对于文件类型特征码的介绍如表3所示。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>文件类型特征码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>block (buffered) special</td>
</tr>
<tr>
<td>c</td>
<td>character (unbuffered) special</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>p</td>
<td>named pipe (FIFO)</td>
</tr>
<tr>
<td>f</td>
<td>regular file</td>
</tr>
<tr>
<td>l</td>
<td>symbolic link; this is never true if the -L option or the -follow option is in effect, unless the symbolic link is broken. If you want to search for symbolic links when -L is in effect, use -xtype</td>
</tr>
<tr>
<td>s</td>
<td>socket</td>
</tr>
<tr>
<td>D</td>
<td>door (Solaris)</td>
</tr>
</tbody></table>
<h3 id="3-4、关于文件所属用户的test"><a href="#3-4、关于文件所属用户的test" class="headerlink" title="3.4、关于文件所属用户的test"></a><strong>3.4、关于文件所属用户的test</strong></h3><p>“-user uname”：表示属于“uname”这个用户的文件，“uname”可以是“用户名称”，也可以是“用户ID，即UID”。</p>
<h3 id="3-5、关于文件所属用户组的test"><a href="#3-5、关于文件所属用户组的test" class="headerlink" title="3.5、关于文件所属用户组的test"></a><strong>3.5、关于文件所属用户组的test</strong></h3><p>“-group gname”：表示属于“gname”这个用户组的文件，“gname”可以是“用户组名称”，也可以是“用户组ID，即GID”。</p>
<h3 id="3-6、关于文件名称的test"><a href="#3-6、关于文件名称的test" class="headerlink" title="3.6、关于文件名称的test"></a><strong>3.6、关于文件名称的test</strong></h3><p>“-name ‘pattern’”：文件名（去掉前导目录）匹配“pattern”这个通配符模式表达式的文件。使用的通配符模式表达式是一个特定的变种，但主要的语法还是可以参考<a href="/blog/2017/05/10/Linux-Shell%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="Linux Shell通配符模式表达式">《Linux Shell通配符模式表达式》</a>。有一点跟Linux Shell通配符模式表达式不一样，本通配符模式表达式变种中，“通配符”，“字符类”，“字符范围”可匹配文件名的开头“.”字符，比如有文件“.a.txt”，<code>find . -name &#39;*.txt&#39;</code>命令，<code>find . -name &#39;?a.txt&#39;</code>命令，<code>find . -name &#39;[.]a.txt&#39;</code>命令，<code>find . -name &#39;[!a]a.txt&#39;</code>命令，<code>find . -name &#39;[!a-z]a.txt&#39;</code>命令都可匹配到该文件。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>“find”命令的完整定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</span><br></pre></td></tr></table></figure>
<p>1、我们在使用“find”命令的时候，一般不解析遇到的软符号链接文件，如果解析的话很容易造成递归死循环，一般也不使用调试和优化选项，因此“-H”，“-L”，“-P”，“-D”，“-O”这些选项不使用<br>2、“expression”包括了“options”，“tests”，“actions”，以及它们之间的“operators”这四个部分。“options”一般没有什么用（除了“-maxdepth”这个“option”），“actions”比较复杂，因而我们可以选择先使用简单的“find”命令，找出符合条件的文件，然后再通过管道或者脚本的方式进行操作，作为连接用的“operators”也就不被使用；只剩下“tests”<br>3、因此，最终“-H”，“-L”，“-P”，“-D”，“-O”，“expression”中的“options”，“actions”，“operators”都不需要</p>
<h2 id="五、例子"><a href="#五、例子" class="headerlink" title="五、例子"></a><strong>五、例子</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># block节点修改时间60分钟以内</span><br><span class="line">find . -mmin -60</span><br><span class="line"></span><br><span class="line"># block节点修改时间60分钟以内，且文件名形如“a*.md”</span><br><span class="line">find . -name &#x27;a*.md&#x27; -mmin -60</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man find
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>grep命令</title>
    <url>/blog/2017/06/06/grep%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [-v] -E &#x27;PATTERN&#x27; FILE...</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>从一个或者多个文件中打印包含“匹配<code>PATTERN</code>的内容”的行，<font color='red'>以行为单位</font>。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><h4 id="2-2-1、“-v”选项"><a href="#2-2-1、“-v”选项" class="headerlink" title="2.2.1、“-v”选项"></a><strong>2.2.1、“-v”选项</strong></h4><p>与正常情况相反，现在要求打印不包含“匹配<code>PATTERN</code>的内容”的行。</p>
<h4 id="2-2-2、“-E-‘PATTERN’”选项"><a href="#2-2-2、“-E-‘PATTERN’”选项" class="headerlink" title="2.2.2、“-E ‘PATTERN’”选项"></a><strong>2.2.2、“-E ‘PATTERN’”选项</strong></h4><p>表示使用GNU ERE正则表达式，默认使用GNU BRE正则表达式。</p>
<h4 id="2-2-3、“FILE…”"><a href="#2-2-3、“FILE…”" class="headerlink" title="2.2.3、“FILE…”"></a><strong>2.2.3、“FILE…”</strong></h4><p>grep命令的目标文件，需要是文本文件，如果是二进制文件，最后得到的结果会比较奇怪。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>可以通过“-r”，“–exclude”，“–exclude-from”，“–exclude-dir”和“–include”等选项的组合形式来筛选目标文件，但是显得职责混淆，这个任务由“find命令”来完成更加名正言顺。<br>假如筛选关键词为“hello world”，目标文件为当前目录下所有以“.txt”为结尾的文件（递归），则两种形式分别为：<br>1、<code>grep -r --include=&#39;*.txt&#39; -E &#39;hello world&#39; .</code><br>2、<code>find . -name &#39;*.txt&#39; | xargs grep -E &#39;hello world&#39;</code></p>
<br/>
参考文献：
[1]man grep
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>happens-before规则</title>
    <url>/blog/2019/12/17/happens-before%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="一、happens-before规则产生背景"><a href="#一、happens-before规则产生背景" class="headerlink" title="一、happens-before规则产生背景"></a><strong>一、happens-before规则产生背景</strong></h2><p>根据<a href="/blog/2019/11/08/%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7/" title="可见性与有序性">《可见性与有序性》</a>，编写Java程序存在“可见性”和“有序性”问题。为提供确定性编程环境，JMM提供了一系列happens-before规则，遵循happens-before规则可获得相对应的“可见性”和“有序性”语义保证，其语义是：<code>假如操作A happens-before 操作B，那么“在可见性维度，操作A对操作B内存可见；在有序性维度，操作A先于操作B”</code>。</p>
<p><strong>备注</strong>：</p>
<ul>
<li>上述“可见性”指代“广义可见性”，“有序性”指代“广义有序性”，本文后续如无特别说明，都是该含义。而且根据<a href="/blog/2019/11/08/%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7/" title="可见性与有序性">《可见性与有序性》</a>可知，“广义可见性”和“广义有序性”是等价的</li>
</ul>
<h2 id="二、happens-before规则的实现原理"><a href="#二、happens-before规则的实现原理" class="headerlink" title="二、happens-before规则的实现原理"></a><strong>二、happens-before规则的实现原理</strong></h2><p>happens-before规则的实现原理是：对于违背happens-before规则所提供“可见性&#x2F;有序性”语义确保的“可见性&#x2F;有序性”问题，通过各个指令&#x2F;语言层级的内存屏障加以解决，比如“通过<code>程序语言层级的内存屏障</code>禁止程序语言编译&#x2F;解释过程中的重排序”；而对于那些不违背happens-before规则所提供“可见性&#x2F;有序性”语义确保的“可见性&#x2F;有序性”问题，不作限制，即“法无禁则行”。</p>
<h2 id="三、happens-before规则"><a href="#三、happens-before规则" class="headerlink" title="三、happens-before规则"></a><strong>三、happens-before规则</strong></h2><p>以下是几个常见的happens-before规则：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
<li>传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C</li>
<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B的任意操作</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</li>
</ul>
<h2 id="四、happens-before规则应用"><a href="#四、happens-before规则应用" class="headerlink" title="四、happens-before规则应用"></a><strong>四、happens-before规则应用</strong></h2><p>happens-before规则的语义理解起来其实不难，只是应用的时候有一个难点：对于happens-before规则而言，先有满足条件的A和B，再有“A happens-before B”关系，但是如何获得满足条件的A和B呢？</p>
<p>接下来探讨如何获得满足条件的A和B：</p>
<ul>
<li>程序顺序规则：在单线程语境中，能够简单获得满足条件的A和B</li>
<li>传递性规则：逻辑推导规则，没有具体的满足条件</li>
<li>start()规则：经分析，能够简单获得满足条件的A和B</li>
<li>join()规则：经分析，能够简单获得满足条件的A和B</li>
<li>监视器锁规则：在单线程语境中，满足条件的A和B简单可获得；在多线程语境中，满足条件的A简单可获得，满足条件的B非简单可获得，主要是如何定义和获得“随后”？结合锁的定义，分为3种情形：1）B中加锁前置于A中解锁对应的加锁，那么就不会存在A，此种情况无需探讨；2）B中加锁前置于A中解锁且后置于A中解锁对应的加锁，那么会阻塞直到使得B中加锁是“随后”的；3）B中加锁后置于A中解锁，那么B中加锁显而易见即是“随后”的</li>
<li>volatile变量规则：在单线程语境中，满足条件的A和B简单可获得。在多线程语境中，满足条件的A简单可获得，满足条件的B非简单可获得，主要是如何定义和达到“后续”？在多线程语境中，判定“后续”十分困难，但是在应用“volatile变量规则”的场景中，可以以另外一个视角来绕过这个判定问题，即<font color='red'>如果“对这个volatile域的读”，能够读到“对该volatile域的写”，那么“对这个volatile域的读”就是“后续”的</font>，这才是实际应用的立足点所在</li>
</ul>
<h2 id="五、基于happens-before规则推导新的happens-before规则"><a href="#五、基于happens-before规则推导新的happens-before规则" class="headerlink" title="五、基于happens-before规则推导新的happens-before规则"></a><strong>五、基于happens-before规则推导新的happens-before规则</strong></h2><p>要想推导新的happens-before规则，须基于现有的happens-before规则，否则推导出的happens-before规则的正确性不能够得到保证。</p>
<h3 id="5-1、例子1"><a href="#5-1、例子1" class="headerlink" title="5.1、例子1"></a><strong>5.1、例子1</strong></h3><p>比如有如下一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;               <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;         <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;          <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a * a;   <span class="comment">//4 </span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>程序顺序规则</code>有“1 happens-before 2，3 happens-before 4”，当&#x2F;&#x2F;3处读取到&#x2F;&#x2F;2处值时，然后可能会错误认为有“2 happens-before 3”，接着再根据<code>传递性规则</code>，推导出有“1 happens-before 3，1 happens-before 4，2 happens-before 4”。但是，实际上“2 happens-before 3”未基于现有happens-before规则而是错误的结论，因此，最终也并没有“1 happens-before 3，1 happens-before 4，2 happens-before 4”，下面的两个可能执行时序也佐证了这个结论。</p>
<p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序。当操作1和操作2重排序时，可能的执行时序图如图1，此时，“1 happens-before 4”不成立。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20191217-0-1.png"></p>
<p>操作3和操作4没有数据依赖关系，但是存在控制依赖关系，控制依赖关系会影响指令执行的并行度，为克服该影响，编译器和处理器会采用猜测执行技术：提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，把该计算结果写入变量i中。可以发现，猜测执行实质上是对操作3和4做了重排序，可能的执行时序图如图2，此时，“1 happens-before 4”不成立。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20191217-0-2.png"></p>
<p><font color='red'>如果给变量flag加上volatile关键词，那么基于<code>volatile变量规则</code>，的确有“2 happens-before 3（3是读取到flag变量写入值的3）”，最终也就有“1 happens-before 3，1 happens-before 4，2 happens-before 4”。</font></p>
<h3 id="5-2、例子2"><a href="#5-2、例子2" class="headerlink" title="5.2、例子2"></a><strong>5.2、例子2</strong></h3><p><code>监视器锁规则</code>中的“锁”包括“内置锁——synchronized关键词所对应锁”和“高级锁”，其中“内置锁”的该happens-before规则语义实现是JDK原生级别的，“高级锁”的该happens-before规则语义实现是非JDK原生级别，基于基础组件推导得的。<br>接下来以高级锁中的“ReentrantLock锁”为例进行推导演示，ReentrantLock锁可细分为“公平锁”和“非公平锁”。</p>
<p><font color='red'>另外需要说明的一点是，在查看源码的过程中可以发现，“unlock()”和“lock()”操作是方法，其显而易见是非原子的，因此可以知道，上述happens-before规则中的“操作”不一定是原子的。</font></p>
<h4 id="5-2-1、公平锁"><a href="#5-2-1、公平锁" class="headerlink" title="5.2.1、公平锁"></a><strong>5.2.1、公平锁</strong></h4><p>解锁代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加锁代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可发现：解锁时最后写volatile变量state，加锁时首先读取state变量，根据<code>volatile变量规则</code>，可推得“对一个锁的解锁，happens-before于随后对这个锁的加锁”，即满足<code>监视器锁规则</code>。</p>
<h4 id="5-2-2、非公平锁"><a href="#5-2-2、非公平锁" class="headerlink" title="5.2.2、非公平锁"></a><strong>5.2.2、非公平锁</strong></h4><p>解锁代码同“5.2.1、公平锁”。<br>加锁代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可发现：解锁时最后写volatile变量state，加锁时首先读取state变量（<code>compareAndSetState</code>是一个CAS操作含有先读取state变量的等价语义，<code>acquire</code>也是先读取state变量），根据<code>volatile变量规则</code>，可推得“对一个锁的解锁，happens-before于随后对这个锁的加锁”，即满足<code>监视器锁规则</code>。</p>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h2><h3 id="6-1、happens-before规则的现实意义"><a href="#6-1、happens-before规则的现实意义" class="headerlink" title="6.1、happens-before规则的现实意义"></a><strong>6.1、happens-before规则的现实意义</strong></h3><p>一个经典的多线程运行场景（线程A和线程B），如下。<br>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语句1</span><br><span class="line">语句2</span><br><span class="line">语句3</span><br><span class="line">语句4</span><br><span class="line">语句5</span><br></pre></td></tr></table></figure>

<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语句11</span><br><span class="line">语句22</span><br><span class="line">语句33</span><br><span class="line">语句44</span><br></pre></td></tr></table></figure>
<p>如果需要分析跨线程的程序运行情况，那么需要考虑所有可能的“可见性，有序性”情形，脑力负担重，易出错，但是借助于happens-before规则就可以简单准确地完成上述分析任务。</p>
<p>通过如下一段示例代码进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataReloader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DataReloader</span> <span class="variable">dataReloader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataReloader</span>();</span><br><span class="line"></span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                dataReloader.reload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        dataReloader.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : set) &#123;                   <span class="comment">//5</span></span><br><span class="line">                System.out.println(s);               <span class="comment">//6</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">        set = reloadLogic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">reloadLogic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// reload set logic</span></span><br><span class="line">        Set&lt;String&gt; tmpset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();   <span class="comment">//1</span></span><br><span class="line">        tmpset.add(<span class="string">&quot;hello&quot;</span>);                          <span class="comment">//2</span></span><br><span class="line">        tmpset.add(<span class="string">&quot;world&quot;</span>);                          <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpset;                                <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这段代码描述的程序逻辑是：1）主线程不断打印集合set内的元素；2）每隔30分钟运行另外一个线程重新加载集合set。<br>现在的实现方式存在的问题是：由于“重排序”的存在，可能出现一种情形——主线程在获得最新的set之后，里面的“hello”和“world”元素还没有添加完成。<br>假如给set加上volatile关键词，此时，定时线程中有“1 happens-before 2，2 happens-before 3，3 happens-before 4”，在主线程中有“5 happens-before 6”，根据<code>volatile变量规则</code>有“4 happens-before 5（5是读取到set变量写入值的5）”，再根据<code>传递性规则</code>，则最终有“1 happens-before 5，2 happens-before 5，3 happens-before 5”，因此上述描述的问题不会再出现。</p>
<p><strong>备注</strong>：</p>
<ul>
<li>Foreach语法的本质是迭代器，因此对于<code>for (String s : set)</code>来说，本质是遍历一个迭代器，并隐式含有“读取set变量 happens-before 生成一个迭代器”</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://stackoverflow.com/questions/18508786/for-each-vs-iterator-which-will-be-the-better-option">https://stackoverflow.com/questions/18508786/for-each-vs-iterator-which-will-be-the-better-option</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>head命令</title>
    <url>/blog/2016/12/30/head%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head [-n K] [FILE | -]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>显示文件或者基本输入的前几行，默认为前10行。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-n K”：显示文件或者基本输入的前K行。</p>
<br/>
参考文献：
[1]man head
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>iconv命令</title>
    <url>/blog/2016/10/20/iconv%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconv -f SrcEncoding -t DestEncoding InputFile -o OutputFile </span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>改变输入文件“InputFile”内容的编码方案，从“SrcEncoding”转变到“DestEncoding”，转变后内容保存到输出文件“OutputFile”。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-f”：源编码方案。<br>“-t”：目标编码方案。<br>“-o”：指定输出文件。</p>
<br/>
参考文献：
[1]man iconv
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jar命令</title>
    <url>/blog/2018/07/28/jar%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a><strong>一、用途</strong></h2><p>jar命令用来“创建，更新，解压，查看”JAR格式文件。</p>
<p><strong>备注：</strong><br>JAR格式文件：基于ZIP格式而又异于ZIP格式（会额外创建“META-INF”目录，“META-INF”目录下会额外创建“MANIFEST.MF”文件和其他一些文件或者子目录）。</p>
<h2 id="二、常用用法"><a href="#二、常用用法" class="headerlink" title="二、常用用法"></a><strong>二、常用用法</strong></h2><h3 id="2-1、创建JAR格式文件"><a href="#2-1、创建JAR格式文件" class="headerlink" title="2.1、创建JAR格式文件"></a><strong>2.1、创建JAR格式文件</strong></h3><p><strong>1、创建普通JAR格式文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvf JAR格式文件名称 -C 待加入JAR格式文件内容文件所在目录A .</span><br></pre></td></tr></table></figure>
<p>“c”：表示创建JAR格式文件的动作。<br>“v”：打印详细日志信息。<br>“f”：表示以“JAR格式文件名称”参数值作为创建后JAR格式文件名称。<br>“-C 待加入JAR格式文件内容文件所在目录A .”：创建时，首先切换进入目录A，再把目录A下内容文件加入到JAR格式文件。如此曲线救国的主要原因是，<code>jar cvf JAR格式文件名称 A</code>和<code>jar cvf JAR格式文件名称 A/*</code>都会在JAR格式文件中创建A目录。<br><strong>2、创建可执行JAR格式文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvfe JAR格式文件名称 入口类 -C 待加入JAR格式文件内容文件所在目录A .</span><br></pre></td></tr></table></figure>
<p>“c”：表示创建JAR格式文件的动作。<br>“v”：打印详细日志信息。<br>“f”：表示以“JAR格式文件名称”参数值作为创建后JAR格式文件名称。<br>“e”：表示以“入口类”参数值作为创建后可执行JAR格式文件的执行入口类。<br>“-C 待加入JAR格式文件内容文件所在目录A .”：创建时，首先切换进入目录A，再把目录A下内容文件加入到JAR格式文件。如此曲线救国的主要原因是，<code>jar cvf JAR格式文件名称 A</code>和<code>jar cvf JAR格式文件名称 A/*</code>都会在JAR格式文件中创建A目录。</p>
<h3 id="2-2、解压JAR格式文件"><a href="#2-2、解压JAR格式文件" class="headerlink" title="2.2、解压JAR格式文件"></a><strong>2.2、解压JAR格式文件</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar xvf JAR格式文件名称</span><br></pre></td></tr></table></figure>
<p>“x”：表示解压JAR格式文件的动作。<br>“v”：打印详细日志信息。<br>“f”：表示以“JAR格式文件名称”参数值作为待解压JAR格式文件的名称。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、保存内容文件的修改时间"><a href="#3-1、保存内容文件的修改时间" class="headerlink" title="3.1、保存内容文件的修改时间"></a><strong>3.1、保存内容文件的修改时间</strong></h3><p>创建JAR格式文件时，内容文件的修改时间也会被保存。因此，相同Java源代码文件，不同时间执行<code>mvn package</code>命令得到的JAR格式文件内容不一致（虽然解压后的内容文件内容一致，但是修改时间不一致）。</p>
<h3 id="3-2、META-INF-MANIFEST-MF文件"><a href="#3-2、META-INF-MANIFEST-MF文件" class="headerlink" title="3.2、META-INF&#x2F;MANIFEST.MF文件"></a><strong>3.2、META-INF&#x2F;MANIFEST.MF文件</strong></h3><p>JAR格式文件中的“META-INF&#x2F;MANIFEST.MF”文件保存有一些元信息，比如入口类是通过“Main-Class: 入口类名称”属性值对保存的。</p>
<br/>
参考文献：
[1]man jar
[2]https://stackoverflow.com/questions/650897/why-do-these-two-jar-files-with-identical-contents-have-different-file-sizes
[3]https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>javac编译需加载依赖的依赖</title>
    <url>/blog/2018/12/11/javac%E7%BC%96%E8%AF%91%E9%9C%80%E5%8A%A0%E8%BD%BD%E4%BE%9D%E8%B5%96%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>有源码文件“A.java”，“A.java”依赖于“B.class”，而“B.class”又依赖于“C.class”。使用<code>javac</code>工具编译“A.java”，要想成功编译“A.java”，既需要加载“B.class”，还需要加载“C.class”。</p>
<h2 id="二、分析解决"><a href="#二、分析解决" class="headerlink" title="二、分析解决"></a><strong>二、分析解决</strong></h2><p>其实一般情形下，使用<code>javac</code>工具编译“A.java”，要想成功编译“A.java”，只需要加载“B.class”即可。现在还需要加载“C.class”，原因可能有：</p>
<ul>
<li>该<code>javac</code>版本实现有bug </li>
<li>该<code>javac</code>版本针对新的Java语言语法的确需要再加载依赖的依赖</li>
</ul>
<p>总结来说，<code>javac</code>编译时是否加载依赖的依赖跟具体实现相关，这个知识点并不很重要，因此无需过多关注。</p>
<br/>
参考文献：
[1]https://stackoverflow.com/questions/40255718/compiling-with-jdk-1-8-java-cannot-access-class-file-class-file-not-found
[2]https://bugs.openjdk.java.net/browse/JDK-8055048
[3]http://openjdk.java.net/groups/compiler/doc/hhgtjavac/index.html
[4]http://scg.unibe.ch/archive/projects/Erni08b.pdf
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JDK</category>
      </categories>
  </entry>
  <entry>
    <title>java命令</title>
    <url>/blog/2017/04/12/java%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><h3 id="1-1、常用用法1"><a href="#1-1、常用用法1" class="headerlink" title="1.1、常用用法1"></a><strong>1.1、常用用法1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java [Options] class [Arguments]</span><br></pre></td></tr></table></figure>
<h3 id="1-2、常用用法2"><a href="#1-2、常用用法2" class="headerlink" title="1.2、常用用法2"></a><strong>1.2、常用用法2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java [Options] -jar file.jar [Arguments]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><h3 id="2-1、常用用法1含义"><a href="#2-1、常用用法1含义" class="headerlink" title="2.1、常用用法1含义"></a><strong>2.1、常用用法1含义</strong></h3><p>运行一个JVM进程，入口类为“class”（内含“public static void main(String[] args)”方法）。</p>
<h3 id="2-2、常用用法2含义"><a href="#2-2、常用用法2含义" class="headerlink" title="2.2、常用用法2含义"></a><strong>2.2、常用用法2含义</strong></h3><p>运行一个JVM进程，入口类为“file.jar”指代的可执行JAR包内“MANIFEST.MF”文件中“Main-Class”参数配置的Java类（内含“public static void main(String[] args)”方法）。</p>
<h2 id="三、选项"><a href="#三、选项" class="headerlink" title="三、选项"></a><strong>三、选项</strong></h2><p>“Arguments”，表示传递给“public static void main(String[] args)”方法的参数。<br>接下来主要介绍“Options”，本文称其为“虚拟机参数”。<br><font color='red'>需要特别注意的是，关于“虚拟机参数”有两点不确定性：1）JVM进程支持的所有“虚拟机参数”和详细使用说明是不确定的（比如通过“-XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+AggressiveOpts -XX:+PrintFlagsFinal”虚拟机参数也只能获取到部分“-XX”类型虚拟机参数），除非查看OpenJDK源代码；2）“虚拟机参数”被传给JVM进程后，由于JVM进程存在缺省配置，“虚拟机参数”之间存在冲突（比如“-Xmn”和“-XX:NewRatio”）等因素，最终产生效果是不确定的，除非查看OpenJDK源代码。<br>即要想获得准确的关于“虚拟机参数”的信息，必须查看OpenJDK源代码。</font>[3][4]<br>因此，接下来只介绍一些常见的“虚拟机参数”。</p>
<h3 id="3-1、一般虚拟机参数"><a href="#3-1、一般虚拟机参数" class="headerlink" title="3.1、一般虚拟机参数"></a><strong>3.1、一般虚拟机参数</strong></h3><h4 id="3-1-1、常用"><a href="#3-1-1、常用" class="headerlink" title="3.1.1、常用"></a><strong>3.1.1、常用</strong></h4><p>描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-classpath&#x2F;-cp classpath</td>
<td>配置用户自定义类路径</td>
</tr>
<tr>
<td>-Dproperty&#x3D;value</td>
<td>配置环境变量</td>
</tr>
<tr>
<td>-verbose&#x2F;-verbose:class</td>
<td>打印类加载日志</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>打印GC简单日志</td>
</tr>
<tr>
<td>-verbose:jni</td>
<td>打印本地方法使用日志</td>
</tr>
</tbody></table>
<h4 id="3-1-2、其他"><a href="#3-1-2、其他" class="headerlink" title="3.1.2、其他"></a><strong>3.1.2、其他</strong></h4><p>描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-client</td>
<td>以“client”模式运行JVM进程</td>
</tr>
<tr>
<td>-server</td>
<td>以“server”模式运行JVM进程</td>
</tr>
<tr>
<td>-d32</td>
<td>以32位模式运行JVM进程，需要本身支持才可，否则会报错</td>
</tr>
<tr>
<td>-d64</td>
<td>以64位模式运行JVM进程，需要本身支持才可，否则会报错</td>
</tr>
<tr>
<td>-agentlib:libname[&#x3D;options]</td>
<td>加载JVMTI实现库[5]</td>
</tr>
<tr>
<td>-agentpath:pathname[&#x3D;options]</td>
<td>另外一种形式加载JVMTI实现库[5]</td>
</tr>
<tr>
<td>-javaagent:jarpath[&#x3D;options]</td>
<td>加载Instrumentation机制代理程序包[6]</td>
</tr>
<tr>
<td>-disableassertions&#x2F;-da[:package name”…”&#124;:class name]</td>
<td>关闭assert语法</td>
</tr>
<tr>
<td>-enableassertions&#x2F;-ea[:package name”…”&#124;:class name]</td>
<td>开启assert语法</td>
</tr>
<tr>
<td>-disablesystemassertions&#x2F;-dsa</td>
<td>关闭系统类中的assert语法</td>
</tr>
<tr>
<td>-enablesystemassertions&#x2F;-esa</td>
<td>开启系统类中的assert语法</td>
</tr>
<tr>
<td>-splash:imagepath</td>
<td>运行JVM进程时，显示路径指定的图片</td>
</tr>
<tr>
<td>-help&#x2F;-?</td>
<td>打印帮助信息</td>
</tr>
<tr>
<td>-version</td>
<td>显示JVM版本信息，退出</td>
</tr>
<tr>
<td>-showversion</td>
<td>显示JVM版本信息，不退出</td>
</tr>
<tr>
<td>-version:release</td>
<td>指定需要的JVM版本</td>
</tr>
<tr>
<td>-jre-restrict-search</td>
<td>进行版本搜索时，包含私有JRE[7]</td>
</tr>
<tr>
<td>-no-jre-restrict-search</td>
<td>进行版本搜索时，不包含私有JRE[7]</td>
</tr>
</tbody></table>
<h3 id="3-2、“-X”类型虚拟机参数"><a href="#3-2、“-X”类型虚拟机参数" class="headerlink" title="3.2、“-X”类型虚拟机参数"></a><strong>3.2、“-X”类型虚拟机参数</strong></h3><h4 id="3-2-1、常用"><a href="#3-2-1、常用" class="headerlink" title="3.2.1、常用"></a><strong>3.2.1、常用</strong></h4><p>描述见表3。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xloggc:file</td>
<td>配置GC日志文件路径</td>
</tr>
<tr>
<td>-Xmn&#60;SIZE&#62;</td>
<td>年轻代精确大小</td>
</tr>
<tr>
<td>-Xms&#60;SIZE&#62;</td>
<td>Java堆初始值和最小值</td>
</tr>
<tr>
<td>-Xmx&#60;SIZE&#62;</td>
<td>Java堆最大值</td>
</tr>
<tr>
<td>-Xss&#60;SIZE&#62;</td>
<td>Java虚拟机栈&#x2F;本地方法栈的精确大小</td>
</tr>
</tbody></table>
<h4 id="3-2-2、其他"><a href="#3-2-2、其他" class="headerlink" title="3.2.2、其他"></a><strong>3.2.2、其他</strong></h4><p>描述见表4。</p>
<p>表4</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xint</td>
<td>对于字节码，使用解释器解释执行，而不使用编译器编译成汇编码或者机器码后执行[16]</td>
</tr>
<tr>
<td>-Xcomp</td>
<td>对于字节码，使用编译器编译成汇编码或者机器码后执行，而不使用解释器解释执行[16]</td>
</tr>
<tr>
<td>-Xmixed</td>
<td>默认方式。对于字节码，一般使用解释器解释执行；对于热点代码[17]，使用编译器编译成汇编码或者机器码后执行[16]</td>
</tr>
<tr>
<td>-Xbatch</td>
<td>关闭后台编译机制</td>
</tr>
<tr>
<td>-Xbootclasspath:bootclasspath</td>
<td>配置bootclasspath</td>
</tr>
<tr>
<td>-Xbootclasspath&#x2F;a:path</td>
<td>在原有的bootclasspath后增加path</td>
</tr>
<tr>
<td>-Xbootclasspath&#x2F;p:path</td>
<td>在原有的bootclasspath前增加path</td>
</tr>
<tr>
<td>-Xcheck:jni</td>
<td>对本地方法进行额外检查</td>
</tr>
<tr>
<td>-Xfuture</td>
<td>对Class文件进行严格检查</td>
</tr>
<tr>
<td>-Xnoclassgc</td>
<td>关闭对永久代的垃圾收集[8]</td>
</tr>
<tr>
<td>-Xincgc</td>
<td>等价于“-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode”，而“-XX:+CMSIncrementalMode”表示的“增量式并发收集模式”已经被声明废弃[9]</td>
</tr>
<tr>
<td>-Xprof</td>
<td>在标准输出中打印JVM进程一些指标统计值</td>
</tr>
<tr>
<td>-Xrs</td>
<td>减少对操作系统信号量的使用</td>
</tr>
<tr>
<td>-Xverify:mode</td>
<td>配置字节码校验模式</td>
</tr>
</tbody></table>
<h3 id="3-3、“-XX”类型虚拟机参数"><a href="#3-3、“-XX”类型虚拟机参数" class="headerlink" title="3.3、“-XX”类型虚拟机参数"></a><strong>3.3、“-XX”类型虚拟机参数</strong></h3><p>“-XX”类型虚拟机参数具有如下格式：如果为布尔型，以“-XX:+&#x2F;-name”形式进行开或关的配置；否则，以“-XX:name&#x3D;value”形式进行值的配置。</p>
<h4 id="3-3-1、常用"><a href="#3-3-1、常用" class="headerlink" title="3.3.1、常用"></a><strong>3.3.1、常用</strong></h4><p>描述见表5。</p>
<p>表5</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:MaxHeapSize&#x3D;N</td>
<td>Java堆最大值，与“-Xmx&#60;SIZE&#62;”等价，两者具有相等优先级</td>
</tr>
<tr>
<td>-XX:NewSize&#x3D;N</td>
<td>配置年轻代的初始值和最小值</td>
</tr>
<tr>
<td>-XX:MaxNewSize&#x3D;N</td>
<td>配置年轻代最大值</td>
</tr>
<tr>
<td>-XX:PermSize&#x3D;N</td>
<td>设置永久代初始值和最小值</td>
</tr>
<tr>
<td>-XX:MaxPermSize&#x3D;N</td>
<td>设置永久代最大值</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize&#x3D;N</td>
<td>设置“直接内存”最大值</td>
</tr>
<tr>
<td>-XX:SurvivorRatio&#x3D;N</td>
<td>Eden区与Survivor区大小比值为N</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseSerialGC</td>
<td>是否使用Serial+Serial Old收集器组合</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseParNewGC</td>
<td>是否使用ParNew+Serial Old收集器组合</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseConcMarkSweepGC</td>
<td>是否使用ParNew+CMS+Serial Old收集器组合，Serial Old垃圾收集器作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseParallelGC</td>
<td>是否使用Parallel Scavenge+Serial Old收集器组合</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseParallelOldGC</td>
<td>是否使用Parallel Scavenge+Parallel Old收集器组合</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseG1GC</td>
<td>是否使用G1收集器</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads&#x3D;N</td>
<td>并行GC时，允许的最大线程数</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold&#x3D;N</td>
<td>阈值，大于该值的对象直接在老年代分配</td>
</tr>
<tr>
<td>-XX:+&#x2F;-HandlePromotionFailure</td>
<td>是否允许“分配担保失败”</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis&#x3D;N</td>
<td>配置GC时最大停顿时间，收集器将尽量使得不超过该时间，仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>-XX:GCTimeRatio&#x3D;N</td>
<td>用户程序运行时间与GC时间比值为N，仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseAdaptiveSizePolicy</td>
<td>开启自动调节机制，不再需要手工指定新生代的大小，Eden区与Survivor区大小比值，晋升老年代对象年龄等细节参数</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction&#x3D;N</td>
<td>当老年代占用空间大于N%，则进行GC，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseCMSCompactAtFullCollection</td>
<td>当进行Full GC时，进行内存碎片整理，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction&#x3D;N</td>
<td>进行N次不进行整理的Full GC，然后执行1次带整理的Full GC，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:+&#x2F;-CMSClassUnloadingEnabled</td>
<td>是否对永久代进行垃圾回收，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold&#x3D;N</td>
<td>阈值，当年轻代中对象年龄大于该值，则晋升到老年代</td>
</tr>
<tr>
<td>-XX:+&#x2F;-CMSParallelRemarkEnabled</td>
<td>是否允许CMS的重新标记阶段进行并行GC</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseCompressedOops</td>
<td>64位JVM上是否压缩普通对象指针</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseTLAB</td>
<td>是否使用TLAB机制</td>
</tr>
<tr>
<td>-XX:+&#x2F;-HeapDumpOnOutOfMemoryError</td>
<td>OutOfMemoryError发生时是否生成堆转存快照</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintTenuringDistribution</td>
<td>打印GC日志时，打印Survivor区中对象年龄分布信息</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGC</td>
<td>是否打印GC简单日志，等价于“-verbose:gc”</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGCDetails</td>
<td>是否打印GC详细日志</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGCTimeStamps</td>
<td>打印GC日志时，是否打印相对时间戳（自JVM进程启动以来经过多少秒）</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGCDateStamps</td>
<td>打印GC日志时，是否打印绝对和相对时间戳</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGCApplicationStoppedTime</td>
<td>打印GC日志时，是否打印应用程序暂停了多少秒</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintGCApplicationConcurrentTime</td>
<td>打印GC日志时，是否打印应用程序运行了多少秒</td>
</tr>
<tr>
<td>-XX:+&#x2F;-TraceClassLoading</td>
<td>是否打印类加载过程信息</td>
</tr>
<tr>
<td>-XX:+&#x2F;-TraceClassUnLoading</td>
<td>是否打印类卸载过程信息</td>
</tr>
<tr>
<td>-XX:+&#x2F;-DisableExplicitGC</td>
<td>是否忽略来自System.gc()方法触发的垃圾收集请求</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio&#x3D;N</td>
<td>当Xmx值比Xms值大时，Java堆可以动态收缩与扩展，这个参数控制当堆空闲大于指定比率时自动收缩</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio&#x3D;N</td>
<td>当Xmx值比Xms值大时，Java堆可以动态收缩与扩展，这个参数控制当堆空闲小于指定比率时自动扩展</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes&#x3D;N</td>
<td>使用指定大小的内存分页，需要操作系统的支持</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseFastAccessorMethods</td>
<td>当频繁反射执行某个方法时，生成字节码来加快反射的执行速度</td>
</tr>
</tbody></table>
<h4 id="3-3-2、其他"><a href="#3-3-2、其他" class="headerlink" title="3.3.2、其他"></a><strong>3.3.2、其他</strong></h4><p>描述见表6。</p>
<p>表6</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+&#x2F;-UseSpinning</td>
<td>是否开启自旋锁避免线程频繁挂起和唤醒</td>
</tr>
<tr>
<td>-XX:PreBlockSpin&#x3D;N</td>
<td>使用自旋锁时默认的自旋次数</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseThreadPriorities</td>
<td>是否使用本地线程优先级</td>
</tr>
<tr>
<td>-XX:+&#x2F;-UseBiasedLocking</td>
<td>是否使用偏向锁</td>
</tr>
<tr>
<td>-XX:+&#x2F;-AggressiveOpts</td>
<td>是否使用激进的优化策略，需要根据具体应用特点进行分析，从而来判定采用该策略是否对性能有好处</td>
</tr>
<tr>
<td>-XX:+&#x2F;-PrintConcurrentLocks</td>
<td>是否打印J.U.C中锁的状态</td>
</tr>
<tr>
<td>-XX:OnOutOfMemoryError&#x3D;”COMMAND”</td>
<td>当抛出OutOfMemoryError异常时，执行指定的命令COMMAND</td>
</tr>
<tr>
<td>-XX:OnError&#x3D;”COMMAND”</td>
<td>当抛出Error异常时，执行指定的命令COMMAND</td>
</tr>
<tr>
<td>-XX:+&#x2F;-DisableAttachMechanism</td>
<td>是否关闭Dynamic Attach机制</td>
</tr>
</tbody></table>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a><strong>四、补充</strong></h2><h3 id="4-1、类路径"><a href="#4-1、类路径" class="headerlink" title="4.1、类路径"></a><strong>4.1、类路径</strong></h3><p>使用“java”命令尝试运行JVM进程时，类路径有3类：Bootstrap Classpath（默认值为“jre&#x2F;lib”，可通过“-Xbootclasspath:bootclasspath”，“-Xbootclasspath&#x2F;a:path”，“-Xbootclasspath&#x2F;p:path”虚拟机参数更改），Extension Classpath（默认值为“jre&#x2F;lib&#x2F;ext”，没有途径更改），User Classpath（默认值为“.”，可通过“-classpath”，“-cp”虚拟机参数更改）。[10]</p>
<h3 id="4-2、JVM运行模式client和server"><a href="#4-2、JVM运行模式client和server" class="headerlink" title="4.2、JVM运行模式client和server"></a><strong>4.2、JVM运行模式client和server</strong></h3><p>自从JDK 5开始，当使用“java”命令尝试运行一个JVM进程时，JVM会判断一系列条件，当条件满足时，以server模式运行JVM进程，否则以client模式运行JVM进程，除非显式指定了“-client”或者“-server”。[11]</p>
<h3 id="4-3、配置Java堆中年轻代大小参数-12-13-14"><a href="#4-3、配置Java堆中年轻代大小参数-12-13-14" class="headerlink" title="4.3、配置Java堆中年轻代大小参数[12][13][14]"></a><strong>4.3、配置Java堆中年轻代大小参数[12][13][14]</strong></h3><p>配置Java堆中年轻代大小的参数有：-XX:NewRatio&#x3D;N，-XX:NewSize&#x3D;N，-XX:MaxNewSize&#x3D;N，-Xmn&#60;SIZE&#62;。描述如表7。</p>
<p>表7</p>
<table>
<thead>
<tr>
<th>参数&#x2F;参数组合</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:NewRatio&#x3D;N</td>
<td>老年代与年轻代大小比值为N，即年轻代与Java堆大小比值为1&#x2F;N+1</td>
</tr>
<tr>
<td>-XX:NewSize&#x3D;N，-XX:MaxNewSize&#x3D;N</td>
<td>NewSize配置年轻代初始值和最小值，MaxNewSize配置年轻代最大值</td>
</tr>
<tr>
<td>-Xmn&#60;SIZE&#62;</td>
<td>-Xmn&#60;SIZE&#62;精确配置年轻代大小为SIZE</td>
</tr>
</tbody></table>
<p>以上3个“参数&#x2F;参数组合”的优先级顺序为：“-Xmn&#60;SIZE&#62;” &#x3D; “-XX:NewSize&#x3D;N，-XX:MaxNewSize&#x3D;N” &gt; “-XX:NewRatio&#x3D;N”，相等优先级情形下，位于后面的“参数&#x2F;参数组合”覆盖前面而真正生效。接下来进行验证。<br>现有如下一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(10 * 60 * 1000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，执行<code>java -XX:NewRatio=4 -Xms10M -Xmx20M Example</code>命令，在该JVM进程（假设JVM进程ID为25101）还在运行时，执行<code>jstat -gcnewcapacity 25101 1000 3</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">    2048.0     4096.0     2048.0    384.0    192.0    384.0    192.0     3328.0     1664.0     0     0</span><br><span class="line">    2048.0     4096.0     2048.0    384.0    192.0    384.0    192.0     3328.0     1664.0     0     0</span><br><span class="line">    2048.0     4096.0     2048.0    384.0    192.0    384.0    192.0     3328.0     1664.0     0     0</span><br></pre></td></tr></table></figure>
<p>再执行<code>java -Xmn8M -XX:NewRatio=4 -Xms10M -Xmx20M Example</code>命令，在该JVM进程（假设JVM进程ID为25165）还在运行时，执行<code>jstat -gcnewcapacity 25165 1000 3</code>命令，得到如下所示结果，结合上一个结果，得到“-Xmn&#60;SIZE&#62;”优先级 &gt; “-XX:NewRatio&#x3D;N”优先级结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br></pre></td></tr></table></figure>
<p>再分别执行<code>java -Xmn8M -XX:NewSize=4M -XX:MaxNewSize=7M -Xms10M -Xmx20M Example</code>和<code>java -XX:NewSize=4M -XX:MaxNewSize=7M -Xmn8M -Xms10M -Xmx20M Example</code>命令，在JVM进程（假设JVM进程ID分别为25328和25369）还在运行时，分别执行<code>jstat -gcnewcapacity 25328 1000 3</code>和<code>jstat -gcnewcapacity 25369 1000 3</code>命令，得到如下两个所示结果，据此可得“-Xmn&#60;SIZE&#62;”优先级 &#x3D; “-XX:NewSize&#x3D;N，-XX:MaxNewSize&#x3D;N”优先级结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">    4096.0     7168.0     4096.0    704.0    384.0    704.0    384.0     5760.0     3328.0     0     0</span><br><span class="line">    4096.0     7168.0     4096.0    704.0    384.0    704.0    384.0     5760.0     3328.0     0     0</span><br><span class="line">    4096.0     7168.0     4096.0    704.0    384.0    704.0    384.0     5760.0     3328.0     0     0</span><br><span class="line"></span><br><span class="line">---分割线---</span><br><span class="line"></span><br><span class="line">NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br><span class="line">    8192.0     8192.0     8192.0    768.0    768.0    768.0    768.0     6656.0     6656.0     0     0</span><br></pre></td></tr></table></figure>
<p>综上，这3个“参数&#x2F;参数组合”的优先级顺序已经得到验证。</p>
<h3 id="4-4、常用虚拟机参数组合片段"><a href="#4-4、常用虚拟机参数组合片段" class="headerlink" title="4.4、常用虚拟机参数组合片段"></a><strong>4.4、常用虚拟机参数组合片段</strong></h3><p>接下来介绍一些常用虚拟机参数组合片段，需要注意的是，这些常用虚拟机参数组合片段只适用于一般情形，如果是特殊情形，还是需要进行针对性调优的。</p>
<h4 id="4-4-1、打印GC日志"><a href="#4-4-1、打印GC日志" class="headerlink" title="4.4.1、打印GC日志"></a><strong>4.4.1、打印GC日志</strong></h4><p>打印GC日志场景的常用虚拟机参数组合片段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -Xloggc:file</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2、服务器上运行JVM服务进程"><a href="#4-4-2、服务器上运行JVM服务进程" class="headerlink" title="4.4.2、服务器上运行JVM服务进程"></a><strong>4.4.2、服务器上运行JVM服务进程</strong></h4><p>服务器上运行JVM服务进程场景的常用虚拟机参数组合片段如下[15]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-server -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -XX:NewSize=256m -XX:MaxNewSize=256m -Xms768m -Xmx768m -XX:MaxPermSize=128m -XX:SurvivorRatio=128 -XX:MaxTenuringThreshold=0 -XX:+UseTLAB</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3、打印常见部分“-XX”类型虚拟机参数"><a href="#4-4-3、打印常见部分“-XX”类型虚拟机参数" class="headerlink" title="4.4.3、打印常见部分“-XX”类型虚拟机参数"></a><strong>4.4.3、打印常见部分“-XX”类型虚拟机参数</strong></h4><p>打印常见部分“-XX”类型虚拟机参数（包括参数类型，名称，值等信息）场景的常用虚拟机参数组合片段如下[3][4]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+AggressiveOpts -XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/java.html
[2]man java
[3]http://www.javaworld.com/article/2073676/hotspot-jvm-options-displayed---xx--printflagsinitial-and--xx--printflagsfinal.html
[4]http://q-redux.blogspot.hk/2011/01/inspecting-hotspot-jvm-options.html
[5]https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/
[6]https://www.ibm.com/developerworks/cn/java/j-lo-jse61/
[7]http://stackoverflow.com/questions/19510169/what-are-the-differences-between-private-jre-and-public-jre
[8]http://stackoverflow.com/questions/27844418/java-xnoclassgc
[9]https://news.ycombinator.com/item?id=3170354
[10]https://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html
[11]http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html
[12]http://eyesmore.iteye.com/blog/1530996
[13]http://stackoverflow.com/questions/23880891/what-does-xmn-jvm-option-stands-for
[14]https://gist.github.com/rednaxelafx/1066883
[15]https://docs.oracle.com/cd/E13209_01/wlcp/wlss30/configwlss/jvmgc.html
[16]http://ifeve.com/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2
[17]http://www.importnew.com/20575.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jhat命令</title>
    <url>/blog/2017/04/19/jhat%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jhat Java堆堆转存快照文件</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>解析hprof格式的Java堆堆转存快照文件，运行一个HTTP Server（默认端口为7000）。然后我们可通过<code>http://localhost:7000</code>网址浏览解析得到的Java堆内存信息。</p>
<h2 id="三、重要说明"><a href="#三、重要说明" class="headerlink" title="三、重要说明"></a><strong>三、重要说明</strong></h2><h3 id="3-1、hprof格式的Java堆堆转存快照文件的获取途径"><a href="#3-1、hprof格式的Java堆堆转存快照文件的获取途径" class="headerlink" title="3.1、hprof格式的Java堆堆转存快照文件的获取途径"></a><strong>3.1、hprof格式的Java堆堆转存快照文件的获取途径</strong></h3><p>获取途径有：</p>
<ol>
<li>使用“hprof”工具[3]</li>
<li>通过“jmap -dump:format&#x3D;b,file&#x3D;FILENAME”命令</li>
<li>使用“jconsole”工具[4]</li>
<li>执行“java”命令时加上“-XX:+HeapDumpOnOutOfMemoryError”虚拟机参数</li>
</ol>
<h3 id="3-2、更加强大的Java堆堆转存快照文件解析工具"><a href="#3-2、更加强大的Java堆堆转存快照文件解析工具" class="headerlink" title="3.2、更加强大的Java堆堆转存快照文件解析工具"></a><strong>3.2、更加强大的Java堆堆转存快照文件解析工具</strong></h3><p>通过<code>http://localhost:7000</code>网址浏览解析得到的Java堆内存信息主要有两种方式：静态方式和动态方式。静态方式：使用方式和页面含义非常直观，无需额外说明；动态方式：通过Object Query Language语言执行查询，要想获得关于Object Query Language语言的帮助，可访问<code>http://localhost:7000/oqlhelp/</code>网址。<br>总的来说，通过jhat命令接口，我们往往“不能快速甚至根本不能”获取一些重要的Java堆内存信息（比如说，获取实例的“Retained Size”[5]）。因此，在实际应用中，我们常常使用一些功能更加强大的解析工具，比如“Java VisualVM”，“Eclipse Memory Analyzer（MAT）”，“YourKit”，“JProfiler”等。</p>
<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html
[2]man jhat
[3]http://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html
[4]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jconsole.html
[5]https://www.yourkit.com/docs/java/help/sizes.jsp
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jinfo命令</title>
    <url>/blog/2017/04/09/jinfo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jinfo [-flag name] JVM进程ID</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、没有选项"><a href="#2-1、没有选项" class="headerlink" title="2.1、没有选项"></a><strong>2.1、没有选项</strong></h3><p>打印两方面内容：1）相应JVM进程运行时环境变量“键-值”列表；2）使用“java”命令运行相应JVM进程时传入的虚拟机参数，<font color='red'>有些虚拟机参数并不显示，比如“-classpath”，“-showversion”</font>。可参照<a href="/blog/2017/04/06/jps%E5%91%BD%E4%BB%A4/" title="jps命令">《jps命令》</a>。</p>
<h3 id="2-2、有“-flag-name-”选项"><a href="#2-2、有“-flag-name-”选项" class="headerlink" title="2.2、有“[-flag name]”选项"></a><strong>2.2、有“[-flag name]”选项</strong></h3><p>此处“name”表示“-XX”类型虚拟机参数的名称，表示打印相应JVM进程运行时该参数的参数值。</p>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a><strong>三、例子</strong></h2><h3 id="3-1、例子1"><a href="#3-1、例子1" class="headerlink" title="3.1、例子1"></a><strong>3.1、例子1</strong></h3><p>有如下一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(10 * 60 * 1000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，执行<code>java -showversion -verbose:jni -Dhello=world -classpath &quot;.:$JAVA_HOME/lib/tools.jar&quot; -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M Example 10 20</code>命令，在该JVM进程（假设JVM进程ID为15506）还在运行时，执行<code>jinfo 15506</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class="line">java.vm.version = 24.79-b02</span><br><span class="line">sun.boot.library.path = /mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/i386</span><br><span class="line">hello = world</span><br><span class="line">java.vendor.url = http://java.oracle.com/</span><br><span class="line">java.vm.vendor = Oracle Corporation</span><br><span class="line">path.separator = :</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">java.vm.name = Java HotSpot(TM) Client VM</span><br><span class="line">sun.os.patch.level = unknown</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">user.country = CN</span><br><span class="line">user.dir = /mnt/bigdisk/workspace/dslztx/src/main/java</span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class="line">java.runtime.version = 1.7.0_79-b15</span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class="line">os.arch = i386</span><br><span class="line">java.endorsed.dirs = /mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/endorsed</span><br><span class="line">java.io.tmpdir = /tmp</span><br><span class="line">line.separator = </span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor = Oracle Corporation</span><br><span class="line">os.name = Linux</span><br><span class="line">sun.jnu.encoding = UTF-8</span><br><span class="line">java.library.path = /usr/java/packages/lib/i386:/lib:/usr/lib</span><br><span class="line">java.specification.name = Java Platform API Specification</span><br><span class="line">java.class.version = 51.0</span><br><span class="line">sun.management.compiler = HotSpot Client Compiler</span><br><span class="line">os.version = 3.16.0-30-generic</span><br><span class="line">user.home = /home/dsl</span><br><span class="line">user.timezone = </span><br><span class="line">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class="line">file.encoding = UTF-8</span><br><span class="line">java.specification.version = 1.7</span><br><span class="line">user.name = dsl</span><br><span class="line">java.class.path = .:/home/dsl/bigdisk/apps/jdk1.7.0_79/lib/tools.jar</span><br><span class="line">java.vm.specification.version = 1.7</span><br><span class="line">sun.arch.data.model = 32</span><br><span class="line">sun.java.command = Example 10 20</span><br><span class="line">java.home = /mnt/bigdisk/apps/jdk1.7.0_79/jre</span><br><span class="line">user.language = zh</span><br><span class="line">java.specification.vendor = Oracle Corporation</span><br><span class="line">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class="line">java.vm.info = mixed mode</span><br><span class="line">java.version = 1.7.0_79</span><br><span class="line">java.ext.dirs = /mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line">sun.boot.class.path = /mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/resources.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/rt.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/sunrsasign.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/jsse.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/jce.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/charsets.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/lib/jfr.jar:/mnt/bigdisk/apps/jdk1.7.0_79/jre/classes</span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">file.separator = /</span><br><span class="line">java.vendor.url.bug = http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding = UnicodeLittle</span><br><span class="line">sun.cpu.endian = little</span><br><span class="line">sun.desktop = gnome</span><br><span class="line">sun.cpu.isalist = </span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line"></span><br><span class="line">-verbose:jni -Dhello=world -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M</span><br></pre></td></tr></table></figure>
<h3 id="3-2、例子2"><a href="#3-2、例子2" class="headerlink" title="3.2、例子2"></a><strong>3.2、例子2</strong></h3><p>使用上一小节的代码，编译后，执行<code>java Example</code>命令，在该JVM进程（假设JVM进程ID为15945）还在运行时，依次执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jinfo -flag PrintGCTimeStamps 15945</span><br><span class="line">jinfo -flag PrintGCDetails 15945</span><br><span class="line">jinfo -flag PrintGCDateStamps 15945</span><br><span class="line">jinfo -flag SurvivorRatio 15945</span><br><span class="line">jinfo -flag PermSize 15945</span><br><span class="line">jinfo -flag MaxPermSize 15945</span><br></pre></td></tr></table></figure>
<p>依次执行结果显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:-PrintGCTimeStamps</span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line">-XX:-PrintGCDateStamps</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:PermSize=12582912</span><br><span class="line">-XX:MaxPermSize=67108864</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html
[2]man jinfo
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jmap命令</title>
    <url>/blog/2017/04/13/jmap%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap [-F] [-dump:format=b,file=FILENAME|-heap|-histo|-permstat] 进程ID</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>“进程ID”是指JVM进程ID，以上常用用法的含义是：打印或者保存相应JVM进程的Java堆信息。</p>
<h2 id="三、选项"><a href="#三、选项" class="headerlink" title="三、选项"></a><strong>三、选项</strong></h2><p>假设现在运行有一个进程ID为3937的JVM进程，以该JVM进程为实验对象，对“选项”进行说明。</p>
<h3 id="3-1、“-F”"><a href="#3-1、“-F”" class="headerlink" title="3.1、“-F”"></a><strong>3.1、“-F”</strong></h3><p>“-F”选项可与接下来的几个选项结合使用，不能单独使用。使用“-F”选项后，会开启“HotSpot Serviceability Agent”机制，这使得JVM进程收到一个“SIGSTOP”信号而被“Hung”，只有当请求的信息获取完成后，该JVM进程才会收到一个“SIGCONT”信号而重新运行。[3][4][5]</p>
<h3 id="3-2、“-dump-format-b-file-FILENAME”"><a href="#3-2、“-dump-format-b-file-FILENAME”" class="headerlink" title="3.2、“-dump:format&#x3D;b,file&#x3D;FILENAME”"></a><strong>3.2、“-dump:format&#x3D;b,file&#x3D;FILENAME”</strong></h3><p>保存Java堆堆转存快照到文件“FILENAME”，供后续进行分析，堆转存快照的格式为“hprof二进制格式”。</p>
<h3 id="3-3、“-heap”"><a href="#3-3、“-heap”" class="headerlink" title="3.3、“-heap”"></a><strong>3.3、“-heap”</strong></h3><p>打印Java堆的如下信息：使用的垃圾收集器，Java堆相关的几个虚拟机参数值，Java堆不同内存区域的使用情况，“字符串常量池”使用情况等。注意跟“jstat”命令的统计信息有所重叠。<br>执行<code>jmap -heap 3937</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attaching to process ID 3937, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Client compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Mark Sweep Compact GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio = 40</span><br><span class="line">   MaxHeapFreeRatio = 70</span><br><span class="line">   MaxHeapSize      = 536870912 (512.0MB)</span><br><span class="line">   NewSize          = 1048576 (1.0MB)</span><br><span class="line">   MaxNewSize       = 4294901760 (4095.9375MB)</span><br><span class="line">   OldSize          = 4194304 (4.0MB)</span><br><span class="line">   NewRatio         = 2</span><br><span class="line">   SurvivorRatio    = 8</span><br><span class="line">   PermSize         = 12582912 (12.0MB)</span><br><span class="line">   MaxPermSize      = 67108864 (64.0MB)</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 7471104 (7.125MB)</span><br><span class="line">   used     = 790304 (0.753692626953125MB)</span><br><span class="line">   free     = 6680800 (6.371307373046875MB)</span><br><span class="line">   10.578142132675438% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 6684672 (6.375MB)</span><br><span class="line">   used     = 790304 (0.753692626953125MB)</span><br><span class="line">   free     = 5894368 (5.621307373046875MB)</span><br><span class="line">   11.822629442401961% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 786432 (0.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 786432 (0.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 786432 (0.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 786432 (0.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">tenured generation:</span><br><span class="line">   capacity = 16429056 (15.66796875MB)</span><br><span class="line">   used     = 7500296 (7.152839660644531MB)</span><br><span class="line">   free     = 8928760 (8.515129089355469MB)</span><br><span class="line">   45.65262909810521% used</span><br><span class="line">Perm Generation:</span><br><span class="line">   capacity = 12582912 (12.0MB)</span><br><span class="line">   used     = 9098864 (8.677352905273438MB)</span><br><span class="line">   free     = 3484048 (3.3226470947265625MB)</span><br><span class="line">   72.31127421061198% used</span><br><span class="line"></span><br><span class="line">4104 interned Strings occupying 306480 bytes.</span><br></pre></td></tr></table></figure>
<h3 id="3-4、“-histo”"><a href="#3-4、“-histo”" class="headerlink" title="3.4、“-histo”"></a><strong>3.4、“-histo”</strong></h3><p>打印每个类的统计信息：类的实例数量，类的实例字节数，类的全限定名称等等。<br>执行<code>jmap -histo 3937</code>命令，得到如下所示结果（限于篇幅，只截取了第一页结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         26723        3048040  &lt;constMethodKlass&gt;</span><br><span class="line">   2:          4967        2283080  [B</span><br><span class="line">   3:         11530        2245392  [C</span><br><span class="line">   4:         26723        1927712  &lt;methodKlass&gt;</span><br><span class="line">   5:           322        1648520  [I</span><br><span class="line">   6:          2768        1435312  &lt;constantPoolKlass&gt;</span><br><span class="line">   7:          2768        1051720  &lt;instanceKlassKlass&gt;</span><br><span class="line">   8:          2118         783680  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   9:          9216         368640  org.apache.lucene.index.FreqProxTermsWriter$PostingList</span><br><span class="line">  10:         10801         259224  java.lang.String</span><br><span class="line">  11:          2959         254872  java.lang.Class</span><br><span class="line">  12:          4057         198384  [S</span><br><span class="line">  13:          4340         193960  [[I</span><br><span class="line">  14:          1802         160184  [Ljava.util.HashMap$Entry;</span><br><span class="line">  15:          3964         126848  java.util.LinkedHashMap$Entry</span><br><span class="line">  16:           288         122976  [Lorg.apache.lucene.index.RawPostingList;</span><br><span class="line">  17:          1798         108408  [Ljava.lang.Object;</span><br><span class="line">  18:          4136          99264  java.util.concurrent.ConcurrentHashMap$HashEntry</span><br><span class="line">  19:          3254          78096  java.util.HashMap$Entry</span><br><span class="line">  20:          1014          56784  java.util.LinkedHashMap</span><br><span class="line">  21:          1133          54384  java.util.HashMap</span><br><span class="line">  22:           174          54288  &lt;objArrayKlassKlass&gt;</span><br><span class="line">  23:           190          39152  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</span><br><span class="line">  24:           456          36480  java.lang.reflect.Method</span><br><span class="line">  25:           550          35200  java.lang.reflect.Field</span><br><span class="line">  26:          4059          32472  java.lang.Object</span><br><span class="line">  27:          1201          28824  java.util.ArrayList</span><br><span class="line">  28:          1079          25896  com.google.inject.TypeLiteral</span><br><span class="line">  29:           366          23424  org.apache.lucene.index.SegmentInfo</span><br><span class="line">  30:           290          18560  java.lang.reflect.Constructor</span><br><span class="line">  31:           622          14928  com.google.inject.Key</span><br><span class="line">  32:           586          14064  java.util.Hashtable$Entry</span><br><span class="line">  33:           437          13984  java.lang.ref.SoftReference</span><br><span class="line">  34:           545          13080  com.google.common.collect.CustomConcurrentHashMap$StrongEntry</span><br><span class="line">  35:           144          12672  org.apache.lucene.index.TermsHashPerField</span><br><span class="line">  36:           513          12312  sun.reflect.annotation.AnnotationInvocationHandler</span><br><span class="line">  37:           204           9792  java.lang.Package</span><br><span class="line">  38:            96           9216  java.io.ObjectStreamClass</span><br><span class="line">  39:           383           9192  com.google.inject.spi.Dependency</span><br><span class="line">  40:           555           8880  com.google.common.collect.CustomConcurrentHashMap$StrongValueReference</span><br><span class="line">  41:           152           8512  java.net.URL</span><br><span class="line">  42:           210           8400  com.google.inject.internal.ProviderInstanceBindingImpl</span><br><span class="line">  43:           255           8160  java.lang.ref.Finalizer</span><br><span class="line">  44:           507           8112  java.lang.Integer</span><br></pre></td></tr></table></figure>
<h3 id="3-5、“-permstat”"><a href="#3-5、“-permstat”" class="headerlink" title="3.5、“-permstat”"></a><strong>3.5、“-permstat”</strong></h3><p>打印类加载器信息：类加载器名称，类加载器加载的类数量，类加载器加载的类字节数，父“类加载器”名称，是否存活标志，类加载器类型等等。<br>执行<code>jmap -permstat 3937</code>命令，得到如下所示结果（限于篇幅，只截取了第一页结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attaching to process ID 3937, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Client compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness............................................................................done.</span><br><span class="line">class_loader	classes	bytes	parent_loader		alive?	type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;	1143	4158120	  null  	live	&lt;internal&gt;</span><br><span class="line">0x9b343750	0	0	0x9b2c85c0	live	java/util/ResourceBundle$RBClassLoader@0xb0bdf870</span><br><span class="line">0x9b69c608	1	1752	0x9b2c85c0	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b3a17d0	0	0	0x9b2c85c0	live	org/sonatype/guice/plexus/scanners/CloningClassLoader@0xb0d62e30</span><br><span class="line">0x9b744a98	1	1752	0x9b2c85c0	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b2c9490	1	1768	  null  	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b2c93e8	1	1768	  null  	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b2c85c0	1827	5868816	0x9b2c9440	live	sun/misc/Launcher$AppClassLoader@0xb0957068</span><br><span class="line">0x9b5d9d70	1	1752	0x9b2c85c0	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b995630	1	1768	  null  	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b744a60	1	1864	0x9b2c85c0	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b2c94e8	1	1768	  null  	dead	sun/reflect/DelegatingClassLoader@0xb0835250</span><br><span class="line">0x9b2c9440	8	40640	  null  	live	sun/misc/Launcher$ExtClassLoader@0xb091e048</span><br><span class="line">0x9b339138	1	16760	0x9b2c85c0	live	org/codehaus/plexus/classworlds/realm/ClassRealm@0xb0b389f0</span><br><span class="line"></span><br><span class="line">total = 14	2987	10098528	    N/A    	alive=6, dead=8	    N/A</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html
[2]man jmap
[3]http://stackoverflow.com/questions/26140182/running-jmap-getting-unable-to-open-socket-file
[4]https://major.io/2009/06/15/two-great-signals-sigstop-and-sigcont/
[5]http://velocity.oreilly.com.cn/2013/ppts/java_web_serviceability_agent.pdf
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>join命令</title>
    <url>/blog/2016/06/03/join%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join [-t CHAR] [-i] [--header] [-1 FIELD] [-2 FIELD] [-e STR] FILE1 FILE2</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>存在两个<font color='red'>已排序</font>文件，假如文件1中的某条记录的某个字段值（默认是第一个字段，从1开始计数）与文件2中的某条记录的某个字段值（默认是第一个字段，从1开始计数）一致，那么在最终打印结果中，将这两条记录拼接成一条记录。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“-t CHAR”：以“CHAR”字符作为记录内字段间的分隔符，默认的分隔符是“空格符”<br>“-i”：两个字段值比较时，忽略大小写<br>“–header”：两个文件的第一行作为说明行，不参与比较<br>“-1 FIELD”：FILE1中以第“FIELD”个字段作为比较字段<br>“-2 FIELD”：FILE2中以第“FIELD”个字段作为比较字段<br>“-e STR”：在最终的拼接记录中，如果某个字段的值为空，那么以“STR”替换<br>“FILE1”：文件1<br>“FILE2”：文件2</p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><h3 id="3-1、实验1"><a href="#3-1、实验1" class="headerlink" title="3.1、实验1"></a><strong>3.1、实验1</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 1</span><br><span class="line">b 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 3</span><br><span class="line">b 4</span><br></pre></td></tr></table></figure>
<p>执行以下命令，得到如图1所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-1.png"></p>
<h3 id="3-2、实验2"><a href="#3-2、实验2" class="headerlink" title="3.2、实验2"></a><strong>3.2、实验2</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a;1</span><br><span class="line">b;2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a;3</span><br><span class="line">b;4</span><br></pre></td></tr></table></figure>
<p>执行以下命令，得到如图2所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -t &#x27;;&#x27; a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-2.png"></p>
<h3 id="3-3、实验3"><a href="#3-3、实验3" class="headerlink" title="3.3、实验3"></a><strong>3.3、实验3</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 1</span><br><span class="line">b 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 3</span><br><span class="line">b 4</span><br></pre></td></tr></table></figure>
<p>执行以下命令，得到如图3所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -i a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-3.png"></p>
<h3 id="3-4、实验4"><a href="#3-4、实验4" class="headerlink" title="3.4、实验4"></a><strong>3.4、实验4</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Col1 Col2</span><br><span class="line">a 1</span><br><span class="line">b 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Col3 Col4</span><br><span class="line">a 3</span><br><span class="line">b 4</span><br></pre></td></tr></table></figure>
<p>执行以下命令，得到如图4所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join --header a.txt b.txt</span><br></pre></td></tr></table></figure>

<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-4.png"></p>
<h3 id="3-5、实验5"><a href="#3-5、实验5" class="headerlink" title="3.5、实验5"></a><strong>3.5、实验5</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 1 f</span><br><span class="line">b 2 g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f 3 5</span><br><span class="line">g 4 6</span><br></pre></td></tr></table></figure>
<p>执行以下命令，得到如图5所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -1 3 -2 1 a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-5.png"></p>
<h3 id="3-6、实验6"><a href="#3-6、实验6" class="headerlink" title="3.6、实验6"></a><strong>3.6、实验6</strong></h3><p>有文件“a.txt”和“b.txt”，内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a </span><br><span class="line">b 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 3</span><br><span class="line">b 4</span><br></pre></td></tr></table></figure>

<p>执行以下命令，得到如图6所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -e &quot;hello world&quot; a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20160603-0-6.png"></p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、“LC-COLLATE”等环境变量"><a href="#4-1、“LC-COLLATE”等环境变量" class="headerlink" title="4.1、“LC_COLLATE”等环境变量"></a><strong>4.1、“LC_COLLATE”等环境变量</strong></h3><p>由于涉及到两个字符串的比较等，故而程序实现中使用“LC_COLLATE”等环境变量，最终结果受到“LC_COLLATE”等环境变量的控制。</p>
<h3 id="4-2、排序策略"><a href="#4-2、排序策略" class="headerlink" title="4.2、排序策略"></a><strong>4.2、排序策略</strong></h3><p>跟“comm”命令一样，join命令实现设定的排序策略是“按照字典序排序”。因而，两个文件“已排序”应该是按照字典序已排序，否则执行join命令得到的结果很有可能不能符合预期。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man join</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>jps命令</title>
    <url>/blog/2017/04/06/jps%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps [-qlmvV]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>列出在本机运行的有权限进行访问的虚拟机进程的状态信息（主要跟“java”命令对应）。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p><strong>1、“无选项”</strong><br>列出所有有权限进行访问的虚拟机进程的进程ID和运行主类&#x2F;运行JAR包名称。<br><strong>2、“-q”选项</strong><br>只列出所有有权限进行访问的虚拟机进程的进程ID。<br><strong>3、“-l”选项</strong><br>运行主类&#x2F;运行JAR包名称以完整路径形式展现。<br><strong>4、“-m”选项</strong><br>列出传递给运行主类&#x2F;运行JAR包“public static void main(String[] args)”方法的参数。<br><strong>5、“-v”选项</strong><br>列出运行虚拟机进程时通过命令行形式传递给虚拟机的参数。<br><strong>6、“-V”选项</strong><br>列出运行虚拟机进程时通过文件形式（“.hotspotrc”文件或者“-XX:Flags&#x3D;&#60;filename&#62;”指定的文件）传递给虚拟机的参数。</p>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a><strong>三、例子</strong></h2><h3 id="3-1、例子1"><a href="#3-1、例子1" class="headerlink" title="3.1、例子1"></a><strong>3.1、例子1</strong></h3><p>有如下一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(10 * 60 * 1000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，执行<code>java -verbose:jni -Dhello=world -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M Example 10 20</code>命令，在该虚拟机进程还在运行时，执行<code>jps -lmvV</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11441 Example 10 20 -verbose:jni -Dhello=world -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M</span><br></pre></td></tr></table></figure>
<h3 id="3-2、例子2"><a href="#3-2、例子2" class="headerlink" title="3.2、例子2"></a><strong>3.2、例子2</strong></h3><p><font color='red'>需要注意的是，在加上“-v&#x2F;-V”选项的情形下，有些虚拟机参数还是不会显示，比如“-classpath”，“-showversion”。</font><br>使用上一小节的代码，编译后，执行<code>java -showversion -verbose:jni -Dhello=world -classpath &quot;.:$JAVA_HOME/lib/tools.jar&quot; -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M Example 10 20</code>命令，在该虚拟机进程还在运行时，执行<code>jps -lmvV</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11541 Example 10 20 -verbose:jni -Dhello=world -Xnoclassgc -Xloggc:jvm.log -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms10M -Xmx20M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html
[2]man jps
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jsadebugd命令</title>
    <url>/blog/2017/05/06/jsadebugd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsadebugd PID [ServerId]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><p>使用jinfo，jmap，jstack命令不仅可监控本地主机上的JVM进程，也可监控远端主机上的JVM进程，前者称为“本地模式”，后者称为“联网模式”。“联网模式”下的整个监控体系实质上是一个RMI应用程序。在“联网模式”下，一般情况下，远端主机上“运行rmiregistry服务，运行RMI Server”，本地主机上“运行RMI Client”，整个体系中“无需运行Web Server服务（因为所有相关类都可在本地获取）”。<br>在远端主机上，通过运行jsadebugd命令开启RMI Server（<font color='red'>需要注意的是，运行jsadebugd命令同时会自动运行rmiregistry服务，而无需手动运行</font>），使用“PID”选项值指定远端主机上待被监控的JVM进程ID，使用“ServerId”选项值作为RMI Server内向rmiregistry服务注册所生成Remote Object实例的名称（如果未指定，则使用默认名称）；在本地主机上，运行jinfo，jmap，jstack命令作为RMI Client。</p>
<h2 id="三、具体使用"><a href="#三、具体使用" class="headerlink" title="三、具体使用"></a><strong>三、具体使用</strong></h2><h3 id="3-1、环境描述"><a href="#3-1、环境描述" class="headerlink" title="3.1、环境描述"></a><strong>3.1、环境描述</strong></h3><p>远端主机内网IP地址为“10.110.20.100”，其上运行的待被监控的JVM进程ID为“4272”。</p>
<h3 id="3-2、实际运行"><a href="#3-2、实际运行" class="headerlink" title="3.2、实际运行"></a><strong>3.2、实际运行</strong></h3><h4 id="3-2-1、远端主机"><a href="#3-2-1、远端主机" class="headerlink" title="3.2.1、远端主机"></a><strong>3.2.1、远端主机</strong></h4><p>在远端主机上，执行<code>jsadebugd 4272 remoteObject1</code>命令开启RMI Server（同时开启rmiregistry服务），并使用“remoteObject1”名称向rmiregistry服务注册所生成的Remote Object实例，被监控JVM进程ID为“4272”。<br>假设运行jsadebugd命令得到的JVM进程ID为“5271”，执行<code>netstat -anp | grep &#39;5271&#39;</code>命令，可得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp        0      0 :::37606                    :::*                        LISTEN      5271/jsadebugd      </span><br><span class="line">tcp        0      0 :::1099                     :::*                        LISTEN      5271/jsadebugd</span><br></pre></td></tr></table></figure>
<p>以上结果证明，运行jsadebugd命令得到的JVM进程开启了rmiregistry服务（rmiregistry服务默认监听1099端口）和RMI Server（37606作为Remote Object实例绑定到的端口）。</p>
<h4 id="3-2-2、本地主机"><a href="#3-2-2、本地主机" class="headerlink" title="3.2.2、本地主机"></a><strong>3.2.2、本地主机</strong></h4><p>在本地主机上，执行<code>jinfo/jmap/jstack remoteObject1@10.110.20.100</code>命令作为RMI Client与远端主机上的rmiregistry服务和RMI Server进行交互，而达到监控远端主机上相应JVM进程的目标。执行jinfo，jmap，jstack命令时可使用的选项参数可具体参考这些命令的“本地模式”用法。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>本地主机和远端主机上的JDK版本需要完全一致，否则会报错。</p>
<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jsadebugd.html
[2]man jsadebugd
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jstatd命令</title>
    <url>/blog/2017/05/07/jstatd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstatd [-n ServerId]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><p>使用jps，jstat命令不仅可监控本地主机上的JVM进程，也可监控远端主机上的JVM进程，前者称为“本地模式”，后者称为“联网模式”。“联网模式”下的整个监控体系实质上是一个RMI应用程序。在“联网模式”下，一般情况下，远端主机上“运行rmiregistry服务，运行RMI Server”，本地主机上“运行RMI Client”，整个体系中“无需运行Web Server服务（因为所有相关类都可在本地获取）”。<br>在远端主机上，通过运行jstatd命令开启RMI Server（<font color='red'>需要注意的是，运行jstatd命令同时会自动运行rmiregistry服务，而无需手动运行</font>），使用“ServerId”选项值作为RMI Server内向rmiregistry服务注册所生成Remote Object实例的名称（如果未指定，则使用默认名称）；在本地主机上，运行jps，jstat命令作为RMI Client。</p>
<h2 id="三、具体使用"><a href="#三、具体使用" class="headerlink" title="三、具体使用"></a><strong>三、具体使用</strong></h2><h3 id="3-1、环境描述"><a href="#3-1、环境描述" class="headerlink" title="3.1、环境描述"></a><strong>3.1、环境描述</strong></h3><p>远端主机内网IP地址为“10.110.20.100”，其上运行有两个JVM进程，JVM进程ID分别为“821”和“11220”。</p>
<h3 id="3-2、实际运行"><a href="#3-2、实际运行" class="headerlink" title="3.2、实际运行"></a><strong>3.2、实际运行</strong></h3><h4 id="3-2-1、远端主机"><a href="#3-2-1、远端主机" class="headerlink" title="3.2.1、远端主机"></a><strong>3.2.1、远端主机</strong></h4><p>在远端主机上，执行<code>jstatd -J-Djava.security.policy=server.policy -n remoteObject1</code>命令开启RMI Server（同时开启rmiregistry服务），并使用“remoteObject1”名称向rmiregistry服务注册所生成的Remote Object实例，通过“-J-Djava.security.policy”选项指定安全访问策略文件（可参见<a href="/blog/2017/04/26/RMI/" title="RMI">《RMI》</a>），在这里“server.policy”文件内容被简单编辑为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设运行jstatd命令得到的JVM进程ID为“2891”，执行<code>netstat -anp | grep &#39;2891&#39;</code>命令，可得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp        0      0 :::1099                     :::*                        LISTEN      2891/jstatd         </span><br><span class="line">tcp        0      0 :::57818                    :::*                        LISTEN      2891/jstatd</span><br></pre></td></tr></table></figure>
<p>以上结果证明，运行jstatd命令得到的JVM进程开启了rmiregistry服务（rmiregistry服务默认监听1099端口）和RMI Server（57818作为Remote Object实例绑定到的端口）。</p>
<h4 id="3-2-2、本地主机"><a href="#3-2-2、本地主机" class="headerlink" title="3.2.2、本地主机"></a><strong>3.2.2、本地主机</strong></h4><h5 id="3-2-2-1、jps命令"><a href="#3-2-2-1、jps命令" class="headerlink" title="3.2.2.1、jps命令"></a><strong>3.2.2.1、jps命令</strong></h5><p>在本地主机上，执行<code>jps rmi://10.110.20.100/remoteObject1</code>命令作为RMI Client与远端主机上的rmiregistry服务和RMI Server进行交互，列出在远端主机运行的有权限进行访问的JVM进程的状态信息。执行jps命令时可使用的选项参数可具体参考该命令的“本地模式”用法。<br>执行以上命令，得到最终结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">821 Agent</span><br><span class="line">2891 Jstatd</span><br><span class="line">11220 Agent</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-2、jstat命令"><a href="#3-2-2-2、jstat命令" class="headerlink" title="3.2.2.2、jstat命令"></a><strong>3.2.2.2、jstat命令</strong></h5><p>在本地主机上，执行<code>jstat rmi://11220@10.110.20.100/remoteObject1</code>命令作为RMI Client与远端主机上的rmiregistry服务和RMI Server进行交互，而达到监控远端主机上相应JVM进程的目标。执行jstat命令时可使用的选项参数可具体参考该命令的“本地模式”用法。<br>执行<code>jstat -gcutil rmi://11220@10.110.20.100/remoteObject1 1000 3</code>命令，得到最终结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">0.00  92.20  62.48  55.51  21.58     35   11.899     0    0.000   11.899</span><br><span class="line">0.00  92.20  62.96  55.51  21.58     35   11.899     0    0.000   11.899</span><br><span class="line">0.00  92.20  65.31  55.51  21.58     35   11.899     0    0.000   11.899</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstatd.html
[2]man jstatd
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>jstat命令</title>
    <url>/blog/2017/04/07/jstat%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat StatOption [-h N] [-t] 进程ID [Interval(s|ms)] [Count]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>根据指定的统计指标，对指定的虚拟机进程进行相应统计，并打印统计信息。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p><strong>1、“StatOption”</strong><br>使用“StatOption”指定统计指标。“StatOption”可取值有：“-class，-compiler，-gc，-gccapacity，-gccause，-gcnew，-gcnewcapacity，-gcold，-gcoldcapacity，-gcpermcapacity，-gcutil，-printcompilation”。详细描述见“三、StatOption”。<br><strong>2、“-h N”</strong><br>每隔N次统计，打印统计指标名称行。<br><strong>3、“-t”</strong><br>额外增加“Timestamp（时间列）”统计指标，该时间表示虚拟机进程开始以来到统计时刻经过的秒数。<br><strong>4、“Interval(s|ms)”</strong><br>两次统计之间的时间间隔，单位可以是“s（秒）”或者“ms（毫秒）”，默认为“ms（毫秒）”。<br><strong>5、“Count”</strong><br>进行“Count”次统计后退出统计。</p>
<h2 id="三、StatOption"><a href="#三、StatOption" class="headerlink" title="三、StatOption"></a><strong>三、StatOption</strong></h2><p>如果不作特别说明，内存以“KB”为单位，耗费时间以“秒”为单位。</p>
<h3 id="3-1、“-class”"><a href="#3-1、“-class”" class="headerlink" title="3.1、“-class”"></a><strong>3.1、“-class”</strong></h3><p>类加载器行为统计。<br>统计指标名称与详细描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>Loaded</td>
<td>被加载类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>被加载字节数量，以“KB”为单位</td>
</tr>
<tr>
<td>Unloaded</td>
<td>被卸载类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>被卸载字节数量，以“KB”为单位</td>
</tr>
<tr>
<td>Time</td>
<td>加载和卸载类行为耗费时间</td>
</tr>
</tbody></table>
<h3 id="3-2、“-compiler”"><a href="#3-2、“-compiler”" class="headerlink" title="3.2、“-compiler”"></a><strong>3.2、“-compiler”</strong></h3><p>“HotSpot Just-In-Time”编译器行为统计。<br>统计指标名称与详细描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>成功编译任务数量</td>
</tr>
<tr>
<td>Failed</td>
<td>失败编译任务数量</td>
</tr>
<tr>
<td>Invalid</td>
<td>无效编译任务数量</td>
</tr>
<tr>
<td>Time</td>
<td>编译任务耗费时间</td>
</tr>
<tr>
<td>FailedType</td>
<td>最近一次失败编译任务对应的编译类型</td>
</tr>
<tr>
<td>FailedMethod</td>
<td>最近一次失败编译任务对应的类名和方法名</td>
</tr>
</tbody></table>
<h3 id="3-3、“-gc”"><a href="#3-3、“-gc”" class="headerlink" title="3.3、“-gc”"></a><strong>3.3、“-gc”</strong></h3><p>Java堆垃圾回收行为统计。<br>统计指标名称与详细描述见表3。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>当前Survivor区0内存容量</td>
</tr>
<tr>
<td>S1C</td>
<td>当前Survivor区1内存容量</td>
</tr>
<tr>
<td>S0U</td>
<td>Survivor区0使用内存</td>
</tr>
<tr>
<td>S1U</td>
<td>Survivor区1使用内存</td>
</tr>
<tr>
<td>EC</td>
<td>当前Eden区内存容量</td>
</tr>
<tr>
<td>EU</td>
<td>Eden区使用内存</td>
</tr>
<tr>
<td>OC</td>
<td>当前老年代内存容量</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用内存</td>
</tr>
<tr>
<td>PC</td>
<td>当前永久代内存容量</td>
</tr>
<tr>
<td>PU</td>
<td>永久代使用内存</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代GC耗费时间</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
<tr>
<td>FGCT</td>
<td>Full GC耗费时间</td>
</tr>
<tr>
<td>GCT</td>
<td>GC耗费总时间</td>
</tr>
</tbody></table>
<h3 id="3-4、“-gccapacity”"><a href="#3-4、“-gccapacity”" class="headerlink" title="3.4、“-gccapacity”"></a><strong>3.4、“-gccapacity”</strong></h3><p>几个区域（年轻代，Survivor区，Eden区，老年代，永久代）内存容量统计。<br>统计指标名称与详细描述见表4。</p>
<p>表4</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>年轻代最小内存容量</td>
</tr>
<tr>
<td>NGCMX</td>
<td>年轻代最大内存容量</td>
</tr>
<tr>
<td>NGC</td>
<td>当前年轻代内存容量</td>
</tr>
<tr>
<td>S0C</td>
<td>当前Survivor区0内存容量</td>
</tr>
<tr>
<td>S1C</td>
<td>当前Survivor区1内存容量</td>
</tr>
<tr>
<td>EC</td>
<td>当前Eden区内存容量</td>
</tr>
<tr>
<td>OGCMN</td>
<td>老年代最小内存容量</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大内存容量</td>
</tr>
<tr>
<td>OGC</td>
<td>当前老年代内存容量</td>
</tr>
<tr>
<td>OC</td>
<td>当前老年代内存容量，跟“OGC”一致</td>
</tr>
<tr>
<td>PGCMN</td>
<td>永久代最小内存容量</td>
</tr>
<tr>
<td>PGCMX</td>
<td>永久代最大内存容量</td>
</tr>
<tr>
<td>PGC</td>
<td>当前永久代内存容量</td>
</tr>
<tr>
<td>PC</td>
<td>当前永久代内存容量，跟“PGC”一致</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
</tbody></table>
<h3 id="3-5、“-gcnew”"><a href="#3-5、“-gcnew”" class="headerlink" title="3.5、“-gcnew”"></a><strong>3.5、“-gcnew”</strong></h3><p>年轻代行为统计。<br>统计指标名称与详细描述见表5。</p>
<p>表5</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>当前Survivor区0内存容量</td>
</tr>
<tr>
<td>S1C</td>
<td>当前Survivor区1内存容量</td>
</tr>
<tr>
<td>S0U</td>
<td>Survivor区0使用内存</td>
</tr>
<tr>
<td>S1U</td>
<td>Survivor区1使用内存</td>
</tr>
<tr>
<td>TT</td>
<td>根据“-XX:MaxTenuringThreshold”参数值和一系列行为动态调整得到的“Tenuring threshold”值，最终根据该值，年轻代中长期存活的对象进入老年代</td>
</tr>
<tr>
<td>MTT</td>
<td>“-XX:MaxTenuringThreshold”参数值</td>
</tr>
<tr>
<td>DSS</td>
<td>DSS&#x3D;SURVIVOR_SPACE*TargetSurvivorRatio&#x2F;100，“TargetSurvivorRatio”参数值通过“-XX:TargetSurvivorRatio”形式设定</td>
</tr>
<tr>
<td>EC</td>
<td>当前Eden区内存容量</td>
</tr>
<tr>
<td>EU</td>
<td>Eden区使用内存</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代GC耗费时间</td>
</tr>
</tbody></table>
<h3 id="3-6、“-gcnewcapacity”"><a href="#3-6、“-gcnewcapacity”" class="headerlink" title="3.6、“-gcnewcapacity”"></a><strong>3.6、“-gcnewcapacity”</strong></h3><p>年轻代内存容量统计。<br>统计指标名称与详细描述见表6。</p>
<p>表6</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>年轻代最小内存容量</td>
</tr>
<tr>
<td>NGCMX</td>
<td>年轻代最大内存容量</td>
</tr>
<tr>
<td>NGC</td>
<td>当前年轻代内存容量</td>
</tr>
<tr>
<td>S0CMX</td>
<td>Survivor区0最大内存容量</td>
</tr>
<tr>
<td>S0C</td>
<td>当前Survivor区0内存容量</td>
</tr>
<tr>
<td>S1CMX</td>
<td>Survivor区1最大内存容量</td>
</tr>
<tr>
<td>S1C</td>
<td>当前Survivor区1内存容量</td>
</tr>
<tr>
<td>ECMX</td>
<td>Eden区最大内存容量</td>
</tr>
<tr>
<td>EC</td>
<td>当前Eden区内存容量</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
</tbody></table>
<h3 id="3-7、“-gcold”"><a href="#3-7、“-gcold”" class="headerlink" title="3.7、“-gcold”"></a><strong>3.7、“-gcold”</strong></h3><p>老年代和永久代行为统计。<br>统计指标名称与详细描述见表7。</p>
<p>表7</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>当前永久代内存容量</td>
</tr>
<tr>
<td>PU</td>
<td>永久代使用内存</td>
</tr>
<tr>
<td>OC</td>
<td>当前老年代内存容量</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用内存</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
<tr>
<td>FGCT</td>
<td>Full GC耗费时间</td>
</tr>
<tr>
<td>GCT</td>
<td>GC耗费总时间</td>
</tr>
</tbody></table>
<h3 id="3-8、“-gcoldcapacity”"><a href="#3-8、“-gcoldcapacity”" class="headerlink" title="3.8、“-gcoldcapacity”"></a><strong>3.8、“-gcoldcapacity”</strong></h3><p>老年代内存容量统计。<br>统计指标名称与详细描述见表8。</p>
<p>表8</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>OGCMN</td>
<td>老年代最小内存容量</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大内存容量</td>
</tr>
<tr>
<td>OGC</td>
<td>当前老年代内存容量</td>
</tr>
<tr>
<td>OC</td>
<td>当前老年代内存容量，跟“OGC”一致</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
<tr>
<td>FGCT</td>
<td>Full GC耗费时间</td>
</tr>
<tr>
<td>GCT</td>
<td>GC耗费总时间</td>
</tr>
</tbody></table>
<h3 id="3-9、“-gcpermcapacity”"><a href="#3-9、“-gcpermcapacity”" class="headerlink" title="3.9、“-gcpermcapacity”"></a><strong>3.9、“-gcpermcapacity”</strong></h3><p>永久代内存容量统计。<br>统计指标名称与详细描述见表9。</p>
<p>表9</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>PGCMN</td>
<td>永久代最小内存容量</td>
</tr>
<tr>
<td>PGCMX</td>
<td>永久代最大内存容量</td>
</tr>
<tr>
<td>PGC</td>
<td>当前永久代内存容量</td>
</tr>
<tr>
<td>PC</td>
<td>当前永久代内存容量，跟“PGC”一致</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
<tr>
<td>FGCT</td>
<td>Full GC耗费时间</td>
</tr>
<tr>
<td>GCT</td>
<td>GC耗费总时间</td>
</tr>
</tbody></table>
<h3 id="3-10、“-gcutil”"><a href="#3-10、“-gcutil”" class="headerlink" title="3.10、“-gcutil”"></a><strong>3.10、“-gcutil”</strong></h3><p>Java堆垃圾回收行为统计，注意跟“3.3、‘-gc’”小节进行类比。<br>统计指标名称与详细描述见表10。</p>
<p>表10</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0</td>
<td>Survivor区0使用内存百分比</td>
</tr>
<tr>
<td>S1</td>
<td>Survivor区1使用内存百分比</td>
</tr>
<tr>
<td>E</td>
<td>Eden区使用内存百分比</td>
</tr>
<tr>
<td>O</td>
<td>老年代使用内存百分比</td>
</tr>
<tr>
<td>P</td>
<td>永久代使用内存百分比</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代GC事件数量</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代GC耗费时间</td>
</tr>
<tr>
<td>FGC</td>
<td>Full GC事件数量</td>
</tr>
<tr>
<td>FGCT</td>
<td>Full GC耗费时间</td>
</tr>
<tr>
<td>GCT</td>
<td>GC耗费总时间</td>
</tr>
</tbody></table>
<h3 id="3-11、“-gccause”"><a href="#3-11、“-gccause”" class="headerlink" title="3.11、“-gccause”"></a><strong>3.11、“-gccause”</strong></h3><p>除了“LGCC”和“GCC”两个统计指标外，跟“3.10、‘-gcutil’”小节一致。<br>上述额外的两个统计指标名称与详细描述见表11。</p>
<p>表11</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>LGCC</td>
<td>最近一次GC原因，比如“Allocation Failure”</td>
</tr>
<tr>
<td>GCC</td>
<td>当前GC原因，比如“Allocation Failure”</td>
</tr>
</tbody></table>
<h3 id="3-12、“-printcompilation”"><a href="#3-12、“-printcompilation”" class="headerlink" title="3.12、“-printcompilation”"></a><strong>3.12、“-printcompilation”</strong></h3><p>HotSpot方法编译行为统计。<br>统计指标名称与详细描述见表12。</p>
<p>表12</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>由最近一次编译方法触发的成功编译任务数量</td>
</tr>
<tr>
<td>Size</td>
<td>最近一次编译方法的字节码字节大小</td>
</tr>
<tr>
<td>Type</td>
<td>最近一次编译任务对应的编译类型</td>
</tr>
<tr>
<td>Method</td>
<td>指代最近一次编译方法对应的的类名和方法名</td>
</tr>
</tbody></table>
<h2 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a><strong>四、举例说明</strong></h2><h3 id="4-1、理论值"><a href="#4-1、理论值" class="headerlink" title="4.1、理论值"></a><strong>4.1、理论值</strong></h3><p>有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        Thread.sleep(10 * 60 * 1000);</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，执行<code>java -Xms100M -Xmx1000M -XX:NewSize=20M -XX:MaxNewSize=400M -XX:SurvivorRatio=8 -XX:PermSize=20M -XX:MaxPermSize=100M Example1</code>命令，根据这些虚拟机参数的含义，上面提及到的一些统计指标与相应值可描述如表13。</p>
<p>表13</p>
<table>
<thead>
<tr>
<th>统计指标名称</th>
<th>相应值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>20*1024&#x3D;20480</td>
<td>由“-XX:NewSize&#x3D;20M”参数直接指定</td>
</tr>
<tr>
<td>NGCMX</td>
<td>400*1024&#x3D;409600</td>
<td>由“-XX:MaxNewSize&#x3D;400M”参数直接指定</td>
</tr>
<tr>
<td>OGCMN</td>
<td>(100-20)*1024&#x3D;81920</td>
<td>作者并不清楚：此种情形下，计算老年代最小内存容量的详细公式，最好参见JDK源代码</td>
</tr>
<tr>
<td>OGCMX</td>
<td>(1000-400)*1024&#x3D;614400</td>
<td>作者并不清楚：此种情形下，计算老年代最大内存容量的详细公式，最好参见JDK源代码</td>
</tr>
<tr>
<td>S0CMX</td>
<td>400&#42;1&#x2F;(8+1+1)&#42;1024&#x3D;40960</td>
<td>根据“-XX:MaxNewSize&#x3D;400M”和“-XX:SurvivorRatio&#x3D;8”参数直接计算可得</td>
</tr>
<tr>
<td>S1CMX</td>
<td>400&#42;1&#x2F;(8+1+1)&#42;1024&#x3D;40960</td>
<td>根据“-XX:MaxNewSize&#x3D;400M”和“-XX:SurvivorRatio&#x3D;8”参数直接计算可得</td>
</tr>
<tr>
<td>ECMX</td>
<td>400&#42;8&#x2F;(8+1+1)&#42;1024&#x3D;327680</td>
<td>根据“-XX:MaxNewSize&#x3D;400M”和“-XX:SurvivorRatio&#x3D;8”参数直接计算可得</td>
</tr>
<tr>
<td>PGCMN</td>
<td>20*1024&#x3D;20480</td>
<td>由“-XX:PermSize&#x3D;20M”参数直接指定</td>
</tr>
<tr>
<td>PGCMX</td>
<td>100*1024&#x3D;102400</td>
<td>由“-XX:MaxPermSize&#x3D;100M”参数直接指定</td>
</tr>
</tbody></table>
<h3 id="4-2、验证值"><a href="#4-2、验证值" class="headerlink" title="4.2、验证值"></a><strong>4.2、验证值</strong></h3><p>假设上一小节中的虚拟机进程ID为“22075”，接下来作几个验证。<br><strong>1、验证1</strong><br>执行<code>jstat -gccapacity -h 3 -t 22075 1000 5</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timestamp        NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC </span><br><span class="line">           33.0  20480.0 409600.0  20480.0 2048.0 2048.0  16384.0    81920.0   614400.0    81920.0    81920.0  20480.0 102400.0  20480.0  20480.0      0     0</span><br><span class="line">           34.0  20480.0 409600.0  20480.0 2048.0 2048.0  16384.0    81920.0   614400.0    81920.0    81920.0  20480.0 102400.0  20480.0  20480.0      0     0</span><br><span class="line">           35.0  20480.0 409600.0  20480.0 2048.0 2048.0  16384.0    81920.0   614400.0    81920.0    81920.0  20480.0 102400.0  20480.0  20480.0      0     0</span><br><span class="line">Timestamp        NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC </span><br><span class="line">           36.0  20480.0 409600.0  20480.0 2048.0 2048.0  16384.0    81920.0   614400.0    81920.0    81920.0  20480.0 102400.0  20480.0  20480.0      0     0</span><br><span class="line">           37.0  20480.0 409600.0  20480.0 2048.0 2048.0  16384.0    81920.0   614400.0    81920.0    81920.0  20480.0 102400.0  20480.0  20480.0      0     0</span><br></pre></td></tr></table></figure>
<p><strong>2、验证2</strong><br>执行<code>jstat -gcnewcapacity -h 3 -t 22075 1000 5</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timestamp         NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">          148.5    20480.0   409600.0    20480.0  40960.0   2048.0  40960.0   2048.0   327680.0    16384.0     0     0</span><br><span class="line">          149.5    20480.0   409600.0    20480.0  40960.0   2048.0  40960.0   2048.0   327680.0    16384.0     0     0</span><br><span class="line">          150.5    20480.0   409600.0    20480.0  40960.0   2048.0  40960.0   2048.0   327680.0    16384.0     0     0</span><br><span class="line">Timestamp         NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">          151.5    20480.0   409600.0    20480.0  40960.0   2048.0  40960.0   2048.0   327680.0    16384.0     0     0</span><br><span class="line">          152.5    20480.0   409600.0    20480.0  40960.0   2048.0  40960.0   2048.0   327680.0    16384.0     0     0</span><br></pre></td></tr></table></figure>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a><strong>五、其他</strong></h2><h3 id="5-1、-Xmx-NGCMX-OGCMX"><a href="#5-1、-Xmx-NGCMX-OGCMX" class="headerlink" title="5.1、-Xmx&#x3D;NGCMX+OGCMX"></a><strong>5.1、-Xmx&#x3D;NGCMX+OGCMX</strong></h3><p>当未显式设置“-Xmx”值时，可通过“NGCMX+OGCMX”获知实际的“-Xmx”值。</p>
<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html
[2]man jstat
[3]http://stackoverflow.com/questions/11253285/jstat-difference-between-ogc-oc-pgc-pc
[4]http://stackoverflow.com/questions/25887715/java-gc-how-is-desired-survivor-size-calculated
[5]http://eyesmore.iteye.com/blog/1530996
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>killall命令</title>
    <url>/blog/2016/04/30/killall%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killall -s KILL -I -v command-name</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>杀掉所有匹配的进程。具体是：</p>
<ol>
<li>在进程中有个“命令+参数”属性，它表示该进程由执行该“命令+参数”获得，它对应于“ps”命令中的“args”指示符</li>
<li>killall会尝试将“command-name”与进程“命令+参数”属性中的“简化后的命令部分内容”进行匹配，匹配的进程将被杀掉。“简化后的命令部分内容”是指：如果“命令”的内容中含有“&#x2F;”字符，那么简化后的命令部分内容是最后一个“&#x2F;”字符后的内容；否则，简化后的命令部分内容就是“命令”内容本身。</li>
</ol>
<p>比如如果有个进程的命令内容为“&#x2F;opt&#x2F;google&#x2F;chrome&#x2F;chrome”，那么<code>killall -s KILL -I -v chrome</code>能够杀死该进程，<code>killall -s KILL -I -v rome</code>不能杀死该进程；有个进程的命令内容为“gnome-pty-helper”，那么<code>killall -s KILL -I -v gnome-pty-helper</code>能够杀死该进程，<code>killall -s KILL -I -v helper</code>不能杀死该进程。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“-s KILL”：killall命令默认发送“TERM”信号，这里指定发送“KILL”信号。killall命令采用的信号机制跟kill命令一致，可以参见kill命令的信号说明。<br>“-I”：匹配时忽略大小写。<br>“-v”：打印日志信息。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>在一个bash进程中，执行<code>killall -s KILL -I -v bash</code>命令，企图杀死所有bash进程，那么该bash进程也会被杀掉，这很有可能导致<code>killall -s KILL -I -v bash</code>命令执行到中途就被退出，不能完全达到目标。因而，如果想杀死bash进程，还是应该发送“TERM”信号。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>kill命令</title>
    <url>/blog/2016/04/30/kill%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -KILL PID</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>发送“KILL”信号通知“PID”对应的进程直接关闭（无需做关闭前处理工作），这个信号不能被对应的进程抓住和忽略。<br>kill命令默认是发送“TERM”信号，这个信号也是通知对应的进程关闭，但是对应的进程可以抓住该信号，并进行一些关闭前处理工作，最后由自身决定是否关闭，因而有可能最后忽略该信号。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>跟“-KILL”信号等价的有“-9”和“-SIGKILL”，但是在不同平台上，有可能“-9”信号对应的是不同的信号，因而为了通用性，尽量不用“-9”这种数字形式来表示信号，而用“-KILL”或者“-SIGKILL”这种形式。<br>同理的，跟“-TERM”信号等价的有“-15”和“-SIGTERM”。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>less命令</title>
    <url>/blog/2017/01/04/less%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less [FILE | -]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与操作"><a href="#二、含义与操作" class="headerlink" title="二、含义与操作"></a><strong>二、含义与操作</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>分屏查看文件或者基本输入的内容。</p>
<h3 id="2-2、操作"><a href="#2-2、操作" class="headerlink" title="2.2、操作"></a><strong>2.2、操作</strong></h3><p>接下来介绍一些“less命令执行过程中”的操作。<br>“b”：后退一页（助记，backward）。<br>“f”：前进一页（助记，forward）。<br>“g”：跳到指定行，默认是文件起始位置，比如“100g”是跳到第100行。<br>“G”：跳到指定行，默认是文件终点位置，比如“100G”是跳到第100行。<br>“&#x2F;pattern”：从前往后搜索，“pattern”是一个正则表达式。<br>“?pattern”：从后往前搜索，“pattern”是一个正则表达式。<br>“n”：重复前一个搜索。<br>“N”：反方向重复前一个搜索。<br>“q”：退出。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>完全可以用<code>less</code>命令来代替<code>more</code>命令。</p>
<br/>
参考文献：
[1]man less
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ln命令</title>
    <url>/blog/2016/12/30/ln%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln [-s] TARGET LINK_NAME</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>创建链接到“TARGET”的“软符号链接文件”或者“硬符号链接文件”。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-s”：有“-s”选项，创建链接到“TARGET”的“软符号链接文件”，“软符号链接文件”文件名为“LINK_NAME”；否则，创建链接到“TARGET”的“硬符号链接文件”，“硬符号链接文件”文件名为“LINK_NAME”。</p>
<p>备注：<br>关于“软符号链接文件”和“硬符号链接文件”，可见文章<a href="/blog/2016/12/21/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8B3%E7%A7%8D%E5%8C%BA%E5%9D%97%E4%B8%8E4%E7%B1%BB%E6%96%87%E4%BB%B6/" title="Linux文件系统之3种区块与4类文件">《Linux文件系统之3种区块与4类文件》</a>。</p>
<br/>
参考文献：
[1]man ln
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>locale命令</title>
    <url>/blog/2016/03/09/locale%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、“locale语境”下概念介绍"><a href="#一、“locale语境”下概念介绍" class="headerlink" title="一、“locale语境”下概念介绍"></a><strong>一、“locale语境”下概念介绍</strong></h2><p>首先进行“locale语境”下的概念介绍。</p>
<h3 id="1-1、locale名称"><a href="#1-1、locale名称" class="headerlink" title="1.1、locale名称"></a><strong>1.1、locale名称</strong></h3><p>如zh_CN.utf8，zh_CN.gbk，zh_CN.gb2312等。</p>
<h3 id="1-2、locale相关环境变量"><a href="#1-2、locale相关环境变量" class="headerlink" title="1.2、locale相关环境变量"></a><strong>1.2、locale相关环境变量</strong></h3><p>如LC_CTYPE，LC_TIME，LC_NUMERIC等，某个“locale相关环境变量”控制某个类别的设置。比如“LC_TIME”控制日期和时间类别的设置。</p>
<h2 id="二、“locale相关环境变量”介绍"><a href="#二、“locale相关环境变量”介绍" class="headerlink" title="二、“locale相关环境变量”介绍"></a><strong>二、“locale相关环境变量”介绍</strong></h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LC_CTYPE</td>
<td>使用所指定locale的字符集</td>
</tr>
<tr>
<td>LC_COLLATE</td>
<td>使用所指定locale的排序规则</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>使用所指定locale的日期与时间格式</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>使用所指定locale的数字格式</td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>使用所指定locale的货币格式</td>
</tr>
<tr>
<td>LC_MESSAGES</td>
<td>使用所指定locale的响应与信息</td>
</tr>
<tr>
<td>LC_PAPER</td>
<td>使用所指定locale的的纸张大小</td>
</tr>
<tr>
<td>LC_NAME</td>
<td>使用所指定locale的称呼</td>
</tr>
<tr>
<td>LC_ADDRESS</td>
<td>使用所指定locale的地址格式</td>
</tr>
<tr>
<td>LC_TELEPHONE</td>
<td>使用所指定locale的电话格式</td>
</tr>
<tr>
<td>LC_MEASUREMENT</td>
<td>使用所指定locale的度量单位</td>
</tr>
<tr>
<td>LC_IDENTIFICATION</td>
<td>使用所指定locale的元数据信息</td>
</tr>
</tbody></table>
<h2 id="三、locale命令使用用法介绍"><a href="#三、locale命令使用用法介绍" class="headerlink" title="三、locale命令使用用法介绍"></a><strong>三、locale命令使用用法介绍</strong></h2><h3 id="3-1、locale"><a href="#3-1、locale" class="headerlink" title="3.1、locale"></a><strong>3.1、locale</strong></h3><p><code>locale</code>：表示列出当前“locale相关环境变量”的配置信息，比如如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160309-0-1.png"></p>
<h3 id="3-2、locale-a"><a href="#3-2、locale-a" class="headerlink" title="3.2、locale -a"></a><strong>3.2、locale -a</strong></h3><p><code>locale -a</code>：表示列出所有支持的“locale”名称，比如如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160309-0-2.png"></p>
<h3 id="3-3、locale-m"><a href="#3-3、locale-m" class="headerlink" title="3.3、locale -m"></a><strong>3.3、locale -m</strong></h3><p><code>locale -m</code>：表示列出所有支持的“代码页”名称，比如如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160309-0-3.png"></p>
<h3 id="3-4、locale-k-locale相关环境变量"><a href="#3-4、locale-k-locale相关环境变量" class="headerlink" title="3.4、locale -k locale相关环境变量"></a><strong>3.4、locale -k locale相关环境变量</strong></h3><p><code>locale -k locale相关环境变量</code>：列出“locale相关环境变量”所指代配置类别下所有条目的名称和值。如图4和图5所示。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160309-0-4.png"></p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160309-0-5.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man locale</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ls命令</title>
    <url>/blog/2016/10/18/ls%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -abFhltr --color=auto [FILE]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>列出文件或者目录的信息。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><h4 id="2-2-1、“a”"><a href="#2-2-1、“a”" class="headerlink" title="2.2.1、“a”"></a><strong>2.2.1、“a”</strong></h4><p>列出以“.”开头的隐藏文件。</p>
<h4 id="2-2-2、“b”"><a href="#2-2-2、“b”" class="headerlink" title="2.2.2、“b”"></a><strong>2.2.2、“b”</strong></h4><p>对于非图形字符加上反义字符，比如“hello\ world”中对空格字符加了反义字符“\”。</p>
<h4 id="2-2-3、“F”"><a href="#2-2-3、“F”" class="headerlink" title="2.2.3、“F”"></a><strong>2.2.3、“F”</strong></h4><p>显示指示符。指示符含义介绍如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>指示符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>@</td>
<td>表示软链接文件或者具有扩展属性</td>
</tr>
<tr>
<td>*</td>
<td>表示可执行文件</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>表示socket</td>
</tr>
<tr>
<td>&#124;</td>
<td>表示命名管道</td>
</tr>
<tr>
<td>&gt;</td>
<td>表示door</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>表示目录</td>
</tr>
</tbody></table>
<h4 id="2-2-4、“h”"><a href="#2-2-4、“h”" class="headerlink" title="2.2.4、“h”"></a><strong>2.2.4、“h”</strong></h4><p>以可视化的形式列出文件和目录的大小。</p>
<h4 id="2-2-5、“l”"><a href="#2-2-5、“l”" class="headerlink" title="2.2.5、“l”"></a><strong>2.2.5、“l”</strong></h4><p>详细展现模式，共有7列数据来展现文件信息。对这7列数据的描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>第一列</td>
<td>代表这个文件的类型和权限配置。共有10个字符，第1个字符表示文件类型，描述见表3；接下来的9个字符以3个为一组，分别配置了“文件所有者，文件所属组组用户，其他用户”对该文件所拥有的权限</td>
</tr>
<tr>
<td>第二列</td>
<td>表示文件的inode节点上的硬链接计数（一个目录至少有2个硬链接计数，因为目录里面有一个“..”文件，再加上自身的1个硬链接，最后的硬链接计数为2）</td>
</tr>
<tr>
<td>第三列</td>
<td>表示文件的所有者</td>
</tr>
<tr>
<td>第四列</td>
<td>表示文件的所属组</td>
</tr>
<tr>
<td>第五列</td>
<td>表示文件的大小。对于“一般文件”，显示的是“使用大小”；对于“目录文件”，并没有累加统计该目录文件下的子文件的大小，而是显示该目录文件自身的“占用大小”（关于文件的“使用大小”和“占用大小”可见<a href="/blog/2016/10/18/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E2%80%9C%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D%E5%92%8C%E2%80%9C%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D/" title="Ext文件系统中，文件的“占用大小”和“使用大小”">《Ext文件系统中，文件的“占用大小”和“使用大小”》</a>）</td>
</tr>
<tr>
<td>第六列</td>
<td>表示文件的“mtime”值（即最后修改block节点中内容的时间）</td>
</tr>
<tr>
<td>第七列</td>
<td>表示文件名</td>
</tr>
</tbody></table>
<p>表3</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>表示目录</td>
</tr>
<tr>
<td>-</td>
<td>表示文件</td>
</tr>
<tr>
<td>l</td>
<td>表示链接文件</td>
</tr>
<tr>
<td>b</td>
<td>表示设备文件里面的可供存储的接口设备</td>
</tr>
<tr>
<td>c</td>
<td>表示设备文件里面的串行端口设备</td>
</tr>
<tr>
<td>s</td>
<td>表示套接字（sockets）数据接口文件</td>
</tr>
<tr>
<td>p</td>
<td>表示管道文件</td>
</tr>
</tbody></table>
<h4 id="2-2-6、“t”"><a href="#2-2-6、“t”" class="headerlink" title="2.2.6、“t”"></a><strong>2.2.6、“t”</strong></h4><p>根据“mtime”值从小到大排序。</p>
<h4 id="2-2-7、“r”"><a href="#2-2-7、“r”" class="headerlink" title="2.2.7、“r”"></a><strong>2.2.7、“r”</strong></h4><p>反向排序。</p>
<h4 id="2-2-8、“–color-auto”"><a href="#2-2-8、“–color-auto”" class="headerlink" title="2.2.8、“–color&#x3D;auto”"></a><strong>2.2.8、“–color&#x3D;auto”</strong></h4><p>展现文件和目录的颜色。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>有如下现象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不加“h”选项时，假定文件大小为“N”，加上“h”选项时，假定相同文件大小为“M(k)”，“M(k)”值并不能通过“N/1024”得到</span><br></pre></td></tr></table></figure>
<p>比如分别执行<code>ls -l file.md</code>和<code>ls -lh file.md</code>命令，有如下两个执行结果，“35(k)”并不能通过“34998&#x2F;1024”得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 dsl dsl 34998 10月 17 21:32 file.md</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 dsl dsl 35K 10月 17 21:32 file.md</span><br></pre></td></tr></table></figure>
<p>个人推测原因如下：<code>ls</code>命令统计文件大小是分段统计的（“分段”可能跟“inode&#x2F;block”体系中的block节点集合相关），如果有加上“h”选项，在分段统计的过程中，就会发生单位的转化（一个block节点集合中，任何一个block节点都有可能未被填满，而不仅仅只是最后一个block节点），误差的累积导致上述现象。</p>
<br/>
参考文献：
[1]man ls
[2]http://stackoverflow.com/questions/17319940/how-to-escape-a-pipe-char-in-a-code-statement-in-a-markdown-table
[3]https://www.reddit.com/r/bugs/comments/3my1yt/cannot_escape_pipe_character_in_tables/
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>luit命令</title>
    <url>/blog/2016/06/11/luit%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">luit -encoding &#x27;编码方案&#x27; program [args]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>由<a href="/blog/2016/06/07/%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="终端模拟器中执行命令出现乱码问题解决">《终端模拟器中执行命令出现乱码问题解决》</a>可知，在终端模拟器中执行命令，通信过程示意图如图1或者图2所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160611-0-1.png"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160611-0-2.png"></p>
<p>执行命令时，使用终端模拟器配置的编码方案，对原命令字符串进行编码，将得到的字节流传递给“命令执行单元” ；展现命令执行结果时，获取字节流形式的命令执行结果，使用终端模拟器配置的编码方案，对其进行解码，得到字符串形式的命令执行结果。</p>
<p>通过使用<code>luit -encoding &#39;编码方案&#39; program [args]</code>命令，现在在终端模拟器中执行命令，通信过程示意图如图3或者图4所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160611-0-3.png"></p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160611-0-4.png"></p>
<p>此时执行命令时，使用终端模拟器配置的编码方案，对原命令字符串进行编码，得到字节流，再使用“UTF-8”编码方案进行解码得到字符流，最后使用“luit”命令中指定的编码方案（比如‘luit -encoding GBK program [args]’中的‘GBK’）进行编码，将得到的字节流传递给“命令执行单元” ；展现命令执行结果时，获取字节流形式的命令执行结果，使用“luit”命令中指定的编码方案进行解码得到字符流，再使用“UTF-8”编码方案进行编码得到字节流，最后对得到的字节流使用终端模拟器配置的编码方案进行解码，得到字符串形式的命令执行结果。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-encoding 编码方案”：指定与“UTF-8”编码方案互转的编码方案，即从“UTF-8”编码方案转换到“该编码方案”或者从“该编码方案”转换到“UTF-8”编码方案<br>“program [args]”：执行命令</p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><h3 id="3-1、实验1"><a href="#3-1、实验1" class="headerlink" title="3.1、实验1"></a><strong>3.1、实验1</strong></h3><p>现有一个名为“你好吗.txt”的文件，相应于该文件名的存储内容存储的是使用“GBK”编码方案编码得到的字节流。<br>设置locale系列环境变量配置值为“zh_CN.gbk”，终端模拟器编码方案为“UTF-8”，分别执行<code>ls</code>和<code>luit -encoding gbk ls</code>命令，得到如表1所示结果。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值</th>
<th>终端模拟器（实验了Gnome Terminal）编码方案</th>
<th>ls命令执行结果截图</th>
<th><code>luit -encoding gbk ls</code>命令执行结果截图</th>
</tr>
</thead>
<tbody><tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160611-0-5.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160611-0-6.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h3 id="3-2、实验2"><a href="#3-2、实验2" class="headerlink" title="3.2、实验2"></a><strong>3.2、实验2</strong></h3><p>现有一个名为“a.txt”的文件，存储有内容“你好吗？”，使用的编码格式为“UTF-8”。<br>设置locale系列环境变量配置值为“zh_CN.gbk”，终端模拟器编码方案为“UTF-8”，分别执行<code>vim a.txt</code>和<code>luit -encoding gbk vim a.txt（在VIM环境中，需要执行&#39;:e ++enc=utf8&#39;）</code>命令，得到如表2所示结果。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值</th>
<th>终端模拟器（实验了Gnome Terminal）编码方案</th>
<th>“vim a.txt”命令执行结果截图</th>
<th>VIM环境中执行“:e ++enc&#x3D;utf8”结果截图</th>
<th>“luit -encoding gbk vim a.txt”命令&amp;&amp;“:e ++enc&#x3D;utf8”结果截图</th>
</tr>
</thead>
<tbody><tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160611-0-7.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160611-0-8.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160611-0-9.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h3 id="3-3、实验3"><a href="#3-3、实验3" class="headerlink" title="3.3、实验3"></a><strong>3.3、实验3</strong></h3><p>现有一个名为“a.txt”的文件，存储有内容“你好吗？”，使用的编码格式为“GBK”。<br>设置locale系列环境变量配置值为“zh_CN.gbk”，终端模拟器编码方案为“UTF-8”，分别执行<code>vim a.txt</code>和<code>luit -encoding gbk vim a.txt</code>命令，得到如表3所示结果。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值</th>
<th>终端模拟器（实验了Gnome Terminal）编码方案</th>
<th>“vim a.txt”命令执行结果截图</th>
<th>VIM环境中执行“:e ++enc&#x3D;gbk”结果截图</th>
<th>“luit -encoding gbk vim a.txt”命令结果截图</th>
</tr>
</thead>
<tbody><tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160611-0-10.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160611-0-11.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160611-0-12.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、常见应用形式"><a href="#4-1、常见应用形式" class="headerlink" title="4.1、常见应用形式"></a><strong>4.1、常见应用形式</strong></h3><p>“luit命令”较常见的一个应用形式是结合“ssh命令”使用，比如<code>luit -encoding gbk ssh myhost</code>。</p>
<h3 id="4-2、用到的脚本"><a href="#4-2、用到的脚本" class="headerlink" title="4.2、用到的脚本"></a><strong>4.2、用到的脚本</strong></h3><p>脚本1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">cd /home/dsl/tmp/shell</span><br><span class="line"></span><br><span class="line">export LC_ALL=$1</span><br><span class="line">export LANG=$1</span><br><span class="line">export LANGUAGE=$1</span><br><span class="line"></span><br><span class="line">locale</span><br><span class="line"></span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line"></span><br><span class="line">luit -encoding gbk ls</span><br></pre></td></tr></table></figure>

<p>脚本2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">cd /home/dsl/tmp/shell</span><br><span class="line"></span><br><span class="line">export LC_ALL=$1</span><br><span class="line">export LANG=$1</span><br><span class="line">export LANGUAGE=$1</span><br><span class="line"></span><br><span class="line">locale</span><br><span class="line"></span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line"></span><br><span class="line">luit -encoding gbk vim a.txt</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man luit</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>man机制</title>
    <url>/blog/2015/07/05/man%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>man机制是Linux上用于管理帮助文档的机制，使用man命令，查看某个主题的帮助文档信息。</p>
<p>使用man命令查看某个主题的帮助文档信息的时候，具体流程如下：</p>
<ol>
<li>从man机制设定的帮助文档存放目录获取该主题的帮助文档源数据，默认的目录是：“&#x2F;usr&#x2F;share&#x2F;man”，帮助文档源数据以gz压缩格式的形式进行保存</li>
<li>经过渲染</li>
<li>使用Pager程序进行输出的展示（在Ubuntu中，这个Pager程序就是less程序）</li>
</ol>
<p>man机制管理的帮助文档类型有9种：</p>
<ul>
<li>可执行程序或shell命令：<code>man 1 主题</code></li>
<li>系统调用（内核提供的函数）：<code>man 2 主题</code></li>
<li>库调用（程序库中的函数）：<code>man 3 主题</code></li>
<li>特殊文件（通常位于&#x2F;dev）：<code>man 4 主题</code></li>
<li>文件格式和规范，如“&#x2F;etc&#x2F;passwd”：<code>man 5 主题</code></li>
<li>游戏：<code>man 6 主题</code></li>
<li>杂项（包括宏包和规范）：<code>man 7 主题</code></li>
<li>系统管理命令（通常只针对root用户）：<code>man 8 主题</code></li>
<li>内核例程（非标准）：<code>man 9 主题</code></li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>默认的，使用<code>man 主题</code>，就相当于使用<code>man 1 主题</code></li>
<li><code>man -k 关键字</code>：查找命令名称和命令的简易说明中包含“关键字”的所有命令</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man man</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>mkdir命令</title>
    <url>/blog/2016/12/30/mkdir%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p DIRECTORY</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>创建目录。过程中目录存在也不报错，如果是层次目录结构，那么依次创建不存在的目录。</p>
<br/>
参考文献：
[1]man mkdir
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>more命令</title>
    <url>/blog/2017/01/04/more%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more [FILE | -]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与操作"><a href="#二、含义与操作" class="headerlink" title="二、含义与操作"></a><strong>二、含义与操作</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>分屏查看文件或者基本输入的内容。</p>
<h3 id="2-2、操作"><a href="#2-2、操作" class="headerlink" title="2.2、操作"></a><strong>2.2、操作</strong></h3><p>接下来介绍一些“more命令执行过程中”的操作。<br>“Enter键”：下一页内容。<br>“q”：退出。</p>
<br/>
参考文献：
[1]man more
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>mv命令</title>
    <url>/blog/2016/10/18/mv%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv --backup=numbered --strip-trailing-slashes SOURCE DEST</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><h4 id="2-1-1、含义1"><a href="#2-1-1、含义1" class="headerlink" title="2.1.1、含义1"></a><strong>2.1.1、含义1</strong></h4><p>移动SOURCE所表示的源文件到目的目录DEST：即DEST的最后一个符号是“&#x2F;”，该目录将作为源文件的父目录。这种情况下，只移动源文件的位置，而不改变文件名。</p>
<h4 id="2-1-2、含义2"><a href="#2-1-2、含义2" class="headerlink" title="2.1.2、含义2"></a><strong>2.1.2、含义2</strong></h4><p>移动SOURCE所表示的源文件，使该文件的最终路径是DEST：即DEST的最后一个符号不是“&#x2F;”，该DEST将作为源文件被移动之后最后的表示路径。这种情况下，既可以移动源文件的位置，也可以改变文件名。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“–backup&#x3D;numbered”：表示启用备份机制，在移动源文件的时候，如果在目的路径上已经存在同名的文件，不会删除同名文件，而是改变其名字。<br>“–strip-trailing-slashes”：如果SOURCE的最后一个符号是“&#x2F;”，那么去除掉它。需要注意的是，在SOURCE中最后的“&#x2F;”符号，本就是没有意义的。</p>
<br/>
参考文献：
[1]man mv
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqladmin命令</title>
    <url>/blog/2018/11/27/mysqladmin%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>mysqladmin命令用于管理MySQL服务端。</p>
<h2 id="一、flush-hosts"><a href="#一、flush-hosts" class="headerlink" title="一、flush-hosts"></a><strong>一、flush-hosts</strong></h2><p>问题描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.sql.SQLException: null,  message from server: &quot;Host &#x27;A&#x27; is blocked because of many connection errors; unblock with &#x27;mysqladmin flush-hosts&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>应用程序出现如上错误，服务器A由于建立过多MySQL连接而被相应MySQL服务端屏蔽。</p>
<p>在对应MySQL服务端上执行如下命令解决上述问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -h MySQL服务端地址 -P MySQL服务端地址端口 -u 用户名 -p密码 flush-hosts</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li>执行mysqladmin命令的MySQL用户须具有<code>RELOAD</code>权限</li>
</ul>
]]></content>
      <categories>
        <category>系统架构</category>
        <category>中间件</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>netstat命令</title>
    <url>/blog/2016/05/16/netstat%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>打印处于所有状态的Socket连接的信息。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p><strong>1、“-a”</strong><br>不加“-a”选项，表示不打印处于“LISTEN／LISTENING”状态的Socket连接的信息；加了“-a”选项，表示打印处于所有状态的Socket连接的信息，包括处于“LISTEN／LISTENING”状态的Socket连接。<br><strong>2、“-n”</strong><br>在打印“网络地址”，“端口”时，不需要解析成字符串形式，只需要以数字形式打印即可。<br><strong>3、“-p”</strong><br>加上该选项，表示打印拥有该Socket连接的本地进程的进程ID和进程名称。<font color='red'>需要注意的是，只有当前执行“netstat”命令的用户拥有对相关进程的相关权限时，进程ID和进程名称才会被打印出来。</font></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、Socket连接与“address-family”"><a href="#3-1、Socket连接与“address-family”" class="headerlink" title="3.1、Socket连接与“address family”"></a><strong>3.1、Socket连接与“address family”</strong></h3><p>“address family”包括有“inet，unix，ipx，ax25，netrom，ddp”等。“inet”这个“address family”中包括有“TCP，UDP，RAW”这3种协议。<br>一个Socket连接使用不同“address family”下的不同协议。</p>
<h3 id="3-2、Socket连接的状态"><a href="#3-2、Socket连接的状态" class="headerlink" title="3.2、Socket连接的状态"></a><strong>3.2、Socket连接的状态</strong></h3><p>当Socket连接使用“inet“这个“address family”时，Socket连接的状态有：“ESTABLISHED，SYN_SENT，SYN_RECV，FIN_WAIT1，FIN_WAIT2，TIME_WAIT，CLOSE，CLOSE_WAIT，LAST_ACK，LISTEN，CLOSING，UNKNOWN”。<br>当Socket连接使用“unix”这个“address family”时，Socket连接的状态有：“FREE，LISTENING，CONNECTING，CONNECTED，DISCONNECTING，空白，UNKNOWN”。</p>
<p><font color='red'>要注意跟TCP连接状态的区分。</font></p>
<p>备注：<br>一个处于“LISTEN／LISTENING”状态的Socket连接准确来说，其实不能被称为“连接”，因为还没有建立“Socket连接”。</p>
<h3 id="3-3、打印格式"><a href="#3-3、打印格式" class="headerlink" title="3.3、打印格式"></a><strong>3.3、打印格式</strong></h3><p>打印信息根据Socket连接使用的“address family”的不同而进行分类，常见的两个类别为：Active Internet connections（对应于“inet”这个“address family”）和Active UNIX domain Sockets（对应于“unix”这个“address family”）。</p>
<h4 id="3-3-1、Active-Internet-connections"><a href="#3-3-1、Active-Internet-connections" class="headerlink" title="3.3.1、Active Internet connections"></a><strong>3.3.1、Active Internet connections</strong></h4><p>本类别下，打印信息分为7列展示，介绍如表1所示。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Proto</td>
<td>Socket连接所使用的协议，即“tcp，udp，raw”这3种的其中一种</td>
</tr>
<tr>
<td>Recv-Q</td>
<td>Socket连接关联的本地进程（也即拥有该Socket连接的本地进程）未处理的字节数量</td>
</tr>
<tr>
<td>Send-Q</td>
<td>Socket连接关联的远端进程未确认是否处理完成的字节数量</td>
</tr>
<tr>
<td>Local Address</td>
<td>Socket连接关联的本地端的网络地址和端口号</td>
</tr>
<tr>
<td>Remote Address</td>
<td>Socket连接关联的远端的网络地址和端口号</td>
</tr>
<tr>
<td>State</td>
<td>Socket连接状态，可取值有：ESTABLISHED，SYN_SENT，SYN_RECV，FIN_WAIT1，FIN_WAIT2，TIME_WAIT，CLOSE，CLOSE_WAIT，LAST_ACK，LISTEN，CLOSING，UNKNOWN</td>
</tr>
<tr>
<td>PID&#x2F;Program name</td>
<td>Socket连接关联的本地进程（也即拥有该Socket连接的本地进程）的进程ID和进程名称</td>
</tr>
</tbody></table>
<h4 id="3-3-2、Active-UNIX-domain-Sockets"><a href="#3-3-2、Active-UNIX-domain-Sockets" class="headerlink" title="3.3.2、Active UNIX domain Sockets"></a><strong>3.3.2、Active UNIX domain Sockets</strong></h4><p>本类别下，打印信息分为8列，介绍如表2所示。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Proto</td>
<td>一般为“unix”</td>
</tr>
<tr>
<td>RefCnt</td>
<td>跟该Socket连接关联的进程的数量</td>
</tr>
<tr>
<td>Flags</td>
<td>可取值为：ACC，W，N</td>
</tr>
<tr>
<td>Type</td>
<td>Socket连接类型，可取值有：SOCK_DGRAM，SOCK_STREAM，SOCK_RAW，SOCK_RDM，SOCK_SEQPACKET，SOCK_PACKET，UNKNOWN</td>
</tr>
<tr>
<td>State</td>
<td>Socket连接状态，可取值有：FREE，LISTENING，CONNECTING，CONNECTED，DISCONNECTING，空白，UNKNOWN</td>
</tr>
<tr>
<td>I-Node</td>
<td>Socket连接相对应文件的Inode</td>
</tr>
<tr>
<td>PID&#x2F;Program name</td>
<td>拥有该Socket连接的本地进程的进程ID和进程名称</td>
</tr>
<tr>
<td>Path</td>
<td>Socket连接关联的进程对应的程序的路径</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man netstat</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>od命令</title>
    <url>/blog/2016/10/20/od%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">od -A d -t x1cz -v -w10 FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>以二进制（八进制，十六进制）形式查看文件内容。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-A d”：表示以10进制的形式展示每行的首字节位移。<br>“-t x1cz”：其中“x1”表示以1个字节为1组，每组以16进制展示。其中“c”表示以ASCII字符的形式展示每个字节，当遇到ASCII中的控制字符，以“\t，\r，\n”等形式展示；不能以ASCII字符的形式展示的字节以3位八进制数展示。“z”表示在每行后面打印该行字节对应的可打印字符。<br>“-v”：表示即便有多行数据完全相同，也不以“*”来代替重复行的数据，而是将每行数据都打印出来。<br>“-w10”：表示每行展示10个字节。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p><code>hexdump(hd)</code>命令也可以实现类似的功能，但是<code>od</code>命令符合POSIX规范，更加标准通用化。</p>
<br/>
参考文献：
[1]man od
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ps命令</title>
    <url>/blog/2016/05/07/ps%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><p>有两种常用用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -o pid -o ppid -o start_time -o s -o tname -o args --sort=start_time,pid -e</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -o pid -o ppid -o start_time -o s -o ruser -o rgroup -o euser -o egroup -o tname -o args -p PID</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>1、第一种用法的含义<br>查询所有的进程，需要显示的列有“pid，ppid，start_time，s，tname，args”，先根据“start_time”列升序排序，再根据“pid”列升序排序。<br>2、第二种用法的含义<br>根据进程ID（即PID）查询某个进程的详情，需要显示的列有“pid，ppid，start_time，s，ruser，rgroup，euser，egroup，tname，args”。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“-o 列特征码”：表示在最终的结果中显示“列特征码”对应的列。<br>“–sort 列特征码组合”：表示根据列特征码组合，对最终显示结果进行排序。<br>“-e”：表示列出所有进程。<br>“-p PID”：表示只列出进程ID为“PID”的进程。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、使用“ps”命令的目标与选择"><a href="#3-1、使用“ps”命令的目标与选择" class="headerlink" title="3.1、使用“ps”命令的目标与选择"></a><strong>3.1、使用“ps”命令的目标与选择</strong></h3><h4 id="3-1-1、期望的关于“ps”命令的目标"><a href="#3-1-1、期望的关于“ps”命令的目标" class="headerlink" title="3.1.1、期望的关于“ps”命令的目标"></a><strong>3.1.1、期望的关于“ps”命令的目标</strong></h4><p>能够列出所有的进程，只列出自己所选定的几列的信息，能够根据进程创建时间和进程ID升序排序，能够查询已知进程ID对应进程的详细情况。</p>
<h4 id="3-1-2、具体选择"><a href="#3-1-2、具体选择" class="headerlink" title="3.1.2、具体选择"></a><strong>3.1.2、具体选择</strong></h4><p>“ps”命令有好几套实现，在具体选择的过程中，要注意使用标准实现方案。<br>关于“列出所有进程”的标准做法为：<code>ps -e</code>。<br>关于“只列出自己所选定的几列的信息”的标准做法：<code>[-o keyword]+</code>(表示1到多个这样的组合，其中“keyword”来自于“man ps”页的“STANDARD FORMAT SPECIFIERS”小节)<br>关于“能够根据进程创建时间和进程ID升序排序”的标准做法：<code>--sort=keyword</code>（“keyword”跟上面一样，同样来自于“man ps”页的“STANDARD FORMAT SPECIFIERS”小节)，如果需要先根据进程创建时间，再根据进程ID升序排序，那么就是“–sort&#x3D;start_time,pid”。<br>关于“能够查询已知进程ID对应进程的详细情况”的标准做法：<code>-p PID</code>。</p>
<h3 id="3-2、另外一些概念介绍"><a href="#3-2、另外一些概念介绍" class="headerlink" title="3.2、另外一些概念介绍"></a><strong>3.2、另外一些概念介绍</strong></h3><h4 id="3-2-1、什么是“session-leaders”"><a href="#3-2-1、什么是“session-leaders”" class="headerlink" title="3.2.1、什么是“session leaders”"></a><strong>3.2.1、什么是“session leaders”</strong></h4><p>In Linux, every process has several IDs associated with it, including:</p>
<ol>
<li>Process ID (PID)<br>This is an arbitrary number identifying the process. Every process has a unique ID, but after the process exits and the parent process has retrieved the exit status, the process ID is freed to be reused by a new process.</li>
<li>Parent Process ID (PPID)<br>This is just the PID of the process that started the process in question.</li>
<li>Process Group ID (PGID)<br>This is just the PID of the process group leader. If PID &#x3D;&#x3D; PGID, then this process is a process group leader.</li>
<li>Session ID (SID)<br>This is just the PID of the session leader. If PID &#x3D;&#x3D; SID, then this process is a session leader.</li>
</ol>
<p>Sessions and process groups are just ways to treat a number of related processes as a unit. All the members of a process group always belong to the same session, but a session may have multiple process groups.<br>Normally, a shell will be a session leader, and every pipeline executed by that shell will be a process group. This is to make it easy to kill the children of a shell when it exits. (See exit(3) for the gory details.)<br>I don’t think there is a special term for a member of a session or process group that isn’t the leader.</p>
<h4 id="3-2-2、进程的“cpu”列信息的含义"><a href="#3-2-2、进程的“cpu”列信息的含义" class="headerlink" title="3.2.2、进程的“cpu”列信息的含义"></a><strong>3.2.2、进程的“cpu”列信息的含义</strong></h4><p>cpu utilization of the process in “##.#” format.Currently, it is the CPU time used divided by the time the process has been running(cputime&#x2F;realtime ratio), expressed as a percentage.  It will not add up to 100% unless you are lucky. </p>
<h4 id="3-2-3、进程状态指示符表示的进程状态"><a href="#3-2-3、进程状态指示符表示的进程状态" class="headerlink" title="3.2.3、进程状态指示符表示的进程状态"></a><strong>3.2.3、进程状态指示符表示的进程状态</strong></h4><p>Here are the different values that the s output specifiers (header “S”) will display to describe the state of a process:</p>
<table>
<thead>
<tr>
<th>进程状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>uninterruptible sleep (usually IO)</td>
</tr>
<tr>
<td>R</td>
<td>running or runnable (on run queue)</td>
</tr>
<tr>
<td>S</td>
<td>interruptible sleep (waiting for an event to complete)</td>
</tr>
<tr>
<td>T</td>
<td>stopped, either by a job control signal or because it is being traced</td>
</tr>
<tr>
<td>W</td>
<td>paging (not valid since the 2.6.xx kernel)</td>
</tr>
<tr>
<td>X</td>
<td>dead (should never be seen)</td>
</tr>
<tr>
<td>Z</td>
<td>defunct (“zombie”) process, terminated but not reaped by its  parent</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man ps<br>[2]<a href="http://unix.stackexchange.com/questions/18166/what-are-session-leaders-in-ps">http://unix.stackexchange.com/questions/18166/what-are-session-leaders-in-ps</a></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>pwd命令</title>
    <url>/blog/2016/12/30/pwd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd [-P]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>打印当前目录。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-P”：不含“-P”选项，打印当前目录，如果目录路径中包含链接文件，不进行解析；包含“-P”选项，打印当前目录，如果目录路径中包含链接文件，进行解析。</p>
<br/>
参考文献：
[1]man pwd
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>rar命令</title>
    <url>/blog/2016/06/26/rar%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rar a &#x27;RAR压缩文件名&#x27; 待加入压缩文件的文件列表（可以是一般文件，也可以是目录文件）</span><br></pre></td></tr></table></figure>

<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>创建一个RAR压缩文件。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“a”：将文件列表中指定的所有文件加入到待创建的RAR压缩文件中</p>
<br/>
参考文献：
[1]man rar
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>rmiregistry命令</title>
    <url>/blog/2017/05/04/rmiregistry%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用的JDK版本为jdk1.7.0_79。</p>
<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmiregistry [PORT]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><p>执行<code>rmiregistry</code>命令运行rmiregistry服务，服务默认监听“1099”端口号，通过“PORT”选项，可自定义监听端口号。</p>
<br/>
参考文献：
[1]http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/rmiregistry.html
[2]man rmiregistry
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JDK命令</tag>
      </tags>
  </entry>
  <entry>
    <title>rm命令</title>
    <url>/blog/2016/12/14/rm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf FILE </span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>删除文件。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-r”：递归删除<br>“-f”：不提醒，强行删除</p>
<br/>
参考文献：
[1]man rm
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>rsync命令</title>
    <url>/blog/2016/10/31/rsync%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a><strong>一、基本介绍</strong></h2><p>rsync命令是一个可用来进行远程&#x2F;本地文件复制的工具，它的功能非常强大，它采取了“差异复制”机制，即只复制“差异数据”，这使得复制数据量大大减少。<br>使用rsync命令复制数据，一般可采用“通过RSH隧道或者SSH隧道”模式，也可采用“C&#x2F;S”模式。前者搭建方便，但是杀鸡用了宰牛刀，需要能够建立RSH隧道或者SSH隧道；后者搭建繁杂，但是没有前述要求。<font color='red'>因此，一般基于“C&#x2F;S”模式使用rsync命令复制数据。</font></p>
<h2 id="二、rsync-client"><a href="#二、rsync-client" class="headerlink" title="二、rsync client"></a><strong>二、rsync client</strong></h2><h3 id="2-1、常用用法"><a href="#2-1、常用用法" class="headerlink" title="2.1、常用用法"></a><strong>2.1、常用用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -vzrt --copy-links [--delete] [--contimeout=600] --log-file=FILEPATH --port=PORT --password-file=FILEPATH [USER@]HOST::SRC... DEST</span><br><span class="line">rsync -vzrt --copy-links [--delete] [--contimeout=600] --log-file=FILEPATH --port=PORT --password-file=FILEPATH SRC... [USER@]HOST::DEST</span><br></pre></td></tr></table></figure>
<h3 id="2-2、含义与选项"><a href="#2-2、含义与选项" class="headerlink" title="2.2、含义与选项"></a><strong>2.2、含义与选项</strong></h3><h4 id="2-2-1、含义"><a href="#2-2-1、含义" class="headerlink" title="2.2.1、含义"></a><strong>2.2.1、含义</strong></h4><p>第一行命令表示：从“远端”复制文件到“本地”，“远端”作为发送端，“本地”作为接收端。<br>第二行命令表示：从“本地”复制文件到“远端”，“本地”作为发送端，“远端”作为接收端。</p>
<h4 id="2-2-2、选项"><a href="#2-2-2、选项" class="headerlink" title="2.2.2、选项"></a><strong>2.2.2、选项</strong></h4><p>“v”：打印日志，“v”越多，打印日志信息越详细，一般使用3个“v”进行调试（rsync 3.0.6版本有个bug，加上“v”选项可能导致卡死）。<br>“z”：传输过程中，压缩文件。<br>“r”：递归传输。<br>“t”：保存“mtime”值，要开启“快速比较(quick check)”需要用到这个属性值。<br>“–copy-links”：当发送端遇到“软符号链接文件”，发送指向文件数据（包括“一般文件”和“目录文件”）。<br>“–delete”：接收端删掉多余的文件，用于同步模式。<br>“–contimeout&#x3D;600”：“rsync client”等待与“rsync daemon”建立连接的超时时间，这里的值为600毫秒。<br>“–log-file&#x3D;FILEPATH”：指定日志文件，可结合“–log-file-format”选项进行日志格式控制。<br>“–port&#x3D;PORT”：指定“rsync daemon”监听的端口号。<br>“–password-file&#x3D;FILEPATH”：指定包含连接“rsync daemon”所需密码的文件，<font color='red'>特别需要注意的是，该文件的权限必须设为“600”，否则会出现验证失败错误</font>。<br>“USER”：不需要是真的系统用户，只需是允许使用rsync服务的用户。<br>“HOST”：远端“rsync daemon”运行主机。<br>“SRC”：“远端”为发送端，则为远端机器上的模块路径；“本地”为发送端，则为本地机器上的目录路径。<br>“DEST”：“本地”为接收端，则为本地机器上的目录路径；“远端”为接收端，则为远端机器上的模块路径。<br>需要注意的是，以上“::”后面跟随的是以“模块名称”为开始的模块路径，而不是具体的目录路径。“rsync daemon”以模块为配置单元，使得配置更加灵活。</p>
<h2 id="三、rsync-daemon"><a href="#三、rsync-daemon" class="headerlink" title="三、rsync daemon"></a><strong>三、rsync daemon</strong></h2><h3 id="3-1、常用用法"><a href="#3-1、常用用法" class="headerlink" title="3.1、常用用法"></a><strong>3.1、常用用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync --daemon --config=rsyncd.conf</span><br></pre></td></tr></table></figure>
<h3 id="3-2、含义与选项"><a href="#3-2、含义与选项" class="headerlink" title="3.2、含义与选项"></a><strong>3.2、含义与选项</strong></h3><h4 id="3-2-1、含义"><a href="#3-2-1、含义" class="headerlink" title="3.2.1、含义"></a><strong>3.2.1、含义</strong></h4><p>加载“rsyncd.conf”文件中的配置，运行“rsync daemon”。</p>
<h4 id="3-2-2、选项"><a href="#3-2-2、选项" class="headerlink" title="3.2.2、选项"></a><strong>3.2.2、选项</strong></h4><p>“–daemon”：以“rsync daemon”模式运行。<br>“–config&#x3D;rsyncd.conf”：加载“rsyncd.conf”文件中的配置。</p>
<h3 id="3-3、“rsyncd-conf”配置文件语法"><a href="#3-3、“rsyncd-conf”配置文件语法" class="headerlink" title="3.3、“rsyncd.conf”配置文件语法"></a><strong>3.3、“rsyncd.conf”配置文件语法</strong></h3><p>“rsyncd.conf”配置文件语法描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局参数配置（key=value）</span><br><span class="line">[模块1]</span><br><span class="line">针对模块1的参数配置（key=value）</span><br><span class="line">[模块2]</span><br><span class="line">针对模块2的参数配置（key=value）</span><br><span class="line"></span><br><span class="line">以“零到多个前导空格符+#”字符开头的行是注释行</span><br></pre></td></tr></table></figure>
<p>一个样例配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rsync daemon进程pid记录文件</span><br><span class="line">pid file=/home/dsl/Desktop/rsync/rsyncservertest/rsyncd.pid</span><br><span class="line"></span><br><span class="line">#rsync daemon进程监听端口号</span><br><span class="line">port=1873</span><br><span class="line"></span><br><span class="line">#模块名</span><br><span class="line">[datamodule]</span><br><span class="line">    #模块对应路径</span><br><span class="line">    path=/home/dsl/Desktop/rsync/rsyncservertest/rsyncimg</span><br><span class="line"></span><br><span class="line">    #允许使用rsync服务的用户，不一定需要真正系统用户</span><br><span class="line">    auth users=dsl</span><br><span class="line"></span><br><span class="line">    #配置“用户以及用户对应的密码”对的文件，文件内容形如“dsl:123456”</span><br><span class="line">    #特别需要注意的是，该文件的权限必须设为“600”，否则会出现验证失败错误</span><br><span class="line">    secrets file=/home/dsl/Desktop/rsync/rsyncservertest/rsyncd.secrets</span><br><span class="line"></span><br><span class="line">    #模块最大连接数 </span><br><span class="line">    max connections=320</span><br><span class="line"> </span><br><span class="line">    #通过lock file文件实现“模块最大连接数”的控制 </span><br><span class="line">    lock file=/home/dsl/Desktop/rsync/rsyncservertest/rsyncd.lock</span><br><span class="line"></span><br><span class="line">    #否则需要“root”权限</span><br><span class="line">    use chroot=no</span><br><span class="line">     </span><br><span class="line">    #允许写入数据   </span><br><span class="line">    read only=no</span><br><span class="line">   </span><br><span class="line">    #“rsync client”试图列出“rsync daemon”下所有模块时，本模块不包括在内</span><br><span class="line">    list=no</span><br><span class="line">   </span><br><span class="line">    #试图删除本模块下数据时，即便遇到IO错误，也忽略继续进行</span><br><span class="line">    ignore errors=no</span><br><span class="line">   </span><br><span class="line">    #与“rsycn client”已建立连接的超时时间，即“当rsync daemon等待超过设定时间时，断开与rsync client已建立的连接”</span><br><span class="line">    timeout=600</span><br><span class="line"></span><br><span class="line">    #指定日志文件</span><br><span class="line">    log file=/home/dsl/Desktop/rsync/rsyncservertest/rsyncd.log</span><br><span class="line"></span><br><span class="line">    #针对每个文件，打印相关日志信息（可结合“log format”选项进行日志格式控制）</span><br><span class="line">    transfer logging=true</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man 1 rsync
[2]man 5 rsyncd.conf
[3]http://stackoverflow.com/questions/20773118/rsync-suddenly-hanging-indefinitely-during-transfers
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>sed命令</title>
    <url>/blog/2016/05/07/sed%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [-r] -e &#x27;sed脚本&#x27; 文件路径</span><br></pre></td></tr></table></figure>

<br/>

<p>备注：<br>一般情况下，既可以使用“双引号（“”）”，也可以使用“单引号（‘’）”，来括起“sed脚本”，但是在有些情况下，使用“双引号（“”）”会导致命令解析错误。</p>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>根据预先设定的规则，对文件内的内容进行编辑，以“行”为基本操作单元。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“-r”：表示sed脚本中使用的正则表达式是扩展正则表达式（即GNU ERE），而不是基本正则表达式（即GNU BRE）。<br>“-e sed脚本”：指定需要执行的sed脚本。<br>“文件路径”：待修改内容的文件路径。</p>
<h2 id="三、sed脚本说明"><a href="#三、sed脚本说明" class="headerlink" title="三、sed脚本说明"></a><strong>三、sed脚本说明</strong></h2><p>sed脚本可以写得十分复杂，但是我们一般只需用sed脚本完成“增删改”操作即可。“增删改”的操作范围有“整体范围”和“指定范围”之分。</p>
<h3 id="3-1、整体范围"><a href="#3-1、整体范围" class="headerlink" title="3.1、整体范围"></a><strong>3.1、整体范围</strong></h3><p>操作对象是文件内所有内容。<br>为了方便进行实验，特建立文件“a.txt”，它的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1、增"><a href="#3-1-1、增" class="headerlink" title="3.1.1、增"></a><strong>3.1.1、增</strong></h4><p>“增”可分为“行前增”和“行后增”。相应的sed脚本语法分别为：<code>i\text</code>和<code>a\text</code>。<br>执行<code>sed -e &#39;i\1&#39; a.txt</code>命令，结果如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-1.png"></p>
<p>执行<code>sed -e &#39;a\1&#39; a.txt</code>命令，结果如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-2.png"></p>
<h4 id="3-1-2、删"><a href="#3-1-2、删" class="headerlink" title="3.1.2、删"></a><strong>3.1.2、删</strong></h4><p>相应的sed脚本语法为<code>d</code>。<br>执行<code>sed -e &#39;d&#39; a.txt</code>命令，结果如图3所示。图3表示所有内容被删除，打印内容为空。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-3.png"></p>
<h4 id="3-1-3、改"><a href="#3-1-3、改" class="headerlink" title="3.1.3、改"></a><strong>3.1.3、改</strong></h4><p>“改”可分为“整行替换”，“字母替换”和“字符串替换”。</p>
<h5 id="3-1-3-1、整行替换"><a href="#3-1-3-1、整行替换" class="headerlink" title="3.1.3.1、整行替换"></a><strong>3.1.3.1、整行替换</strong></h5><p>相应的sed脚本语法为：<code>c\text</code>。<br>执行<code>sed -e &#39;c\dsl&#39; a.txt</code>命令，结果如图4所示。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-4.png"></p>
<h5 id="3-1-3-2、字母替换"><a href="#3-1-3-2、字母替换" class="headerlink" title="3.1.3.2、字母替换"></a><strong>3.1.3.2、字母替换</strong></h5><p>相应的sed脚本语法为：<code>y/source/dest/</code>。注意“source”和“dest”中字母数量必须一致，“source”中某个位置的字母会被替换成“dest”中对应位置的字母。<br>执行<code>sed -e &#39;y/abcde/ABCDE/&#39; a.txt</code>命令，结果如图5所示。</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-5.png"></p>
<h5 id="3-1-3-3、字符串替换"><a href="#3-1-3-3、字符串替换" class="headerlink" title="3.1.3.3、字符串替换"></a><strong>3.1.3.3、字符串替换</strong></h5><p>相应的sed脚本语法为：<code>s/regexp/replacement/</code>。<font color='red'>注意在“replacement”中可以有以下两类特殊字符：“\0”和“\1-9”。“\0”表示指代完整正则表达式所匹配的内容，“\1-9”表示相应的正则表达式单元所匹配的内容。</font></p>
<p>执行<code>sed -r -e &#39;s/el/lelele/&#39; a.txt</code>命令，结果如图6所示。</p>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-6.png"></p>
<p>执行<code>sed -e &#39;s/[l]+/lelele/&#39; a.txt</code>命令，结果如图7所示。</p>
<p>图7</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-7.png"></p>
<p>执行<code>sed -r -e &#39;s/[l]+/lelele/&#39; a.txt</code>命令，结果如图8所示。</p>
<p>图8</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-8.png"></p>
<p>图7和图8的结果验证了加“-r”选项与不加“-r”选项的区别，加“-r”选项表示使用“GNU ERE正则表达式”，而不加“-r”选项表示使用“GNU BRE正则表达式”。</p>
<p>执行<code>sed -r -e &#39;s/([l]+)(o|d)/\0\2\0/&#39; a.txt</code>命令，结果如图9所示。</p>
<p>图9</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-9.png"></p>
<p>这是实验了“replacement”中的“\0”和“\1-9”这两类特殊字符。</p>
<h3 id="3-2、指定范围"><a href="#3-2、指定范围" class="headerlink" title="3.2、指定范围"></a><strong>3.2、指定范围</strong></h3><p>操作对象是文件指定范围内的内容，最常见的指定范围的方式是“通过正则表达式<font color='red'>（这里使用的正则表达式是‘GNU ERE’还是‘GNU BRE’，依旧由上面提及到的‘-r’选项所控制）</font>”，具体的语法形式如下，其中加上“!”表示最终的“指定范围”是“&#x2F;regexp&#x2F;”所指定范围的补集范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/regexp/[!]</span><br></pre></td></tr></table></figure>
<p>举例子进行说明，现在有一个文件“b.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###a comment</span><br><span class="line">hello world</span><br><span class="line">###b comment</span><br></pre></td></tr></table></figure>
<p>执行<code>sed -r -e &#39;/[#]+/d&#39; b.txt</code>命令，结果如图10所示。</p>
<p>图10</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-10.png"></p>
<p>执行<code>sed -r -e &#39;/[#]+/!d&#39; b.txt</code>命令，结果如图11所示。</p>
<p>图11</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-0-11.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man sed</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>sort命令</title>
    <url>/blog/2016/11/18/sort%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort [-d | -g | -M | -h | -n] [-r] [-f] [-t CHAR] [-k KEYDEF [-k KEYDEF ... -k KEYDEF]] FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>对文件中的记录进行排序。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“-d”：按照字典序排序，默认就是按照字典序排序的。<br>“-g”：按照数字大小排序，支持科学计数表示法。<br>“-M”：按照月份大小排序，比如<code>JAN&lt;DEC</code>。<br>“-h”：支持识别人类可读形式单位然后进行排序，比如<code>2K&lt;1G</code>。<br>“-n”：按照数字大小排序，不支持科学计数表示法。<br>“-r”：表示反方向排序。<br>“-f”：排序比较时，忽略大小写。<br>“-t CHAR”：以“CHAR”字符作为字段间分隔符，默认是以“空格符”或者“Tab”作为分隔符。<br>“-k KEYDEF”：见“2.2.1、‘-k KEYDEF’”。</p>
<h4 id="2-2-1、“-k-KEYDEF”"><a href="#2-2-1、“-k-KEYDEF”" class="headerlink" title="2.2.1、“-k KEYDEF”"></a><strong>2.2.1、“-k KEYDEF”</strong></h4><h5 id="2-2-1-1、选项用途"><a href="#2-2-1-1、选项用途" class="headerlink" title="2.2.1.1、选项用途"></a><strong>2.2.1.1、选项用途</strong></h5><p>默认排序时以整行记录作为比较关键词，通过“-k KEYDEF”选项可以自己指定一个或者多个比较关键词。</p>
<h5 id="2-2-1-2、KEYDEF"><a href="#2-2-1-2、KEYDEF" class="headerlink" title="2.2.1.2、KEYDEF"></a><strong>2.2.1.2、KEYDEF</strong></h5><p>“KEYDEF”形如“F[.C][b][,F[.C][b]][OPTS]”。<br><strong>1、第一个“F[.C][b]”</strong><br>第一个“F[.C][b]”用来指定关键词的起始位置。“F”表示记录中的第“F”个字段（字段从1开始计数）；“C”表示该字段中的第“C”个字符（字符从1开始计数），<font color='red'>需要注意的是，省略“.C”，等价于“.1”（即表示该字段的第一个字符）</font>；“b”选项表示不将字段的前导分隔符作为该字段的一部分，如果不加“b”选项，那么“F.1”指向的其实是第“F”个字段的前导分隔符。<br><strong>2、第二个“F[.C][b]”</strong><br>第二个“F[.C][b]”用来指定关键词的结束位置，如果省略，以行结尾作为该关键词的结束位置。“F”表示记录中的第“F”个字段（字段从1开始计数）；“C”表示该字段中的第“C”个字符（字符从1开始计数），<font color='red'>需要注意的是，省略“.C”，等价于表示该字段的最后一个字符</font>；“b”选项表示不将字段的前导分隔符作为该字段的一部分，如果不加“b”选项，那么“F.1”指向的其实是第“F”个字段的前导分隔符。<br><strong>3、OPTS</strong><br>“OTPS”用来指定排序选项，可选值有“dgMhnrf”。注意跟“2.2、选项表示的意思”中的排序选项进行比对。<br><strong>4、举例</strong><br>见实验8，9，10，11，12，13。</p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><h3 id="3-1、实验1"><a href="#3-1、实验1" class="headerlink" title="3.1、实验1"></a><strong>3.1、实验1</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>执行<code>sort a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<p>备注：<br>执行<code>sort -d a.txt</code>命令，得到相同结果。</p>
<h3 id="3-2、实验2"><a href="#3-2、实验2" class="headerlink" title="3.2、实验2"></a><strong>3.2、实验2</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.2E10</span><br><span class="line">2.4</span><br><span class="line">01.245</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -g a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01.245</span><br><span class="line">2.4</span><br><span class="line">1.2E10</span><br></pre></td></tr></table></figure>
<h3 id="3-3、实验3"><a href="#3-3、实验3" class="headerlink" title="3.3、实验3"></a><strong>3.3、实验3</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAN</span><br><span class="line">SEP</span><br><span class="line">DEC</span><br><span class="line">OCT</span><br></pre></td></tr></table></figure>
<p>执行<code>LC_ALL=C sort -M a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAN</span><br><span class="line">SEP</span><br><span class="line">OCT</span><br><span class="line">DEC</span><br></pre></td></tr></table></figure>

<p><font color='red'>注意：</font><br>执行命令时加上“LC_ALL&#x3D;C”是因为在有些语系环境中，“JAN，SEP，DEC，OCT”并不表示月份，故而<code>JAN&lt;SEP&lt;OCT&lt;DEC</code>也不成立。比如执行<code>LC_ALL=zh_CN.utf8 sort -M a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEC</span><br><span class="line">JAN</span><br><span class="line">OCT</span><br><span class="line">SEP</span><br></pre></td></tr></table></figure>
<p>如果将“a.txt”内容改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">06月</span><br><span class="line">07月</span><br><span class="line">12月</span><br><span class="line">01月</span><br></pre></td></tr></table></figure>
<p>此时再执行<code>LC_ALL=zh_CN.utf8 sort -M a.txt</code>命令，就能得到如下所示结果，这符合预期。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01月</span><br><span class="line">06月</span><br><span class="line">07月</span><br><span class="line">12月</span><br></pre></td></tr></table></figure>
<h3 id="3-4、实验4"><a href="#3-4、实验4" class="headerlink" title="3.4、实验4"></a><strong>3.4、实验4</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1G</span><br><span class="line">1K</span><br><span class="line">1M</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -h a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1K</span><br><span class="line">1M</span><br><span class="line">1G</span><br></pre></td></tr></table></figure>
<h3 id="3-5、实验5"><a href="#3-5、实验5" class="headerlink" title="3.5、实验5"></a><strong>3.5、实验5</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">0000001</span><br><span class="line">000000001000</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -n a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000001</span><br><span class="line">100</span><br><span class="line">000000001000</span><br></pre></td></tr></table></figure>
<h3 id="3-6、实验6"><a href="#3-6、实验6" class="headerlink" title="3.6、实验6"></a><strong>3.6、实验6</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -r a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<h3 id="3-7、实验7"><a href="#3-7、实验7" class="headerlink" title="3.7、实验7"></a><strong>3.7、实验7</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>执行<code>sort a.txt</code>命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">A</span><br><span class="line">b</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<p>发现此时有“LC_ALL&#x3D;zh_CN.utf8”，由此可知在“zh_CN.utf8”语系环境中，字典序中的大小写字母紧邻而列。<br>再执行<code>LC_ALL=C sort a.txt</code>命令，得到结果如“结果1”所示，由此可知在“C”语系环境中，字典序中的大小写字母非紧邻而列，需要加上“-f”选项，才能达到“使大小写字母紧邻而列”的要求，即执行<code>LC_ALL=C sort -f a.txt</code>命令，执行命令后得到结果如“结果2”所示，这符合预期。</p>
<p>结果1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>结果2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">a</span><br><span class="line">B</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<h3 id="3-8、实验8"><a href="#3-8、实验8" class="headerlink" title="3.8、实验8"></a><strong>3.8、实验8</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 1 1</span><br><span class="line">1 2 3 6</span><br><span class="line">3 2 4 5</span><br></pre></td></tr></table></figure>
<p>执行<code>sort a.txt</code>命令（以整行记录内容作为比较关键词），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 6</span><br><span class="line">2 1 1 1</span><br><span class="line">3 2 4 5</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -k 2n a.txt</code>命令（从第2个字段前导分隔符开始到行尾为止内容作为比较关键词），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 1 1</span><br><span class="line">1 2 3 6</span><br><span class="line">3 2 4 5</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -k 2,2n -k 4,4n a.txt</code>命令（第一个比较关键词是“从第2个字段前导分隔符开始到第2个字段末尾字符为止内容”，第二个比较关键词是“从第4个字段前导分隔符开始到第4个字段末尾字符为止内容”），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 1 1</span><br><span class="line">3 2 4 5</span><br><span class="line">1 2 3 6</span><br></pre></td></tr></table></figure>
<h3 id="3-9、实验9"><a href="#3-9、实验9" class="headerlink" title="3.9、实验9"></a><strong>3.9、实验9</strong></h3><p>有文件“c.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 R2 a</span><br><span class="line">4 R3 b</span><br><span class="line">3 R10 c</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -k 2.2n c.txt</code>命令（从第2个字段第2个字符开始到行尾为止内容作为比较关键词，“第2个字段第2个字符”实际是3行中的“R”字符，前导分隔符作为字段一部分），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 R2 a</span><br><span class="line">3 R10 c</span><br><span class="line">4 R3 b</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -k 2.3n c.txt</code>命令（从第2个字段第3个字符开始到行尾为止内容作为比较关键词，3行中的“第2个字段第3个字符”分别是“2”，“3”和“1”，前导分隔符作为字段一部分），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 R2 a</span><br><span class="line">4 R3 b</span><br><span class="line">3 R10 c</span><br></pre></td></tr></table></figure>
<p>执行<code>sort -k 2.2b,2n c.txt</code>命令（从第2个字段第2个字符开始到第2个字段末尾字符为止内容作为比较关键词，由于加上“b”选项，不将字段前导分隔符作为字段一部分，故而3行中的“第2个字段第2个字符”分别是“2”，“3”和“1”），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 R2 a</span><br><span class="line">4 R3 b</span><br><span class="line">3 R10 c</span><br></pre></td></tr></table></figure>
<h3 id="3-10、实验10"><a href="#3-10、实验10" class="headerlink" title="3.10、实验10"></a><strong>3.10、实验10</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 bat 51</span><br><span class="line">2 animal 62</span><br><span class="line">3 check 75</span><br><span class="line">4 car 84</span><br></pre></td></tr></table></figure>
<p>执行<code>LC_ALL=C sort -k 2.1b,2.1b -k 3.2b,3.2bn a.txt</code>命令（第一个比较关键词是“第2个字段的第1个字符”，第二个比较关键词是“第3个字段的第2个字符”，前导分隔符不作为字段一部分），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 animal 62</span><br><span class="line">1 bat 51</span><br><span class="line">4 car 84</span><br><span class="line">3 check 75</span><br></pre></td></tr></table></figure>
<h3 id="3-11、实验11"><a href="#3-11、实验11" class="headerlink" title="3.11、实验11"></a><strong>3.11、实验11</strong></h3><p>有文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab1 2ef</span><br><span class="line">cd0 5hi</span><br><span class="line">ef3 4jk</span><br><span class="line">aa3 1cc</span><br><span class="line">bb0 4dd</span><br></pre></td></tr></table></figure>
<p>执行<code>LC_ALL=C sort -k 1.3b,2.1bn a.txt</code>命令（从第1个字段第3个字符开始到第2个字段第1个字符为止内容作为比较关键词，即“比较关键词”横跨两个字段，前导分隔符不作为字段一部分），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bb0 4dd</span><br><span class="line">cd0 5hi</span><br><span class="line">ab1 2ef</span><br><span class="line">aa3 1cc</span><br><span class="line">ef3 4jk</span><br></pre></td></tr></table></figure>
<h3 id="3-12、实验12"><a href="#3-12、实验12" class="headerlink" title="3.12、实验12"></a><strong>3.12、实验12</strong></h3><p>有文件“e.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">126 Mar  8 07:45:09 nod1 /sbin/ccccilio[12712]: INFO: sadasdasdas</span><br><span class="line">  2 Mar  9 08:16:22 nod1 /sbin/zzzzo[12712]: sadsdasdas</span><br><span class="line">  3 JUN  3 10:16:22 nod1 /sbin/hah</span><br><span class="line">  1 Mar  8 17:20:01 nod1 /usr/sbin/cron[1826]: asdasdas</span><br><span class="line">  4 Mar  9 06:24:01 nod1 /USR/SBIN/CRON[27199]: aaaasdsd</span><br><span class="line">  1 Mar  9 06:24:01 nod1 /USR/SBIN/CRON[27201]: aaadas</span><br></pre></td></tr></table></figure>
<p>执行<code>LC_ALL=C sort -k 2b,2bM -k 3b,3bn -k 4b,4b e.txt</code>命令（第一个比较关键词是“第2个字段，不包括前导分隔符”，第二个比较关键词是“第3个字段，不包括前导分隔符”，第三个比较关键词是“第4个字段，不包括前导分隔符”），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">126 Mar  8 07:45:09 nod1 /sbin/ccccilio[12712]: INFO: sadasdasdas</span><br><span class="line">  1 Mar  8 17:20:01 nod1 /usr/sbin/cron[1826]: asdasdas</span><br><span class="line">  1 Mar  9 06:24:01 nod1 /USR/SBIN/CRON[27201]: aaadas</span><br><span class="line">  4 Mar  9 06:24:01 nod1 /USR/SBIN/CRON[27199]: aaaasdsd</span><br><span class="line">  2 Mar  9 08:16:22 nod1 /sbin/zzzzo[12712]: sadsdasdas</span><br><span class="line">  3 JUN  3 10:16:22 nod1 /sbin/hah</span><br></pre></td></tr></table></figure>
<p>以上命令的效果是根据时间排序。</p>
<h3 id="3-13、实验13"><a href="#3-13、实验13" class="headerlink" title="3.13、实验13"></a><strong>3.13、实验13</strong></h3><p>有文件“e.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Feb 27 2011 23:05 SOMETHING 2011.02.24.avi</span><br><span class="line">Feb 11 2011 20:06 SOMETHING 2011.02.10.avi</span><br><span class="line">Jan 23 2011 10:42 SOMETHING 2007.12.20.avi</span><br><span class="line">Jan 29 2011 09:17 SOMETHING 2011.01.27.avi</span><br><span class="line">Feb 12 2010 SOMETHING 2010.02.11.avi</span><br><span class="line">Jun 26 2009 SOMETHING 2009.06.25.avi</span><br></pre></td></tr></table></figure>
<p>执行<code>LC_ALL=C sort -k 3b,3bnr -k 1b,1bMr -k 2b,2bnr -k 4b,4br e.txt</code>命令（第一个比较关键词是“第3个字段，不包括前导分隔符”，第二个比较关键词是“第1个字段，不包括前导分隔符”，第三个比较关键词是“第2个字段，不包括前导分隔符”，第四个比较关键词是“第4个字段，不包括前导分隔符”），得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Feb 27 2011 23:05 SOMETHING 2011.02.24.avi</span><br><span class="line">Feb 11 2011 20:06 SOMETHING 2011.02.10.avi</span><br><span class="line">Jan 29 2011 09:17 SOMETHING 2011.01.27.avi</span><br><span class="line">Jan 23 2011 10:42 SOMETHING 2007.12.20.avi</span><br><span class="line">Feb 12 2010 SOMETHING 2010.02.11.avi</span><br><span class="line">Jun 26 2009 SOMETHING 2009.06.25.avi</span><br></pre></td></tr></table></figure>
<p>以上命令的效果是根据时间逆序排序。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>程序实现中使用“LC_COLLATE，LC_ALL，LC_CTYPE”等环境变量，因而最终结果受到“LC_COLLATE，LC_ALL，LC_CTYPE”等环境变量的控制。</p>
<br/>
参考文献：
[1]man sort
[2]info sort
[3]http://stackoverflow.com/questions/1255782/whats-the-difference-between-general-numeric-sort-and-numeric-sort-options
[4]http://stackoverflow.com/questions/12162210/sort-by-just-month-name-and-day-bash
[5]http://unix.stackexchange.com/questions/8352/sorting-by-date
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh-add命令</title>
    <url>/blog/2017/02/14/ssh-add%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add [-dDl] [私钥文件路径，私钥文件如果有密码，输入密码]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义和选项"><a href="#二、含义和选项" class="headerlink" title="二、含义和选项"></a><strong>二、含义和选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>增加，删除，查看由ssh-agent程序管理的私钥文件。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-d”：在由ssh-agent程序管理的私钥文件库中删除指定的私钥文件。<br>“-D”：删除所有由ssh-agent程序管理的私钥文件。<br>“-l”：查看所有由ssh-agent程序管理的私钥文件，以私钥文件指纹形式展现。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>只有当ssh-agent程序运行时，ssh-add命令才能正常工作。</p>
<br/>
参考文献：
[1]man ssh-add
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh-agent命令</title>
    <url>/blog/2017/02/14/ssh-agent%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><p>开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval `ssh-agent`</span><br></pre></td></tr></table></figure>
<p>停止：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval `ssh-agent -k`</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>运行ssh-agent程序，它将接管本由SSH Client做的“公钥私钥匹配验证计算过程”，详见参考文献[2]。<br>需要注意的是，ssh-agent程序运行结束后，由其管理的私钥文件库被清空。</p>
<h2 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a><strong>三、应用</strong></h2><h3 id="3-1、简单应用"><a href="#3-1、简单应用" class="headerlink" title="3.1、简单应用"></a><strong>3.1、简单应用</strong></h3><p>本机L1尝试与远程服务器R1使用“公钥私钥对验证机制”进行SSH连接，ssh-agent程序运行后，它将接管“公钥私钥匹配验证计算过程”，详见参考文献[2]。</p>
<h3 id="3-2、复杂应用"><a href="#3-2、复杂应用" class="headerlink" title="3.2、复杂应用"></a><strong>3.2、复杂应用</strong></h3><p>本机L1与远程服务器R1建立SSH连接后，后续想要在R1上级联地与远程服务器R2，R3，…，Rn建立SSH连接，而出于安全考虑，这些远程服务器上并没有放置相应的私钥文件。针对以上情形，一种解决方案是：在L1上运行ssh-agent程序，在与R1建立SSH连接时开通“ForwardAgent”选项（需要远程服务器上的SSHD程序也开通该选项），此后所有的“公钥私钥匹配验证计算过程”都会被转交给该ssh-agent程序，从而可顺利地与R2，R3，…，Rn级联建立SSH连接。</p>
<br/>
参考文献：
[1]man ssh-agent
[2]http://www.unixwiz.net/techtips/ssh-agent-forwarding.html
[3]http://wiki.jikexueyuan.com/project/github-developer-guides/using-ssh-agent.html
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh_config文件配置实例</title>
    <url>/blog/2017/02/15/ssh-config%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>根据<a href="/blog/2017/02/15/ssh-config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" title="ssh_config配置文件">《ssh_config配置文件》</a>的介绍，这里做几个关于ssh_config文件配置的练习。</p>
<h2 id="一、环境设定"><a href="#一、环境设定" class="headerlink" title="一、环境设定"></a><strong>一、环境设定</strong></h2><p>1、假定使用ssh_config文件中的“<del>&#x2F;.ssh&#x2F;config”文件<br>2、现在有服务器A，B和C，这3台服务器上都运行SSH Server<br>3、A，B，C的域名分别为：“antix1.space.org，antix2.space.org，antix3.space.org”<br>4、A，B，C上SSH Server监听的端口号都为“1046”<br>5、本地机器上的SSH Client与A，B，C上的SSH Server建立SSH连接使用的账户都为“dsl”<br>6、本地机器上的SSH Client与A，B，C上的SSH Server建立SSH连接对应“dsl”账户的私钥文件都为“</del>&#x2F;.ssh&#x2F;dsl_private_key”</p>
<h2 id="二、通过命令行方式与A，B，C上的SSH-Server建立SSH连接"><a href="#二、通过命令行方式与A，B，C上的SSH-Server建立SSH连接" class="headerlink" title="二、通过命令行方式与A，B，C上的SSH Server建立SSH连接"></a><strong>二、通过命令行方式与A，B，C上的SSH Server建立SSH连接</strong></h2><p>与A，B，C上的SSH Server建立SSH连接的命令分别如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/dsl_private_key -l dsl -p 1046 antix1.space.org</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/dsl_private_key -l dsl -p 1046 antix2.space.org</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/dsl_private_key -l dsl -p 1046 antix3.space.org</span><br></pre></td></tr></table></figure>
<h2 id="三、通过ssh-config文件配置方式与A，B，C上的SSH-Server建立SSH连接（不使用通配符，转义序列等高级配置）"><a href="#三、通过ssh-config文件配置方式与A，B，C上的SSH-Server建立SSH连接（不使用通配符，转义序列等高级配置）" class="headerlink" title="三、通过ssh_config文件配置方式与A，B，C上的SSH Server建立SSH连接（不使用通配符，转义序列等高级配置）"></a><strong>三、通过ssh_config文件配置方式与A，B，C上的SSH Server建立SSH连接（不使用通配符，转义序列等高级配置）</strong></h2><p>现在“~&#x2F;.ssh&#x2F;config”文件中配置有如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host antix1  </span><br><span class="line">    HostName antix1.space.org  </span><br><span class="line">    User dsl  </span><br><span class="line">    Port 1046  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key  </span><br><span class="line">  </span><br><span class="line">Host antix2  </span><br><span class="line">    HostName antix2.space.org  </span><br><span class="line">    User dsl  </span><br><span class="line">    Port 1046  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key  </span><br><span class="line">  </span><br><span class="line">Host antix3  </span><br><span class="line">    HostName antix3.space.org  </span><br><span class="line">    User dsl  </span><br><span class="line">    Port 1046  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key  </span><br></pre></td></tr></table></figure>
<p>与A，B，C上的SSH Server建立SSH连接的命令分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix3</span><br></pre></td></tr></table></figure>
<h2 id="四、通过ssh-config文件配置方式与A，B，C上的SSH-Server建立SSH连接（使用通配符，转义序列等高级配置）"><a href="#四、通过ssh-config文件配置方式与A，B，C上的SSH-Server建立SSH连接（使用通配符，转义序列等高级配置）" class="headerlink" title="四、通过ssh_config文件配置方式与A，B，C上的SSH Server建立SSH连接（使用通配符，转义序列等高级配置）"></a><strong>四、通过ssh_config文件配置方式与A，B，C上的SSH Server建立SSH连接（使用通配符，转义序列等高级配置）</strong></h2><p>现在“~&#x2F;.ssh&#x2F;config”文件中配置有如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host antix*  </span><br><span class="line">    HostName %h.space.org  </span><br><span class="line">    User dsl  </span><br><span class="line">    Port 1046  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key  </span><br></pre></td></tr></table></figure>
<p>与A，B，C上的SSH Server建立SSH连接的命令分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh antix3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh_config配置文件</title>
    <url>/blog/2017/02/15/ssh-config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、SSH-Client的参数值来源"><a href="#一、SSH-Client的参数值来源" class="headerlink" title="一、SSH Client的参数值来源"></a><strong>一、SSH Client的参数值来源</strong></h2><p>SSH Client的参数值来源主要有3个，分别是“命令行配置”，“~&#x2F;.ssh&#x2F;config”和“&#x2F;etc&#x2F;ssh&#x2F;ssh_config”。</p>
<h2 id="二、ssh-config文件"><a href="#二、ssh-config文件" class="headerlink" title="二、ssh_config文件"></a><strong>二、ssh_config文件</strong></h2><p>ssh_config文件：指代“~&#x2F;.ssh&#x2F;config”和“&#x2F;etc&#x2F;ssh&#x2F;ssh_config”这两个配置文件。</p>
<h2 id="三、优先级顺序"><a href="#三、优先级顺序" class="headerlink" title="三、优先级顺序"></a><strong>三、优先级顺序</strong></h2><p>不同来源的参数值的优先级按照“etc&#x2F;ssh&#x2F;ssh_config”，“<del>&#x2F;.ssh&#x2F;config”，“命令行配置”顺序从低到高排序。<br>在ssh_config文件中（即在“</del>&#x2F;.ssh&#x2F;config”和“&#x2F;etc&#x2F;ssh&#x2F;ssh_config”配置文件中），越早定义的参数值优先级越高。</p>
<h2 id="四、ssh-config文件的格式"><a href="#四、ssh-config文件的格式" class="headerlink" title="四、ssh_config文件的格式"></a><strong>四、ssh_config文件的格式</strong></h2><h3 id="4-1、注释"><a href="#4-1、注释" class="headerlink" title="4.1、注释"></a><strong>4.1、注释</strong></h3><p>#开头的语句是注释语句。</p>
<h3 id="4-2、基本结构"><a href="#4-2、基本结构" class="headerlink" title="4.2、基本结构"></a><strong>4.2、基本结构</strong></h3><p>ssh_config文件的基本结构是“keyword arguments(参数名 参数值)”。</p>
<h3 id="4-3、重要内容——“Host”隔开的小节"><a href="#4-3、重要内容——“Host”隔开的小节" class="headerlink" title="4.3、重要内容——“Host”隔开的小节"></a><strong>4.3、重要内容——“Host”隔开的小节</strong></h3><p>在ssh_config文件中，可以使用“Host”来隔开不同的配置小节，在这样的配置小节中，可以配置以下这些重要参数：<br><strong>1、“Host”</strong><br>配置本小节被命中的条件，比较的对象是“命令行中输入的host name”，支持通配符（“*”表示任意字符串，“?”表示任意单个字符）。<br><strong>2、“HostName”</strong><br>表示SSH Server所在机子的域名，支持完整域名，缩写别名，IP地址，也支持“%h”这个转义序列，该转义序列指代“命令行中输入的host name”。<br><strong>3、“Port”</strong><br>指定SSH Server所监听的端口。<br><strong>4、“IdentityFile”</strong><br>建立SSH连接使用的私钥文件。<br><strong>5、“User”</strong><br>建立SSH连接使用的用户名。<br><strong>6、“ForwardAgent”</strong><br>是否将“公钥私钥验证匹配计算过程”递交给ssh-agent程序处理。</p>
<h2 id="五、ssh-config文件的反自然命中逻辑"><a href="#五、ssh-config文件的反自然命中逻辑" class="headerlink" title="五、ssh_config文件的反自然命中逻辑"></a><strong>五、ssh_config文件的反自然命中逻辑</strong></h2><p>ssh_config文件中存在多个配置小节，自然的命中逻辑应该为：按照配置小节的配置顺序，依次进行命中测试，一旦首次命中即停止，最终生效的参数集合和相应的参数值完全来自于该命中配置小节。而实际中的命中逻辑是反自然的：按照配置小节的配置顺序，依次进行命中测试，首次命中不停止，直到找出所有命中配置小节，最终生效的参数集合是这些命中配置小节中参数集合的并集，相应的参数值是这些命中配置小节中该参数的首次配置值。<br>举例来说，假如ssh_config文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host dsl</span><br><span class="line">    HostName www.dsl.com.cn</span><br><span class="line">    User dslztx</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/keys/dsl.key</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">    HostName www.dsl.com</span><br><span class="line">    User dslztx</span><br><span class="line">    Port 23</span><br><span class="line">    IdentityFile ~/.ssh/keys/dsl.key</span><br><span class="line">    ProxyCommand  ssh -W %h:%p proxy-agent</span><br></pre></td></tr></table></figure>
<p>现在命令行中输入的“host name”为“dsl”，因此两个配置小节都被命中，最终生效的参数集合和相应的参数值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HostName www.dsl.com.cn</span><br><span class="line">User dslztx</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile ~/.ssh/keys/dsl.key</span><br><span class="line">ProxyCommand  ssh -W %h:%p proxy-agent</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]man 5 ssh_config
[2]https://unix.stackexchange.com/questions/152264/stop-ssh-config-on-first-match
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh-keygen命令</title>
    <url>/blog/2017/02/15/ssh-keygen%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、ssh-keygen"><a href="#一、ssh-keygen" class="headerlink" title="一、ssh-keygen"></a><strong>一、ssh-keygen</strong></h2><p>ssh-keygen程序是用来创建，管理和转换密钥的工具，它支持的密钥类型有“RSA，DSA，ECDSA，ED25519，RSA1”。<br>前面4种密钥类型适用于“SSH Protocol Version 2”，最后1种密钥类型适用于“SSH Protocol Version 1”。</p>
<h2 id="二、关于“passphrase”"><a href="#二、关于“passphrase”" class="headerlink" title="二、关于“passphrase”"></a><strong>二、关于“passphrase”</strong></h2><p>在创建公钥私钥对时，可以设置“passphrase”值，该值用来加密私钥的内容，从而达到保护私钥内容的目的。</p>
<h2 id="三、“Host-Key”"><a href="#三、“Host-Key”" class="headerlink" title="三、“Host Key”"></a><strong>三、“Host Key”</strong></h2><p>为了防止中间人攻击（一台机器冒充SSH Server与你的SSH Client进行连接），给每台SSH Server创建一个唯一标识码，当你的SSH Client试图连接一台SSH Server的时候，通过读取该台SSH Server的这个唯一标识码，并与上次连接之后本地保存的唯一标识码（保存在“~&#x2F;.ssh&#x2F;known_hosts”文件中）进行比对，如果一致则认为不存在中间人攻击。该唯一标识码被称为“Host Key”。<br>“Host Key”本质上是公钥和私钥对中的公钥，存放路径位于“&#x2F;etc&#x2F;ssh&#x2F;”下。</p>
<h2 id="四、具体命令"><a href="#四、具体命令" class="headerlink" title="四、具体命令"></a><strong>四、具体命令</strong></h2><h3 id="4-1、创建公钥私钥对"><a href="#4-1、创建公钥私钥对" class="headerlink" title="4.1、创建公钥私钥对"></a><strong>4.1、创建公钥私钥对</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t type</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ol>
<li>“type”是“RSA，DSA，ECDSA，ED25519，RSA1”5种类型之一</li>
<li>创建得到的公钥私钥文件只能存放在“~&#x2F;.ssh&#x2F;”目录下</li>
<li>交互式命令，需要指定私钥文件名（公钥文件名&#x3D;私钥文件名.pub）</li>
</ol>
<h3 id="4-2、管理“passphrase”"><a href="#4-2、管理“passphrase”" class="headerlink" title="4.2、管理“passphrase”"></a><strong>4.2、管理“passphrase”</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ol>
<li>交互式命令，需要选择欲操作“passphrase”的私钥文件</li>
<li>可用于清除旧的“passphrase”</li>
</ol>
<h3 id="4-3、创建“Host-Key”"><a href="#4-3、创建“Host-Key”" class="headerlink" title="4.3、创建“Host Key”"></a><strong>4.3、创建“Host Key”</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -A</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<ol>
<li>需要以root身份运行以上命令</li>
<li>针对每种支持的密钥类型创建公钥私钥对，其中的公钥作为“Host Key”</li>
</ol>
<br/>
参考文献：
[1]man ssh-keygen
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh命令</title>
    <url>/blog/2017/02/15/ssh%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>ssh程序是SSH Client中的客户程序，下面根据不同应用场景中ssh程序的使用来介绍ssh程序。</p>
<h2 id="一、基本应用场景"><a href="#一、基本应用场景" class="headerlink" title="一、基本应用场景"></a><strong>一、基本应用场景</strong></h2><p>在本应用场景中，建立SSH连接，允许进行“用户登录，命令执行等”操作。</p>
<h3 id="1-1、建立ssh连接命令"><a href="#1-1、建立ssh连接命令" class="headerlink" title="1.1、建立ssh连接命令"></a><strong>1.1、建立ssh连接命令</strong></h3><p>在本场景中，使用ssh程序建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -l dslztx -i ~/.ssh/id_dsa -p 22 192.168.1.5</span><br></pre></td></tr></table></figure>
<h4 id="1-1-1、选项的含义"><a href="#1-1-1、选项的含义" class="headerlink" title="1.1.1、选项的含义"></a><strong>1.1.1、选项的含义</strong></h4><p><strong>1、“-i”</strong><br>指定私钥文件<br><strong>2、“-p”</strong><br>指定SSH Server监听端口<br><strong>3、“-l”</strong><br>指定SSH连接登录用户<br><strong>4、“192.168.1.5”</strong><br>表示SSH Server所在机器的IP地址</p>
<h4 id="1-1-2、ssh-config文件中对应的配置"><a href="#1-1-2、ssh-config文件中对应的配置" class="headerlink" title="1.1.2、ssh_config文件中对应的配置"></a><strong>1.1.2、ssh_config文件中对应的配置</strong></h4><p>以上这些参数值可在“ssh_config文件”中配置，配置后内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host RemoteHost #指定配置匹配条件</span><br><span class="line">    HostName 192.168.1.5</span><br><span class="line">    User dslztx</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/id_dsa</span><br></pre></td></tr></table></figure>
<p>现在执行<code>ssh RemoteHost</code>命令，即可达到跟执行原来命令相同的效果。</p>
<h2 id="二、SSH隧道应用场景"><a href="#二、SSH隧道应用场景" class="headerlink" title="二、SSH隧道应用场景"></a><strong>二、SSH隧道应用场景</strong></h2><p>在本应用场景中，建立SSH连接，将SSH连接作为隧道。在继续之前，首先进行以下几点说明：</p>
<ol>
<li>SSH Client端所在的机器称为“本地机器”，SSH Server端所在的机器称为“RemoteHost”</li>
<li>“-l，-i，-p，域名或者ip地址”这些参数的参数值已经在“ssh_config文件”中配置</li>
<li>根据<a href="/blog/2017/02/15/SSH%E5%8D%8F%E8%AE%AE/" title="SSH协议">《SSH协议》</a>，ssh连接必须由SSH Client请求建立，但是一旦得以建立，数据通信请求既可由SSH Client发起，也可由SSH Server发起，即在SSH连接建立后，可由任意端发起数据通信请求</li>
</ol>
<p>使用SSH隧道的应用具体又可细分为4种形式，下面分别进行介绍。</p>
<h3 id="2-1、SSH-Client端设定被监听的应用转发端口——本地转发"><a href="#2-1、SSH-Client端设定被监听的应用转发端口——本地转发" class="headerlink" title="2.1、SSH Client端设定被监听的应用转发端口——本地转发"></a><strong>2.1、SSH Client端设定被监听的应用转发端口——本地转发</strong></h3><h4 id="2-1-1、建立ssh连接命令"><a href="#2-1-1、建立ssh连接命令" class="headerlink" title="2.1.1、建立ssh连接命令"></a><strong>2.1.1、建立ssh连接命令</strong></h4><p>在本场景中，使用ssh程序建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L [bind_address:]port:host:hostport RemoteHost  </span><br></pre></td></tr></table></figure>
<h5 id="2-1-1-1、选项的含义"><a href="#2-1-1-1、选项的含义" class="headerlink" title="2.1.1.1、选项的含义"></a><strong>2.1.1.1、选项的含义</strong></h5><p><strong>1、“port”</strong><br>本地机器的端口号，被监听的应用转发端口<br><strong>2、“host”</strong><br>当其值为“localhost”或者“127.0.0.1”时，相当于一个“相对地址”，它的绝对地址是“RemoteHost”；否则，它的绝对地址就是“host”值。（即以“RemoteHost”为参照基准）<br><strong>3、“hostport”</strong><br>“host”所表示机器上的端口号<br><strong>4、“bind_address”</strong><br>表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道。当“bind_address”值为“localhost”或“127.0.0.1”时，相当于一个相对地址，它的绝对地址是本地机器，表示只有来自自身的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值不为“localhost”或者“127.0.0.1”，而为特定的某个域名或者IP地址时，它的绝对地址就是“bind_address”值，表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值为“*”或者为空时，没有所谓的绝对地址，表示来自所有地址的对“port”端口的访问都被允许通过SSH隧道（即以“本地机器”为参照基准）</p>
<h5 id="2-1-1-2、ssh-config文件中对应的配置"><a href="#2-1-1-2、ssh-config文件中对应的配置" class="headerlink" title="2.1.1.2、ssh_config文件中对应的配置"></a><strong>2.1.1.2、ssh_config文件中对应的配置</strong></h5><p>“[bind_address:]port:host:hostport”这些参数的参数值可以在“ssh_config文件”中配置，具体配置选项是“LocalForward”。</p>
<h4 id="2-1-2、原理分析"><a href="#2-1-2、原理分析" class="headerlink" title="2.1.2、原理分析"></a><strong>2.1.2、原理分析</strong></h4><p>建立的SSH连接被应用作为隧道，由于SSH Client端设定被监听的应用转发端口，因此应用连接必须由本地机器上的应用程序发起建立，称为<font color='red'>本地转发</font>。<br>具体的数据流图如图1所示。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20170215-0-1.jpg"></p>
<p>有以下几点需要注意：</p>
<ul>
<li>执行<code>ssh -L [bind_address:]port:host:hostport RemoteHost</code>建立SSH连接隧道，设置好被监听的转发端口，转发目标地址和端口等参数</li>
<li>应用连接由本地机器上的应用程序发起建立</li>
<li>在应用连接由本地机器上的应用程序发起建立之后：<br>当“bind_address”为“127.0.0.1&#x2F;localhost”，“host”为“127.0.0.1&#x2F;localhost”时，数据流通道为：数据通道2——数据通道3——SSH隧道——数据通道5；当“bind_address”为“非‘127.0.0.1&#x2F;localhost’”的某个特定地址，“host”为“127.0.0.1&#x2F;localhost”时，数据流通道为：数据通道1——数据通道3——SSH隧道——数据通道5。依此类推</li>
</ul>
<h3 id="2-2、SSH-Server端设定被监听的应用转发端口——远端转发"><a href="#2-2、SSH-Server端设定被监听的应用转发端口——远端转发" class="headerlink" title="2.2、SSH Server端设定被监听的应用转发端口——远端转发"></a><strong>2.2、SSH Server端设定被监听的应用转发端口——远端转发</strong></h3><h4 id="2-2-1、建立ssh连接命令"><a href="#2-2-1、建立ssh连接命令" class="headerlink" title="2.2.1、建立ssh连接命令"></a><strong>2.2.1、建立ssh连接命令</strong></h4><p>在本场景中，使用ssh程序建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R [bind_address:]port:host:hostport RemoteHost  </span><br></pre></td></tr></table></figure>
<h5 id="2-2-1-1、选项的含义"><a href="#2-2-1-1、选项的含义" class="headerlink" title="2.2.1.1、选项的含义"></a><strong>2.2.1.1、选项的含义</strong></h5><p><strong>1、“port”</strong><br>“RemoteHost”上的端口号，被监听的应用转发端口<br><strong>2、“host”</strong><br>当“host”值为“localhost”或者“127.0.0.1”时，相当于一个“相对地址”，它的绝对地址是“本地机器”；否则，它的绝对地址就是“host”值（即以本地机器为参照基准）<br><strong>3、“hostport”</strong><br>“host”所表示机器上的端口号<br><strong>4、“bind_address”</strong><br>表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道。当“bind_address”值为“localhost”或“127.0.0.1”时，相当于一个相对地址，它的绝对地址是“RemoteHost”，表示只有来自自身的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值不为“localhost”或者“127.0.0.1”，而为特定的某个域名或者IP地址时，它的绝对地址就是“bind_address”值，表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值为“*”或者为空时，没有所谓的绝对地址，表示来自所有地址的对“port”端口的访问都被允许通过SSH隧道（即以“RemoteHost”为参照基准）</p>
<h5 id="2-2-1-2、ssh-config文件中对应的配置"><a href="#2-2-1-2、ssh-config文件中对应的配置" class="headerlink" title="2.2.1.2、ssh_config文件中对应的配置"></a><strong>2.2.1.2、ssh_config文件中对应的配置</strong></h5><p>“[bind_address:]port:host:hostport”这些参数的参数值可以在“ssh_config文件”中配置，具体配置选项是“RemoteForward”。</p>
<h4 id="2-2-2、原理分析"><a href="#2-2-2、原理分析" class="headerlink" title="2.2.2、原理分析"></a><strong>2.2.2、原理分析</strong></h4><p>建立的SSH连接被应用连接作为隧道，由于SSH Server端设定被监听的应用转发端口，因此应用连接由“RemoteHost”上的应用程序发起建立，称为<font color='red'>远端转发</font>。<br>（注意，SSH连接隧道由SSH Client发起建立，但是一旦得以建立SSH Client和SSH Server都可在SSH连接隧道上发起数据通信请求。因而“RemoteHost”上的应用程序发起建立应用连接的请求，进而由SSH Server在SSH连接隧道上发起相应的数据通信请求是可行的）<br>具体的数据流图如图2所示。</p>
<p>图2<br><img src="https://blog.dslztx.top/imgs/20170215-0-2.jpg"></p>
<p>有以下几点需要注意：</p>
<ul>
<li>执行<code>ssh -R [bind_address:]port:host:hostport RemoteHost</code>建立SSH连接隧道，设置好被监听的转发端口，转发目标地址和端口等参数</li>
<li>应用连接由“RemoteHost”上的应用程序发起建立</li>
<li>在应用连接由“RemoteHost”上的应用程序发起建立之后：<br>当“bind_address”为“127.0.0.1&#x2F;localhost”，“host”为“127.0.0.1&#x2F;localhost”时，数据流通道为：数据通道2——数据通道3——SSH隧道——数据通道5；当“bind_address”为“非‘127.0.0.1&#x2F;localhost’”的某个特定地址，“host”为“127.0.0.1&#x2F;localhost”时，数据流通道为：数据通道1——数据通道3——SSH隧道——数据通道5。依此类推</li>
</ul>
<h3 id="2-3、动态转发"><a href="#2-3、动态转发" class="headerlink" title="2.3、动态转发"></a><strong>2.3、动态转发</strong></h3><h4 id="2-3-1、建立ssh连接命令"><a href="#2-3-1、建立ssh连接命令" class="headerlink" title="2.3.1、建立ssh连接命令"></a><strong>2.3.1、建立ssh连接命令</strong></h4><p>在本场景中，使用ssh程序建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D [bind_address:]port RemoteHost</span><br></pre></td></tr></table></figure>
<h5 id="2-3-1-1、选项含义"><a href="#2-3-1-1、选项含义" class="headerlink" title="2.3.1.1、选项含义"></a><strong>2.3.1.1、选项含义</strong></h5><p><strong>1、“port”</strong><br>本地机器的端口号，被监听的动态转发端口<br><strong>2、“bind_address”</strong><br>表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道。当“bind_address”值为“localhost”或“127.0.0.1”时，相当于一个相对地址，它的绝对地址是本地机器，表示只有来自自身的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值不为“localhost”或者“127.0.0.1”，而为特定的某个域名或者IP地址时，它的绝对地址就是“bind_address”值，表示只有来自“bind_address”地址的对“port”端口的访问才被允许通过SSH隧道；当“bind_address”值为“*”或者为空时，没有所谓的绝对地址，表示来自所有地址的对“port”端口的访问都被允许通过SSH隧道（即以“本地机器”为参照基准）</p>
<h5 id="2-3-1-2、ssh-config文件中对应的配置"><a href="#2-3-1-2、ssh-config文件中对应的配置" class="headerlink" title="2.3.1.2、ssh_config文件中对应的配置"></a><strong>2.3.1.2、ssh_config文件中对应的配置</strong></h5><p>“[bind_address:]port”这些参数的参数值可以在“ssh_config文件”中配置，具体配置选项是“DynamicForward”。</p>
<h4 id="2-3-2、原理分析"><a href="#2-3-2、原理分析" class="headerlink" title="2.3.2、原理分析"></a><strong>2.3.2、原理分析</strong></h4><p>建立的SSH连接被应用作为隧道，由于SSH Client端设定被监听的应用动态转发端口，因此应用连接必须由本地机器上的应用程序发起建立，但是跟“本地转发”不一样的是，转发目标地址和转发目标端口都根据应用协议动态获得。这被称为<font color='red'>动态转发</font>。<br>其实在动态转发的过程中，主要应用的协议是“SOCKS4”或者“SOCKS5”，而不是“SSH”，此时SSH Client和SSH Server的身份分别是SOCKS Client和SOCKS Server。（OpenSSH默认不仅支持实现了SSH协议，还支持实现了SOCKS4和SOCKS5协议）。<br>具体的数据流图如图3所示。</p>
<p>图3<br><img src="https://blog.dslztx.top/imgs/20170215-0-3.jpg"></p>
<p>有以下几点需要注意：</p>
<ul>
<li>执行<code>ssh -D [bind_address:]port RemoteHost</code>建立SSH连接隧道，设置好被监听的转发端口等参数</li>
<li>应用连接由本地机器上的应用程序发起建立</li>
<li>在应用连接由本地机器上的应用程序发起建立之后：<br>当“bind_address”为“127.0.0.1&#x2F;localhost”，“转发目标地址和目标端口”为<code>http://127.0.0.1/localhost:8080</code>时，数据流通道为：数据通道2——数据通道3——SSH隧道——数据通道5；当“bind_address”为“非‘127.0.0.1&#x2F;localhost’”的某个特定地址，“转发目标地址和目标端口”为<code>http://www.youtube.com:80</code>时，数据流通道为：数据通道1——数据通道3——SSH隧道——数据通道4。依此类推</li>
</ul>
<h3 id="2-4、图形界面扩展应用场景"><a href="#2-4、图形界面扩展应用场景" class="headerlink" title="2.4、图形界面扩展应用场景"></a><strong>2.4、图形界面扩展应用场景</strong></h3><h4 id="2-4-1、建立ssh连接命令"><a href="#2-4-1、建立ssh连接命令" class="headerlink" title="2.4.1、建立ssh连接命令"></a><strong>2.4.1、建立ssh连接命令</strong></h4><p>在本场景中，使用ssh程序建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -X RemoteHost  </span><br></pre></td></tr></table></figure>
<h5 id="2-4-1-1、选项含义"><a href="#2-4-1-1、选项含义" class="headerlink" title="2.4.1.1、选项含义"></a><strong>2.4.1.1、选项含义</strong></h5><p><strong>1、“-X”</strong><br>表示允许图形界面扩展</p>
<h5 id="2-4-1-2、ssh-config文件中对应的配置"><a href="#2-4-1-2、ssh-config文件中对应的配置" class="headerlink" title="2.4.1.2、ssh_config文件中对应的配置"></a><strong>2.4.1.2、ssh_config文件中对应的配置</strong></h5><p>“-X”允许图形界面扩展，可以在“ssh_config文件”中配置，具体配置选项是“ForwardX11”。</p>
<h4 id="2-4-2、原理分析"><a href="#2-4-2、原理分析" class="headerlink" title="2.4.2、原理分析"></a><strong>2.4.2、原理分析</strong></h4><p>建立的SSH连接被应用连接作为隧道，允许打开SSH Server所在机器上的图形界面应用程序并在SSH Client所在机器上显示，本应用场景的另外一个称呼是建立“X11”SSH连接。<br>在本场景中，X Client和X Server并没有通过X Protocol直接连接传输数据，而是通过SSH连接隧道传输数据，因而也属于SSH隧道应用范畴。<br>具体的数据流图如图4所示。</p>
<p>图4<br><img src="https://blog.dslztx.top/imgs/20170215-0-4.jpg"></p>
<p>有以下几点需要注意：</p>
<ul>
<li>SSH Client开启“-X”选项需要SSH Server的支持，SSH Server可以在“sshd_config文件”中配置是否开启支持“-X”选项。详细内容可参见“man 5 sshd_config”中关于“X11”的内容</li>
<li>执行<code>ssh -X RemoteHost</code>建立“X11”SSH连接隧道</li>
<li>根据“X Window System”的介绍，X Server由“DISPLAY”这个环境变量指定，在建立“X11”SSH连接的过程中，会自动配置“RemoteHost”上的“DISPLAY”环境变量，并最终使得SSH Server被作为一个虚拟的X Server。此时SSH Client被作为一个虚拟的X Client</li>
<li>在“X11”SSH连接建立之后，即SSH连接隧道得以建立，此时由SSH Client发起打开“RemoteHost”上的图形界面应用程序的请求（必须由SSH Client发起，因为SSH Client并没有作为虚拟的X Server），接下来应用程序的图形数据从“RemoteHost”上相应的X Client传递到“RemoteHost”上的SSH Server（虚拟X Server），接着通过SSH隧道传递到本地机器上的SSH Client（虚拟X Client），最后传递给本地机器上的真实X Server。数据流通道为：数据通道2——SSH隧道——数据通道1</li>
</ul>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、打印日志信息"><a href="#3-1、打印日志信息" class="headerlink" title="3.1、打印日志信息"></a><strong>3.1、打印日志信息</strong></h3><p>在执行ssh命令的时候，可以加入“-v”选项，“-v”选项表示打印日志信息，这有助于我们进行调试，解决遇到的问题。最多可以加入3个“-v”选项，“-v”选项越多，表示打印的日志信息越详细。</p>
<h3 id="3-2、端口选择原则"><a href="#3-2、端口选择原则" class="headerlink" title="3.2、端口选择原则"></a><strong>3.2、端口选择原则</strong></h3><p>不管是在本地转发，远端转发还是动态转发中，被监听的用来转发的端口的端口号必须大于1023（否则需要root权限），并且该端口不被其他程序所占用。</p>
<h3 id="3-3、关于在“本地转发，远端转发，动态转发”中提及到的“-bind-address-port”的几点注意事项"><a href="#3-3、关于在“本地转发，远端转发，动态转发”中提及到的“-bind-address-port”的几点注意事项" class="headerlink" title="3.3、关于在“本地转发，远端转发，动态转发”中提及到的“[bind_address:]port”的几点注意事项"></a><strong>3.3、关于在“本地转发，远端转发，动态转发”中提及到的“[bind_address:]port”的几点注意事项</strong></h3><p>1、“bind_address”值为“*”或者“为空”中的“为空”，是指这样的形式“:port”，而不是这样的形式“port”<br>2、在“ssh_config文件”（在远端转发中，相应的是“sshd_config文件”）中可以配置“GatewayPorts”参数值。当该值为“yes”时，“port”等价于“*:port”；当该值为“no”时，“port”等价于“localhost:port”<br>3、在执行ssh命令时，加入“-g”选项，等价于“*:port”的形式<br>4、为了更好的可读性和更精准的定义，“bind_address”还是显式配置比较好</p>
<br/>
参考文献：
[1]man ssh
[2]http://docstore.mik.ua/orelly/networking_2ndEd/ssh/ch09_03.htm
[3]http://blog.csdn.net/dslztx/article/details/46654383
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh命令之ProxyCommand选项</title>
    <url>/blog/2017/05/19/ssh%E5%91%BD%E4%BB%A4%E4%B9%8BProxyCommand%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a><strong>一、背景介绍</strong></h2><p>有一台机器A，欲与机器C建立SSH连接，但由于隔离限制（比如“存在防火墙”）该SSH连接不能直接建立。<br>ssh命令的“ProxyCommand”选项被设计用来解决以上问题。</p>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>通过“ProxyCommand”选项，机器A能够灵活使用任意代理机制与机器C上的SSH Server端口建立连接，接着机器A上的SSH Client再与该连接进行数据交互，从而机器A上的SSH Client与机器C上的SSH Server之间建立了与一般“直接SSH连接”不太一样的“间接SSH连接”。不过由于“间接SSH连接”的透明性，逻辑上可认为机器A上的SSH Client与机器C上的SSH Server建立了“直接SSH连接”。<br>“直接SSH连接”示意图如图1，“间接SSH连接”示意图如图2。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170519-0-1.jpg"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170519-0-2.jpg"></p>
<p>常使用代理机制有两种，接下来进行介绍。</p>
<h2 id="三、常使用代理机制"><a href="#三、常使用代理机制" class="headerlink" title="三、常使用代理机制"></a><strong>三、常使用代理机制</strong></h2><h3 id="3-1、常使用代理机制1"><a href="#3-1、常使用代理机制1" class="headerlink" title="3.1、常使用代理机制1"></a><strong>3.1、常使用代理机制1</strong></h3><p>“ProxyCommand”选项值形式为“ssh -W C:CPort -l USER -i PRIVATE_KEY -p BPort B”，原理：ssh命令自提供的代理机制，在机器A上另外单独建立与B的SSH连接（使用“-l USER -i PRIVATE_KEY -p BPort B”这些参数），该SSH连接的B端侧与机器C上的SSH Server端口（即“C:CPort”）建立连接，该SSH连接的A端侧与机器A上的SSH Client（即“最终欲建立‘间接SSH连接’在机器A上的SSH Client”）建立连接。<br>假定A上ssh_config配置文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host B</span><br><span class="line">    HostName %h</span><br><span class="line">    User dsl</span><br><span class="line">    Port 1046</span><br><span class="line">    IdentityFile ~/.ssh/id_dsa</span><br><span class="line"></span><br><span class="line">Host C</span><br><span class="line">    HostName %h</span><br><span class="line">    User dsl </span><br><span class="line">    Port 1046</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    ProxyCommand ssh -W %h:%p B</span><br></pre></td></tr></table></figure>
<p>在A上执行<code>ssh C</code>命令，发现A与C成功建立SSH连接。根据以上所述，此时在A上应该有两个SSH进程，一个对应于“A与B的SSH连接”，另外一个对应于“A与C的SSH连接”。在A上执行<code>ps -ef | grep &#39;ssh&#39;</code>命令，得到如下结果，得证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7851  7689 15:55 S pts/10   ssh C</span><br><span class="line">7852  7851 15:55 S pts/10   ssh -W C:1046 B</span><br></pre></td></tr></table></figure>
<h3 id="3-2、常使用代理机制2"><a href="#3-2、常使用代理机制2" class="headerlink" title="3.2、常使用代理机制2"></a><strong>3.2、常使用代理机制2</strong></h3><p>“ProxyCommand”选项值形式为“nc -X 5 -x B:BPort C CPort”，原理：利用“nc”命令，在机器A上使用“nc”命令与代理服务器（即“-x B:BPort”，通过“-X 5”参数来指定与代理服务器的通信协议为“SOCKS4&#x2F;SOCKS5&#x2F;HTTPS”）建立代理连接，该代理连接的B端侧与机器C上的SSH Server端口（即“C CPort”）建立连接，该代理连接的A端侧与机器A上的SSH Client（即“最终欲建立‘间接SSH连接’在机器A上的SSH Client”）建立连接。<br>假定A上ssh_config配置文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host C</span><br><span class="line">    HostName %h</span><br><span class="line">    User dsl </span><br><span class="line">    Port 1046</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    ProxyCommand nc -X 5 -x B:8989 %h %p </span><br></pre></td></tr></table></figure>
<p>在A上执行<code>ssh C</code>命令，发现A与C成功建立SSH连接。根据以上所述，此时在A上应该有一个NC进程和一个SSH进程，前者对应于“A与B的代理连接”，后者对应于“A与C的SSH连接”。在A上执行<code>ps -ef | grep -e &#39;ssh&#39; -e &#39;nc&#39;</code>命令，得到如下结果，得证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8816  8089 16:08 S pts/10   ssh C</span><br><span class="line">8817  8816 16:08 S pts/10   nc -X 5 -x B:8989 C 1046</span><br></pre></td></tr></table></figure>
<h2 id="四、ssh命令“端口转发”和“ProxyCommand”选项之间的关系"><a href="#四、ssh命令“端口转发”和“ProxyCommand”选项之间的关系" class="headerlink" title="四、ssh命令“端口转发”和“ProxyCommand”选项之间的关系"></a><strong>四、ssh命令“端口转发”和“ProxyCommand”选项之间的关系</strong></h2><p>端口转发包括：本地转发，远端转发和动态转发。其中“本地转发”和“远端转发”属于“静态转发”（因为转发目标端口是固定的）。<br>“ProxyCommand”选项能够使用基于“动态转发”的代理机制（在外面封装“nc”命令层），而不能使用基于“静态转发”的代理机制。</p>
<br/>
参考文献：
[1]man ssh_config
[2]man ssh
[3]https://serverfault.com/questions/337120/ssh-via-3rd-machine
[4]https://www.lainme.com/doku.php/blog/2011/01/%E9%80%8F%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5ssh
[5]http://stackoverflow.com/questions/22635613/what-is-the-difference-between-ssh-proxycommand-w-nc-exec-nc
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh应用实例</title>
    <url>/blog/2017/02/15/ssh%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="一、简单例子"><a href="#一、简单例子" class="headerlink" title="一、简单例子"></a><strong>一、简单例子</strong></h2><h3 id="1-1、本地转发（bind-address-localhost-host-localhost）"><a href="#1-1、本地转发（bind-address-localhost-host-localhost）" class="headerlink" title="1.1、本地转发（bind_address&#x3D;localhost,host&#x3D;localhost）"></a><strong>1.1、本地转发（bind_address&#x3D;localhost,host&#x3D;localhost）</strong></h3><h4 id="1-1-1、环境设定"><a href="#1-1-1、环境设定" class="headerlink" title="1.1.1、环境设定"></a><strong>1.1.1、环境设定</strong></h4><p>现在有机器A和机器B，A中运行SSH Client，B中运行SSH Server，在B中运行着Mysql服务，监听端口为3306。在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-1-2、具体应用"><a href="#1-1-2、具体应用" class="headerlink" title="1.1.2、具体应用"></a><strong>1.1.2、具体应用</strong></h4><p>可以建立一个SSH连接的本地转发，使得监听A中的5010端口，将传输给该端口的数据通过A和B之间的SSH隧道转发给B中的3306端口，即访问A中的5010端口就能够访问B中的3306端口，这样子就能使用B的Mysql服务。（这里限制只有来自于A自身的对5010端口的访问才被允许通过SSH隧道，即设置“bind_address&#x3D;localhost”）<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L localhost:5010:localhost:3306 B  </span><br></pre></td></tr></table></figure>
<h3 id="1-2、远端转发（bind-address-localhost-host-localhost）"><a href="#1-2、远端转发（bind-address-localhost-host-localhost）" class="headerlink" title="1.2、远端转发（bind_address&#x3D;localhost,host&#x3D;localhost）"></a><strong>1.2、远端转发（bind_address&#x3D;localhost,host&#x3D;localhost）</strong></h3><h4 id="1-2-1、环境设定"><a href="#1-2-1、环境设定" class="headerlink" title="1.2.1、环境设定"></a><strong>1.2.1、环境设定</strong></h4><p>现在有机器A和机器B，A处于公司内部网络中，没有自身的对外IP地址，B具有自身的对外IP（即A能够直接访问B，而B不能够直接访问A）。A中运行SSH Client，B中运行SSH Server，A中运行Mysql服务，监听端口为3306。在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-2-2、具体应用"><a href="#1-2-2、具体应用" class="headerlink" title="1.2.2、具体应用"></a><strong>1.2.2、具体应用</strong></h4><p>可以建立一个SSH连接的远端转发，使得监听B中的5010端口，将传输给该端口的数据通过A和B之间的SSH隧道转发给A中的3306端口，即访问B中的5010端口就能够访问A中的3306端口，这样子就能使用A的Mysql服务。（这里限制只有来自于B自身的对5010端口的访问才被允许通过SSH隧道，即设置“bind_address&#x3D;localhost”）<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R localhost:5010:localhost:3306 B  </span><br></pre></td></tr></table></figure>
<h3 id="1-3、动态转发-bind-address-localhost"><a href="#1-3、动态转发-bind-address-localhost" class="headerlink" title="1.3、动态转发(bind_address&#x3D;localhost)"></a><strong>1.3、动态转发(bind_address&#x3D;localhost)</strong></h3><h4 id="1-3-1、环境设定"><a href="#1-3-1、环境设定" class="headerlink" title="1.3.1、环境设定"></a><strong>1.3.1、环境设定</strong></h4><p>现在有机器A和B，A处于某个防火墙内，不能访问有些网页，B处于防火墙之外，能够访问所有网页。A中运行SSH Client，B中运行SSH Server。在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-3-2、具体应用"><a href="#1-3-2、具体应用" class="headerlink" title="1.3.2、具体应用"></a><strong>1.3.2、具体应用</strong></h4><p>可以建立一个SSH连接的动态转发，使得监听A中的5010端口，将传输给该端口的数据通过A和B之间的SSH隧道转发给B，在B处根据应用协议动态决定数据转发的目的地和目的端口，比如<code>http://www.youtube.com:80</code>。即将数据请求传递给A中的5010端口，该数据请求被转发给B，B会根据应用协议动态决定数据请求转发的目的地和目的端口，以B的身份去进行数据请求，然后将返回得到的数据传输给“将数据传递给A中的5010端口的应用程序”。（这里限制只有来自于A自身的对5010端口的访问才被允许通过SSH隧道，即设置“bind_address&#x3D;localhost”）<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D localhost:5010 B  </span><br></pre></td></tr></table></figure>
<h3 id="1-4、“X11”SSH连接"><a href="#1-4、“X11”SSH连接" class="headerlink" title="1.4、“X11”SSH连接"></a><strong>1.4、“X11”SSH连接</strong></h3><h4 id="1-4-1、环境设定"><a href="#1-4-1、环境设定" class="headerlink" title="1.4.1、环境设定"></a><strong>1.4.1、环境设定</strong></h4><p>现在有机器A和机器B，A中运行SSH Client，B中运行SSH Server，B中的sshd_config文件中配置允许建立“X11”SSH连接。<br>在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-4-2、具体应用"><a href="#1-4-2、具体应用" class="headerlink" title="1.4.2、具体应用"></a><strong>1.4.2、具体应用</strong></h4><p>可以建立一个“X11”SSH连接，使得能够打开B中的图形界面应用程序，并在A中显示，数据通过A和B之间的SSH隧道传输。<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -X B  </span><br></pre></td></tr></table></figure>
<h3 id="1-5、本地转发（bind-address-localhost-host-非localhost）"><a href="#1-5、本地转发（bind-address-localhost-host-非localhost）" class="headerlink" title="1.5、本地转发（bind_address&#x3D;localhost,host&#x3D;非localhost）"></a><strong>1.5、本地转发（bind_address&#x3D;localhost,host&#x3D;非localhost）</strong></h3><h4 id="1-5-1、环境设定"><a href="#1-5-1、环境设定" class="headerlink" title="1.5.1、环境设定"></a><strong>1.5.1、环境设定</strong></h4><p>现在有机器A，B和C，A中运行SSH Client，B中运行SSH Server，C中运行Mysql服务，监听端口为3306，A跟C不能直接连接，A跟B能够直接连接，B跟C能够直接连接。在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-5-2、具体应用"><a href="#1-5-2、具体应用" class="headerlink" title="1.5.2、具体应用"></a><strong>1.5.2、具体应用</strong></h4><p>可以建立一个SSH连接的本地转发，使得监听A中的5010端口，将传输给该端口的数据通过A和B之间的SSH隧道转发给C中的3306端口，即访问A中的5010端口就能够访问C中的3306端口，这样子就能使用C的Mysql服务。（这里限制只有来自于A自身的对5010端口的访问才被允许通过SSH隧道，即设置“bind_address&#x3D;localhost”）<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L localhost:5010:C:3306 B  </span><br></pre></td></tr></table></figure>
<h3 id="1-6、远端转发（bind-address-非localhost-host-非localhost）"><a href="#1-6、远端转发（bind-address-非localhost-host-非localhost）" class="headerlink" title="1.6、远端转发（bind_address&#x3D;非localhost,host&#x3D;非localhost）"></a><strong>1.6、远端转发（bind_address&#x3D;非localhost,host&#x3D;非localhost）</strong></h3><h4 id="1-6-1、环境设定"><a href="#1-6-1、环境设定" class="headerlink" title="1.6.1、环境设定"></a><strong>1.6.1、环境设定</strong></h4><p>现在有A，B，C和D四台机器，在这四台机器的两两关系中，只有“A与B”和“C与D”能够直接连接，另外还有“半个连接”，即B处于公司内部网络中，没有自身的对外IP地址，C具有自身的对外IP（即B能够直接访问C，而C不能够直接访问B）。在B中运行SSH Client，在C中运行SSH Server，在A中运行Mysql服务，监听3306端口。在B中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。</p>
<h4 id="1-6-2、具体应用"><a href="#1-6-2、具体应用" class="headerlink" title="1.6.2、具体应用"></a><strong>1.6.2、具体应用</strong></h4><p>可以建立一个SSH连接的远端转发，使得监听C中的5010端口，将传输给该端口的数据通过B和C之间的SSH隧道转发给A中的3306端口，即在D中访问C中的5010端口就能够访问A中的3306端口，这样子就能使用A的Mysql服务。（要设定允许D可以访问C中的5010端口，可以配置“bind_address&#x3D;D”或者“bind_address&#x3D;*”）<br>B中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R D:5010:A:3306 C  </span><br><span class="line">或者  </span><br><span class="line">ssh -R *:5010:A:3306 C  </span><br><span class="line">或者  </span><br><span class="line">ssh -R :5010:A:3306 C  </span><br><span class="line">或者  </span><br><span class="line">ssh -g -R 5010:A:3306 C  </span><br></pre></td></tr></table></figure>
<h2 id="二、复杂例子"><a href="#二、复杂例子" class="headerlink" title="二、复杂例子"></a><strong>二、复杂例子</strong></h2><h3 id="2-1、环境设定"><a href="#2-1、环境设定" class="headerlink" title="2.1、环境设定"></a><strong>2.1、环境设定</strong></h3><p>现在有机器A和B，A处于公司内部网络中，没有自身的对外IP地址，B具有自身的对外IP（即A能够直接访问B，而B不能够直接访问A）。A中运行SSH Client和SSH Server，B中运行SSH Client和SSH Server。在A中的ssh_config文件中已经配置好“Host，HostName，User，Port，IdentityFile”。A中的SSH Server监听端口为22。</p>
<h3 id="2-2、具体应用"><a href="#2-2、具体应用" class="headerlink" title="2.2、具体应用"></a><strong>2.2、具体应用</strong></h3><p>可以建立一个SSH连接的远端转发，使得监听B中的5010端口，将传输给该端口的数据通过A和B之间的SSH隧道转发给A中的22端口，即访问B中的5010端口就能够访问A中的22端口，这样子就能使用A的SSH Server服务。（这里限制只有来自于B自身的对5010端口的访问才被允许通过SSH隧道，即设置“bind_address&#x3D;localhost”）<br>A中建立SSH连接的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R localhost:5010:localhost:22 B  </span><br></pre></td></tr></table></figure>
<p>然后在B中，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 5010 -l loginuser -i identityfile A  </span><br></pre></td></tr></table></figure>
<p>当然这些参数可以在B中的ssh_config文件中通过“Host，HostName，User，Port，IdentityFile”配置。</p>
<h3 id="2-3、总结"><a href="#2-3、总结" class="headerlink" title="2.3、总结"></a><strong>2.3、总结</strong></h3><p>以上是两层SSH连接，第一层SSH连接的身份是隧道，第二层SSH连接的身份是应用连接。<br>不过可以再增加第三层应用，此时第一层和第二层SSH连接的身份都为隧道。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh端口转发真实应用</title>
    <url>/blog/2017/02/15/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%9C%9F%E5%AE%9E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>以下是作者本人在公司工作过程中遇到的案例，使用SSH端口转发进行解决。</p>
<h2 id="一、案例一"><a href="#一、案例一" class="headerlink" title="一、案例一"></a><strong>一、案例一</strong></h2><h3 id="1-1、案例描述"><a href="#1-1、案例描述" class="headerlink" title="1.1、案例描述"></a><strong>1.1、案例描述</strong></h3><p>公司有两个网络A和B，作者的机器A1在网络A中，B中的机器都作为服务器之用，B中的机器互相之间能够连通。现在在B网络中存在两台机器B1和B2：B2对外没有提供IP地址（即A1不能直接连接B2），其上运行有MySQL服务，监听端口为3306；B1对外提供了IP地址（即A1能够直接连接B1），B1上运行SSH Server服务，监听端口为22，A1能够以“dsl”账户与该SSH Server进行连接，相应的私钥文件为“~&#x2F;.ssh&#x2F;dsl_private_key”。<br>现在的需求是：想要使A1能够使用B2的Mysql服务。</p>
<h3 id="1-2、解决方案"><a href="#1-2、解决方案" class="headerlink" title="1.2、解决方案"></a><strong>1.2、解决方案</strong></h3><p>解决方案有两种，一种是本地转发，另外一种是动态转发。<br>假定在A1的“~&#x2F;.ssh&#x2F;config”中已经配置好如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host B1   </span><br><span class="line">    HostName B1的对外IP地址   </span><br><span class="line">    User dsl    </span><br><span class="line">    Port 22  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key   </span><br></pre></td></tr></table></figure>
<h4 id="1-2-1、解决方案1"><a href="#1-2-1、解决方案1" class="headerlink" title="1.2.1、解决方案1"></a><strong>1.2.1、解决方案1</strong></h4><p>在A1上执行以下命令建立SSH的本地转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L localhost:5010:B2:3306 B1  </span><br></pre></td></tr></table></figure>
<p>现在在A1中访问A1中的5010端口就可以使用B2上的Mysql服务。<br>具体的连接B2上的Mysql服务的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 5010 -u &#x27;合法的Mysql账户&#x27; -p&#x27;合法的Mysql密码&#x27;  </span><br></pre></td></tr></table></figure>
<h4 id="1-2-2、解决方案2"><a href="#1-2-2、解决方案2" class="headerlink" title="1.2.2、解决方案2"></a><strong>1.2.2、解决方案2</strong></h4><p>在A1上执行以下命令建立SSH的动态转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D localhost:5010 B1  </span><br></pre></td></tr></table></figure>
<p>另外配置A1上的全局代理，使得A1上所有的对外连接请求都被转发给A1上的5010端口，转发给A1上的5010端口的数据会被转发给A1上的SSH Client，接着A1上的SSH Client通过SSH隧道将连接请求传递给B1上的SSH Server，然后由SSH Server代理去进行这些连接的请求。（注意，此时发起连接请求的源地址是B1，而不再是A1，而B1是有权限访问B2的）<br>此时具体的连接B2上的Mysql服务的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h &#x27;在B网络中B2的内网地址&#x27; -P 3306 -u &#x27;合法的Mysql账户&#x27; -p&#x27;合法的Mysql密码&#x27;  </span><br></pre></td></tr></table></figure>
<h2 id="二、案例二"><a href="#二、案例二" class="headerlink" title="二、案例二"></a><strong>二、案例二</strong></h2><h3 id="2-1、案例描述"><a href="#2-1、案例描述" class="headerlink" title="2.1、案例描述"></a><strong>2.1、案例描述</strong></h3><p>公司有两个网络A和B，作者的机器A1在网络A中，B中的机器都作为服务器之用，B中的机器互相之间能够连通。现在在B网络中存在两台机器B1和B2：B2对外没有提供IP地址（即A1不能直接连接B2），其上运行有Web服务，监听端口为8080；B1对外提供了IP地址（即A1能够直接连接B1），B1上运行SSH Server服务，监听端口为22，A1能够以“dsl”账户与该SSH Server进行连接，相应的私钥文件为“~&#x2F;.ssh&#x2F;dsl_private_key”。<br>现在的需求是：想要使A1能够使用B2的Web服务。</p>
<h3 id="2-2、解决方案"><a href="#2-2、解决方案" class="headerlink" title="2.2、解决方案"></a><strong>2.2、解决方案</strong></h3><p>解决方案有两种，一种是本地转发，另外一种是动态转发。<br>假定在A1的“~&#x2F;.ssh&#x2F;config”中已经配置好如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host B1   </span><br><span class="line">    HostName B1的对外IP地址   </span><br><span class="line">    User dsl    </span><br><span class="line">    Port 22  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key    </span><br></pre></td></tr></table></figure>
<h4 id="2-2-1、解决方案1"><a href="#2-2-1、解决方案1" class="headerlink" title="2.2.1、解决方案1"></a><strong>2.2.1、解决方案1</strong></h4><p>在A1上执行以下命令建立SSH的本地转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L localhost:5010:B2:8080 B1  </span><br></pre></td></tr></table></figure>
<p>现在在A1中访问A1中的5010端口就可以使用B2上的Web服务。<br>具体的使用B2上的Web服务的方式如下：在A1的浏览器中访问<code>http://localhost:5010</code>。</p>
<h4 id="2-2-2、解决方案2"><a href="#2-2-2、解决方案2" class="headerlink" title="2.2.2、解决方案2"></a><strong>2.2.2、解决方案2</strong></h4><p>在A1上执行以下命令建立SSH的动态转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D localhost:5010 B1  </span><br></pre></td></tr></table></figure>
<p>另外配置A1上的全局代理，使得A1上所有的对外连接请求都被转发给A1上的5010端口，转发给A1上的5010端口的数据会被转发给A1上的SSH Client，接着A1上的SSH Client通过SSH隧道将连接请求传递给B1上的SSH Server，然后由SSH Server代理去进行这些连接的请求。（注意，此时发起连接请求的源地址是B1，而不再是A1，而B1是有权限访问B2的）<br>此时具体的使用B2上的Web服务的方式如下：在A1的浏览器中访问<code>http://‘在B网络中B2的内网地址’:8080</code>。</p>
<h2 id="三、案例三"><a href="#三、案例三" class="headerlink" title="三、案例三"></a><strong>三、案例三</strong></h2><h3 id="3-1、案例描述"><a href="#3-1、案例描述" class="headerlink" title="3.1、案例描述"></a><strong>3.1、案例描述</strong></h3><p>公司有两个网络A和B，作者的机器A1在网络A中，B中的机器都作为服务器之用，B中的机器互相之间能够连通。现在在B网络中存在N台机器B1，B2，B3，B4…BN。B2到BN这些机器对外都没有提供IP地址（即A1不能直接连接这些机器），这些机器上面都运行有Web服务，监听端口位于“8080-8090”范围之内；B1对外提供了IP地址（即A1能够直接连接B1），B1上运行SSH Server服务，监听端口为22，A1能够以“dsl”账户与该SSH Server进行连接，相应的私钥文件为“~&#x2F;.ssh&#x2F;dsl_private_key”。<br>现在的需求是：想要使A1能够访问B2到BN这些机器的Web服务。</p>
<h3 id="3-2、解决方案"><a href="#3-2、解决方案" class="headerlink" title="3.2、解决方案"></a><strong>3.2、解决方案</strong></h3><p>解决方案有两种，一种是本地转发，另外一种是动态转发。<br>假定在A1的“~&#x2F;.ssh&#x2F;config”中已经配置好如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host B1   </span><br><span class="line">    HostName B1的对外IP地址   </span><br><span class="line">    User dsl    </span><br><span class="line">    Port 22  </span><br><span class="line">    IdentityFile ~/.ssh/dsl_private_key    </span><br></pre></td></tr></table></figure>
<h4 id="3-2-1、解决方案1"><a href="#3-2-1、解决方案1" class="headerlink" title="3.2.1、解决方案1"></a><strong>3.2.1、解决方案1</strong></h4><p>首先获取B2-BN这些机器上Web服务对应的端口，比如分别为“8080，8081，8082…8090”，然后在A1上针对每台机器建立一个SSH本地转发，SSH命令形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L localhost:5010:B2:8080 B1  </span><br><span class="line">ssh -L localhost:5011:B3:8081 B1  </span><br><span class="line">ssh -L localhost:5012:B4:8082 B1  </span><br><span class="line">ssh -L localhost:5013:B5:8083 B1  </span><br></pre></td></tr></table></figure>
<p>现在在A1中访问A1中的5010端口就可以访问B2上的Web服务，访问A1中的5011端口就可以访问B3上的Web服务，依此类推。<br>具体的使用B2上的Web服务的方式如下：在A1的浏览器中访问<code>http://localhost:5010</code>。<br>以上方案繁杂不方便，如果“B2到BN”的机器数量非常大，那么工作量会非常巨大。</p>
<h4 id="3-2-2、解决方案2"><a href="#3-2-2、解决方案2" class="headerlink" title="3.2.2、解决方案2"></a><strong>3.2.2、解决方案2</strong></h4><p>在A1上执行以下命令建立SSH的动态转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D localhost:5010 B1  </span><br></pre></td></tr></table></figure>
<p>另外配置A1上的全局代理，使得A1上所有的对外连接请求都被转发给A1上的5010端口，转发给A1上的5010端口的数据会被转发给A1上的SSH Client，接着A1上的SSH Client通过SSH隧道将连接请求传递给B1上的SSH Server，然后由SSH Server代理去进行这些连接的请求。（注意，此时发起连接请求的源地址是B1，而不再是A1，而B1是有权限访问B2到BN的）<br>此时具体的访问B2上的Web服务（假定Web服务端口为8080）的方式如下：在A1的浏览器中访问<code>http://‘在B网络中B2的内网地址’:8080</code>。<br>此时具体的访问B3上的Web服务（假定Web服务端口为8081）的方式如下：在A1的浏览器中访问<code>http://‘在B网络中B3的内网地址’:8081</code>。<br>此时具体的访问B4上的Web服务（假定Web服务端口为8082）的方式如下：在A1的浏览器中访问<code>http://‘在B网络中B4的内网地址’:8082</code>。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>stat命令</title>
    <url>/blog/2016/12/22/stat%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stat 文件路径</span><br></pre></td></tr></table></figure>
<h2 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a><strong>二、含义</strong></h2><p>打印文件的详细信息。<br>比如现在有一个“readme.md”文件，执行<code>stat readme.md</code>命令，可得如图1所示结果。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20161222-0-1.png"></p>
<p>有一个“Desktop”目录，执行<code>stat Desktop</code>命令，可得如图2所示结果。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20161222-0-2.png"></p>
<h2 id="三、打印信息属性介绍"><a href="#三、打印信息属性介绍" class="headerlink" title="三、打印信息属性介绍"></a><strong>三、打印信息属性介绍</strong></h2><p>“文件”：文件名称。<br>“大小”：表示文件的大小。对于“一般文件”，显示的是“使用大小”；对于“目录文件”，并没有累加统计该目录文件下的子文件的大小，而是显示该目录文件自身的“占用大小”（关于文件的“使用大小”和“占用大小”可见<a href="/blog/2016/10/18/Ext%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E2%80%9C%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D%E5%92%8C%E2%80%9C%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F%E2%80%9D/" title="Ext文件系统中，文件的“占用大小”和“使用大小”">《Ext文件系统中，文件的“占用大小”和“使用大小”》</a>）（<font color='red'>显示文件大小的方式跟<code>ls</code>命令一致。</font>）<br>“块”：这个“块”不是指“inode&#x2F;block”体系中的“block”数量，而是指某种容量单元的数量。可通过公式<code>块*单个该种容量单元所含字节数/一个block所含字节数</code>换算得到需要的“block”数量，其中单个该种容量单元所含字节数，可通过<code>stat --format=%B readme</code>命令获得。假如单个该种容量单元含有字节数为“512B”，一个“block”含有字节数为“4096B”，现在“块&#x3D;8”，那么“block数量&#x3D;1”。注意，这个属性极易被混淆。<br>“IO 块”：optimal I&#x2F;O transfer size hint（作者不知道该属性的含义）。<br>“普通文件&#x2F;目录”：表示“文件类型”为“普通文件&#x2F;目录”。<br>“设备”：设备号。<br>“Inode”：Inode节点号。<br>“硬链接”：文件的硬链接计数值。<br>“权限”：文件“读取执行权限”信息。<br>“Uid”：文件所属用户信息。<br>“Gid”：文件所属组信息。<br>“最近访问”：即“atime”值。<br>“最近更改”：即“mtime”值。<br>“最近改动”：即“ctime”值。<br>“创建时间”：即文件创建时间，一般情况下该值为空。</p>
<br/>
参考文献：
[1]man stat
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized-volatile-final关键词</title>
    <url>/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="一、Java语法语义"><a href="#一、Java语法语义" class="headerlink" title="一、Java语法语义"></a><strong>一、Java语法语义</strong></h2><h3 id="1-1、synchronized关键词"><a href="#1-1、synchronized关键词" class="headerlink" title="1.1、synchronized关键词"></a><strong>1.1、synchronized关键词</strong></h3><ol start="0">
<li>实现Java语言内置锁</li>
<li>实现happens-before规则——<code>对一个锁的解锁，happens-before于随后对这个锁的加锁</code></li>
</ol>
<h3 id="1-2、volatile关键词"><a href="#1-2、volatile关键词" class="headerlink" title="1.2、volatile关键词"></a><strong>1.2、volatile关键词</strong></h3><ol start="0">
<li>针对所有基本类型和引用类型的<font color='red'>简单读写</font>操作（一个易混淆点，“变量自增”和“变量自减”不是<font color='red'>简单读写</font>操作）是否是原子的：<ul>
<li>非volatile变量。除了<code>long</code>和<code>double</code>之外的基本类型和引用类型，其非volatile变量的<font color='red'>简单读写</font>操作是原子的；而对于<code>long</code>和<code>double</code>基本类型，其非volatile变量的<font color='red'>简单读写</font>操作不一定是原子的[1]</li>
<li>volatile变量。对所有基本类型和引用类型，其volatile变量的<font color='red'>简单读写</font>操作是原子的</li>
</ul>
</li>
<li>在现代多CPU&#x2F;CPU核处理器架构下，为提升存取性能，引入了<code>高速缓存-写缓冲器-失效队列</code>机制，该机制会导致“狭义内存可见性”问题，使用volatile关键词解决该问题。“volatile变量写”对于后续的“volatile变量读”立即可见</li>
<li>实现happens-before规则——<code>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</code></li>
</ol>
<br/>

<p><strong>备注</strong>：</p>
<ul>
<li>在上述3个语法语义中，最有价值的是第3个，其余两个价值不大</li>
<li>在上述第1点和第3点中，提及到了“后续”，其实在并发环境中，“后续”的判定十分困难。在应用第3点中的happens-before规则时，如何绕过“后续”的判定可参见<a href="/blog/2019/12/17/happens-before%E8%A7%84%E5%88%99/" title="happens-before规则">《happens-before规则》</a></li>
</ul>
<h3 id="1-3、final关键词"><a href="#1-3、final关键词" class="headerlink" title="1.3、final关键词"></a><strong>1.3、final关键词</strong></h3><ol start="0">
<li>表示“不可改变的”：<ul>
<li>final类不能被继承</li>
<li>final方法不能被子类的方法覆盖，需要注意的是，final不能用于修饰构造方法</li>
<li>final变量只能被赋值一次，赋值后值不再改变</li>
</ul>
</li>
<li>提供一个内存可见语义规则，详见“3.3、final关键词内存可见语义规则”小节</li>
</ol>
<h2 id="二、实现概述"><a href="#二、实现概述" class="headerlink" title="二、实现概述"></a><strong>二、实现概述</strong></h2><p>Java语言实现通过各种机制实现上述语法语义，手段包括使用“内存屏障”，“CAS操作”等。需要注意的是，这里所说的“内存屏障”和“CAS操作”是全层次的，即“既包含JVM指令层的内存屏障指令&#x2F;CAS指令，也包含处理器指令层的内存屏障指令&#x2F;CAS指令”，当然最后执行的是处理器指令层的内存屏障指令&#x2F;CAS指令。<br>比如：</p>
<ol>
<li>实现synchronized关键词相关的<code>hotspot/src/share/vm/runtime/objectMonitor.cpp:733</code>C++源代码处的<code>OrderAccess::fence()</code>内存屏障指令调用</li>
<li>实现volatile关键词内存语义：<ol>
<li>volatile变量简单读写操作最终映射到的目标机器指令是原子的</li>
<li>为实现volatile变量写语义，对于volatile变量写操作应该有个绑定型内存屏障：其语义是“刷新缓存到内存，并使相应的缓存失效（这样子读取volatile变量时从内存重新加载最新值）”。需要绑定型内存屏障，是为了避免目标操作和内存屏障之间插入其他操作，关于绑定型内存屏障的介绍参见<a href="/blog/2020/02/13/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" title="内存屏障">《内存屏障》</a></li>
<li>为实现volatile关键词的happens-before规则语义，在以上第2点的基础上，还需要按照以下方案添加内存屏障。可以发现，对于<code>在每个volatile写操作的前面插入一个LoadStore内存屏障</code>，<code>在每个volatile写操作的前面插入一个StoreStore内存屏障</code>和<code>volatile变量写操作应该有个绑定型内存屏障</code>的要求，可以用一个绑定型的StoreLoad内存屏障进行替代（因为StoreLoad内存屏障是“全能型”内存屏障，同时具有StoreStore，LoadLoad和LoadStore内存屏障的效果）。<font color='red'>需要说明的是，这里的描述掺杂了笔者的自我理解，跟书本《Java并发编程的艺术》P43的描述并不一致，如有错误，请不吝赐教</font>：<ul>
<li>在每个volatile写操作的前面插入一个LoadStore内存屏障</li>
<li>在每个volatile写操作的前面插入一个StoreStore内存屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad内存屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore内存屏障</li>
</ul>
</li>
</ol>
</li>
<li>实现final关键词内存可见语义规则（在《Java Language Specification》中，通过<code>freeze action</code>来实现[2][3]）：<ul>
<li>围绕对final实例成员变量赋值的构造方法C，C隐含有一个<code>return</code>语句，C内非final实例成员变量赋值操作允许重排序到<code>return</code>之后，C内final实例成员变量赋值操作禁止重排序到<code>return</code>之后，然后在<font color='red'>紧邻<code>return</code>之前</font>插入一个特殊的StoreStore内存屏障，为什么说是“特殊的StoreStore内存屏障”呢？因为正常的StoreStore内存屏障如果在紧邻<code>return</code>之前插入，那么C内所有的操作都应该被禁止重排序到<code>return</code>之后，比如在“3.3、final关键词内存可见语义规则”小节中，示例代码3的构造方法内<code>i</code>实例成员变量的赋值可重排序到构造方法之外。<font color='red'>跟《Java并发编程的艺术》叙述有一定冲突，但感觉笔者的理解才是正确的</font></li>
<li>在“读实例对象引用”和“读该实例对象的final实例成员变量”之间插入一个LoadLoad内存屏障，避免上述两个操作的重排序</li>
</ul>
</li>
</ol>
<br/>
具体实现有很多细节，太难也没有必要过度深入，因为主要矛盾在于宏观使用！

<h2 id="三、final关键词详解"><a href="#三、final关键词详解" class="headerlink" title="三、final关键词详解"></a><strong>三、final关键词详解</strong></h2><h3 id="3-1、编译期常量"><a href="#3-1、编译期常量" class="headerlink" title="3.1、编译期常量"></a><strong>3.1、编译期常量</strong></h3><p><strong>编译期常量定义</strong>：如果一个类的成员变量（包括“类成员变量”和“实例成员变量”）由final关键词修饰，其类型为基本类型或者String类型，且在定义时赋“字面量”值，那么该变量为编译期常量。比如<code>final int a = 10</code>，<code>static final long b = 20L</code>，<code>final String s = &quot;hello world&quot;</code>。<br><strong>编译期常量的特殊之处</strong>：编译时会直接以对应的“字面量”值替换变量的使用。</p>
<h3 id="3-2、匿名内部类访问外围变量"><a href="#3-2、匿名内部类访问外围变量" class="headerlink" title="3.2、匿名内部类访问外围变量"></a><strong>3.2、匿名内部类访问外围变量</strong></h3><p>匿名内部类访问外围变量须遵守规则——<code>匿名内部类来自外部闭包环境的自由变量必须是final的</code>。那么哪些变量是“自由变量”？只有匿名内部类所在外围方法的局部变量才是“自由变量”，也即所在外围类的实例成员变量和类成员变量都不是“自由变量”。</p>
<p>作出以上区分的本质原因在于访问变量的不同方式：</p>
<ul>
<li>对于外围类的实例成员变量和类成员变量，匿名内部类通过“外围类类名”或者“外围类实例对象引用”的方式进行访问，后续对该变量的修改可传导到匿名内部类中</li>
<li>对于外围方法的局部变量，匿名内部类通过复制变量的方式进行访问，后续对该变量的修改不可传导到匿名内部类中，为避免“看似修改成功-实则修改未成功”的歧义和误导，语法索性直接规定该局部变量必须是<code>final</code>的，后续修改操作是非法的</li>
</ul>
<p><strong>需要注意的是</strong>：在JDK 1.8之前，对于自由变量需要显式声明<code>final</code>关键词，而在JDK 1.8之后，编译器会帮你隐式声明，但我们最好还是显式声明下明确化这点。</p>
<p><strong>1、例子1</strong><br>原代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Obj</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        a = <span class="number">20</span>;                    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        b = new Obj(&quot;world&quot;);    // 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Obj</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次执行<code>javac AnonymousInnerClass0.java</code>和<code>javap -v AnonymousInnerClass0\$1.class</code>命令，可知匿名内部类的实际构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousInnerClass0$1</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Obj val$b;</span><br><span class="line">    descriptor: LObj;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> AnonymousInnerClass0 <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">    descriptor: LAnonymousInnerClass0;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  AnonymousInnerClass0$<span class="number">1</span>(AnonymousInnerClass0, Obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上可知，匿名内部类访问外围类实例成员变量<code>a</code>的方式是通过外围类实例对象引用<code>this$0</code>，访问外围方法局部变量<code>b</code>的方式是复制到本类的实例成员变量<code>val$b</code>，故“&#x2F;&#x2F; 1”处修改可传导到匿名内部类中，而“&#x2F;&#x2F; 2”处修改不可传导到匿名内部类中，为避免歧义和误导，语法索性直接规定需要将<code>b</code>变量设为<code>final</code>的，使得“&#x2F;&#x2F; 2”处操作直接为非法的。</p>
<p><strong>2、例子2</strong><br>原代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Obj</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        a = <span class="number">20</span>;                       <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        b = new Obj(&quot;world&quot;);       // 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Obj</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次执行<code>javac AnonymousInnerClass1.java</code>和<code>javap -v AnonymousInnerClass1\$1.class</code>命令，可知匿名内部类的实际构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass1$1</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Obj val$b;</span><br><span class="line">    descriptor: LObj;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  AnonymousInnerClass1$<span class="number">1</span>(Obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上可知，匿名内部类访问外围类类成员变量<code>a</code>的方式是通过外围类类名，访问外围方法局部变量<code>b</code>的方式是复制到本类的实例成员变量<code>val$b</code>，故“&#x2F;&#x2F; 1”处修改可传导到匿名内部类中，“&#x2F;&#x2F; 2”处修改不可传导到匿名内部类中，为避免歧义和误导，语法索性直接规定需要将<code>b</code>变量设为<code>final</code>的，使得“&#x2F;&#x2F; 2”处操作直接为非法的。</p>
<h3 id="3-3、final关键词内存可见语义规则"><a href="#3-3、final关键词内存可见语义规则" class="headerlink" title="3.3、final关键词内存可见语义规则"></a><strong>3.3、final关键词内存可见语义规则</strong></h3><h4 id="3-3-1、含义"><a href="#3-3-1、含义" class="headerlink" title="3.3.1、含义"></a><strong>3.3.1、含义</strong></h4><p>在《Java Language Specification》中[4]，正式的英文叙述是：</p>
<blockquote>
<p>The usage model for final fields is a simple one: Set the final fields for an object in that object’s constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object’s constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object’s final fields. It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are</p>
</blockquote>
<p>形象的案例叙述是：</p>
<blockquote>
<p>在示例代码0中，对于“&#x2F;&#x2F; 13”这个final实例成员变量的读操作来说，“&#x2F;&#x2F; 3 4 11”操作对其内存可见；而对于“&#x2F;&#x2F; 12”这个非final实例成员变量的读操作来说，“&#x2F;&#x2F; 10”操作可能重排序到构造方法之外，故不一定内存可见，更不用说“&#x2F;&#x2F; 1 2”操作</p>
</blockquote>
<p>示例代码0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line">    Person person0;</span><br><span class="line">    <span class="keyword">final</span> Person person1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalExample</span><span class="params">(Person person0, Person person1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person0 = person0;                                           <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.person1 = person1;                                           <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;浙江&quot;</span>, <span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;西湖村&quot;</span>);    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dslztx0&quot;</span>, <span class="number">31</span>, address0);             <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">address1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;浙江&quot;</span>, <span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;西溪村&quot;</span>);    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dslztx1&quot;</span>, <span class="number">31</span>, address1);             <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>(<span class="string">&quot;no&quot;</span>);                              <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Repo</span> <span class="variable">repo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Repo</span>(<span class="string">&quot;github&quot;</span>);                                   <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">5</span>;                                                        <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">6</span>;                                                        <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;                                                        <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">FinalExample</span>(person0, person1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">personValue0</span> <span class="operator">=</span> obj.person0;                            <span class="comment">// 12</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">personValue1</span> <span class="operator">=</span> obj.person1;                            <span class="comment">// 13</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String nation;</span><br><span class="line"></span><br><span class="line">    String province;</span><br><span class="line"></span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    String country;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String nation, String province, String city, String country)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nation = nation;</span><br><span class="line">        <span class="built_in">this</span>.province = province;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">        <span class="built_in">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Repo</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Repo</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中文正式叙述是：</p>
<blockquote>
<p>对于final实例成员变量，当满足“在构造方法中对final实例成员变量赋值”和“在构造方法中不提前‘逸出’正在构造对象的引用”这两个条件时，就能够有语义确保：<code>使用构造完成对象访问其final实例成员变量，与该final实例成员变量相关的所有内存操作都可见</code>，为更好理解“与该final实例成员变量相关的所有内存操作都可见”，可参考示例代码1<br>在以上语义确保中，避免了本来需要考虑的两个问题：1）由于重排序，“构造方法语句”可能重排序到“读取到对象引用”之后，在以上场景中，“与该final实例成员变量相关的所有内存操作”不会重排序到“读取到对象引用”之后；2）由于重排序，“读取对象成员变量”可能重排序到“读取到对象引用”之前，在以上场景中，“读取对象final实例成员变量”不会重排序到“读取到对象引用”之前</p>
</blockquote>
<p>示例代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object0 object0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object1 object1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object2 object2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        object0 = <span class="keyword">new</span> <span class="title class_">Object0</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];                      <span class="comment">//2</span></span><br><span class="line">        b[<span class="number">1</span>] = <span class="number">20</span>;                                 <span class="comment">//3</span></span><br><span class="line">        b[<span class="number">2</span>] = <span class="number">30</span>;                                 <span class="comment">//4</span></span><br><span class="line">        b[<span class="number">3</span>] = <span class="number">40</span>;                                 <span class="comment">//5</span></span><br><span class="line">        b[<span class="number">4</span>] = <span class="number">50</span>;                                 <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">        object1 = <span class="keyword">new</span> <span class="title class_">Object1</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dslztx&quot;</span>, <span class="number">31</span>);  <span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        object2 = <span class="keyword">new</span> <span class="title class_">Object2</span>(person, <span class="string">&quot;china&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object0 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对于“//11”，“//1”操作对其内存可见</span></span><br><span class="line">            System.out.println(object0.a);         <span class="comment">//11</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对于“//12”，“//2 3 4 5 6 7 8”操作对其内存可见</span></span><br><span class="line">            System.out.println(object1.array);     <span class="comment">//12</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对于“//13”，“//9 10”操作对其内存可见</span></span><br><span class="line">            System.out.println(object2.person);    <span class="comment">//13</span></span><br><span class="line">            System.out.println(object2.nation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object0</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Object0</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;                               <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object1</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Object1</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;                       <span class="comment">//7</span></span><br><span class="line">        <span class="built_in">this</span>.array[<span class="number">0</span>] = <span class="number">10</span>;                       <span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object2</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Person person;</span><br><span class="line"></span><br><span class="line">    String nation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Object2</span><span class="params">(Person person, String nation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;                    <span class="comment">//10</span></span><br><span class="line">        <span class="built_in">this</span>.nation = nation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p><font color='red'>要特别注意“final关键词内存可见语义规则”适用的限定条件</font>：</p>
<ul>
<li>“在构造方法返回之前，被构造对象的实例对象引用不被其他线程所见”，故示例代码2中读线程B获取实例对象引用的方式不满足条件</li>
<li>“在构造方法中对final实例成员变量赋值”，排除掉了<code>final类成员变量的两种赋值情形——“定义赋值”和“静态初始化语句赋值”</code>和<code>final实例成员变量的另外两种赋值情形——“定义赋值”和“实例初始化语句赋值”</code>，在排除掉的情形中包括了编译期常量的情形，而编译期常量情形更是显而易见需要排除掉的</li>
</ul>
<p>示例代码2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReferenceAhead &#123;</span><br><span class="line">    static ReferenceAhead referenceAhead = null;</span><br><span class="line"></span><br><span class="line">    final int a;</span><br><span class="line"></span><br><span class="line">    int b;</span><br><span class="line"></span><br><span class="line">    public ReferenceAhead() &#123;</span><br><span class="line">        a = 10;</span><br><span class="line">        referenceAhead = this;</span><br><span class="line">        b = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读线程B执行</span><br><span class="line">     */</span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        if (referenceAhead != null) &#123;</span><br><span class="line">            System.out.println(referenceAhead.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写线程A执行</span><br><span class="line">     */</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        new ReferenceAhead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2、与happens-before规则的关系"><a href="#3-3-2、与happens-before规则的关系" class="headerlink" title="3.3.2、与happens-before规则的关系"></a><strong>3.3.2、与happens-before规则的关系</strong></h4><p>“final关键词内存可见语义规则”与“happens-before规则”的关系：都属于“JMM提供的语义确保”范畴，两者相互独立，也没有语义确保强弱之分，只不过happens-before规则更易于理解和通用。</p>
<p>对于“示例代码0”，构造方法允许重排序，因此“&#x2F;&#x2F; 1 2 3 4 5 6 7 8 9 10 11 12 13”操作之间本就存在可见性问题：</p>
<ul>
<li>如果写线程A和读线程B是同一个线程，且<code>writer()</code>方法执行先于<code>reader()</code>方法，那么根据happens-before规则——<code>一个线程中的每个操作，happens-before于该线程中的任意后续操作</code>，就有“1 2 3 4 5 6 7 8 9 10 11 12 13”的顺序happens-before关系</li>
<li>如果obj变量增加<code>volatile</code>关键词修饰，且<code>reader()</code>方法中<code>if (obj != null)</code>语句执行结果为true，那么根据happens-before规则——<code>一个线程中的每个操作，happens-before于该线程中的任意后续操作</code>、<code>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</code>和<code>如果A happens-before B，且B happens-before C，那么A happens-before C</code>，就有“1 2 3 4 5 6 7 8 9 10 11 12 13”的顺序happens-before关系</li>
<li>“&#x2F;&#x2F; 13”操作满足“final关键词内存可见语义规则”，那么对于“&#x2F;&#x2F; 13”操作所指代的final实例成员变量读操作来说，“&#x2F;&#x2F; 3 4 11”操作对其内存可见</li>
</ul>
<h4 id="3-3-3、应用"><a href="#3-3-3、应用" class="headerlink" title="3.3.3、应用"></a><strong>3.3.3、应用</strong></h4><p><strong>1、案例1</strong><br>来自《Java并发编程的艺术》P56。</p>
<p>示例代码3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalExample</span><span class="params">()</span> &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">FinalExample</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不能确保读取到值 1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> obj.i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 满足“final关键词内存可见语义规则”，确保能读取到值 2</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> obj.j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、案例2</strong><br>“示例代码4”展示了一种常见的使用Runnable匿名内部类的形式，一直有个困惑：在另外一个线程或者线程池中异步执行该Runnable对象的<code>run()</code>方法时，与所传入外围变量相关的所有操作都内存可见吗？</p>
<p>特别需要注意的是，虽然都涉及到匿名内部类，但是这里跟“3.2、匿名内部类访问外围变量”小节的强调点不同，即“一个强调内存可见性，一个强调自由变量必须是final的”。</p>
<br/>

<p>接下来进行释疑分析。</p>
<p>依次执行<code>javac Outer.java</code>和<code>javap -v Outer\$1.class</code>命令，可知Runnable匿名内部类的实际构造方法如示例代码5，如果进行合并，那么Outer类的最终等价形式如示例代码6。</p>
<p>在示例代码6中，“&#x2F;&#x2F; 5”操作处隐含的“this.val$person”读操作满足“final关键词内存可见语义规则”，那么“&#x2F;&#x2F; 1 2 3 4”操作对其内存可见。</p>
<p>示例代码4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;dslztx&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Person val$person;</span><br><span class="line">    descriptor: LPerson;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Outer <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">    descriptor: LOuter;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  Outer$<span class="number">1</span>(Outer, Person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();     <span class="comment">// 1</span></span><br><span class="line">        person.setName(<span class="string">&quot;dslztx&quot;</span>);               <span class="comment">// 2</span></span><br><span class="line">        person.setAge(<span class="number">31</span>);                      <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Outer$1</span> <span class="variable">outer$1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$1</span>(<span class="built_in">this</span>, person);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(outer$<span class="number">1</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable &#123;</span><br><span class="line">    <span class="keyword">final</span> Person val$person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Outer <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Outer$<span class="number">1</span>(Outer <span class="built_in">this</span>$<span class="number">0</span>, Person val$person) &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.val$person = val$person;            <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(val$person);          <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a><br>[2]<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5.1</a><br>[3]<a href="https://dzone.com/articles/final-keyword-and-jvm-memory-impact">https://dzone.com/articles/final-keyword-and-jvm-memory-impact</a><br>[4]<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5</a><br>[5]<a href="https://blog.csdn.net/hzy38324/article/details/77986095">https://blog.csdn.net/hzy38324/article/details/77986095</a><br>[6]<a href="https://stackoverflow.com/questions/27254152/what-exactly-does-the-final-keyword-guarantee-regarding-concurrency">https://stackoverflow.com/questions/27254152/what-exactly-does-the-final-keyword-guarantee-regarding-concurrency</a><br>[7]<a href="https://cloud.tencent.com/developer/article/1585263">https://cloud.tencent.com/developer/article/1585263</a><br>[8]<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/newFinal.pdf">http://www.cs.umd.edu/~pugh/java/memoryModel/newFinal.pdf</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized锁内部实现</title>
    <url>/blog/2020/03/26/synchronized%E9%94%81%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="一、基本语义"><a href="#一、基本语义" class="headerlink" title="一、基本语义"></a><strong>一、基本语义</strong></h2><h3 id="1-1、两种形式、一种锁"><a href="#1-1、两种形式、一种锁" class="headerlink" title="1.1、两种形式、一种锁"></a><strong>1.1、两种形式、一种锁</strong></h3><p>synchronized关键词对应synchronized锁，synchronized关键词有两种形式的用法：1）<code>synchronized方法</code>；2）<code>synchronized(Java对象obj)语句块</code>。</p>
<p>但是本质只有一种synchronized锁，该锁围绕对应的Java对象：</p>
<ul>
<li>在前者情形中，如果是非静态方法，对应的Java对象为实例对象；如果是静态方法，对应的Java对象为类对象</li>
<li>在后者情形中，对应的Java对象就是obj</li>
</ul>
<h3 id="1-2、申请锁和释放锁"><a href="#1-2、申请锁和释放锁" class="headerlink" title="1.2、申请锁和释放锁"></a><strong>1.2、申请锁和释放锁</strong></h3><p><strong>申请锁</strong>：“<code>synchronized方法</code>进入”或者“<code>synchronized(Java对象obj)语句块</code>进入”。<br><strong>释放锁</strong>：“<code>synchronized方法</code>退出”或者“<code>synchronized(Java对象obj)语句块</code>退出”。</p>
<h3 id="1-3、锁分类"><a href="#1-3、锁分类" class="headerlink" title="1.3、锁分类"></a><strong>1.3、锁分类</strong></h3><p>从不同维度进行锁分类，synchronized锁属于：</p>
<ul>
<li>悲观锁</li>
<li>排他锁</li>
<li>阻塞锁</li>
<li>可重入锁</li>
<li>非公平锁</li>
</ul>
<h2 id="二、内部实现之4种锁状态"><a href="#二、内部实现之4种锁状态" class="headerlink" title="二、内部实现之4种锁状态"></a><strong>二、内部实现之4种锁状态</strong></h2><p>接下来所作内部实现讨论所基于操作系统为Linux。<br>最初的synchronized锁内部实现中，只有“无锁”和“有锁”两种锁状态，“有锁”的实现基于<code>Monitor（参见“3.1.3、Monitor”小节）</code>，但是存在“Monitor操作使用代价高昂，有些锁使用场景不必须使用Monitor”的问题，比如“一些工具类方法为提供线程安全性会加上synchronized关键词，但在实际应用中却只是在单线程语境下使用”。<br>因此，为提升synchronized锁性能，引入“偏向锁”和“轻量级锁”两种锁状态，将原来的“有锁”锁状态重命名为“重量级锁”，故共有4个锁状态：无锁、偏向锁、轻量级锁、重量级锁。4个锁状态适用的锁使用场景如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>适用锁使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一个线程竞争锁</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多个线程交替竞争锁（线程T1申请锁，释放锁后，线程T2申请锁，释放锁，…）</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多个线程无序竞争锁（即锁竞争非常激烈）</td>
</tr>
</tbody></table>
<br/>
偏向锁、轻量级锁、重量级锁的锁分类如表2。

<p>表2</p>
<table>
<thead>
<tr>
<th>锁类别\锁分类</th>
<th>悲观锁</th>
<th>排他锁</th>
<th>阻塞锁</th>
<th>可重入锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td><font color='red'>无意义</font></td>
</tr>
<tr>
<td>轻量级锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td><font color='red'>无意义</font></td>
</tr>
<tr>
<td>重量级锁</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ul>
<li>根据“公平锁”和“非公平锁”的定义，由于“偏向锁”和“轻量级锁”不涉及到等待队列，故关于“偏向锁&#x2F;轻量级锁是否为公平锁&#x2F;非公平锁”的问题没有意义</li>
</ul>
<h2 id="三、内部实现之OpenJDK源代码阅读"><a href="#三、内部实现之OpenJDK源代码阅读" class="headerlink" title="三、内部实现之OpenJDK源代码阅读"></a><strong>三、内部实现之OpenJDK源代码阅读</strong></h2><p>这里的OpenJDK源代码指的是OpenJDK 8源代码。</p>
<p>在继续讨论之前，首先定义一些名词：</p>
<ul>
<li><code>lockObj</code>，表示synchronized锁所围绕的Java对象，这个Java对象可以是实例对象，也可以是类对象<sup>1</sup>。比如“<code>synchronized(obj)&#123;&#125;</code>中的obj”，“<code>synchronized(A.class)&#123;&#125;</code>中的类A所对应的对象”</li>
<li><code>kclassObj</code>，表示lockObj所对应的类对象<sup>2</sup>，这个类对象<sup>2</sup>属于VM进程内部实现层面，对Java语言层面不可见，并不是属于Java语言层面的类对象<sup>1</sup></li>
<li><code>lockObj-&gt;markword</code>，表示lockObj这个Java对象的Mark Word字段</li>
<li><code>kclassObj-&gt;prototype_markword</code>，表示kclassObj这个类对象<sup>2</sup>的原型Mark Word字段</li>
</ul>
<p><font color='red'>另外需要注意的是，本文注重描述主体脉络，一些具体细节并未涉及到。</font></p>
<h3 id="3-1、数据结构"><a href="#3-1、数据结构" class="headerlink" title="3.1、数据结构"></a><strong>3.1、数据结构</strong></h3><h4 id="3-1-1、Mark-Word"><a href="#3-1-1、Mark-Word" class="headerlink" title="3.1.1、Mark Word"></a><strong>3.1.1、Mark Word</strong></h4><p>根据synchronized关键词的用法可知，实例对象和类对象都可作为锁对象，锁对象的Mark Word字段被设计用于保存相应的锁状态信息。<br>Mark Word可分为32位和64位，接下来以32位Mark Word为例。</p>
<p>32位Mark Word字段保存锁状态信息的方案设计如表3所示。</p>
<p>表3</p>
<table>
<thead>
<tr><th rowspan=4>对象状态</th></tr>
<tr><th colspan=5>Mark Word</th></tr>
<tr><th colspan=2>25bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr>
<tr><th>23bit</th><th>2bit</th><th></th><th>是否可偏向</th><th>锁标志位</th></tr>
</thead>
<tbody>
<tr><th>无锁</th><th colspan=2>HashCode</th><th>对象分代年龄</th><th>0</th><th>01</th></tr>
<tr><th>偏向锁</th><th>ThreadID</th><th>Epoch</th><th>对象分代年龄</th><th>1</th><th>01</th></tr>
<tr><th>轻量级锁</th><th colspan=4>Lock Record指针</th><th>00</th></tr>
<tr><th>重量级锁</th><th colspan=4>Monitor指针</th><th>10</th></tr>
<tr><th>标记为GC</th><th colspan=4>无</th><th>11</th></tr>
</tbody>
</table>

<h4 id="3-1-2、Lock-Record"><a href="#3-1-2、Lock-Record" class="headerlink" title="3.1.2、Lock Record"></a><strong>3.1.2、Lock Record</strong></h4><p>锁最终被线程持有，线程使用线程栈中的Lock Record来记录本线程的锁持有情况。<br>Lock Record主要有两个字段：1）obj，指向对应的lockObj；2）displaced_header，释放轻量级锁时作为Mark Word的复制来源。</p>
<p>具体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A BasicObjectLock associates a specific Java object with a BasicLock.</span></span><br><span class="line"><span class="comment">// It is currently embedded in an interpreter frame.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicObjectLock</span> VALUE_OBJ_CLASS_SPEC &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BasicLock _lock; <span class="comment">// the lock, must be double word aligned</span></span><br><span class="line">    oop _obj; <span class="comment">// object holds the lock;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicLock</span> VALUE_OBJ_CLASS_SPEC &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">volatile</span> markOop _displaced_header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-1、创建"><a href="#3-1-2-1、创建" class="headerlink" title="3.1.2.1、创建"></a><strong>3.1.2.1、创建</strong></h5><p>每次线程T0申请lockObj的锁时，都会在T0的线程栈中申请一个用于lockObj的Lock Record，创建过程描述如下：<br>0. 从T0线程栈的空闲Lock Record列表中取“上限下内存地址最高的Lock Record”，“上限下内存地址最高的Lock Record”的含义是“如果已经存在obj指向lockObj的Lock Record，其中最低内存地址为A0，那么下次再申请用于lockObj的Lock Record时，内存地址上限为A0；如果未存在obj指向lockObj的Lock Record，那么下次再申请用于lockObj的Lock Record时，内存地址上限为空闲Lock Record列表的本身内存地址上限”<br>0. 假设拿到的空Lock Record为LR0，那么LR0的obj字段指向lockObj<br>0. LR0的displaced_header字段填充分为3种情形：<br>    - 申请的是偏向锁，那么displaced_header的值不管是首次申请成功，还是锁重入，始终为NULL<br>    - 申请的是轻量级锁，如果是首次申请成功，设为该轻量级锁释放后Mark Word需要还原到的值；如果是锁重入，那么displaced_header的值为NULL<br>    - 申请的是重量级锁，那么displaced_header的值不管是首次申请成功，还是锁重入，都为某个特定的值，这个特定的值没有任何语义，只是为了标识持有锁状态为重量级锁</p>
<h5 id="3-1-2-2、销毁"><a href="#3-1-2-2、销毁" class="headerlink" title="3.1.2.2、销毁"></a><strong>3.1.2.2、销毁</strong></h5><p>每次线程T0释放lockObj的锁时，在T0线程栈的Lock Record列表中找到属于lockObj的最低内存地址的Lock Record进行销毁，即将其obj字段置为NULL。</p>
<h5 id="3-1-2-3、Lock-Record的意义"><a href="#3-1-2-3、Lock-Record的意义" class="headerlink" title="3.1.2.3、Lock Record的意义"></a><strong>3.1.2.3、Lock Record的意义</strong></h5><p>线程T0线程栈中属于lockObj的Lock Record列表是能表达T0对lockObj<code>持有状态</code>和<code>持有次数</code>最准确的数据。</p>
<table>
<thead>
<tr>
<th>&#92;</th>
<th>持有状态</th>
<th>持有次数</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>当T0释放偏向锁且为最后一次释放（即不为偏向锁锁重入的释放）后，相应Mark Word上的ThreadID并未更新，<font color='red'>此时Mark Word的ThreadID表达持有状态是不准确的</font>，只有此时最后一个Lock Record也被销毁才能准确表达这个锁持有状态的变化</td>
<td>只能通过Lock Record来表达</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>通过Mark Word上Lock Record指针准确表达：当为NULL，表示未持有锁；当不为NULL，Lock Record所在线程持有锁</td>
<td>只能通过Lock Record来表达</td>
</tr>
<tr>
<td>重量级锁</td>
<td>通过Mark Word上Monitor指针准确表达：当为NULL，表示未持有锁；当不为NULL，所指向Monitor对象的owner字段直接或者间接表征（此时，owner的值为指向Lock Record的指针）持有线程，当然如果owner字段为NULL，同样表示未持有锁</td>
<td><font color='red'>当升级到重量级锁时，如果原来并没有“偏向锁和轻量级锁”的锁重入，此时recursions字段能表达锁重入次数，否则recursions字段不能表达锁重入次数，只有Lock Record表达锁重入次数恒久保持准确</font></td>
</tr>
</tbody></table>
<h4 id="3-1-3、Monitor"><a href="#3-1-3、Monitor" class="headerlink" title="3.1.3、Monitor"></a><strong>3.1.3、Monitor</strong></h4><p>即重量级锁，对应的数据结构为<code>ObjectMonitor</code>，其文件路径是<code>hotspot/src/share/vm/runtime/objectMonitor.hpp:77</code>。</p>
<h3 id="3-2、VM参数"><a href="#3-2、VM参数" class="headerlink" title="3.2、VM参数"></a><strong>3.2、VM参数</strong></h3><p>在synchronized锁的源代码实现中有两个VM参数值得说明：</p>
<ul>
<li><code>-XX:+/-UseBiasedLocking</code>：是否开启&#x2F;关闭偏向锁</li>
<li><code>-XX:+/-UseHeavyMonitors</code>：是否只使用重量级锁，而不使用偏向锁和轻量级锁，<code>-XX:+UseHeavyMonitors</code>隐式包含了<code>-XX:-UseBiasedLocking</code></li>
</ul>
<h3 id="3-3、锁申请和锁释放"><a href="#3-3、锁申请和锁释放" class="headerlink" title="3.3、锁申请和锁释放"></a><strong>3.3、锁申请和锁释放</strong></h3><p>关于“锁申请”和“锁释放”这里作简单说明，详见源代码。<br><strong>1、锁申请</strong><br>线程T1持有锁，线程T2竞争申请锁，且过程中T1不释放锁，那么：</p>
<ul>
<li>当锁状态为重量级锁时，T2阻塞</li>
<li>当锁状态为偏向锁或者轻量级锁，锁最终升级为重量级锁（可能有中间状态的轻量级锁），锁升级后仍由T1持有（包括中间状态的轻量级锁），T2阻塞。锁升级后仍由T1持有是<font color='red'>显而易见的，否则就是“在线程T1持有锁的过程中，允许锁的持有权被抢断式转移”，这违背happens-before规则——“对一个锁的解锁，happens-before于随后对这个锁的加锁”</font></li>
</ul>
<p><strong>2、锁释放</strong><br>锁释放分为两种情形“重入锁释放”和“非重入锁释放”：</p>
<ul>
<li>重入锁释放。偏向锁、轻量级锁、重量级锁的释放操作正常无特别之处</li>
<li>非重入锁释放。1）偏向锁释放时，不会被置为匿名偏向状态，即“Mark Word的ThreadID域值不会被置为全0值，而是保持原值”，考虑到“一个线程竞争锁”的偏向锁使用场景（T0持有偏向锁，释放，稍后再度申请持有时，无需CAS操作修改Mark Word，直接持有偏向锁成功），这个设计是合理的；2）轻量级锁释放时，会使用<code>displaced_header</code>重置Mark Word，且<code>displaced_header</code>值必为无锁状态；3）重量级锁释放时，不会回退到无锁，考虑到“升级到重量级锁意味着锁竞争十分激烈，现在回退后后续仍然有很大概率继续升级”，这个设计是合理的</li>
</ul>
<h3 id="3-4、偏向锁"><a href="#3-4、偏向锁" class="headerlink" title="3.4、偏向锁"></a><strong>3.4、偏向锁</strong></h3><h4 id="3-4-1、匿名偏向和非匿名偏向"><a href="#3-4-1、匿名偏向和非匿名偏向" class="headerlink" title="3.4.1、匿名偏向和非匿名偏向"></a><strong>3.4.1、匿名偏向和非匿名偏向</strong></h4><p><strong>匿名偏向</strong>：表示开启偏向锁，但是还未偏向具体线程，此时Mark Word中的ThreadID域值为全0。<br><strong>非匿名偏向</strong>：即正常偏向，表示开启偏向锁，也已经偏向到具体线程，此时Mark Word中的ThreadID域值为该具体线程的ID。</p>
<h4 id="3-4-2、控制是否开启偏向锁"><a href="#3-4-2、控制是否开启偏向锁" class="headerlink" title="3.4.2、控制是否开启偏向锁"></a><strong>3.4.2、控制是否开启偏向锁</strong></h4><p>有两个途径控制是否开启偏向锁：</p>
<ul>
<li><code>-XX:+/-UseBiasedLocking</code>VM参数，须知<code>-XX:+/-UseHeavyMonitors</code>VM参数只是通过隐式设置<code>-XX:+/-UseBiasedLocking</code>VM参数来间接控制是否开启偏向锁。这个途径是静态固定的</li>
<li><code>kclassObj-&gt;prototype_markword</code>上的锁标志位，为<code>101</code>表示开启偏向锁，否则表示关闭偏向锁。这个途径是动态可变的，具体是“开始开启偏向锁，经过偏向锁使用数据统计发现属于该kclassObj的lockObj不适合使用偏向锁，关闭偏向锁”</li>
</ul>
<p>在创建lockObj对象分配内存时，当开启偏向锁时，Mark Word的初始状态为匿名偏向状态，否则为无锁状态。</p>
<p><strong>备注</strong>：笔者不能确定<code>-XX:+/-UseBiasedLocking</code>VM参数和“kclassObj-&gt;prototype_markword上初始锁标志位”两者之间的关系，推测是“如果设置了<code>-XX:-UseBiasedLocking</code>VM参数，那么kclassObj-&gt;prototype_markword上的初始锁标志位不为101”</p>
<h4 id="3-4-3、重偏向和撤销"><a href="#3-4-3、重偏向和撤销" class="headerlink" title="3.4.3、重偏向和撤销"></a><strong>3.4.3、重偏向和撤销</strong></h4><p>首先介绍两个概念：</p>
<ul>
<li>VM线程，即VM Thread，该线程会在进入安全点时，从VMOperationQueue队列中取出需要在安全点执行的操作去执行，比如GC操作</li>
<li>安全点，即Safe Point，其代表一个状态，在该状态下所有线程都是暂停的，除了VM线程</li>
</ul>
<p><strong>1、重偏向</strong><br><strong>重偏向</strong>：<code>lockObj-&gt;markword</code>处于正常偏向状态，且ThreadID域的值表征线程T1，但实际上T1已释放掉该偏向锁，那么如果此时T2申请该偏向锁，则可成功，ThreadID域的值置为线程T2，这就是偏向锁的重偏向。</p>
<p>重偏向过程的重点在于“如何知晓T1已释放掉偏向锁？”。因为根据“3.3、锁申请和锁释放”小节内容可知，偏向锁释放时<code>Mark Word的ThreadID域值不会被置为全0值，而是保持原值</code>，有两种策略：1）主动侦测线程T1是否仍然持有偏向锁；2）查看<code>lockObj-&gt;markword</code>中Epoch域值与对应的<code>kclassObj-&gt;prototype_markword</code>中Epoch域值是否不一致，即Epoch阈值是否过期，如果过期，则表征T1已释放掉该偏向锁。<font color='red'>这个不一致状态是由“批量重偏向”过程设置的</font></p>
<p>上述提及的“批量重偏向”过程命名有一定歧义性，因为本质上并没有完成重偏向，而只是为后续完成重偏向作了预处理。另外，关于这个“批量重偏向”过程有4点说明：</p>
<ul>
<li>触发条件是基于统计数据，满足设定的批量重偏向阈值时进行</li>
<li>方法名是<code>bulk_revoke_or_rebias_at_safepoint()</code></li>
<li>执行时机是：在安全点，VM线程执行</li>
<li>具体过程是：所传入lockObj对应的<code>kclassObj-&gt;prototype_markword</code>中的Epoch域值+1，遍历所有存活线程，所持有锁对应lockObj0的<code>lockObj0-&gt;markword</code>中的Epoch域值同步+1，相对的，未被存活线程持有锁对应lockObj0的<code>lockObj0-&gt;markword</code>中的Epoch域值未被同步+1。需要注意的是，上述lockObj0与所传入lockObj属于同一个<code>kclassObj</code></li>
</ul>
<p><strong>2、撤销</strong><br><strong>撤销</strong>：从“已偏向锁”状态置为“无锁、匿名偏向锁、轻量级锁”。</p>
<p>关于“批量撤销”有4点说明：</p>
<ul>
<li>触发条件是基于统计数据，满足设定的批量撤销阈值时进行</li>
<li>方法名是<code>bulk_revoke_or_rebias_at_safepoint()</code></li>
<li>执行时机是：在安全点，VM线程执行</li>
<li>具体过程是：所传入lockObj对应的<code>kclassObj-&gt;prototype_markword</code>中的锁标志位设为“关闭偏向锁”，遍历所有存活线程，如果所持有锁对应lockObj与所传入lockObj属于同一个<code>kclassObj</code>时，撤销该偏向锁</li>
</ul>
<h3 id="3-5、轻量级锁"><a href="#3-5、轻量级锁" class="headerlink" title="3.5、轻量级锁"></a><strong>3.5、轻量级锁</strong></h3><p>相对最简单的锁形态。<br>所指向Lock Record的<code>displaced_header</code>字段存放释放该轻量级锁后需要还原到的Mark Word值，是一个无锁状态的值。</p>
<h3 id="3-6、重量级锁"><a href="#3-6、重量级锁" class="headerlink" title="3.6、重量级锁"></a><strong>3.6、重量级锁</strong></h3><p>接下来对重量级锁的申请和释放过程作进一步细化描述，首先须知的是对应于重量级锁的数据结构ObjectMonitor内有两个相关等待队列<code>ContentionList（简称为cxq）</code>和<code>EntryList</code>，其内部元素对象数据结构为ObjectWaiter。<br>现假定线程T0已获得重量级锁M0：</p>
<ul>
<li>后续一系列线程T1，T2，T3，…申请锁，首先尝试直接竞争锁，如果成功直接返回，否则基于线程本身构造一个ObjectWaiter对象加入cxq队列，调用阻塞方法阻塞线程本身，这里的阻塞分为两种情形：<ul>
<li>无超时阻塞，只会被唤醒方法唤醒，唤醒后尝试竞争锁，如果成功直接返回，否则继续下一轮无超时阻塞</li>
<li>超时阻塞，除了会被唤醒方法唤醒外，还会在设定超时时间到期后自动唤醒，唤醒后尝试竞争锁，如果成功直接返回，否则继续下一轮无超时阻塞。被选中的超时阻塞线程称为“_Responsible”线程</li>
</ul>
</li>
<li>T0释放锁，首先合并<code>cxq</code>和<code>EntryList</code>队列，选取合并后队列首元素ObjectWaiter，唤醒对应的线程，该选中线程又被称为“假定继承人（称为假定是因为不一定能竞争锁成功）”，结合上面描述可知，这个假定继承人可能是“_Responsible”线程，也可能不是“_Responsible”线程</li>
<li>根据上面描述可知，极端情况下同时竞争锁的线程最多有3个来源：申请锁的新线程、无超时阻塞线程被唤醒、超时阻塞线程设定超时时间到期后自动唤醒</li>
</ul>
<p><font color='red'>根据上面叙述，重量级锁为非公平锁。</font></p>
<h3 id="3-7、HashCode计算"><a href="#3-7、HashCode计算" class="headerlink" title="3.7、HashCode计算"></a><strong>3.7、HashCode计算</strong></h3><p>根据表3可知，在无锁状态时，Mark Word中有个HashCode字段，该字段用来保存第一次计算原生HashCode值（调用未被覆盖的hashCode()方法，即<code>lockObj.hashCode()</code>，覆盖后的hashCode()方法计算值无需保存；或者调用System.identityHashCode()方法，即<code>System.identityHashCode(lockObj)</code>）的结果值，避免后续重复计算。</p>
<p>在“偏向锁”或者“轻量级锁”状态时，没有字段存放原生HashCode值，故此种情形下，为了能够存放原生HashCode值，也会进行锁升级，即最终升级到重量级锁，在重量级锁对应的ObjectMonitor数据结构中有个字段可用来存放该原生HashCode值。</p>
<h3 id="3-8、锁状态转移图"><a href="#3-8、锁状态转移图" class="headerlink" title="3.8、锁状态转移图"></a><strong>3.8、锁状态转移图</strong></h3><p>锁状态示意图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20200326-0-0.svg"></p>
<p>关于锁状态转移有以下几点说明：</p>
<ul>
<li>关于“锁申请、锁释放、偏向锁的重偏向和撤销”已经在上文中涉及。这里主要说明下“重量级锁-&gt;无锁（即图示中<code>重量级锁降级[1]</code>）”的状态转移过程，根据“3.3、锁申请和锁释放”可知，释放重量级锁时，该过程并不会发生，但实际上该过程是客观存在的，对应的具体方法路径是“hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;synchronizer.cpp”源文件内的<code>deflate_idle_monitors()</code>方法，而对于该方法的具体调用条件、时机等，笔者并不是很清楚。关于这点，《Java并发编程的艺术》一书中作者说到“重量级锁没有锁降级机制”应该是个错误</li>
<li>“合法的锁升级”包含：|无锁、偏向锁| -&gt; |轻量级锁|，|无锁、轻量级锁| -&gt; |重量级锁|；“合法的锁降级”包含：|轻量级锁、重量级锁| -&gt; |无锁|</li>
</ul>
<h3 id="3-9、源代码阅读"><a href="#3-9、源代码阅读" class="headerlink" title="3.9、源代码阅读"></a><strong>3.9、源代码阅读</strong></h3><p>synchronized锁有两种使用形式，对应着两条源代码实现路径，synchronized锁的两种使用示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次执行<code>javac SynchronizedExample.java</code>和<code>javap -v SynchronizedExample</code>命令，得到以上类的JVM指令形式。</p>
<p>f()方法和g()方法的JVM指令片段分别如下：</p>
<p>f()方法的JVM指令片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void f();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=1, args_size=1</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String hello world</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 4: 0</span><br><span class="line">      line 5: 8</span><br></pre></td></tr></table></figure>

<p>g()方法的JVM指令片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void g();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String hello world</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: monitorexit</span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_2</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: monitorexit</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: athrow</span><br><span class="line">      22: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    14    17   any</span><br><span class="line">          17    20    17   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 8: 0</span><br><span class="line">      line 9: 4</span><br><span class="line">      line 10: 12</span><br><span class="line">      line 11: 22</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 17</span><br><span class="line">        locals = [ class SynchronizedExample, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure>
<p>在f()方法的JVM指令片段中，使用<code>ACC_SYNCHRONIZED</code>来标记synchronized方法（最终也会转换成锁申请和释放操作），在g()方法的JVM指令片段中，使用<code>monitorenter</code>和<code>monitorexit</code>分别标记锁申请和释放。两者对应两条源代码实现路径（虽然这两条源代码实现路径相似度非常高），接下来基于后者对应的源代码实现路径来进行介绍。</p>
<p>接下来在JVM源码中寻找解析“monitorenter”和“monitorexit”指令的地方，有两处标的：<code>hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp:1884</code>和<code>hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp:3668</code>。第一处标的是“字节码解释器”实现形式，用C++语言实现，其优点是“实现相对简单且容易理解”，缺点是“执行慢”；第二处标的是“模板解释器”实现形式，用汇编语言实现，其优点是“执行快”，缺点是“不好理解”。两者的实现是等价的，为了便于理解，跟踪阅读第一处标的。</p>
<p><font color='red'>另外</font>，在源代码中有一个出现频率非常高的CAS方法<code>cmpxchg_ptr(newV, addr, oldV)</code>，这个CAS方法是属于C++语言层面的，底层会映射到处理器的CAS指令，其含义是“如果内存地址addr当下值等于oldV，则其值原子更新成newV，否则更新失败，方法恒返回内存地址当下值”。</p>
<h4 id="3-9-1、申请锁"><a href="#3-9-1、申请锁" class="headerlink" title="3.9.1、申请锁"></a><strong>3.9.1、申请锁</strong></h4><table>
<thead>
<tr>
<th>方法&#x2F;语句块</th>
<th>方法&#x2F;语句块对应的流程图</th>
</tr>
</thead>
<tbody><tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;bytecodeInterpreter.cpp”源文件： <code>CASE(_monitorenter)</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-1.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;interpreterRuntime.cpp”源文件： <code>InterpreterRuntime::monitorenter()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-2.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;synchronizer.cpp”源文件： <code>ObjectSynchronizer::slow_enter()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-3.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;biasedLocking.cpp”源文件： <code>BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-4.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;biasedLocking.cpp”源文件： <code>BiasedLocking::Condition revoke_bias()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-5.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;synchronizer.cpp”源文件： <code>ObjectSynchronizer::inflate()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-6.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp”源文件： <code>ObjectMonitor::enter()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-7.svg"></td>
</tr>
</tbody></table>
<h4 id="3-9-2、释放锁"><a href="#3-9-2、释放锁" class="headerlink" title="3.9.2、释放锁"></a><strong>3.9.2、释放锁</strong></h4><table>
<thead>
<tr>
<th>方法&#x2F;语句块</th>
<th>方法&#x2F;语句块对应的流程图</th>
</tr>
</thead>
<tbody><tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;bytecodeInterpreter.cpp”源文件： <code>CASE(_monitorexit)</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-8.svg"></td>
</tr>
<tr>
<td>“src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp”源文件： <code>ObjectMonitor::exit()</code></td>
<td><img src="https://blog.dslztx.top/imgs/20200326-0-9.svg"></td>
</tr>
</tbody></table>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、一个Bug"><a href="#4-1、一个Bug" class="headerlink" title="4.1、一个Bug"></a><strong>4.1、一个Bug</strong></h3><p>Bug描述：配置了<code>-XX:+UseHeavyMonitors</code>VM参数，意图不使用偏向锁和轻量级锁，但是由下面会执行到的方法可知，还是有可能会去申请轻量级锁的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">        <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">        <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">        <span class="comment">// 申请轻量级锁</span></span><br><span class="line">        lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">        <span class="keyword">if</span> (mark == (markOop)Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span>(slow_enter</span><br><span class="line">                   : release stacklock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">        <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">        lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、阻塞"><a href="#4-2、阻塞" class="headerlink" title="4.2、阻塞"></a><strong>4.2、阻塞</strong></h3><p>对于synchronized锁来说，竞争不到锁阻塞，本质是对于重量级锁状态而言，如果是无锁、偏向锁和轻量级锁状态，则最终会升级成重量级锁再阻塞。</p>
<br/>

<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h2><p>[1]<a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a><br>[2]<a href="https://github.com/farmerjohngit/myblog/issues/13">https://github.com/farmerjohngit/myblog/issues/13</a><br>[3]<a href="https://github.com/farmerjohngit/myblog/issues/14">https://github.com/farmerjohngit/myblog/issues/14</a><br>[4]<a href="https://github.com/farmerjohngit/myblog/issues/15">https://github.com/farmerjohngit/myblog/issues/15</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>tail命令</title>
    <url>/blog/2016/12/30/tail%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail [-n K] [-f] [FILE | -]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>显示文件或者基本输入的后几行，默认为后10行。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-n K”：表示显示文件或者基本输入的后K行。<br>“-f”：表示随着文件或者基本输入内容的增加而增加显示内容。</p>
<br/>
参考文献：
[1]man tail
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>tar命令</title>
    <url>/blog/2016/10/28/tar%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><h3 id="1-1、打包压缩常用用法"><a href="#1-1、打包压缩常用用法" class="headerlink" title="1.1、打包压缩常用用法"></a><strong>1.1、打包压缩常用用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar --exclude=&#x27;PATTERN&#x27; -cavf 打包压缩后文件名 待打包压缩目录或者一般文件</span><br></pre></td></tr></table></figure>
<h3 id="1-2、解压缩解包常用用法"><a href="#1-2、解压缩解包常用用法" class="headerlink" title="1.2、解压缩解包常用用法"></a><strong>1.2、解压缩解包常用用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar --exclude=&#x27;PATTERN&#x27; -xavf 打包压缩后文件名</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><h4 id="2-1-1、打包压缩含义"><a href="#2-1-1、打包压缩含义" class="headerlink" title="2.1.1、打包压缩含义"></a><strong>2.1.1、打包压缩含义</strong></h4><p>对待打包压缩目录或者一般文件进行打包压缩，其中压缩这个步骤是可选的。</p>
<h4 id="2-1-2、解压缩解包含义"><a href="#2-1-2、解压缩解包含义" class="headerlink" title="2.1.2、解压缩解包含义"></a><strong>2.1.2、解压缩解包含义</strong></h4><p>对打包压缩后文件，进行解压缩解包，其中解压缩这个步骤是可选的。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><h4 id="2-2-1、打包压缩选项"><a href="#2-2-1、打包压缩选项" class="headerlink" title="2.2.1、打包压缩选项"></a><strong>2.2.1、打包压缩选项</strong></h4><p>“–exclude&#x3D;’PATTERN’”：打包时，过滤掉指定文件。“PATTERN”是一个通配符模式表达式。<font color='red'>可以有多个“–exclude”选项。</font><br>“c”：表示打包（助记“create”）。<br>“a”：根据打包压缩后文件名的后缀来确定压缩算法，如果不能找到相应的压缩算法，那么就不压缩，即只打包而已。具体见“三、其他”（助记“auto”）。<br>“v”：打印过程中的日志信息。<br>“f”：指定打包压缩后文件名，比如有“test.tar.gz，test.tar.xz，test.tgz，test.tar”（助记“file”）。<br>“待打包压缩目录或者一般文件”：可对一个目录进行打包压缩，也可对一个一般文件进行打包压缩。</p>
<h4 id="2-2-2、解压缩解包选项"><a href="#2-2-2、解压缩解包选项" class="headerlink" title="2.2.2、解压缩解包选项"></a><strong>2.2.2、解压缩解包选项</strong></h4><p>“–exclude&#x3D;’PATTERN’”：解包时，过滤掉指定文件。“PATTERN”是一个通配符模式表达式。<font color='red'>可以有多个“–exclude”选项。</font><br>“x”：表示解包（助记“extract”）。<br>“a”：根据打包压缩后文件名的后缀来确定解压缩算法，具体见“三、其他”（助记“auto”）。<br>“v”：打印过程中的日志信息。<br>“f”：指定打包压缩后文件名，比如“test.tar.gz，test.tar.xz，test.tgz，test.tar”（助记“file”）。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>tar命令支持很多压缩算法，比如“gzip，bzip2，lzip，lzma，lzop，xz和compress”等。在打包过程中，在对目录或者一般文件打包得到一个打包文件后，可以选择某个上述压缩算法对该打包文件进行压缩，即先打包再压缩；在解包过程中，完全是个逆过程，即先解压缩再解包。<br>为了省去需要明确指定使用的压缩算法的麻烦，tar命令提供一个“-a”选项，通过启用该选项，tar命令可以根据“打包压缩后文件名”中的后缀来确定需要使用的压缩算法。<br>后缀跟压缩算法的映射见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>压缩算法</th>
</tr>
</thead>
<tbody><tr>
<td>.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>.tgz</td>
<td>gzip</td>
</tr>
<tr>
<td>.taz</td>
<td>gzip</td>
</tr>
<tr>
<td>.Z</td>
<td>compress</td>
</tr>
<tr>
<td>.taZ</td>
<td>compress</td>
</tr>
<tr>
<td>.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>.tz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>.tbz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>.tbz</td>
<td>bzip2</td>
</tr>
<tr>
<td>.lz</td>
<td>lzip</td>
</tr>
<tr>
<td>.lzma</td>
<td>lzma</td>
</tr>
<tr>
<td>.tlz</td>
<td>lzma</td>
</tr>
<tr>
<td>.lzo</td>
<td>lzop</td>
</tr>
<tr>
<td>.xz</td>
<td>xz</td>
</tr>
</tbody></table>
<p>接下来举几个例子如下：<br>只打包不压缩：<code>tar -cavf tmp.tar tmp</code>。<br>打包gzip压缩：<code>tar -cavf tmp.tar.gz tmp</code>。<br>打包xz压缩：<code>tar -cavf tmp.tar.xz tmp</code>。<br>打包gzip压缩，过滤掉以“txt”结尾的文件：<code>tar --exclude=&#39;*.txt&#39; -cavf tmp.tar.gz tmp</code>。<br>解压解包：<code>tar -xavf tmp.tar.xz</code>。<br>解压解包：<code>tar -xavf tmp.tar.gz</code>。<br>解包：<code>tar -xavf tmp.tar</code>。<br>解压解包，过滤掉“bin”目录文件：<code>tar --exclude=&#39;bin&#39; -xavf tmp.tar.gz</code>。</p>
<br/>
参考文献：
[1]https://www.gnu.org/software/tar/manual/html_node/gzip.html#auto_002dcompress
[2]man tar
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump命令</title>
    <url>/blog/2016/02/17/tcpdump%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>tcpdump命令抓取的是OSI七层模型中“数据链路层”的帧。</p>
<h2 id="二、常用用法"><a href="#二、常用用法" class="headerlink" title="二、常用用法"></a><strong>二、常用用法</strong></h2><p>一般用于两种情形，分别是：粗略分析网络流量和详细分析网络流量。</p>
<h3 id="2-1、粗略分析网络流量"><a href="#2-1、粗略分析网络流量" class="headerlink" title="2.1、粗略分析网络流量"></a><strong>2.1、粗略分析网络流量</strong></h3><p>tcpdump命令在抓取“数据链路层”的帧后，会进行解析，得到可读性较好的展示形式。但是由于不是原始的“帧”数据，因而只能进行粗略的分析。<br>具体使用形式为：<br><code>tcpdump -i 网卡名 expression</code>(关于expression见<a href="/blog/2016/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="网络抓包过滤表达式">链接</a>，对于expression，推荐采用单引号包围起来的方式)</p>
<h3 id="2-2、详细分析网络流量"><a href="#2-2、详细分析网络流量" class="headerlink" title="2.2、详细分析网络流量"></a><strong>2.2、详细分析网络流量</strong></h3><p>可以将“tcpdump”命令仅作为捕获“数据链路层”的帧的工具，将原始的帧数据保存到文件中，然后传给Wireshark进行分析，从而达到详细分析网络流量的目的。tcpdump命令保存原始帧数据到文件时，使用libpcap库，保存得到的文件符合PCAP文件规范，而Wireshark工具依赖libpcap库进行输入文件的解析，因此Wireshark工具可以准确识别tcpdump保存的文件。<br>具体使用形式为：<br><code>tcpdump -i 网卡名 -w 保存文件路径 expression</code>(关于expression见<a href="/blog/2016/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="网络抓包过滤表达式">链接</a>，对于expression，推荐采用单引号包围起来的方式)<br><br/><br>另外：<br>-c选项：表示当捕获c个数据帧后自动停止捕获</p>
<h2 id="三、一些例子"><a href="#三、一些例子" class="headerlink" title="三、一些例子"></a><strong>三、一些例子</strong></h2><p>一些例子见<a href="/blog/2016/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="网络抓包过滤表达式">链接</a>。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://www.kroosec.com/2012/10/a-look-at-pcap-file-format.html">http://www.kroosec.com/2012/10/a-look-at-pcap-file-format.html</a><br>[2]<a href="https://en.wikipedia.org/wiki/Tcpdump">https://en.wikipedia.org/wiki/Tcpdump</a><br>[3]<a href="https://wiki.wireshark.org/libpcap">https://wiki.wireshark.org/libpcap</a><br>[4]<a href="https://en.wikipedia.org/wiki/Wireshark">https://en.wikipedia.org/wiki/Wireshark</a><br>[5]man tcpdump</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>touch命令</title>
    <url>/blog/2016/10/20/touch%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch [-a | -m] [--date=STRING] FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>修改“FILE”所指代文件的“atime”和“mtime”的属性值，如果文件不存在，则首先创建一个空白文件。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“不加任何选项”：修改“FILE”所指代文件的“atime”和“mtime”的属性值为当前时间。<br>“–date&#x3D;STRING”：修改“FILE”所指代文件的“atime”和“mtime”的属性值为指定时间。比如指定<code>--date=&#39;2004-02-29  16:21:42&#39;</code>，那么会修改“FILE”所指代文件的“atime”和“mtime”的属性值为“2004-02-29  16:21:42”。<br>“-a”：只修改“FILE”所指代文件的“atime”的属性值。<br>“-m”：只修改“FILE”所指代文件的“mtime”的属性值。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>文件还有另外一个“ctime”属性，指的是最后修改inode节点中元数据的时间，修改“atime”和“mtime”属性值（其他包括硬链接计数，文件所有者，文件所属组，权限等等属性值）都是修改inode节点中的元数据，因而只要执行“touch”命令，文件的“ctime”的值都会更新为当前时间。</p>
<br/>
参考文献：
[1]man touch
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>tr命令</title>
    <url>/blog/2016/05/10/tr%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><p>有3种常用的模式，因而有3种常用用法，分别介绍如下。</p>
<h3 id="1-1、删除"><a href="#1-1、删除" class="headerlink" title="1.1、删除"></a><strong>1.1、删除</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他命令的输出 | tr [--complement] -d SET</span><br></pre></td></tr></table></figure>
<h3 id="1-2、去重"><a href="#1-2、去重" class="headerlink" title="1.2、去重"></a><strong>1.2、去重</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他命令的输出 | tr [--complement] -s SET</span><br></pre></td></tr></table></figure>
<h3 id="1-3、替换"><a href="#1-3、替换" class="headerlink" title="1.3、替换"></a><strong>1.3、替换</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他命令的输出 | tr SET1 SET2</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>相应于3种常用用法，含义分别介绍如下。</p>
<h4 id="2-1-1、删除"><a href="#2-1-1、删除" class="headerlink" title="2.1.1、删除"></a><strong>2.1.1、删除</strong></h4><p>对于标准输入内容，如果未指定“–complement”选项，表示删除其中属于“SET”的字符，进行打印；如果指定“–complement”选项，表示删除其中属于“SET补集”的字符，进行打印。</p>
<h4 id="2-1-2、去重"><a href="#2-1-2、去重" class="headerlink" title="2.1.2、去重"></a><strong>2.1.2、去重</strong></h4><p>对于标准输入内容，如果未指定“–complement”选项，当其中存在一个子串，子串的长度大于1，子串只由1个字符构成，且该字符属于“SET”，那么进行去重，即以构成该子串的字符代替该子串；如果指定“–complement”选项，将“字符属于‘SET’”的条件改为“字符属于‘SET补集’”。</p>
<h4 id="2-1-3、替换"><a href="#2-1-3、替换" class="headerlink" title="2.1.3、替换"></a><strong>2.1.3、替换</strong></h4><p>对于标准输入内容，其中的任意一个字符，只要该字符属于“SET1”，那么就以“SET2”中相应位置的字符进行替换。</p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“–complement”：表示使用显式所指定集合的补集。<br>“-d”：表示“删除”模式。<br>“-s”：表示“去重”模式。</p>
<h2 id="三、“SET”集合表示方法"><a href="#三、“SET”集合表示方法" class="headerlink" title="三、“SET”集合表示方法"></a><strong>三、“SET”集合表示方法</strong></h2><p>对于“SET”集合的表示最常用的有两种方法，分别是：枚举法和范围法。</p>
<h3 id="3-1、枚举法"><a href="#3-1、枚举法" class="headerlink" title="3.1、枚举法"></a><strong>3.1、枚举法</strong></h3><p>枚举出构成“SET”集合的所有元素，比如“abcde”。</p>
<h3 id="3-2、范围法"><a href="#3-2、范围法" class="headerlink" title="3.2、范围法"></a><strong>3.2、范围法</strong></h3><p>指定“SET”集合的“首端元素”和“尾端元素”，以“-”相连接，比如“[a-z]”。注意我们是在“递增”的语境中，确定“首端元素”和“尾端元素”的，比如对于“abc…xyz”这26个小写英文字母，在“递增”的语境中，“首端元素”是“a”，“尾端元素”是“z”。</p>
<p>备注：<br><font color='red'>允许以转义形式表达某些特殊字符，比如“\n”，“\t”和“\r”等。</font></p>
<h2 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a><strong>四、一些例子</strong></h2><h3 id="4-1、删除"><a href="#4-1、删除" class="headerlink" title="4.1、删除"></a><strong>4.1、删除</strong></h3><p><strong>1、例子1</strong><br>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot; | tr -d &quot;abcde&quot;</span><br></pre></td></tr></table></figure>
<p>所得结果如图1所示：</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160510-0-1.png"></p>
<p><strong>2、例子2</strong><br>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot; | tr --complement -d &quot;abcde\n&quot;</span><br></pre></td></tr></table></figure>
<p>所得结果如图2所示：</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160510-0-2.png"></p>
<h3 id="4-2、去重"><a href="#4-2、去重" class="headerlink" title="4.2、去重"></a><strong>4.2、去重</strong></h3><p><strong>1、例子1</strong><br>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hellllo&quot; | tr -s &quot;l&quot;</span><br></pre></td></tr></table></figure>
<p>所得结果如图3所示：</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160510-0-3.png"></p>
<p><strong>2、例子2</strong><br>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hellllo&quot; | tr --complement -s &quot;abcde&quot;</span><br></pre></td></tr></table></figure>
<p>所得结果如图4所示：</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160510-0-4.png"></p>
<h3 id="4-3、替换"><a href="#4-3、替换" class="headerlink" title="4.3、替换"></a><strong>4.3、替换</strong></h3><p><strong>1、例子1</strong><br>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot; | tr &quot;[a-z]&quot; &quot;[A-Z]&quot;</span><br></pre></td></tr></table></figure>
<p>所得结果如图5所示：</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160510-0-5.png"></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>uniq命令</title>
    <url>/blog/2016/11/19/uniq%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq [-c] [-d | -u] [-i] [-f N] [-s N] INPUT</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>对“相邻行”进行“唯一性”运算，也即对“相邻行”进行互相比较操作。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-c”：打印行出现次数。<br>“-d”：只打印出现次数大于1的行。<br>“-u”：只打印出现次数等于1的行。<br>“-i”：“相邻行”比较时，忽略大小写差异。<br>“-f N”：“相邻行”比较时，跳过前N个字段的比较，字段之间由“空格+TAB”组成的字符串隔开。<br>“-s N”：“相邻行”比较时，跳过前N个字符的比较。</p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><p>现在有一个文件“a.txt”，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">D</span><br><span class="line">d</span><br><span class="line">h world</span><br><span class="line">u world</span><br><span class="line">jklhaha</span><br><span class="line">abchaha</span><br><span class="line">jklmhah</span><br><span class="line">abcdhah</span><br><span class="line">h world hah</span><br><span class="line">u world ahh</span><br></pre></td></tr></table></figure>
<h3 id="3-1、实验1"><a href="#3-1、实验1" class="headerlink" title="3.1、实验1"></a><strong>3.1、实验1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">D</span><br><span class="line">d</span><br><span class="line">h world</span><br><span class="line">u world</span><br><span class="line">jklhaha</span><br><span class="line">abchaha</span><br><span class="line">jklmhah</span><br><span class="line">abcdhah</span><br><span class="line">h world hah</span><br><span class="line">u world ahh</span><br></pre></td></tr></table></figure>
<p>表明默认情况下，会打印所有行，但是重复行只打印1次。</p>
<h3 id="3-2、实验2"><a href="#3-2、实验2" class="headerlink" title="3.2、实验2"></a><strong>3.2、实验2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 c</span><br><span class="line">1 D</span><br><span class="line">1 d</span><br><span class="line">1 h world</span><br><span class="line">1 u world</span><br><span class="line">1 jklhaha</span><br><span class="line">1 abchaha</span><br><span class="line">1 jklmhah</span><br><span class="line">1 abcdhah</span><br><span class="line">1 h world hah</span><br><span class="line">1 u world ahh</span><br></pre></td></tr></table></figure>
<p>增加“-c”选项，额外打印了行出现次数。</p>
<h3 id="3-3、实验3"><a href="#3-3、实验3" class="headerlink" title="3.3、实验3"></a><strong>3.3、实验3</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c -u a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 a</span><br><span class="line">1 D</span><br><span class="line">1 d</span><br><span class="line">1 h world</span><br><span class="line">1 u world</span><br><span class="line">1 jklhaha</span><br><span class="line">1 abchaha</span><br><span class="line">1 jklmhah</span><br><span class="line">1 abcdhah</span><br><span class="line">1 h world hah</span><br><span class="line">1 u world ahh</span><br></pre></td></tr></table></figure>
<p>增加“-u”选项，只打印出现次数等于1的行。</p>
<h3 id="3-4、实验4"><a href="#3-4、实验4" class="headerlink" title="3.4、实验4"></a><strong>3.4、实验4</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c -d a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 b</span><br><span class="line">3 c</span><br></pre></td></tr></table></figure>
<p>增加“-d”选项，只打印出现次数大于1的行。</p>
<h3 id="3-5、实验5"><a href="#3-5、实验5" class="headerlink" title="3.5、实验5"></a><strong>3.5、实验5</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c -d -i a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 b</span><br><span class="line">3 c</span><br><span class="line">2 D</span><br></pre></td></tr></table></figure>
<p>增加“-i”选项，比较时忽略大小写差异。</p>
<h3 id="3-6、实验6"><a href="#3-6、实验6" class="headerlink" title="3.6、实验6"></a><strong>3.6、实验6</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c -d -f 1 a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 a</span><br><span class="line">2 h world</span><br><span class="line">4 jklhaha</span><br></pre></td></tr></table></figure>
<p>增加“-f 1”选项，跳过第1个字段的比较。</p>
<h3 id="3-7、实验7"><a href="#3-7、实验7" class="headerlink" title="3.7、实验7"></a><strong>3.7、实验7</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -c -d -s 3 a.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 a</span><br><span class="line">2 h world</span><br><span class="line">2 jklhaha</span><br></pre></td></tr></table></figure>
<p>增加“-s 3”选项，跳过前3个字符的比较。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>由于涉及到两个字符串的比较等，故而程序实现中使用到“LC_COLLATE”等环境变量，最终结果受到“LC_COLLATE”等环境变量的控制。</p>
<br/>
参考文献：
[1]man uniq
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>unrar命令</title>
    <url>/blog/2016/12/08/unrar%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unrar x &#x27;rar文件名&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>解压rar文件到当前目录，并保存原压缩文件目录结构。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“x”：解压时保存原压缩文件目录结构。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>unzip命令</title>
    <url>/blog/2017/08/24/unzip%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -O 解码文件名使用的编码方案 ZIP文件路径</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>解压ZIP文件到当前目录，在解码文件名时使用指定的编码方案。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-O”：指定解码文件名时所使用的编码方案，详见“三、解压后文件名乱码”。</p>
<h2 id="三、解压后文件名乱码"><a href="#三、解压后文件名乱码" class="headerlink" title="三、解压后文件名乱码"></a><strong>三、解压后文件名乱码</strong></h2><p>ZIP文件制作程序在制作ZIP文件时，默认使用所在操作系统的默认编码方案来编码待加入ZIP文件中的文件的文件名，ZIP文件中不存储这个使用的编码方案；而ZIP文件解压程序在解压ZIP文件时，默认也使用所在操作系统的默认编码方案来解码ZIP文件中的文件的文件名。如果解压时所在操作系统的默认编码方案跟制作时所在操作系统的默认编码方案不一致，那么在解压时解码得到的ZIP文件内文件的文件名就会出现乱码情形。<br>可以通过“-O”选项来应对这种情况，通过该选项可以指定解压时解码ZIP文件内文件的文件名所应该使用的编码方案。<font color='red'>“-O”选项在“man unzip”中没有介绍，在“unzip –help”中有一句话的介绍。</font><br>比如在中文Windows下制作一个ZIP文件，待加入文件的文件名包含有中文字符，在中文Windows中，默认的操作系统编码方案是CP936，因而使用CP936来编码这些文件的文件名。现在想要将该ZIP文件在Linux下解压，Linux下默认的操作系统编码方案是UTF-8，因而我们需要通过“-O”选项来指定使用CP936编码方案来解码文件的文件名，这样子解压后的文件名才不会出现乱码。<br>另外，RAR文件中会存储制作RAR文件时编码文件的文件名时所使用的编码方案，因而在解压的时候，可以直接读取该值，使用该值表示的编码方案来解码RAR中文件的文件名。</p>
<br/>
参考文献：
[1]man unzip
[2]unzip --help
[3]http://forum.ubuntu.org.cn/viewtopic.php?f=122&t=175405&p=1343326
[4]http://blog.sina.com.cn/s/blog_6261f8690101c1gx.html
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>wc命令</title>
    <url>/blog/2016/10/20/wc%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc [-c | -m | -l | -w | -L] FILE</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>统计文件中字节数，字符数，行数，单词数以及最长行长度等。</p>
<h3 id="2-2、选项"><a href="#2-2、选项" class="headerlink" title="2.2、选项"></a><strong>2.2、选项</strong></h3><p>“-c”：统计“FILE”文件中字节数。<br>“-m”：统计“FILE”文件中字符数。<br>“-l”：统计“FILE”文件中行数。<br>“-w”：统计“FILE”文件中单词数。<br>“-L”：打印“FILE”文件中最长行的长度。</p>
<br/>
参考文献：
[1]man wc
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>wget命令</title>
    <url>/blog/2015/06/24/wget%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>wget命令有两个作用：</p>
<ol>
<li>下载文件</li>
<li>作为一个网络爬虫，将网站内容抓取下来</li>
</ol>
<p>wget命令支持HTTP，FTP和HTTPS协议。</p>
<h2 id="一、下载文件"><a href="#一、下载文件" class="headerlink" title="一、下载文件"></a><strong>一、下载文件</strong></h2><p>常用用法：<code>wget URL</code><br>含义：下载URL指向的文件</p>
<h2 id="二、网络爬虫"><a href="#二、网络爬虫" class="headerlink" title="二、网络爬虫"></a><strong>二、网络爬虫</strong></h2><p>常用用法：<code>wget -e robots=off -r -l 2 -k -p -E -H https://mybatis.github.io/mybatis-3/zh/</code><br>含义：爬“<a href="https://mybatis.github.io”网站的内容,以“https//mybatis.github.io/mybatis-3/zh/%E2%80%9D%E4%B8%BA%E8%B5%B7%E5%A7%8BURL">https://mybatis.github.io”网站的内容，以“https://mybatis.github.io/mybatis-3/zh/”为起始URL</a></p>
<p>选项解释：<br><code>-e robots=off</code>：表示不遵循robots.txt文档<br><code>-r</code>：递归下载，默认深度为5<br><code>-l 2</code>：自定义递归下载的深度为2<br><code>-k</code>：转换下载得到文档中的链接，使得可正常使用<br><code>-p</code>：下载正常显示单个文档所必需的所有文件<br><code>-E</code>：自动给一些文档增加“.html”后缀<br><code>-H</code>：在递归下载时，允许跨域名</p>
<p><strong>备注</strong>：</p>
<ul>
<li>当URL使用HTTPS协议时，经常出现如下错误：“无法建立SSL连接”，具体如图1所示。这是因为wget在使用HTTPS协议时，默认会去验证网站的证书，而这个证书验证经常会失败。加上“–no-check-certificate”选项，就能排除掉这个错误。另外一种可能有效的解决方案是用HTTP协议替换HTTPS协议（有些网站同时支持这两种协议访问相同资源，有些网站只支持HTTPS协议或者HTTP协议）</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20150624-0-1.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man wget<br>[2]<a href="https://www.gnu.org/software/wget/manual/html_node/Robot-Exclusion.html">https://www.gnu.org/software/wget/manual/html_node/Robot-Exclusion.html</a></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>xargs命令</title>
    <url>/blog/2022/10/08/xargs%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、常用用法"><a href="#一、常用用法" class="headerlink" title="一、常用用法"></a><strong>一、常用用法</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他命令的输出 | xargs [command] [initial-arguments]</span><br></pre></td></tr></table></figure>
<h2 id="二、含义与选项"><a href="#二、含义与选项" class="headerlink" title="二、含义与选项"></a><strong>二、含义与选项</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>解析命令字符串并执行。<font color='red'>一般情况下，其他命令的输出以“空格”或者“换行符”为分隔符隔开为多个部分，对于每个部分，“xargs”后面的命令都会执行一次。</font></p>
<h3 id="2-2、选项表示的意思"><a href="#2-2、选项表示的意思" class="headerlink" title="2.2、选项表示的意思"></a><strong>2.2、选项表示的意思</strong></h3><p>“command”：欲执行命令，默认命令是“echo”<br>“initial-arguments”：欲执行命令的初始化参数<br>“其他命令的输出”：欲执行命令除“initial-arguments”之外的参数来源</p>
<h2 id="三、样例"><a href="#三、样例" class="headerlink" title="三、样例"></a><strong>三、样例</strong></h2><h3 id="3-1、样例1"><a href="#3-1、样例1" class="headerlink" title="3.1、样例1"></a><strong>3.1、样例1</strong></h3><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&quot; | xargs ls -lrt</span><br></pre></td></tr></table></figure>
<p>得到如图1所示结果：</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-1-1.png"></p>
<h3 id="3-2、样例2"><a href="#3-2、样例2" class="headerlink" title="3.2、样例2"></a><strong>3.2、样例2</strong></h3><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;-l&quot; | xargs ls -rt</span><br></pre></td></tr></table></figure>
<p>得到如图2所示结果：</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-1-2.png"></p>
<h3 id="3-3、样例3"><a href="#3-3、样例3" class="headerlink" title="3.3、样例3"></a><strong>3.3、样例3</strong></h3><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;-lrt&quot; | xargs ls</span><br></pre></td></tr></table></figure>
<p>得到如图3所示结果：</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-1-3.png"></p>
<h3 id="3-4、样例4"><a href="#3-4、样例4" class="headerlink" title="3.4、样例4"></a><strong>3.4、样例4</strong></h3><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&quot; | ls</span><br></pre></td></tr></table></figure>
<p>得到如图4所示结果：</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-1-4.png"></p>
<h3 id="3-5、样例5"><a href="#3-5、样例5" class="headerlink" title="3.5、样例5"></a><strong>3.5、样例5</strong></h3><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;a.sh&quot; &quot;b.sh&quot; | xargs stat</span><br></pre></td></tr></table></figure>
<p>得到如图5所示结果：</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160507-1-5.png"></p>
<p>以上验证了<code>一般情况下，其他命令的输出以“空格”或者“换行符”为分隔符隔开为多个部分，对于每个部分，“xargs”后面的命令都会执行一次</code>。</p>
<h3 id="3-6、样例6"><a href="#3-6、样例6" class="headerlink" title="3.6、样例6"></a><strong>3.6、样例6</strong></h3><p>与find命令联用的场景中，如果结果文件路径中有空格符，使用xargs命令需要加上<code>-d &#39;\n&#39;</code>选项以表示只将“换行符”作为分隔符，避免将一个含有空格字符的文件路径作为两部分分别传入导致出现<code>没有那个文件或目录</code>错误。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>“取反加一”等价于“减一取反”的证明</title>
    <url>/blog/2016/06/26/%E2%80%9C%E5%8F%96%E5%8F%8D%E5%8A%A0%E4%B8%80%E2%80%9D%E7%AD%89%E4%BB%B7%E4%BA%8E%E2%80%9C%E5%87%8F%E4%B8%80%E5%8F%96%E5%8F%8D%E2%80%9D%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>在补码运算中，经常需要进行“取反加一”操作。本文尝试证明“减一取反”操作与“取反加一”操作等价。</p>
<h2 id="一、设定"><a href="#一、设定" class="headerlink" title="一、设定"></a><strong>一、设定</strong></h2><p>假如一个补码数有“1+x”位，第1位为符号位，后面x位为有效数据位。“取反加一”或者“减一取反”操作在有效数据位上进行。</p>
<h2 id="二、证明"><a href="#二、证明" class="headerlink" title="二、证明"></a><strong>二、证明</strong></h2><p>证明可分为两种情况。</p>
<h3 id="2-1、从右往左数，遇到的第一个“1”所在位为第k位，且k"><a href="#2-1、从右往左数，遇到的第一个“1”所在位为第k位，且k" class="headerlink" title="2.1、从右往左数，遇到的第一个“1”所在位为第k位，且k&lt;&#x3D;x"></a><strong>2.1、从右往左数，遇到的第一个“1”所在位为第k位，且k&lt;&#x3D;x</strong></h3><p>可以将有效数据位分为两部分：[x…k+1]和[k…1]，前半部分A可以表示成“xxxx…xxx”的形式，后半部分B可以表示成“1000…000”的形式。<br>对有效数据位分别进行“取反加一”操作和“减一取反”操作。</p>
<ul>
<li>“取反加一”操作结果为：<br>前半部分A转换成“~A”<br>后半部分B转换成“B”（“取反”得到“0111…111”，“加一”得到“1000…000”）</li>
<li>“减一取反”操作结果为：<br>前半部分A转换成“~A”<br>后半部分B转换成“B”（“减一”得到“0111…111”，“取反”得到“1000…000”）</li>
</ul>
<p>以上证明两种操作等价。</p>
<h3 id="2-2、从右往左数，从第1位到第x位都为“0”，不存在“1”位"><a href="#2-2、从右往左数，从第1位到第x位都为“0”，不存在“1”位" class="headerlink" title="2.2、从右往左数，从第1位到第x位都为“0”，不存在“1”位"></a><strong>2.2、从右往左数，从第1位到第x位都为“0”，不存在“1”位</strong></h3><p>可以将有效数据位表示成“0000…000”的形式。<br>对有效数据位分别进行“取反加一”操作和“减一取反”操作。</p>
<ul>
<li>“取反加一”操作结果为：<br>“0000…000”（“取反”得到“1111…111”，“加一”得到“0000…000”）</li>
<li>“减一取反”操作结果为：<br>“0000…000”（“减一”得到“1111…111”，“取反”得到“0000…000”）</li>
</ul>
<p>以上证明两种操作等价。</p>
<br/>
<font color='red'>综合2.1和2.2，可以证明“取反加一”操作和“减一取反”操作等价。</font>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>《Version Control With Git》Git库的基础数据结构</title>
    <url>/blog/2017/03/29/%E3%80%8AVersion-Control-With-Git%E3%80%8BGit%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文介绍Git库的基础数据结构，这是Git得以运转的基础。Git库的基础数据结构根据作用主要可分为“支持存放数据信息的”，“支持存放配置信息的”和“支持存放索引信息的”这3大类。详细描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>基础数据结构作用</th>
<th>基础数据结构名称</th>
<th>基础数据结构存放路径</th>
</tr>
</thead>
<tbody><tr>
<td>支持存放数据信息的</td>
<td>Object Store和Pack File</td>
<td>.git&#x2F;objects目录</td>
</tr>
<tr>
<td>支持存放配置信息的</td>
<td>配置文件</td>
<td>.git&#x2F;config文件</td>
</tr>
<tr>
<td>支持存放索引信息的</td>
<td>索引文件</td>
<td>.git&#x2F;index文件</td>
</tr>
</tbody></table>
<h2 id="一、Object-Store"><a href="#一、Object-Store" class="headerlink" title="一、Object Store"></a><strong>一、Object Store</strong></h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a><strong>1.1、概念</strong></h3><p>Object Store内存储有Git库内所有数据文件和所有修改操作记录等数据，根据这些数据可获得Git库任意版本的快照。Object Store内所有数据文件可分为“Blob”，“Tree”，“Commit”和“Tag”这4种类型，文件名由40个十六进制字符构成，具体是对文件内容应用SHA1算法而获得。<br>Object Store内数据文件具体存放路径为“.git&#x2F;objects目录”，取文件名前两个十六进制字符创建子目录，防止直接平铺文件数量过多。</p>
<h4 id="1-1-1、Blob"><a href="#1-1-1、Blob" class="headerlink" title="1.1.1、Blob"></a><strong>1.1.1、Blob</strong></h4><p>Blob类型文件存储Git库内数据文件的具体内容，Git库内不同数据文件和数据文件的不同版本对应于不同的Blob类型文件（一个数据文件的两个版本即便只有一点修改，仍会以“两个独立的Blob类型文件”形式存在，而不是“一个独立的Blob类型文件，另外一个差异内容文件”形式）。<br>Blob类型文件不能引用其他类型文件，只能被Tree类型文件引用。</p>
<h4 id="1-1-2、Tree"><a href="#1-1-2、Tree" class="headerlink" title="1.1.2、Tree"></a><strong>1.1.2、Tree</strong></h4><p>Tree类型文件内有0到多行记录，每行记录或指向一个Blob类型文件，或指向另外一个Tree类型文件。选取某个Tree类型文件为树的根节点，向下遍历，可得到文件系统内相应的一棵“目录-文件层次树”。<br>Tree类型文件能够引用Tree类型或者Blob类型文件，且能够被Tree类型或者Commit类型文件引用。</p>
<h4 id="1-1-3、Commit"><a href="#1-1-3、Commit" class="headerlink" title="1.1.3、Commit"></a><strong>1.1.3、Commit</strong></h4><p>Commit类型文件保存修改操作记录，每次提交修改操作记录时都会创建一个新的Commit类型文件。Commit类型文件（除了初始Commit类型文件）会以上一次提交修改操作记录时创建的Commit类型文件为父Commit类型文件，同时会引用一个Tree类型文件。以该Tree类型文件为树的根节点进行遍历，得到的相应的“目录-文件层次树”即为Git库某个版本的完整快照。<br>Commit类型文件能够以Commit类型文件为父Commit类型文件，能够引用Tree类型文件，且能够被Tag类型文件引用。</p>
<h4 id="1-1-4、Tag"><a href="#1-1-4、Tag" class="headerlink" title="1.1.4、Tag"></a><strong>1.1.4、Tag</strong></h4><p>Tag类型文件保存相关联的其他类型文件的描述信息，比如说“版本号”，这个其他类型文件一般为“Commit类型文件”。<br>Tag类型文件要么不存在，如果存在，则引用一个Commit类型文件。</p>
<h3 id="1-2、实例"><a href="#1-2、实例" class="headerlink" title="1.2、实例"></a><strong>1.2、实例</strong></h3><h4 id="1-2-1、增加操作"><a href="#1-2-1、增加操作" class="headerlink" title="1.2.1、增加操作"></a><strong>1.2.1、增加操作</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Commit类型文件包含提交时间，因此，Commit类型文件文件名很大可能跟图示不一致</span><br><span class="line"># Tag类型文件引用Commit类型文件，由以上知，Tag类型文件文件名很大可能也跟图示不一致</span><br><span class="line">rm -rf *</span><br><span class="line">git init</span><br><span class="line">git config --local user.email &#x27;dslztx@not.com&#x27;</span><br><span class="line">git config --local user.name &#x27;dslztx&#x27;</span><br><span class="line">echo &quot;hello world&quot; &gt; hello.txt</span><br><span class="line">git add hello.txt</span><br><span class="line">git commit . -m &#x27;first commit&#x27;</span><br><span class="line">mkdir subdir1</span><br><span class="line">echo &quot;hello world again&quot; &gt; subdir1/hello.txt</span><br><span class="line">git add subdir1</span><br><span class="line">git commit . -m &#x27;second commit&#x27;</span><br><span class="line">mkdir subdir2</span><br><span class="line">cp hello.txt subdir2/</span><br><span class="line">git add subdir2</span><br><span class="line">git commit . -m &#x27;third commit&#x27;</span><br><span class="line"># 以下命令需要手动补全</span><br><span class="line"># git tag -m &#x27;Version 1.0&#x27; V1.0 第1次Commit类型文件文件名</span><br><span class="line"># git tag -m &#x27;Version 2.0&#x27; V2.0 第2次Commit类型文件文件名</span><br><span class="line"># git tag -m &#x27;Version 3.0&#x27; V3.0 第3次Commit类型文件文件名</span><br></pre></td></tr></table></figure>
<p>读取Object Store内数据文件的内容，可得到如图1所示引用关系图。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170329-1-1.jpg"></p>
<h4 id="1-2-2、删除操作"><a href="#1-2-2、删除操作" class="headerlink" title="1.2.2、删除操作"></a><strong>1.2.2、删除操作</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Commit类型文件包含提交时间，因此，Commit类型文件文件名很大可能跟图示不一致</span><br><span class="line">rm -rf *</span><br><span class="line">git init</span><br><span class="line">git config --local user.email &#x27;dslztx@not.com&#x27;</span><br><span class="line">git config --local user.name &#x27;dslztx&#x27;</span><br><span class="line">echo &quot;hello world&quot; &gt; hello.txt</span><br><span class="line">git add hello.txt</span><br><span class="line">git commit . -m &#x27;first commit&#x27;</span><br><span class="line">git rm hello.txt</span><br><span class="line">git commit . -m &#x27;second commit&#x27;</span><br></pre></td></tr></table></figure>
<p>读取Object Store内数据文件的内容，可得到如图2所示引用关系图。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170329-1-2.jpg"></p>
<h4 id="1-2-3、修改操作"><a href="#1-2-3、修改操作" class="headerlink" title="1.2.3、修改操作"></a><strong>1.2.3、修改操作</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Commit类型文件包含提交时间，因此，Commit类型文件文件名很大可能跟图示不一致</span><br><span class="line">rm -rf *</span><br><span class="line">git init</span><br><span class="line">git config --local user.email &#x27;dslztx@not.com&#x27;</span><br><span class="line">git config --local user.name &#x27;dslztx&#x27;</span><br><span class="line">echo &quot;hello world&quot; &gt; hello.txt</span><br><span class="line">git add hello.txt</span><br><span class="line">git commit . -m &#x27;first commit&#x27;</span><br><span class="line">git mv hello.txt hello.txt.alter</span><br><span class="line">git commit . -m &#x27;second commit&#x27;</span><br><span class="line">echo &quot;hello world content alter&quot; &gt; hello.txt.alter</span><br><span class="line">git commit . -m &#x27;third commit&#x27;</span><br></pre></td></tr></table></figure>
<p>读取Object Store内数据文件的内容，可得到如图3所示引用关系图。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20170329-1-3.jpg"></p>
<h2 id="二、Pack-File"><a href="#二、Pack-File" class="headerlink" title="二、Pack File"></a><strong>二、Pack File</strong></h2><p>为了节省空间，Git会将Object Store内数据文件的内容使用zlib库进行压缩（也因此，不能直接查看这些数据文件的内容）。而为了更加压缩存储空间，Git又提供了Pack File机制，该机制会将Object Store内数据文件重新整合起来，以特定格式进行组织，达到再次压缩的目的。<br>Pack File机制产出文件的具体存放路径为“.git&#x2F;objects&#x2F;pack目录”和“.git&#x2F;objects&#x2F;info目录”。<br>触发Pack File机制的途径有：Object Store内含有过多数据文件，<code>push</code>本地Git库到远端Git库，执行<code>git gc</code>命令。<br>接下来进行举例说明，在上面的描述中，同一个文件的不同版本即便只有一点修改，也会以“两个独立的Blob类型文件”的形式保存，有些时候，这会显得浪费空间。在这种情形下，触发Pack File机制，可以大大减少空间的浪费，以下是具体的实验步骤。<br>1、执行以下命令，将原“repo.rb”和新“repo.rb”文件提交到Git库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb</span><br><span class="line">git add repo.rb</span><br><span class="line">git commit . -m &#x27;first commit&#x27;</span><br><span class="line">echo &quot;hello world&quot; &gt;&gt; repo.rb</span><br><span class="line">git commit . -m &#x27;second commit&#x27;</span><br></pre></td></tr></table></figure>
<p>此时Object Store内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git/objects</span><br><span class="line">.git/objects/95</span><br><span class="line">.git/objects/95/18b8504da44df20d70a5d8589a02535ca1e2a5</span><br><span class="line">.git/objects/03</span><br><span class="line">.git/objects/03/3b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5</span><br><span class="line">.git/objects/10</span><br><span class="line">.git/objects/10/e19ae731d1179fe21d22f223fb70d60c6a04e6</span><br><span class="line">.git/objects/c0</span><br><span class="line">.git/objects/c0/addf97e62267442515f4c7b31f754e6a777789</span><br><span class="line">.git/objects/38</span><br><span class="line">.git/objects/38/feecbdf638935287fd920e8f2d694aa8c28d9f</span><br><span class="line">.git/objects/pack</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/58</span><br><span class="line">.git/objects/58/7438a7ab34b34ca57e2da92ecf7b79c8bb4fb0</span><br></pre></td></tr></table></figure>
<p>经过查找发现原“repo.rb”和新“repo.rb”文件对应的Blob类型文件文件名分别为“033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5”和“587438a7ab34b34ca57e2da92ecf7b79c8bb4fb0”，分别执行<code>git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5</code>和<code>git cat-file -s 587438a7ab34b34ca57e2da92ecf7b79c8bb4fb0</code>命令，可知“033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5”和“587438a7ab34b34ca57e2da92ecf7b79c8bb4fb0”文件大小分别为“22044”和“22056”字节<br>2、执行<code>/usr/bin/du --block-size=1 -s .git/objects</code>命令，可知此时Object Store内数据文件总大小为“69632”字节<br>3、执行<code>git gc</code>命令触发Pack File机制，此时Object Store内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git/objects</span><br><span class="line">.git/objects/pack</span><br><span class="line">.git/objects/pack/pack-72421cdfd34c79982edc4882bd4febc308e5ae11.idx</span><br><span class="line">.git/objects/pack/pack-72421cdfd34c79982edc4882bd4febc308e5ae11.pack</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/info/packs</span><br></pre></td></tr></table></figure>
<p>4、执行<code>git verify-pack -v .git/objects/pack/pack-72421cdfd34c79982edc4882bd4febc308e5ae11.idx</code>命令，可知“587438a7ab34b34ca57e2da92ecf7b79c8bb4fb0”文件大小为“22056”字节，“033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5”文件引用“587438a7ab34b34ca57e2da92ecf7b79c8bb4fb0”，而其自身大小为“9”字节<br>5、执行<code>/usr/bin/du --block-size=1 -s .git/objects</code>命令，可知此时Object Store内数据文件总大小为“28672”字节</p>
<h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a><strong>三、配置文件</strong></h2><p>Git库的本地配置文件为“.git&#x2F;config文件”，但是，参数配置不单只有该途径。参数配置按照优先级从低到高顺序为：“&#x2F;etc&#x2F;gitconfig文件”，“~&#x2F;.gitconfig文件”，“.git&#x2F;config文件”，“环境变量”和“命令行参数配置”。</p>
<h2 id="四、索引文件"><a href="#四、索引文件" class="headerlink" title="四、索引文件"></a><strong>四、索引文件</strong></h2><p>对Git库的操作（增加，删除，修改等）暂时被保存在索引文件中，只在<code>git commit</code>命令执行后，才被真正提交到Git库。</p>
<br/>
参考文献：
[1]https://git-scm.com/book/be/v2/Git-Internals-Packfiles
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>《Version Control With Git》介绍</title>
    <url>/blog/2017/03/09/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>“Version Control System（VCS）”发展简要：<br>1、“Source Code Control System”，简称“SCCS”<br>2、“Revision Control System”，简称“RCS”<br>3、“Concurrent Version System”，简称“CVS”<br>4、“Subversion”，简称“SVN”<br>5、“BitKeeper”<br>6、“Mercurial”<br>7、“Git”</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>《Version Control With Git》入门</title>
    <url>/blog/2017/03/20/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、基本概念–Git目录"><a href="#一、基本概念–Git目录" class="headerlink" title="一、基本概念–Git目录"></a><strong>一、基本概念–Git目录</strong></h2><p>每个Git目录下都有一个“.git”目录，该目录存储相应的“Git库”的所有数据信息，配置信息和索引信息等信息。<br>Git目录逻辑上包含“Git库”和“本地工作目录”，核心是“Git库”。</p>
<h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a><strong>二、基本命令</strong></h2><p>通过<code>git help</code>和<code>git help 子命令</code>语法可分别查看使用git命令和git子命令的帮助信息。</p>
<h3 id="2-1、git-init"><a href="#2-1、git-init" class="headerlink" title="2.1、git init"></a><strong>2.1、git init</strong></h3><p>在一个本地工作目录下执行<code>git init</code>命令，会在当前目录下生成一个“.git”目录，即产生得到一个“Git库”，此时该Git库不含有内容，即为空。<br>此时“原本地工作目录”晋升为“Git目录”，其下包含“Git库”和“本地工作目录”。</p>
<h3 id="2-2、git-add"><a href="#2-2、git-add" class="headerlink" title="2.2、git add"></a><strong>2.2、git add</strong></h3><p>对于一个未被置于Git库中的本地工作目录下的文件“a.txt”，通过<code>git add a.txt</code>命令可将该文件加入到Git库中。</p>
<h3 id="2-3、git-rm"><a href="#2-3、git-rm" class="headerlink" title="2.3、git rm"></a><strong>2.3、git rm</strong></h3><p>文件“a.txt”已经被置于Git库中。执行<code>git rm a.txt</code>命令表示从Git库中删除文件“a.txt”，同时也删除本地工作目录下相应的文件“a.txt”。</p>
<h3 id="2-4、git-mv"><a href="#2-4、git-mv" class="headerlink" title="2.4、git mv"></a><strong>2.4、git mv</strong></h3><p>文件“a.txt”已经被置于Git库中。执行<code>git mv a.txt b.txt</code>命令表示将Git库中的文件“a.txt”重命名为“b.txt”，同时本地工作目录下相应的文件“a.txt”也被重命名为“b.txt”。</p>
<h3 id="2-5、修改文件"><a href="#2-5、修改文件" class="headerlink" title="2.5、修改文件"></a><strong>2.5、修改文件</strong></h3><p>文件“a.txt”已经被置于Git库中。使用“vim，emacs”等编辑器编辑本地工作目录下相应文件“a.txt”的内容，使用<code>git commit</code>提交时能够自动识别这些修改。</p>
<h3 id="2-6、git-commit"><a href="#2-6、git-commit" class="headerlink" title="2.6、git commit"></a><strong>2.6、git commit</strong></h3><p>把所有修改操作真正提交到Git库，在此之前所有修改操作只是被临时性保存而已。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>《Version Control With Git》安装Git</title>
    <url>/blog/2017/03/10/%E3%80%8AVersion-Control-With-Git%E3%80%8B%E5%AE%89%E8%A3%85Git/</url>
    <content><![CDATA[<p>Ubuntu下安装Git的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>以上命令用于安装Git核心工具包，除此之外还有“git-doc”，“git-svn”，“git-email”等Git附加工具包。<br>可通过如下命令获取完整的Git工具包列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git[TAB按键]</span><br></pre></td></tr></table></figure>
<p>完整的Git工具包如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170309-0-1.png"></p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》垃圾收集器与内存分配策略</title>
    <url>/blog/2017/03/16/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>本文讨论垃圾收集和内存分配技术。我们知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟机进程内存管理对所使用的“Native Memory”的具体分类为：</span><br><span class="line">程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区，直接内存，自己写的JNI方法直接所分配内存，虚拟机进程运行自身需要内存和其他使用内存。</span><br></pre></td></tr></table></figure>
<p>关于这些内存区域的“垃圾收集和内存分配”有以下几点：</p>
<ul>
<li>“程序计数器，Java虚拟机栈，本地方法栈”这3个内存区域随线程而生，随线程而灭，栈中的栈帧（栈帧需要多少内存在类结构确定时就大体已知）随着方法的进入和退出执行出栈和入栈操作，线程结束时，这3个区域的内存自然就跟随着被回收，因此这3个区域的垃圾收集和内存分配具备确定性</li>
<li>“直接内存”这个内存区域的垃圾收集和内存分配跟C&#x2F;C++语言类似：手动回收和分配内存（使用“直接内存”有使用“sun.misc.Unsafe”和“java.nio.ByteBuffer”两种方式，使用“java.nio.ByteBuffer”方式时，“回收内存”的方法会被自动调用，此时内存回收“不再手动”）[1]</li>
<li>“自己写的JNI方法直接所分配内存，虚拟机进程运行自身需要内存，其他使用内存”这3个内存区域的垃圾收集和内存分配方式是“手动的”</li>
<li>对于“Java堆和方法区”这两个内存区域而言，垃圾收集和内存分配是动态的。由于两者存储对象的性质不同，因此，两者的垃圾收集和内存分配策略也不尽相同</li>
</ul>
<p><font color='red'>由于“Java堆”是虚拟机进程中最重要的内存区域，因此，接下来围绕“Java堆”这个内存区域介绍垃圾收集和内存分配技术。不同JDK版本，采用的机制和实现有可能不同，本文选定JDK6版本（具体是jdk1.6.0_23）。</font><br>为了更好地管理“Java堆”内存，“Java堆”分为“新生代（又被称为“New”）”和“老年代（又被称为“Old”或者“Tenured”）两个年代区域。“新生代”又由“1个Eden区和2个Survivor区”构成，“新生代”可使用总内存为“1个Eden区与1个Survivor区”内存之和。</p>
<h2 id="一、可达性分析——判断对象能否被回收"><a href="#一、可达性分析——判断对象能否被回收" class="headerlink" title="一、可达性分析——判断对象能否被回收"></a><strong>一、可达性分析——判断对象能否被回收</strong></h2><h3 id="1-1、“引用”的扩展概念"><a href="#1-1、“引用”的扩展概念" class="headerlink" title="1.1、“引用”的扩展概念"></a><strong>1.1、“引用”的扩展概念</strong></h3><p>在JDK 1.2之后，“引用”概念被扩展，分为：强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference）和虚引用（Phantom Reference）。详细描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>详细介绍</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>普遍存在于Java代码中，类似于<code>Object obj=new Object()</code></td>
</tr>
<tr>
<td>软引用</td>
<td><font color='red'>在抛出内存溢出异常之前</font>，虚拟机会断掉“软引用”关系，并进行一次垃圾收集，如果在垃圾收集后，内存还是不足，才会真正抛出内存溢出异常。JDK中关于“软引用”的相关类为<code>java.lang.ref.SoftReference</code></td>
</tr>
<tr>
<td>弱引用</td>
<td>“弱引用”关系只能经历一次垃圾收集过程，之后该“弱引用”关系便会断掉。JDK中关于“弱引用”的相关类为<code>java.lang.ref.WeakReference</code></td>
</tr>
<tr>
<td>虚引用</td>
<td>被“虚引用”的对象相当于没被引用，“虚引用”关系存在的唯一目的是：在被“虚引用”的对象被回收时，能够得到一个系统通知。JDK中关于“虚引用”的相关类为<code>java.lang.ref.PhantomReference</code></td>
</tr>
</tbody></table>
<h3 id="1-2、可达性分析算法"><a href="#1-2、可达性分析算法" class="headerlink" title="1.2、可达性分析算法"></a><strong>1.2、可达性分析算法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以一系列被称为“GC Roots”的对象作为起始点，如果某个对象被引用可达，那么该对象不可被回收，否则，该对象可被回收。</span><br></pre></td></tr></table></figure>
<p>Java语言中，可作为“GC Roots”的对象包括下面几种：</p>
<ul>
<li>Java虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<p><font color='red'>需要注意的是，上述“引用可达”中的“引用”包括“强引用，软引用和弱引用”，另外，由上一小节内容可知，“软引用”和“弱引用”关系在某些条件下会“断掉”，“断掉”就意味着“不可达”。</font></p>
<h3 id="1-3、能否“死而复生”"><a href="#1-3、能否“死而复生”" class="headerlink" title="1.3、能否“死而复生”"></a><strong>1.3、能否“死而复生”</strong></h3><p>对象真正可被回收，需要得到两次标记：<br>1、对象从“GC Roots”不可达，得到1次标记<br>2、“对象没有覆盖finalize()方法”或者“对象覆盖了finalize()方法，且该方法被虚拟机调用过1次”，得到1次标记；否则，有一个由虚拟机自动建立的低优先级的Finalizer线程会去触发执行该对象的finalize()方法，然后该对象得到1次标记</p>
<p><font color='red'>备注：</font><br>1、Finalizer线程触发执行对象的finalize()方法，但是并不保证finalize()方法一定会执行完成<br>2、对象的finalize()方法最多被触发执行1次<br>3、对象的finalize()方法执行过程中，可将对象自身变为从“GC Roots”可达，从而“死而复生”<br>4、对象的finalize()方法运行代价高昂，而且该方法能做的使用“try-finally”或者其他方式都可以做到，因此，应该完全忘记掉该方法的存在</p>
<h2 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a><strong>二、垃圾收集</strong></h2><h3 id="2-1、基本垃圾收集算法描述"><a href="#2-1、基本垃圾收集算法描述" class="headerlink" title="2.1、基本垃圾收集算法描述"></a><strong>2.1、基本垃圾收集算法描述</strong></h3><p>基本垃圾收集算法描述见表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>英文名称</th>
<th>描述</th>
<th>不足</th>
</tr>
</thead>
<tbody><tr>
<td>标记-清除</td>
<td>Mark-Sweep</td>
<td>“标记阶段”：标记所有需要回收的对象；“清除阶段”：统一回收被标记的对象</td>
<td>“标记阶段”和“清除阶段”效率不高，标记清除之后会产生大量内存碎片</td>
</tr>
<tr>
<td>复制</td>
<td>Copying</td>
<td>将可用内存分为相同大小的两半内存。“标记阶段”：标记所有需要回收的对象；“回收阶段”时，将一半内存中未在“标记阶段”被标记的对象复制到另外一半内存</td>
<td>可使用内存减少一半</td>
</tr>
<tr>
<td>标记-整理</td>
<td>Mark-Compact</td>
<td>“标记阶段”：标记所有需要回收的对象；“整理阶段”：保留未被标记的对象，并进行紧凑整理</td>
<td>“标记阶段”和“整理阶段”效率不高</td>
</tr>
</tbody></table>
<h3 id="2-2、垃圾收集器"><a href="#2-2、垃圾收集器" class="headerlink" title="2.2、垃圾收集器"></a><strong>2.2、垃圾收集器</strong></h3><p>在继续介绍之前，先介绍几个概念：<br><strong>1、并行和并发</strong><br>“原始并行”的含义是：存在多CPU，多个进程&#x2F;线程在不同CPU上同时运行；“原始并发”的含义是：存在单CPU，多个进程&#x2F;线程在该单CPU上交替运行。“本文上下文的并行”的含义是：多个GC线程并行&#x2F;并发运行，用户线程暂停；“本文上下文的并发”的含义是：GC线程和用户线程并行&#x2F;并发运行。<br><strong>2、吞吐量和停顿时间控制平衡</strong><br>吞吐量&#x3D;用户线程运行时间&#x2F;（用户线程运行时间+GC线程运行时间）。想要减小停顿时间，在不考虑优化垃圾回收算法前提下，只能减小待回收垃圾内存空间的大小，这会导致虽然单次垃圾回收停顿时间减小，但是在一个恒定时间区间内，垃圾回收次数增加，停顿时间总和增加，因此，停顿时间减小，吞吐量也随之减小。<br>停顿时间越小，越适合交互应用程序；吞吐量越大，越适合后台计算式不需要太多交互的应用程序。<br><strong>3、不同年代垃圾回收具有独立性</strong><br>通过一定技术手段，新生代和老年代的垃圾收集器能够独立完成所处年代的垃圾回收工作。<font color='red'>即可独立完成所处年代的可达性分析，并进行垃圾回收。</font><br><strong>4、安全点、安全区域和STW</strong><br>为完成垃圾回收过程的一些关键步骤，必须暂停所有用户线程，只允许运行GC线程，此时的状态被称为“Stop The World（STW）”。此时，用户线程或暂停于安全点（Safepoint），或处于安全区域（Safe Region）中（处于安全区域中的用户线程或处于Running状态，或处于Sleep状态，或处于Blocked状态，或跟安全点处的用户线程一样处于暂停状态。<font color='red'>需要注意的是，处于Sleep或者Blocked状态的用户线程一定处于安全区域中</font>）。“安全区域”可被认为是扩展的“安全点”，接下来的图示中，以“安全点”涵盖“安全点和安全区域”。<br><strong>5、新生代垃圾收集器与老年代垃圾收集器配对</strong><br>新生代的垃圾收集器与老年代的垃圾收集器不能任意匹配，存在一个配对关系。如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-1.jpg"></p>
<h4 id="2-2-1、Serial收集器"><a href="#2-2-1、Serial收集器" class="headerlink" title="2.2.1、Serial收集器"></a><strong>2.2.1、Serial收集器</strong></h4><p>采用“复制算法”的“新生代”垃圾收集器，JVM运行在Client模式下首选的“新生代”垃圾收集器，主要关注点在于尽量小的停顿时间。进行GC过程时，既不“并行”，也不“并发”，需要“Stop The World”。示意图如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-2.jpg"></p>
<h4 id="2-2-2、ParNew收集器"><a href="#2-2-2、ParNew收集器" class="headerlink" title="2.2.2、ParNew收集器"></a><strong>2.2.2、ParNew收集器</strong></h4><p>采用“复制算法”的“新生代”垃圾收集器，JVM运行在Server模式下首选的“新生代”垃圾收集器，主要关注点在于尽量小的停顿时间。进行GC过程时，“并行”不“并发”，需要“Stop The World”。示意图如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-3.jpg"></p>
<h4 id="2-2-3、Parallel-Scavenge收集器"><a href="#2-2-3、Parallel-Scavenge收集器" class="headerlink" title="2.2.3、Parallel Scavenge收集器"></a><strong>2.2.3、Parallel Scavenge收集器</strong></h4><p>采用“复制算法”的“新生代”垃圾收集器，主要关注点在于达到可控制的吞吐量，<font color='red'>且能够进行自适应调节</font>。进行GC过程时，“并行”不“并发”，需要“Stop The World”。示意图如图4所示。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-3.jpg"></p>
<h4 id="2-2-4、Serial-Old收集器"><a href="#2-2-4、Serial-Old收集器" class="headerlink" title="2.2.4、Serial Old收集器"></a><strong>2.2.4、Serial Old收集器</strong></h4><p>采用“标记-整理算法”的“老年代”垃圾收集器，主要关注点在于尽量小的停顿时间。进行GC过程时，既不“并行”，也不“并发”，需要“Stop The World”。示意图如图5所示。</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-2.jpg"></p>
<h4 id="2-2-5、Parallel-Old收集器"><a href="#2-2-5、Parallel-Old收集器" class="headerlink" title="2.2.5、Parallel Old收集器"></a><strong>2.2.5、Parallel Old收集器</strong></h4><p>采用“标记-整理算法”的“老年代”垃圾收集器，主要关注点在于达到可控制的吞吐量，<font color='red'>且能够进行自适应调节。</font>进行GC过程时，“并行”不“并发”，需要“Stop The World”。示意图如图6所示。</p>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-3.jpg"></p>
<h4 id="2-2-6、CMS收集器"><a href="#2-2-6、CMS收集器" class="headerlink" title="2.2.6、CMS收集器"></a><strong>2.2.6、CMS收集器</strong></h4><p>采用“标记-清除算法”的“老年代”垃圾收集器，主要关注点在于尽量小的停顿时间。整个GC过程分为4个步骤：初始标记，并发标记，重新标记和并发清除。示意图如图7所示。</p>
<p>图7</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-4.jpg"></p>
<p><strong>1、初始标记</strong><br>标记GC Roots能直接可达的对象。既不“并发”，也不“并行”。需要“Stop The World”。<br><strong>2、并发标记</strong><br>标记GC Roots间接可达的对象。“并发”不“并行”。<br><strong>3、重新标记</strong><br>修正“2、并发标记”阶段由于用户程序运行造成的变动。“并行”不“并发”。需要“Stop The World”。<br><strong>4、并发清除</strong><br>清除不可达对象。“并发”不“并行”。</p>
<p><font color='red'>几个缺点：</font><br>1、“并发”导致“吞吐量”下降<br>2、会出现“浮动垃圾”；如果“并发清除”阶段用户线程运行内存需求得不到满足，会导致出现“Concurrent Mode Failure”<br>3、具有“标记-清除算法”的固有缺点，即产生大量内存碎片</p>
<h2 id="三、内存分配"><a href="#三、内存分配" class="headerlink" title="三、内存分配"></a><strong>三、内存分配</strong></h2><p>内存分配的几条重要原则如下：<br>1、对象优先在新生代的Eden区进行分配<br>2、大对象直接进入老年代，涉及到的JVM参数为<code>PretenureSizeThreshold</code><br>3、新生代中能够长期存活的对象将进入老年代，而不是一直处于新生代的Survivor区中，涉及到的JVM参数为<code>MaxTenuringThreshold</code><br>4、如果新生代Survivor区中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可直接进入老年代<br>在内存分配过程中，如果出现分配失败，会触发垃圾收集过程（涉及到“新生代和老年代的垃圾收集过程”，也涉及到“Minor GC，Major GC和Full GC等过程”）。<font color='red'>具体详细的内存分配过程和垃圾收集触发过程非常复杂，网上也缺少这方面的资料，因此最好的方式是阅读OpenJDK相应模块的源代码。</font></p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、JVM运行的Client模式和Server模式"><a href="#4-1、JVM运行的Client模式和Server模式" class="headerlink" title="4.1、JVM运行的Client模式和Server模式"></a><strong>4.1、JVM运行的Client模式和Server模式</strong></h3><p>JVM的运行模式之分。JVM运行在Client模式，启动速度快，适合于交互应用程序；JVM运行在Server模式，启动速度慢，整体性能好，适合后台计算式不需要太多交互的应用程序。</p>
<h3 id="4-2、JDK的product，debug和fastdebug版本"><a href="#4-2、JDK的product，debug和fastdebug版本" class="headerlink" title="4.2、JDK的product，debug和fastdebug版本"></a><strong>4.2、JDK的product，debug和fastdebug版本</strong></h3><p>JDK的版本之分。不同的版本具有不同的应用场景，比如“product版本的JDK”经过优化，运行速度快；“debug版本的JDK”未经过优化，但能够打印很多有用的日志信息；“fastdebug版本的JDK”介于“product版本”和“debug版本”之间。从源代码编译生成JDK时，通过不同的编译参数可生成不同的JDK版本。</p>
<h3 id="4-3、Minor-GC，Majoc-GC和Full-GC"><a href="#4-3、Minor-GC，Majoc-GC和Full-GC" class="headerlink" title="4.3、Minor GC，Majoc GC和Full GC"></a><strong>4.3、Minor GC，Majoc GC和Full GC</strong></h3><p>Minor GC指代发生在新生代的垃圾收集过程，由于新生代内的对象具有朝生夕灭的特性，因而Minor GC回收速度快，但也发生得非常频繁。<br>“Major GC”和“Full GC”都没有官方正式的定义，因此想要了解它们具体详细的含义，最好查看OpenJDK源代码。不过可以明确的一点是，“Major GC”和“Full GC”指代的垃圾收集过程相对于“Minor GC”速度慢得多。</p>
<h3 id="4-4、G1收集器"><a href="#4-4、G1收集器" class="headerlink" title="4.4、G1收集器"></a><strong>4.4、G1收集器</strong></h3><p>G1收集器管控新生代和老年代，整体采用“标记-整理算法”，局部采用“复制算法”，主要关注点在于尽量小的停顿时间，<font color='red'>并且已经达到“可预测的停顿时间”水平</font>。在G1收集器模型中，新生代和老年代的内存区域不再连续，Java堆被分为多个大小相等的区域（Region），该模型下的新生代和老年代都是一部分Region（不需要连续）的集合。G1收集器保存Region内对象的价值大小（回收该对象获得的空间大小和回收该对象所需时间的经验值），在后台维护一个优先列表，在进行垃圾回收过程时，优先回收价值最大的Region（这也是Garbage-First名称的由来）。<br>G1收集器进行垃圾回收时，整个GC过程分为4个步骤：初始标记，并发标记，最终标记和筛选回收。示意图如图8所示。</p>
<p>图8</p>
<p><img src="https://blog.dslztx.top/imgs/20170316-0-5.jpg"></p>
<p><strong>1、初始标记</strong><br>标记GC Roots能直接可达的对象。既不“并发”，也不“并行”。需要“Stop The World”。<br><strong>2、并发标记</strong><br>标记GC Roots间接可达的对象。“并发”不“并行”。<br><strong>3、最终标记</strong><br>修正“2、并发标记”阶段由于用户程序运行造成的变动。“并行”不“并发”。需要“Stop The World”。<br><strong>4、筛选回收</strong><br>根据Region回收价值大小进行排序，依优先级回收Region。“并行”不“并发”。需要“Stop The World”。</p>
<h3 id="4-5、GC日志阅读"><a href="#4-5、GC日志阅读" class="headerlink" title="4.5、GC日志阅读"></a><strong>4.5、GC日志阅读</strong></h3><p>GC日志中关键内容的格式描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC/Full GC &#123;Java堆GC前后内存变化描述&#125; 可有可无的“两者之间逗号” &#123;方法区/永久代GC前后内存变化描述&#125;, 整个GC过程耗费时间]</span><br><span class="line"></span><br><span class="line">Java堆GC前后内存变化描述=[年代名称:该年代的&#123;GC前后内存变化描述&#125; 可有可无的“该年代GC过程耗费时间”]...[年代名称:该年代的&#123;GC前后内存变化描述&#125; 可有可无的“该年代GC过程耗费时间”] Java堆的&#123;GC前后内存变化描述&#125;</span><br><span class="line"></span><br><span class="line">方法区/永久代GC前后内存变化描述=[方法区/永久代名称:该年代的&#123;GC前后内存变化描述&#125; 可有可无的“该年代GC过程耗费时间”]</span><br><span class="line"></span><br><span class="line">GC前后内存变化描述=GC前占用内存-&gt;GC后占用内存(总内存)</span><br></pre></td></tr></table></figure>
<p>关于年代名称的值列表如表3。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>年代</th>
<th>名称值列表</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Java堆的年轻代</td>
<td>DefNew，PSYoungGen</td>
<td>无</td>
</tr>
<tr>
<td>Java堆的老年代</td>
<td>Tenured，CMS，PSOldGen，ParOldGen</td>
<td>无</td>
</tr>
<tr>
<td>方法区&#x2F;永久代</td>
<td>Perm，CMS Perm，PSPermGen</td>
<td>方法区&#x2F;永久代在不同垃圾收集器中具有不同名称</td>
</tr>
</tbody></table>
<p>GC日志例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC [DefNew: 4679K-&gt;371K(9216K), 0.0034140 secs] 4679K-&gt;4467K(19456K), 0.0035090 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC [Tenured: 0K-&gt;4467K(10240K), 0.0093960 secs] 4679K-&gt;4467K(19456K), [Perm : 29K-&gt;29K(12288K)], 0.0095620 secs] [Times: user=0.00 sys=0.00, real=0.02 secs]</span><br><span class="line">[Full GC [Tenured: 4467K-&gt;4454K(10240K), 0.0065910 secs] 4467K-&gt;4454K(19456K), [Perm : 29K-&gt;23K(12288K)], 0.0067530 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">[Full GC [PSYoungGen: 376K-&gt;0K(9216K)] [PSOldGen: 4096K-&gt;4467K(10240K)] 4472K-&gt;4467K(19456K) [PSPermGen: 1698K-&gt;1698K(12288K)], 0.0029130 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">[Full GC [PSYoungGen: 0K-&gt;0K(9216K)] [ParOldGen: 4467K-&gt;4454K(10240K)] 4467K-&gt;4454K(19456K) [PSPermGen: 1697K-&gt;1692K(12288K)], 0.0067000 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://blog.csdn.net/aitangyong/article/details/39323125
[2]http://stackoverflow.com/questions/198577/real-differences-between-java-server-and-java-client
[3]https://blogs.oracle.com/kto/entry/mustang_jdk_6_0_fastdebug
[4]https://plumbr.eu/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc
[5]http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
]]></content>
      <categories>
        <category>TODEL</category>
      </categories>
  </entry>
  <entry>
    <title>一个JVM进程卡住问题</title>
    <url>/blog/2018/12/29/%E4%B8%80%E4%B8%AAJVM%E8%BF%9B%E7%A8%8B%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、现象描述"><a href="#一、现象描述" class="headerlink" title="一、现象描述"></a><strong>一、现象描述</strong></h2><p>一个JVM进程运行一段时间后，应用线程卡住不能继续正常运行。</p>
<h2 id="二、排查复盘"><a href="#二、排查复盘" class="headerlink" title="二、排查复盘"></a><strong>二、排查复盘</strong></h2><p>排查过程复盘：<br>0. 执行<code>jstat</code>命令，发现进程持续进行“Full GC”，导致应用线程卡住<br>0. 分别执行<code>jmap</code>和<code>jstack</code>命令，dump堆内存快照和线程快照<br>0. 使用Memory Analyzer解析堆内存快照，发现所有应用线程几乎耗尽所有堆内存，结合线程快照，发现这些应用线程都处于正常工作路径，且都处于“RUNNABLE”的线程状态<br>0. 根据上一点发现可知，该进程正常运行的确需要更多堆内存（不存在“内存泄漏”，“垃圾回收策略可改进”等可能），加大堆内存，进程正常运行，问题不再重现</p>
<br/>
图1 Memory Analyzer解析堆内存快照结果（由于截图所限，只是部分应用线程）

<p><img src="https://blog.dslztx.top/imgs/20181229-0-1.png"></p>
<p>图2 线程快照内相应线程信息（以“pool-1-thread-1”应用线程为例）</p>
<p><img src="https://blog.dslztx.top/imgs/20181229-0-2.png"></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
  </entry>
  <entry>
    <title>一个JVM进程老年代堆内存不能释放问题</title>
    <url>/blog/2019/01/10/%E4%B8%80%E4%B8%AAJVM%E8%BF%9B%E7%A8%8B%E8%80%81%E5%B9%B4%E4%BB%A3%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E8%83%BD%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、现象描述"><a href="#一、现象描述" class="headerlink" title="一、现象描述"></a><strong>一、现象描述</strong></h2><p>一个JVM进程持续进行Full GC，老年代堆内存还是占用超过90%以上。</p>
<h2 id="二、排查复盘"><a href="#二、排查复盘" class="headerlink" title="二、排查复盘"></a><strong>二、排查复盘</strong></h2><p>JVM进程内存得不到释放，一般有两个原因：1）内存中的对象的确仍处于存活状态；2）存在内存泄漏。<br>排查过程复盘：</p>
<ul>
<li>分别执行<code>jmap</code>和<code>jstack</code>命令，dump堆内存快照和线程快照</li>
<li>使用Memory Analyzer解析堆内存快照，根据“Leak_Suspects”文件报告，显示存在两个“疑似问题点”，如图1所示</li>
<li>打开“疑似问题1”的详细信息，部分截图如图2和3所示，显示一个MultiJedisPool实例对象中的HashMap成员对象（结合源代码，可定位到该成员字段名为“jedisPoolMap”）占用大约38%的内存，该HashMap对象保存的键值对为<code>&lt;Jedis对象，该Jedis对象所属JedisPool在一个JedisPool列表中的下标索引&gt;</code>，当一个Jedis被客户端使用时，创建一条Entry记录；当一个Jedis被客户端归还时，删除相应的Entry记录。根据图3，显示该HashMap对象拥有多达327736条Entry记录，而根据我们的JedisPool（底层是Apache的“commons-pool”库）配置，JedisPool理论上不可能创建这么多不同的Jedis对象，这个应该是先前已经被发现的Apache的“commons-pool”库的bug造成的，该版本（1.5.4）的“commons-pool”库不仅会创建超过配置数量的Jedis对象，而且还可能将一个未被归还的Jedis对象重新分配出去。不过，<font color='red'>即便存在创建过多Jedis对象的bug，如果正确归还Jedis对象并清除相应Entry记录的话，上述HashMap对象也不至于持有如此巨大数量的Entry记录，查看相应归还Jedis对象的源代码，发现果然存在一个内存泄漏点</font>，具体源代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnRedisClient</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">listIdx</span> <span class="operator">=</span> jedisPoolMap.get(jedis);</span><br><span class="line">    <span class="keyword">if</span> (listIdx == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (JedisPool jedisPool : jedisPoolList)</span><br><span class="line">            jedisPool.returnResource(jedis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正确的应该是“jedisPoolMap.remove(jedis)”，导致内存泄漏</span></span><br><span class="line">        jedisPoolMap.remove(listIdx);</span><br><span class="line">        jedisPoolList.get(listIdx).returnResource(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开“疑似问题2”的详细信息，部分截图如图4所示，显示同样是一个MultiJedisPool实例对象中的HashMap成员对象占据过大内存，即“疑似问题2”与“疑似问题1”的问题原因相同</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20190111-0-1.png"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20190111-0-2.png"></p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20190111-0-3.png"></p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20190111-0-4.png"></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>另外一个服务节点上有个同应用JVM进程出现了同样的现象，经过排查，发现原因也是一致的，它甚至导致了高达69%的内存占用，如图5所示。</p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20190111-0-5.png"></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
  </entry>
  <entry>
    <title>一个应用程序的4个模块</title>
    <url>/blog/2018/08/21/%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%844%E4%B8%AA%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>一般情况下，一个应用程序由4个模块构成：配置模块，心跳模块，报警模块，主体模块。<br>示意图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180821-0-1.svg"></p>
<p><strong>1、配置模块</strong><br>给整个应用程序提供配置，包括另外3个模块。<br><strong>2、心跳模块</strong><br>负责维持与心跳中心的心跳，心跳中心根据心跳状态检测应用程序是否存活。<br>心跳中心与应用程序禁止处于同一台机器，否则该台机器一旦出现故障宕机，就会面临“应用程序挂了且没有机制能告警该状态”的最坏情况，不处于同一台机器，面临“应用程序挂了且没有机制能告警该状态”最坏情况的可能性就大大降低。<br><strong>3、报警模块</strong><br>隶属于应用程序自身的“报警模块”相对于“第三方报警模块”更加明晰应用程序的业务逻辑，因此，告警会更加全面完整准确。<br><strong>4、主体模块</strong><br>应用程序的主体模块，完成应用程序的主体任务。</p>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
  </entry>
  <entry>
    <title>一个看起来违反JVM垃圾自动回收机制的例子</title>
    <url>/blog/2017/03/28/%E4%B8%80%E4%B8%AA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E8%BF%9D%E5%8F%8DJVM%E5%9E%83%E5%9C%BE%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>本文内容中所使用的JDK版本为<code>jdk1.6.0_23</code>。</p>
<h2 id="一、问题重现"><a href="#一、问题重现" class="headerlink" title="一、问题重现"></a><strong>一、问题重现</strong></h2><p>有如下一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        byte[] a, b;</span><br><span class="line">        a = new byte[3 * _1MB];</span><br><span class="line">        b = new byte[4 * _1MB];</span><br><span class="line"></span><br><span class="line">        b = new byte[5 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 Example</span><br></pre></td></tr></table></figure>
<p>以上命令中的虚拟机配置参数表示“Java堆内存20M，其中新生代内存10M，老年代内存10M，新生代中Eden区内存8M，新生代中1个Survivor区内存1M，故而新生代可用内存9M；当对象所需内存大于3M时，直接在老年代进行分配；打印GC日志信息”。<br>命令执行后结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC [Tenured: 7168K-&gt;7283K(10240K), 0.0111970 secs] 7495K-&gt;7283K(19456K), [Perm : 28K-&gt;28K(12288K)], 0.0112600 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC [Tenured: 7283K-&gt;7270K(10240K), 0.0074390 secs] 7283K-&gt;7270K(19456K), [Perm : 28K-&gt;22K(12288K)], 0.0074690 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at Example.main(Example.java:9)</span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 327K [0x8d770000, 0x8e170000, 0x8e170000)</span><br><span class="line">  eden space 8192K,   4% used [0x8d770000, 0x8d7c1f40, 0x8df70000)</span><br><span class="line">  from space 1024K,   0% used [0x8df70000, 0x8df70000, 0x8e070000)</span><br><span class="line">  to   space 1024K,   0% used [0x8e070000, 0x8e070000, 0x8e170000)</span><br><span class="line"> tenured generation   total 10240K, used 7270K [0x8e170000, 0x8eb70000, 0x8eb70000)</span><br><span class="line">   the space 10240K,  71% used [0x8e170000, 0x8e889af8, 0x8e889c00, 0x8eb70000)</span><br><span class="line"> compacting perm gen  total 12288K, used 22K [0x8eb70000, 0x8f770000, 0x92b70000)</span><br><span class="line">   the space 12288K,   0% used [0x8eb70000, 0x8eb75be0, 0x8eb75c00, 0x8f770000)</span><br><span class="line">    ro space 10240K,  61% used [0x92b70000, 0x93197708, 0x93197800, 0x93570000)</span><br><span class="line">    rw space 12288K,  60% used [0x93570000, 0x93ca7cc0, 0x93ca7e00, 0x94170000)</span><br></pre></td></tr></table></figure>
<h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a><strong>二、原因分析</strong></h2><p>“一、问题重现”中的代码执行结果抛出了<code>OutOfMemoryError</code>异常。但是，我们知道，当出现“分配内存不足”时，会触发GC过程，变量b原来引用的占据4M内存的对象会被回收掉，而变量a引用的对象占据3M内存，故而此时，老年代剩余(10M-3M&#x3D;7M)内存，大于所需5M内存，那么为何还会抛出<code>OutOfMemoryError</code>异常呢？<br><font color='red'>原因就在于执行顺序问题：只有当占据5M内存的对象被成功分配内存后，该地址值才会被赋值给变量b，否则在此之前，变量b依旧引用原来的占据4M内存的对象，因此，在GC时，该占据4M内存的对象不会被回收。</font></p>
<h2 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a><strong>三、验证</strong></h2><h3 id="3-1、验证1"><a href="#3-1、验证1" class="headerlink" title="3.1、验证1"></a><strong>3.1、验证1</strong></h3><p>有如下验证代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] a, b;</span><br><span class="line">        a = new byte[3 * _1MB];</span><br><span class="line">        b = new byte[4 * _1MB];</span><br><span class="line"></span><br><span class="line">        b = null;</span><br><span class="line"></span><br><span class="line">        b = new byte[5 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行相同的指令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC [Tenured: 7168K-&gt;3187K(10240K), 0.0137400 secs] 7495K-&gt;3187K(19456K), [Perm : 28K-&gt;28K(12288K)], 0.0138020 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 163K [0x8d770000, 0x8e170000, 0x8e170000)</span><br><span class="line">  eden space 8192K,   2% used [0x8d770000, 0x8d798fd0, 0x8df70000)</span><br><span class="line">  from space 1024K,   0% used [0x8df70000, 0x8df70000, 0x8e070000)</span><br><span class="line">  to   space 1024K,   0% used [0x8e070000, 0x8e070000, 0x8e170000)</span><br><span class="line"> tenured generation   total 10240K, used 8307K [0x8e170000, 0x8eb70000, 0x8eb70000)</span><br><span class="line">   the space 10240K,  81% used [0x8e170000, 0x8e98ce88, 0x8e98d000, 0x8eb70000)</span><br><span class="line"> compacting perm gen  total 12288K, used 28K [0x8eb70000, 0x8f770000, 0x92b70000)</span><br><span class="line">   the space 12288K,   0% used [0x8eb70000, 0x8eb770e0, 0x8eb77200, 0x8f770000)</span><br><span class="line">    ro space 10240K,  61% used [0x92b70000, 0x93197708, 0x93197800, 0x93570000)</span><br><span class="line">    rw space 12288K,  60% used [0x93570000, 0x93ca7cc0, 0x93ca7e00, 0x94170000)</span><br></pre></td></tr></table></figure>
<p>由于<code>b=null</code>，因此，在GC时，变量b原来引用的占据4M内存的对象被回收，占据5M的对象内存分配成功，并且该地址值被赋值给变量b，此时，老年代使用(3M+5M&#x3D;8M)内存。</p>
<h3 id="3-2、验证2"><a href="#3-2、验证2" class="headerlink" title="3.2、验证2"></a><strong>3.2、验证2</strong></h3><p>有如下验证代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] a, b;</span><br><span class="line">        a = new byte[3 * _1MB];</span><br><span class="line">        b = new byte[4 * _1MB];</span><br><span class="line"></span><br><span class="line">        a = null;</span><br><span class="line"></span><br><span class="line">        b = new byte[5 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行相同的指令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC [Tenured: 7168K-&gt;4211K(10240K), 0.0163810 secs] 7495K-&gt;4211K(19456K), [Perm : 28K-&gt;28K(12288K)], 0.0164420 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 163K [0x8d770000, 0x8e170000, 0x8e170000)</span><br><span class="line">  eden space 8192K,   2% used [0x8d770000, 0x8d798fd0, 0x8df70000)</span><br><span class="line">  from space 1024K,   0% used [0x8df70000, 0x8df70000, 0x8e070000)</span><br><span class="line">  to   space 1024K,   0% used [0x8e070000, 0x8e070000, 0x8e170000)</span><br><span class="line"> tenured generation   total 10240K, used 9331K [0x8e170000, 0x8eb70000, 0x8eb70000)</span><br><span class="line">   the space 10240K,  91% used [0x8e170000, 0x8ea8ce88, 0x8ea8d000, 0x8eb70000)</span><br><span class="line"> compacting perm gen  total 12288K, used 28K [0x8eb70000, 0x8f770000, 0x92b70000)</span><br><span class="line">   the space 12288K,   0% used [0x8eb70000, 0x8eb770c0, 0x8eb77200, 0x8f770000)</span><br><span class="line">    ro space 10240K,  61% used [0x92b70000, 0x93197708, 0x93197800, 0x93570000)</span><br><span class="line">    rw space 12288K,  60% used [0x93570000, 0x93ca7cc0, 0x93ca7e00, 0x94170000)</span><br></pre></td></tr></table></figure>
<p>由于<code>a=null</code>，因此，在GC时，变量a原来引用的占据3M内存的对象被回收，占据5M的对象内存分配成功，并且该地址值被赋值给变量b，此时，老年代使用(4M+5M&#x3D;9M)内存。<font color='red'>需要注意的是，变量b原来引用的占据4M内存的对象在下一次GC时会被回收。</font></p>
<h3 id="3-3、验证3"><a href="#3-3、验证3" class="headerlink" title="3.3、验证3"></a><strong>3.3、验证3</strong></h3><p>有如下验证代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        byte[] a, b;</span><br><span class="line">        a = new byte[3 * _1MB];</span><br><span class="line">        b = new byte[4 * _1MB];</span><br><span class="line"></span><br><span class="line">        a = null;</span><br><span class="line"></span><br><span class="line">        b = new byte[5 * _1MB];</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        // 等待手动触发的GC完成</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行相同的指令，得到如下所示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC [Tenured: 7168K-&gt;4211K(10240K), 0.0178210 secs] 7495K-&gt;4211K(19456K), [Perm : 28K-&gt;28K(12288K)], 0.0178700 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </span><br><span class="line">[Full GC (System) [Tenured: 9331K-&gt;5235K(10240K), 0.0105780 secs] 9331K-&gt;5235K(19456K), [Perm : 28K-&gt;28K(12288K)], 0.0108090 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 327K [0x8d770000, 0x8e170000, 0x8e170000)</span><br><span class="line">  eden space 8192K,   4% used [0x8d770000, 0x8d7c1f48, 0x8df70000)</span><br><span class="line">  from space 1024K,   0% used [0x8df70000, 0x8df70000, 0x8e070000)</span><br><span class="line">  to   space 1024K,   0% used [0x8e070000, 0x8e070000, 0x8e170000)</span><br><span class="line"> tenured generation   total 10240K, used 5235K [0x8e170000, 0x8eb70000, 0x8eb70000)</span><br><span class="line">   the space 10240K,  51% used [0x8e170000, 0x8e68ce88, 0x8e68d000, 0x8eb70000)</span><br><span class="line"> compacting perm gen  total 12288K, used 28K [0x8eb70000, 0x8f770000, 0x92b70000)</span><br><span class="line">   the space 12288K,   0% used [0x8eb70000, 0x8eb77140, 0x8eb77200, 0x8f770000)</span><br><span class="line">    ro space 10240K,  61% used [0x92b70000, 0x93197708, 0x93197800, 0x93570000)</span><br><span class="line">    rw space 12288K,  60% used [0x93570000, 0x93ca7cc0, 0x93ca7e00, 0x94170000)</span><br></pre></td></tr></table></figure>
<p>由于<code>a=null</code>，因此，在GC时，变量a原来引用的占据3M内存的对象被回收，占据5M的对象内存分配成功，并且该地址值被赋值给变量b，此时，老年代使用(4M+5M&#x3D;9M)内存。再由于执行<code>System.gc()</code>命令，即手动触发GC过程（参见结果中以“Full GC (System)”开头的日志记录），变量b原来引用的占据4M内存的对象被回收，最终老年代使用(5M)内存。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>一些Linux世界的术语</title>
    <url>/blog/2016/03/28/%E4%B8%80%E4%BA%9BLinux%E4%B8%96%E7%95%8C%E7%9A%84%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="一、POSIX"><a href="#一、POSIX" class="headerlink" title="一、POSIX"></a><strong>一、POSIX</strong></h2><p>全称为“Portable Operating System Interface ”，是一套关于“application programming interface (API，即应用编程接口), command line shells interfaces，utility interfaces”等的标准规范，遵循POSIX开发的软件产品在所有遵循POSIX的操作系统上可通用。<br>根据遵循POSIX的程度，操作系统可分为“完全不遵循POSIX”，“部分遵循POSIX”和“完全遵循POSIX”（其实现实中并没有完全遵循POSIX的操作系统）。<br>需要注意的是，POSIX的制定以Unix为基础，但又扩展于Unix。因而，最后我们只能说，Unix操作系统“部分遵循POSIX”。<br>有些操作系统“完全不遵循POSIX”，但是可以在这些操作系统上安装一层软件层，这层软件层遵循支持POSIX，从而使得这些操作系统具有支持POSIX的能力。比如Windows上的“Cygwin”，“MinGW”等，OS2上的“emx+gcc”等，DOS上的“emx+gcc ”等。<br>接下来，根据与POSIX的关系，对操作系统进行分类。</p>
<h3 id="1-1、通过POSIX认证"><a href="#1-1、通过POSIX认证" class="headerlink" title="1.1、通过POSIX认证"></a><strong>1.1、通过POSIX认证</strong></h3><p>“通过POSIX认证”表示遵循1项或者多项POSIX标准规范，并且通过POSIX自动化测试集。属于该类的操作系统有：HP-UX，OS X，Solaris等。</p>
<h3 id="1-2、事实POSIX兼容"><a href="#1-2、事实POSIX兼容" class="headerlink" title="1.2、事实POSIX兼容"></a><strong>1.2、事实POSIX兼容</strong></h3><p>“事实POSIX兼容”：表示虽未通过POSIX认证，但是事实上遵循1项或者多项POSIX标准规范。属于该类的操作系统有：Linux，FreeBSD，NetBSD，MINIX，OpenBSD，SkyOS，Android等。</p>
<h2 id="二、GNU"><a href="#二、GNU" class="headerlink" title="二、GNU"></a><strong>二、GNU</strong></h2><p>GNU是Richard Stallman想要开发的一个操作系统，它的全称是“GNU’s Not Unix!”。Richard Stallman对该操作系统的设想是兼容Unix（也就是部分或者完全遵循POSIX），但却是一个完全自由的操作系统。要开发GNU操作系统，需要开发一个操作系统内核和一系列基础软件库。GNU内核的开发属于一波三折，到今日为止还不算成功完成；倒是一系列基础软件库的开发非常顺利，比如GNU编译器套装（GCC），GNU的C库（glibc），GNU核心工具库（coreutils），GNU调试器（GDB）、GNU二进制实用程序包（里面包含有著名的GNU Bash shell） 和GNOME桌面环境等。期间，涌现了很多优秀的操作系统内核，比如“FreeBSD，Linux”等，“FreeBSD，Linux等操作系统内核”加上“GNU系列基础软件库”构成了一个完整的操作系统。正是因为这样，有观点认为，现在的Linux操作系统准确地应该被称为“GNU&#x2F;Linux操作系统”。<br>GNU操作系统内核和GNU基础软件库都遵循POSIX。但是不是完全遵循，只是部分遵循。比如在POSIX标准规范中，“df”和“du”命令的块大小定为512字节，而为了更符合常识，“GNU df”和“GNU du”命令的实现中还是将块大小定为1024字节。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/POSIX">https://en.wikipedia.org/wiki/POSIX</a><br>[2]<a href="https://zh.wikipedia.org/wiki/GNU">https://zh.wikipedia.org/wiki/GNU</a></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>一种正则表达式匹配模型</title>
    <url>/blog/2017/06/02/%E4%B8%80%E7%A7%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、模型图示"><a href="#一、模型图示" class="headerlink" title="一、模型图示"></a><strong>一、模型图示</strong></h2><p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20170602-0-1.jpg"></p>
<h2 id="二、模型概述"><a href="#二、模型概述" class="headerlink" title="二、模型概述"></a><strong>二、模型概述</strong></h2><p>在匹配过程中，目标字符串按照图1模型进行标注，即增加索引位置，索引位置标号值从0开始，最后一个标号值等于目标字符串的长度值。<br>关于索引位置有如下几点论述：</p>
<ol>
<li>正则表达式在目标字符串中的匹配字符串对应一个索引位置区间，比如图1中的“hello”字符串如果作为匹配字符串，那么对应的索引位置区间为“[0,5)”</li>
<li>有两种索引位置区间：点区间和非点区间。点区间，左闭右闭，区间长度为零，<font color='red'>对应零长度匹配</font>，比如“[5-5]”；非点区间，左闭右开，区间长度大于零，<font color='red'>对应非零长度匹配</font>，比如“[5-7)”</li>
<li>索引位置区间的重叠。重叠例子：“[5-7)”和“[6-8)”，“[5-5]”和“[5-7)”；非重叠例子：“[5-7)”和“[7-9)”，“[5-7)”和“[10-12)”</li>
<li>一般情况下，正则表达式匹配过程的最终等价效果是：从左至右依次找到一系列互不重叠的索引位置区间。假如正则表达式为“[a-z]{2}”，图1中的字符串作为目标字符串，那么依次得到的“匹配字符串（对应的索引位置区间）”系列为：he[0,2)，ll[2,4)，wo[6,8)，rl[8,10)</li>
<li>正则表达式中的边界匹配符描述的是索引位置的性质。假如正则表达式为“\bhel\B”，图1中的字符串作为目标字符串，那么能够得到一个匹配字符串“hel”（目标字符串中索引位置0的确是“单词边界”，索引位置3的确是“非单词边界”）</li>
</ol>
<h2 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a><strong>三、实践</strong></h2><table>
<thead>
<tr>
<th>正则表达式</th>
<th>目标字符串</th>
<th>结果</th>
<th>对应的索引位置区间序列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>a?</code></td>
<td><code>abcafdas</code></td>
<td>I found the text “a” starting at index 0 and ending at index 1.<br/>I found the text “” starting at index 1 and ending at index 1.<br/>I found the text “” starting at index 2 and ending at index 2.<br/>I found the text “a” starting at index 3 and ending at index 4.<br/>I found the text “” starting at index 4 and ending at index 4.<br/>I found the text “” starting at index 5 and ending at index 5.<br/>I found the text “a” starting at index 6 and ending at index 7.<br/>I found the text “” starting at index 7 and ending at index 7.<br/>I found the text “” starting at index 8 and ending at index 8.</td>
<td>[0,1)，[1,1]，[2,2]，[3,4)，[4,4]，[5,5]，[6,7)，[7,7]，[8,8]</td>
<td>从左至右，从“索引位置0”开始，到“索引位置8”结束。尝试以“索引位置0”为边界左值，找到匹配字符串“a”，对应的边界右值为“索引位置1”，即“[0,1)”；尝试以“索引位置1”为边界左值，找到零长度匹配，对应的边界右值为“索引位置1”，即“[1,1]”；尝试以“索引位置2”为边界左值，找到零长度匹配，对应的边界右值为“索引位置2”，即“[2,2]”；尝试以“索引位置3”为边界左值，找到匹配字符串“a”，对应的边界右值为“索引位置4”，即“[3,4)”；尝试以“索引位置4”为边界左值，找到零长度匹配，对应的边界右值为“索引位置4”，即“[4,4]”；尝试以“索引位置5”为边界左值，找到零长度匹配，对应的边界右值为“索引位置5”，即“[5,5]”；尝试以“索引位置6”为边界左值，找到匹配字符串“a”，对应的边界右值为“索引位置7”，即“[6,7)”；尝试以“索引位置7”为边界左值，找到零长度匹配，对应的边界右值为“索引位置7”，即“[7,7]”；尝试以“索引位置8”为边界左值，找到零长度匹配，对应的边界右值为“索引位置8”，即“[8,8]”</td>
</tr>
<tr>
<td><code>a*</code></td>
<td><code>aabaaaca</code></td>
<td>I found the text “aa” starting at index 0 and ending at index 2.<br/>I found the text “” starting at index 2 and ending at index 2.<br/>I found the text “aaa” starting at index 3 and ending at index 6.<br/>I found the text “” starting at index 6 and ending at index 6.<br/>I found the text “a” starting at index 7 and ending at index 8.<br/>I found the text “” starting at index 8 and ending at index 8.</td>
<td>[0,2)，[2,2]，[3,6)，[6,6]，[7,8)，[8,8]</td>
<td>从左至右，从“索引位置0”开始，到“索引位置8”结束。尝试以“索引位置0”为边界左值，找到匹配字符串“aa”，对应的边界右值为“索引位置2”，即“[0,2)”；尝试以“索引位置2”为边界左值，找到零长度匹配，对应的边界右值为“索引位置2”，即“[2,2]”；尝试以“索引位置3”为边界左值，找到匹配字符串“aaa”，对应的边界右值为“索引位置6”，即“[3,6)”；尝试以“索引位置6”为边界左值，找到零长度匹配，对应的边界右值为“索引位置6”，即“[6,6]”；尝试以“索引位置7”为边界左值，找到匹配字符串“a”，对应的边界右值为“索引位置8”，即“[7,8)”；尝试以“索引位置8”为边界左值，找到零长度匹配，对应的边界右值为“索引位置8”，即“[8,8]”</td>
</tr>
<tr>
<td><code>^he\B</code></td>
<td><code>hello world</code></td>
<td>I found the text “he” starting at index 0 and ending at index 2.</td>
<td>[0,2)</td>
<td>从左至右，从“索引位置0”开始，到“索引位置11”结束。尝试以“索引位置0”为边界左值，找到匹配字符串“he”，对应的边界右值为“索引位置2”，即“[0,2)”；依次尝试以“索引位置2”，“索引位置3”，“索引位置4”，“索引位置5”，“索引位置6”，“索引位置7”，“索引位置8”，“索引位置9”，“索引位置10”，“索引位置11”为边界左值，找不到匹配</td>
</tr>
<tr>
<td><code>aa</code></td>
<td><code>cdfaacdf</code></td>
<td>I found the text “aa” starting at index 3 and ending at index 5.</td>
<td>[3,5)</td>
<td>从左至右，从“索引位置0”开始，到“索引位置8”结束。依次尝试以“索引位置0”，“索引位置1”，“索引位置2”为边界左值，找不到匹配，尝试以“索引位置3”为边界左值，找到匹配字符串“aa”，对应的边界右值为“索引位置5”，即“[3,5)”；依次尝试以“索引位置5”，“索引位置6”，“索引位置7”，“索引位置8”为边界左值，找不到匹配</td>
</tr>
</tbody></table>
<h2 id="四、模型适用"><a href="#四、模型适用" class="headerlink" title="四、模型适用"></a><strong>四、模型适用</strong></h2><p>采用本模型的正则表达式匹配引擎在匹配时会使用本模型进行匹配，但是当我们自己进行“人工匹配”时，一般使用“粗放匹配（即直接根据字符串进行匹配）”方式，在这种方式下，极易漏掉“零长度匹配”，因此，当有可能出现“零长度匹配”时，我们最好还是遵循本模型的方式进行“人工匹配”。<br>比如有“正则表达式：<code>a?</code>，目标字符串：<code>abcafdas</code>”，使用“粗放匹配”方式，很容易找到“a（第1个字符）”，“a（第4个字符）”和“a（第7个字符）”这3个匹配字符串，但是很容易遗漏零长度匹配；使用“本模型”方式，不容易遗漏任何可能的匹配（可参见“三、实践”小节）。</p>
<br/>
参考文献：
[1]https://docs.oracle.com/javase/tutorial/essential/regex/literals.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>一般方法覆盖</title>
    <url>/blog/2018/04/18/%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>“覆盖”针对“一般方法”而言。<br>覆盖一般方法须满足以下两个条件：</p>
<ul>
<li>覆盖方法所在类须继承被覆盖方法所在类，覆盖方法所在类须可继承被覆盖方法</li>
<li>覆盖方法与被覆盖方法方法声明完全一致或者<font color='red'>变种一致</font></li>
</ul>
<p>接下来着重介绍“变种一致”的所有情形。</p>
<h2 id="二、变种一致"><a href="#二、变种一致" class="headerlink" title="二、变种一致"></a><strong>二、变种一致</strong></h2><h3 id="2-1、修饰符"><a href="#2-1、修饰符" class="headerlink" title="2.1、修饰符"></a><strong>2.1、修饰符</strong></h3><h4 id="2-1-1、abstract修饰符"><a href="#2-1-1、abstract修饰符" class="headerlink" title="2.1.1、abstract修饰符"></a><strong>2.1.1、abstract修饰符</strong></h4><p>被覆盖方法额外具有“abstract”修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2、synchronized修饰符"><a href="#2-1-2、synchronized修饰符" class="headerlink" title="2.1.2、synchronized修饰符"></a><strong>2.1.2、synchronized修饰符</strong></h4><p>被覆盖方法或者覆盖方法额外具有“synchronized”修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3、final修饰符"><a href="#2-1-3、final修饰符" class="headerlink" title="2.1.3、final修饰符"></a><strong>2.1.3、final修饰符</strong></h4><p>覆盖方法额外具有“final”修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4、访问权限控制符"><a href="#2-1-4、访问权限控制符" class="headerlink" title="2.1.4、访问权限控制符"></a><strong>2.1.4、访问权限控制符</strong></h4><p>覆盖方法的访问权限控制符权限大于被覆盖方法的访问权限控制符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5、native修饰符"><a href="#2-1-5、native修饰符" class="headerlink" title="2.1.5、native修饰符"></a><strong>2.1.5、native修饰符</strong></h4><p>被覆盖方法或者覆盖方法额外具有“native”修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、返回结果"><a href="#2-2、返回结果" class="headerlink" title="2.2、返回结果"></a><strong>2.2、返回结果</strong></h3><p>Java SE5中添加了协变返回类型，覆盖方法可以返回被覆盖方法返回类型的某种导出类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheat</span> <span class="keyword">extends</span> <span class="title class_">Grain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line"></span><br><span class="line">  Grain <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Grain</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WheatMill</span> <span class="keyword">extends</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line"></span><br><span class="line">  Wheat <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wheat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CovariantReturn</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Mill</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mill</span>();</span><br><span class="line">    <span class="type">Grain</span> <span class="variable">g</span> <span class="operator">=</span> m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">    m = <span class="keyword">new</span> <span class="title class_">WheatMill</span>();</span><br><span class="line">    g = m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>与Github repository连接的3种方式</title>
    <url>/blog/2016/06/26/%E4%B8%8EGithub-repository%E8%BF%9E%E6%8E%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>本文介绍与Github repository连接的3种方式。<br>首先在Github建立一个用于测试的“repository”，取名为“testtest”。</p>
<h2 id="一、使用HTTPS"><a href="#一、使用HTTPS" class="headerlink" title="一、使用HTTPS"></a><strong>一、使用HTTPS</strong></h2><p>首先获取“testtest repository”的使用HTTPS的clone地址，如图1所示。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20160626-2-1.png"></p>
<p>接下来验证是否能够成功建立连接：</p>
<ol>
<li>在本地某个目录下执行<code>git clone https://github.com/dslztx/testtest.git</code>命令，发现“testtest repository”的内容被成功复制到本地，说明成功建立连接</li>
<li>在本地进行一些修改，然后执行<code>git commit -m &#39;comment&#39;;git push origin master</code>命令，发现本地的修改被更新到“testtest repository”，说明成功建立连接</li>
</ol>
<h2 id="二、使用SSH，SSH-Server监听端口22"><a href="#二、使用SSH，SSH-Server监听端口22" class="headerlink" title="二、使用SSH，SSH Server监听端口22"></a><strong>二、使用SSH，SSH Server监听端口22</strong></h2><p>在尝试建立SSH连接之前，应该首先确定是否能够与“22”端口正常通信，因此先执行<code>telnet github.com 22</code>命令，得到如图2所示结果。</p>
<p>图2<br><img src="https://blog.dslztx.top/imgs/20160626-2-2.png"></p>
<p>由以上结果可知，不能与“22”端口正常通信，也就不能成功建立SSH连接。<br>经过简单分析可知，出现以上结果的原因在于：有太多人使用SSH方式“穿墙”，而SSH Server的默认监听端口为“22”，然后ZF应该直接就干扰掉“22”端口了。</p>
<h2 id="三、使用SSH，SSH-Server监听端口443"><a href="#三、使用SSH，SSH-Server监听端口443" class="headerlink" title="三、使用SSH，SSH Server监听端口443"></a><strong>三、使用SSH，SSH Server监听端口443</strong></h2><p>首先尝试确定是否能够与“443”端口正常通信，先执行<code>telnet ssh.github.com 443</code>命令，得到如图3所示结果。</p>
<p>图3<br><img src="https://blog.dslztx.top/imgs/20160626-2-3.png"></p>
<p>由以上结果可知，能够与“443”端口正常通信。（“443”端口作为HTTPS协议的默认监听端口，跟“80”端口作为HTTP协议的默认监听端口一样，因而ZF应该没有干扰“443”端口，否则波及面太广了）</p>
<p>接着分两步与“ssh.github.com”建立SSH连接：</p>
<ol>
<li>生成一个公私钥对，将公钥的内容配置到Github中，假定私钥文件的路径为“~&#x2F;.ssh&#x2F;id_rsarsa”</li>
<li>执行<code>ssh -l git -i ~/.ssh/id_rsarsa -p 443 ssh.github.com</code>命令，与“ssh.github.com”建立SSH连接</li>
</ol>
<p>在“~&#x2F;.ssh&#x2F;config”文件中配置如下片段，此后只需执行<code>ssh github.com</code>命令即可与“ssh.github.com”建立连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsarsa</span><br></pre></td></tr></table></figure>

<p>接着获取“testtest repository”的使用SSH的clone地址（当使用该地址与Github repository进行通信时，会基于后台建立的SSH连接传输数据），如图4所示。</p>
<p>图4<br><img src="https://blog.dslztx.top/imgs/20160626-2-4.png"></p>
<p>接下来验证是否能够成功建立连接：</p>
<ol>
<li>在本地某个目录下执行<code>git clone git@github.com:dslztx/testtest.git</code>命令，发现“testtest repository”的内容被成功复制到本地，说明成功建立连接</li>
<li>在本地进行一些修改，然后执行<code>git commit -m &#39;comment&#39;;git push origin master</code>命令，发现本地的修改被更新到“testtest repository”，说明成功建立连接</li>
</ol>
<br/>
参考文献：
[1]https://help.github.com/categories/ssh/
[2]https://help.github.com/articles/testing-your-ssh-connection/
[3]https://help.github.com/articles/using-ssh-over-the-https-port/
[4]http://www.howtogeek.com/233383/why-was-80-chosen-as-the-default-http-port-and-443-as-the-default-https-port/
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>个人数据存储方案</title>
    <url>/blog/2017/08/24/%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>为保障数据安全，特制订如下个人数据存储方案：</p>
<ol>
<li>一份数据至少有一个备份，即同一份数据至少有两处存储</li>
<li>数据按照年份存储，分为“历史年份”和“今年年份”</li>
<li>“历史年份”数据一份存储在百度云，另外一份存储在移动硬盘</li>
<li>“今年年份”数据分为“小容量数据”和“大容量数据”。“小容量数据”一份存储在Git远程仓库，另外一份存储在本地；“大容量数据”一份存储在百度云，另外一份存储在本地</li>
</ol>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>代理转发</title>
    <url>/blog/2024/02/06/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<p>想使用代理服务器的代理服务（Socks代理服务器的Socks代理服务，HTTP代理服务器的HTTP代理服务等），我们必须配置一个代理转发器，它可以将正常的网络请求转发给代理服务器，从而使用相应的代理服务。</p>
<p>通过代理转发器对外进行网络访问的数据流为：<code>对外网络访问请求客户端 -&gt; 代理转发器 -&gt; 代理服务器 -&gt; 互联网</code>（正常对外进行网络访问的数据流为<code>对外网络访问请求客户端 -&gt; 互联网</code>）。</p>
<p>根据作用范围的不同，可以将代理转发器分为：全局代理转发器和局部代理转发器。</p>
<h2 id="一、全局代理转发器"><a href="#一、全局代理转发器" class="headerlink" title="一、全局代理转发器"></a><strong>一、全局代理转发器</strong></h2><p>一旦在一个机子上配置了全局代理转发器，该机子上的所有对外网络访问请求都会被转发给所配置的代理服务器，使用该代理服务器的代理服务，即由该代理服务器代为进行这些对外网络访问请求。<br>一般的操作系统都自带有全局代理转发器，比如在Linux中，通过“网络设置”中的“网络代理”配置，就可以使用系统自带的全局代理转发器。<br>第三方全局代理转发器中比较常见的有：redsocks，ProxyCap，ProxyChains等[1]。</p>
<h2 id="二、局部代理转发器"><a href="#二、局部代理转发器" class="headerlink" title="二、局部代理转发器"></a><strong>二、局部代理转发器</strong></h2><p>跟全局代理转发器相对，局部代理转发器只转发相应软件的对外网络访问请求，即配置好对应于一些软件的局部代理转发器之后，这些软件的对外网络访问请求都会被该局部代理转发器转发给所配置的代理服务器，而其他软件的对外网络访问请求不受影响。<br>最常见的局部代理转发器有针对浏览器的局部代理转发器和针对一些网络游戏的局部代理转发器。<br>在针对浏览器的局部代理转发器中最知名的当属SwitchyOmega了[2]。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/Comparison_of_proxifiers">https://en.wikipedia.org/wiki/Comparison_of_proxifiers</a><br>[2]<a href="https://github.com/FelisCatus/SwitchyOmega">https://github.com/FelisCatus/SwitchyOmega</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>使用/proc/cpuinfo文件查看CPU信息</title>
    <url>/blog/2023/02/16/%E4%BD%BF%E7%94%A8-proc-cpuinfo%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8BCPU%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>关于CPU的基本概念、架构和核心参数可参见[1]。</p>
<p>本文介绍Linux下使用“&#x2F;proc&#x2F;cpuinfo”文件查看CPU信息（可以与官网根据CPU具体型号查得的信息进行比对验证）。</p>
<h2 id="一、核心参数获取"><a href="#一、核心参数获取" class="headerlink" title="一、核心参数获取"></a><strong>一、核心参数获取</strong></h2><h3 id="1-1、CPU数量相关"><a href="#1-1、CPU数量相关" class="headerlink" title="1.1、CPU数量相关"></a><strong>1.1、CPU数量相关</strong></h3><ol>
<li>物理CPU数量：<code>cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</code></li>
<li>物理CPU Core数量：∑ 物理CPU<sub>k</sub>上物理CPU Core数量</li>
<li>逻辑CPU Core数量：<code>cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</code></li>
</ol>
<h3 id="1-2、主频"><a href="#1-2、主频" class="headerlink" title="1.2、主频"></a><strong>1.2、主频</strong></h3><p><code>cat /proc/cpuinfo</code>每个逻辑CPU Core描述段落中：</p>
<ul>
<li><code>cpu MHz</code>字段值，表示工作实际主频</li>
<li><code>model name</code>字段值中的频率，表示额定主频</li>
</ul>
<h3 id="1-3、缓存大小"><a href="#1-3、缓存大小" class="headerlink" title="1.3、缓存大小"></a><strong>1.3、缓存大小</strong></h3><p><code>cat /proc/cpuinfo</code>每个逻辑CPU Core描述段落中的<code>cache size</code>字段值，在现代CPU架构中其表示L3 Cache大小，在较老CPU架构中其表示L2 Cache大小。</p>
<h3 id="1-4、其他"><a href="#1-4、其他" class="headerlink" title="1.4、其他"></a><strong>1.4、其他</strong></h3><ol>
<li>特定物理CPU上的物理CPU Core数量：找到指定物理CPU上任何一个逻辑CPU Core的描述段落，查看<code>cpu cores</code>字段值</li>
<li>特定物理CPU上的逻辑CPU数量：找到指定物理CPU上任何一个逻辑CPU Core的描述段落，查看<code>siblings</code>字段值</li>
<li>特定物理CPU是否开启SMT技术：找到指定物理CPU上任何一个逻辑CPU Core的描述段落，当<code>P(P = siblings字段值 / cpu cores字段值) != 1</code>，则表示开启了SMT技术，且为P路-SMT</li>
</ol>
<p><strong>[备注]</strong> 在[1]中介绍SMT技术时，未阐明SMT技术的实现粒度是物理CPU还是物理CPU Core，一般情况下，实现粒度是物理CPU。</p>
<h2 id="二、“-proc-cpuinfo”文件信息解释"><a href="#二、“-proc-cpuinfo”文件信息解释" class="headerlink" title="二、“&#x2F;proc&#x2F;cpuinfo”文件信息解释"></a><strong>二、“&#x2F;proc&#x2F;cpuinfo”文件信息解释</strong></h2><h3 id="2-1、一个样例"><a href="#2-1、一个样例" class="headerlink" title="2.1、一个样例"></a><strong>2.1、一个样例</strong></h3><p>一个样例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processor	: 0</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 2600.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 0</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 0</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 0</span><br><span class="line">initial apicid	: 0</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5200.18</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 1</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 2600.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 0</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 0</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 1</span><br><span class="line">initial apicid	: 1</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.88</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 2</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 2600.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 0</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 1</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 2</span><br><span class="line">initial apicid	: 2</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.89</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 3</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 2600.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 0</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 1</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 3</span><br><span class="line">initial apicid	: 3</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.86</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 4</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 4160.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 1</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 0</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 4</span><br><span class="line">initial apicid	: 4</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.87</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 5</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 4160.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 1</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 0</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 5</span><br><span class="line">initial apicid	: 5</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.90</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 6</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 1300.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 1</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 1</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 6</span><br><span class="line">initial apicid	: 6</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.88</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br><span class="line"></span><br><span class="line">processor	: 7</span><br><span class="line">vendor_id	: GenuineIntel</span><br><span class="line">cpu family	: 6</span><br><span class="line">model		: 63</span><br><span class="line">model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz</span><br><span class="line">stepping	: 2</span><br><span class="line">cpu MHz		: 1300.092</span><br><span class="line">cache size	: 20480 KB</span><br><span class="line">physical id	: 1</span><br><span class="line">siblings	: 4</span><br><span class="line">core id		: 1</span><br><span class="line">cpu cores	: 2</span><br><span class="line">apicid		: 7</span><br><span class="line">initial apicid	: 7</span><br><span class="line">fpu		: yes</span><br><span class="line">fpu_exception	: yes</span><br><span class="line">cpuid level	: 15</span><br><span class="line">wp		: yes</span><br><span class="line">flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm ida arat epb xsaveopt pln pts dtherm tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms</span><br><span class="line">bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</span><br><span class="line">bogomips	: 5199.88</span><br><span class="line">clflush size	: 64</span><br><span class="line">cache_alignment	: 64</span><br><span class="line">address sizes	: 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br></pre></td></tr></table></figure>

<h3 id="2-2、说明"><a href="#2-2、说明" class="headerlink" title="2.2、说明"></a><strong>2.2、说明</strong></h3><p>“&#x2F;proc&#x2F;cpuinfo”文件结构以对一个逻辑CPU Core的描述为一个基本段，有N个逻辑CPU Core就有N段。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
<th>样例中的对应</th>
<th>参数层次说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color='red'>processor</font></td>
<td>逻辑CPU Core编号，从0开始。整体文件信息按照该编号值从小到大排序</td>
<td>0-7</td>
<td>逻辑CPU Core本层</td>
</tr>
<tr>
<td><font color='red'>vendor_id</font></td>
<td>逻辑CPU Core的制造厂商ID</td>
<td>“GenuineIntel”表示英特尔公司</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>cpu family</td>
<td>逻辑CPU Core的CPU系列，即“微处理器架构代号”</td>
<td>6</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>model</td>
<td>逻辑CPU Core在具体CPU系列中的CPU具体型号，搜索时须转换成十六进制</td>
<td>63，即<code>0x3f</code></td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>model name</font></td>
<td>逻辑CPU Core型号名称，包括“品牌商标”，“具体产品编号”，“CPU额定主频”等信息</td>
<td>“Intel(R) Xeon(R)”：英特尔公司的至强品牌（英特尔品牌商标另外还有<code>Intel(R) Core(TM)-英特尔酷睿品牌</code>，<code>Intel(R) Pentium(TM)-英特尔奔腾品牌</code>，<code>Intel(R) Celeron(TM)-英特尔赛扬品牌</code>等）<br/>“E5-2640 v3”：具体产品编号<br/>“2.60GHz”：额定主频</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>stepping</td>
<td>逻辑CPU Core的更新步进，表示版本小升级编号</td>
<td>2</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>cpu MHz</font></td>
<td>逻辑CPU Core的工作实际主频</td>
<td>1300.092&#x2F;2600.092&#x2F;4160.092</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td><font color='red'>cache size</font></td>
<td>逻辑CPU Core的L3 Cache大小</td>
<td>20480KB</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>physical id</font></td>
<td>逻辑CPU Core所在物理CPU的编号</td>
<td>有两个物理CPU，编号分别为0和1</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>siblings</font></td>
<td>逻辑CPU Core所在物理CPU上的逻辑CPU Core数量</td>
<td>物理CPU 0上有2个物理CPU Core，每个物理CPU Core开启2路超线程技术（<code>*2</code>），故共有<code>2 * 2 = 4</code>个逻辑CPU Core；物理CPU 1相同</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>core id</font></td>
<td>逻辑CPU Core所在物理CPU Core在所在物理CPU中的编号</td>
<td>物理CPU 0中有两个物理CPU Core，该两个物理CPU Core在物理CPU 0中的编号分别为0和1；物理CPU 1中有两个物理CPU Core，该两个物理CPU Core在物理CPU 1中的编号分别为0和1</td>
<td>继承自所在物理CPU Core</td>
</tr>
<tr>
<td><font color='red'>cpu cores</font></td>
<td>逻辑CPU Core所在物理CPU中含有的物理CPU Core数量</td>
<td>物理CPU 0含有2个物理CPU Core；物理CPU 1含有2个物理CPU Core</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td>apicid</td>
<td>用来区分不同逻辑CPU Core的编号，不同逻辑CPU Core的此编号必然不同</td>
<td>0-7</td>
<td>逻辑CPU Core本层</td>
</tr>
<tr>
<td>initial apicid</td>
<td>用来区分不同逻辑CPU Core的编号，不同逻辑CPU Core的此编号必然不同</td>
<td>0-7</td>
<td>逻辑CPU Core本层</td>
</tr>
<tr>
<td>fpu</td>
<td>逻辑CPU Core是否具有浮点运算单元（Floating Point Unit）</td>
<td>yes</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>fpu_exception</td>
<td>逻辑CPU Core是否支持浮点计算异常</td>
<td>yes</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>cpuid level</td>
<td>执行<code>cpuid</code>指令前，EAX寄存器中的值，根据不同的值，<code>cpuid</code>指令会返回不同的内容</td>
<td>15</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>wp</td>
<td>逻辑CPU Core是否支持内核态对用户空间的写保护（Write Protection）</td>
<td>yes</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>flags</td>
<td>逻辑CPU Core支持的功能，比如“<code>vmx</code>表示支持虚拟化”，“<code>aes</code>表示针对AES算法进行了硬件优化”，“<code>ht</code>表示支持超线程技术”等</td>
<td><code>fpu vme de ...</code></td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>bugs</td>
<td>逻辑CPU Core所修复的补丁</td>
<td><code>cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds</code></td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>bogomips</td>
<td>逻辑CPU Core在系统内核启动时粗略测算的速度（Million Instructions Per Second）</td>
<td>5199.90</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>clflush size</td>
<td>逻辑CPU Core的每次刷新缓存的大小单位</td>
<td>64</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>cache_alignment</td>
<td>逻辑CPU Core的高速缓存地址对齐单位</td>
<td>64</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>address sizes</td>
<td>逻辑CPU Core的可访问地址空间位数</td>
<td>46 bits physical, 48 bits virtual</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>power management</td>
<td>逻辑CPU Core对能源管理的支持</td>
<td>&#x2F;</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2019/06/03/CPU/" title="CPU">《CPU》</a><br>[2]<a href="http://www.linfo.org/proc_cpuinfo.html">http://www.linfo.org/proc_cpuinfo.html</a><br>[3]<a href="https://www.intel.cn/content/www/cn/zh/processors/processor-numbers.html">https://www.intel.cn/content/www/cn/zh/processors/processor-numbers.html</a><br>[4]<a href="https://www.tecmint.com/check-linux-cpu-information/">https://www.tecmint.com/check-linux-cpu-information/</a><br>[5]<a href="https://www.cnblogs.com/wxxjianchi/p/10522049.html">https://www.cnblogs.com/wxxjianchi/p/10522049.html</a><br>[6]<a href="https://zhuanlan.zhihu.com/p/68239031">https://zhuanlan.zhihu.com/p/68239031</a><br>[7]<a href="https://doc.callmematthi.eu/static/webArticles/Understanding%20Linux%20_proc_cpuinfo.pdf">https://doc.callmematthi.eu/static/webArticles/Understanding%20Linux%20_proc_cpuinfo.pdf</a><br>[8]<a href="https://superuser.com/questions/1093689/what-does-r-and-tm-mean-in-intel-brand-name">https://superuser.com/questions/1093689/what-does-r-and-tm-mean-in-intel-brand-name</a><br>[9]man &#x2F;proc&#x2F;cpuinfo</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>伪共享</title>
    <url>/blog/2020/07/22/%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="一、伪共享含义"><a href="#一、伪共享含义" class="headerlink" title="一、伪共享含义"></a><strong>一、伪共享含义</strong></h2><p>根据<a href="/blog/2019/06/07/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" title="高速缓存">《高速缓存》</a>可知，高速缓存中的Cache Line缓存一定数量的字节，而不是只有1个字节。一般情况下，一个Cache Line有32或者64个字节。如果属于不同资源（比如“变量”）的字节被加载到同一个Cache Line，就导致出现了伪共享。</p>
<h2 id="二、伪共享带来的问题"><a href="#二、伪共享带来的问题" class="headerlink" title="二、伪共享带来的问题"></a><strong>二、伪共享带来的问题</strong></h2><p>根据以上叙述，伪共享带来问题的本质叙述是：由于Cache Line缓存一定数量的字节，使得一部分原本不处于竞争关系的资源具有了竞争关系，而这最终导致了并发性能下降。<br><font color='red'>伪共享问题是底层硬件机制问题，故存在于所有程序语言中。</font></p>
<p>比如：</p>
<ul>
<li>假定变量a和b被加载到同一个Cache Line，在缓存锁定场景中，对a&#x2F;b变量进行原子操作时，相应的Cache Line被缓存锁定，此时不能再并发修改和读取另外一个变量</li>
<li>假定变量a和b被加载到同一个Cache Line，在MESI协议中，对a&#x2F;b变量修改时，MESI协议要求锁住相应的Cache Line（需要注意的是，“锁住”与“缓存锁定”不同），此时不能再并发修改另外一个变量</li>
</ul>
<h2 id="三、伪共享带来的问题解决"><a href="#三、伪共享带来的问题解决" class="headerlink" title="三、伪共享带来的问题解决"></a><strong>三、伪共享带来的问题解决</strong></h2><p>对于伪共享带来的问题，常见的解决方案有：</p>
<ul>
<li>缓存行填充。缓存行填充的本质原理是，对于需要确保不分配在同一个Cache Line的两个资源，只需在它们中间填充字节，使得最后两者之间的字节距离大于一个Cache Line长度，此时可简单证明必然不会被分配到同一个Cache Line</li>
<li>资源对齐。自动调整使得资源在Cache Line边界开始</li>
<li>…</li>
</ul>
<p>伪共享问题的存在不可杜绝，解决伪共享问题需要一定成本，比如“Cache Line空间浪费”，“使用额外机制的复杂性引入”等，因此，是否解决伪共享问题需要具体情况具体分析，一般只有当收益远远大于成本时，才需要考虑解决伪共享问题，比如“一个队列数据结构，head和tail指针有大的并发修改概率”。</p>
<h2 id="四、Java中伪共享问题解决"><a href="#四、Java中伪共享问题解决" class="headerlink" title="四、Java中伪共享问题解决"></a><strong>四、Java中伪共享问题解决</strong></h2><p>接下来的叙述以64位系统为环境，在64位系统中，一个Cache Line的长度为64字节。</p>
<h3 id="4-1、解决方案"><a href="#4-1、解决方案" class="headerlink" title="4.1、解决方案"></a><strong>4.1、解决方案</strong></h3><p>Java中对于伪共享问题的解决方案是“缓存行填充”，常见的具体手段有：“填充冗余变量”和“Java 8中引入的&#64;sun.misc.Contended注解”。</p>
<p>在继续介绍之前，首先须明晰下Java内存结构与Cache Line的关系：</p>
<ul>
<li>Java内存结构（包括“栈”、“Java堆”、“方法区”等）跟Cache Line没有关系，Cache Line只跟主存数据块有关</li>
<li>Java中两个变量是否会被加载到同一个Cache Line只由他们是否被分配到同一个主存数据块决定。围绕Java堆中Java对象（Java对象内存布局参见“备注”）内的变量进行说明：<ul>
<li>一个Java类A，其内只有一个long变量value，那么类A的实例对象在不考虑“对齐填充字节”的前提下占据24个字节（对象头16个字节，value变量8个字节）。围绕value变量，一个Cache Line最多可以加载3个value变量（1个不完整的类A实例对象，但加载了value部分，8到16个字节；2个完整的类A实例对象共48个字节），也可以是2个value变量，1个value变量，0个value变量</li>
<li>一个Java类A，其内只有一个long变量value，一个<code>m = new A[3]</code>数组对象m，那么类A的实例对象在不考虑“对齐填充字节”的前提下占据24个字节（对象头16个字节，value变量8个字节），m在不考虑“对齐填充字节”的前提下占据32个字节（对象头20个字节，实例数据是3个引用变量12个字节）。围绕value变量和数组元素引用变量refer，一个Cache Line最多可以加载2个value变量和3个refer变量（1个不完整的类A实例对象，但加载了value部分，8个字节；1个完整的类A实例对象24个字节；1个完整的m数组对象32个字节）</li>
</ul>
</li>
</ul>
<br/>

<p><strong>备注</strong>：<br>Java对象的内存布局由3部分组成：</p>
<ul>
<li>对象头。包含3部分：Mark Word（在64位系统中占据8字节），指向类元数据的指针（Klass Pointer，在64位系统中占据8字节），数组长度（在64位系统中占据4字节，只有数组对象才有该部分）</li>
<li>实例数据</li>
<li>对齐填充字节，Java对象大小要求是8字节的倍数，因此可能需要进行字节填充对齐</li>
</ul>
<h4 id="4-1-1、填充冗余变量"><a href="#4-1-1、填充冗余变量" class="headerlink" title="4.1.1、填充冗余变量"></a><strong>4.1.1、填充冗余变量</strong></h4><p>假定需要隔离的两个变量为a和b，那么可在a和b之间填充冗余变量。</p>
<p>上述方案的缺点是：</p>
<ul>
<li>耦合系统位数。在32和64位系统中，冗余变量填充所需的个数不一样。在32位系统中，Cache Line的长度为32字节，Java对象头所占据字节数分别为“Mark Word（4字节）”，“指向类的指针（4字节）”，“数组长度（4字节，只有数组对象才有该部分）”；在64位系统中，Cache Line的长度为64字节，Java对象头所占据字节数分别为“Mark Word（8字节）”，“指向类的指针（8字节）”，“数组长度（4字节，只有数组对象才有该部分）”</li>
<li>一些JDK会智能去掉冗余变量，此时，该方案失效。故跟使用的JDK耦合</li>
</ul>
<h4 id="4-1-2、Java-8中引入的-64-sun-misc-Contended注解"><a href="#4-1-2、Java-8中引入的-64-sun-misc-Contended注解" class="headerlink" title="4.1.2、Java 8中引入的&#64;sun.misc.Contended注解"></a><strong>4.1.2、Java 8中引入的&#64;sun.misc.Contended注解</strong></h4><p>通过使用该注解解决伪共享问题的原理是：运行时会分别在前后填充128字节。<br>注解的修饰目标有两个，分别是“类”和“类内成员变量”：</p>
<ul>
<li>类。在类内首个成员变量前填充128字节，在类内最后一个成员变量后填充128字节</li>
<li>类内成员变量。在成员变量前填充128字节，在成员变量后填充128字节</li>
</ul>
<p><strong>备注：</strong></p>
<ul>
<li>以上填充策略描述只是大体轮廓，还有很多具体细节未涉及</li>
</ul>
<h3 id="4-2、几个案例"><a href="#4-2、几个案例" class="headerlink" title="4.2、几个案例"></a><strong>4.2、几个案例</strong></h3><p><strong>1、案例1</strong><br>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增了一个队列类LinkedTransferQueue，它的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PaddedAtomicReference</span> &lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AtomicReference</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line">        <span class="built_in">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReference</span> &lt;V&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>在上述代码中，head和tail分别指向头部节点和尾部节点，不过需要注意的是，实际指向节点的引用变量是其中的value变量。当head和tail指向的对象相邻近时，head的value和tail的value很容易被加载到同一个Cache Line，在并发修改头节点和尾节点十分频繁的场景中，并发性能会大大降低，因此，通过填充冗余变量p0-pe（从理论上来说，其实无需填充15个冗余变量这么多，因为PaddedAtomicReference类的实例对象的对象头占据16个字节）的方式，使得两个value的字节距离必大于64个字节，从而确保两者不会被加载到同一个Cache Line。</p>
<p><strong>2、案例2</strong><br>高性能队列Disruptor中的RingBuffer类使用填充冗余变量的方式解决伪共享问题。<br>截取部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RingBuffer</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">RingBufferFields</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Cursored</span>, EventSequencer&lt;E&gt;, EventSink&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">INITIAL_CURSOR_VALUE</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p1;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p2;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p3;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p4;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p5;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p6;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> p7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、案例3</strong><br>接下来进行一个实验，笔者机器的CPU配置是：1CPU，4核心，3.2GHz主频。<br>实验代码参考自网络：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FalseSharing</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">ITERATIONS</span> <span class="operator">=</span> <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREADS</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// change</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> arrayIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> arrayIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;starting....&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            NUM_THREADS = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        longs = <span class="keyword">new</span> <span class="title class_">VolatileLong</span>[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> <span class="title class_">VolatileLong</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        runTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;duration = &quot;</span> + (System.nanoTime() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FalseSharing</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>java FalseSharing</code>，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting....</span><br><span class="line">duration = 25836786319</span><br></pre></td></tr></table></figure>
<p>即25秒左右，通过填充5个冗余变量的方式解决伪共享问题，<code>VolatileLong</code>类修改后的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> p1, p2, p3, p4, p5; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在两个实例对象内的value变量字节距离至少为64个字节（对象头16个字节，value变量8个字节，5个冗余变量40个字节），执行<code>java -XX:-UseCompressedOops FalseSharing</code>（这里需要加上“-XX:-UseCompressedOops”VM参数，否则上述64个字节距离的计算是错误的），结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting....</span><br><span class="line">duration = 15333024669</span><br></pre></td></tr></table></figure>
<p>即15秒左右，通过填充6个冗余变量的方式解决伪共享问题，<code>VolatileLong</code>类修改后的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>java FalseSharing</code>，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting....</span><br><span class="line">duration = 4591050110</span><br></pre></td></tr></table></figure>
<p>即4秒左右，这里有个奇怪的现象就是：理论上来说，填充5个冗余变量的方式跟填充6个冗余变量的方式都解决了伪共享问题，但是后者却比前者大大提升了性能。<font color='red'>笔者百思不得其解，请知道的读者不吝赐教。</font></p>
<p>接下来使用Contended注解的方式解决伪共享问题，<code>VolatileLong</code>类修改后的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>java -XX:-RestrictContended FalseSharing</code>（要想使用“@Contended”注解，须加上“-XX:-RestrictContended”VM参数），结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting....</span><br><span class="line">duration = 5072695821</span><br></pre></td></tr></table></figure>


<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://blog.csdn.net/qq_27680317/article/details/78486220">https://blog.csdn.net/qq_27680317/article/details/78486220</a><br>[2]<a href="http://ifeve.com/from-javaeye-false-sharing/">http://ifeve.com/from-javaeye-false-sharing/</a><br>[3]<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a><br>[4]<a href="https://blog.csdn.net/lkforce/article/details/81128115">https://blog.csdn.net/lkforce/article/details/81128115</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>使用Github Pages搭建个人博客</title>
    <url>/blog/2016/06/25/%E4%BD%BF%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a><strong>一、原理分析</strong></h2><p>Github Pages是Github提供的一项可用来托管个人静态站点的服务，详细介绍见[1]。通过Github Pages，可以省去自行购买VPS等服务搭建托管环境的麻烦。<br>Jekyll是一个静态站点生成器，它能够提取使用Markdown语言或者Textile语言编写的文章内容文件，并与配置使用的CSS文件，JS文件等素材文件一起作为转换引擎的输入，经过转换引擎转换，获取最终的HTML文件，这些HTML文件构成个人静态站点的主要部分。<br>Hexo跟Jekyll一样都是静态站点生成器，只不过Hexo只支持识别使用Markdown语言编写的文章内容文件。另外Hexo和Jekyll实现采用的技术方案不一致。<br>另外类似的静态站点生成器还有：Octopress，FarBox等。<br><font color='red'>由于Hexo的易用和高效，作者选择使用Hexo。</font></p>
<h2 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a><strong>二、具体步骤</strong></h2><p>首先声明，作者的系统环境是“Ubuntu 14.04”。</p>
<h3 id="2-1、开启Github-Pages服务"><a href="#2-1、开启Github-Pages服务" class="headerlink" title="2.1、开启Github Pages服务"></a><strong>2.1、开启Github Pages服务</strong></h3><ol>
<li>在Github上新建一个“repository”，作者取名为“blogtest”</li>
<li>在“blogtest repository”的“Settings”页面点击“Launch automatic page generator”按钮，开启Github Pages服务，会提示访问网址为<code>https://dslztx.github.io/blogtest/</code></li>
<li>完成以上步骤后，在“blogtest repository”下会新建一个“gh-pages branch”，需要把静态站点的内容发布到这里</li>
</ol>
<h3 id="2-2、本地搭建Hexo环境"><a href="#2-2、本地搭建Hexo环境" class="headerlink" title="2.2、本地搭建Hexo环境"></a><strong>2.2、本地搭建Hexo环境</strong></h3><h4 id="2-2-1、安装Git"><a href="#2-2-1、安装Git" class="headerlink" title="2.2.1、安装Git"></a><strong>2.2.1、安装Git</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2、安装Node-js"><a href="#2-2-2、安装Node-js" class="headerlink" title="2.2.2、安装Node.js"></a><strong>2.2.2、安装Node.js</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install node.js</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3、安装npm"><a href="#2-2-3、安装npm" class="headerlink" title="2.2.3、安装npm"></a><strong>2.2.3、安装npm</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4、安装Hexo"><a href="#2-2-4、安装Hexo" class="headerlink" title="2.2.4、安装Hexo"></a><strong>2.2.4、安装Hexo</strong></h4><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>上述命令执行过程中，出现错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh: 1: node: not found</span><br><span class="line">npm ERR! weird error 127</span><br><span class="line">npm WARN This failure might be due to the use of legacy binary &quot;node&quot;</span><br><span class="line">npm WARN For further explanations, please read /usr/share/doc/nodejs/README.Debian</span><br></pre></td></tr></table></figure>

<p>相应的解决方案是安装“nodejs-legacy”依赖[4]，具体执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>

<p>然后再重复执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5、使用Hexo初始化本地环境根目录"><a href="#2-2-5、使用Hexo初始化本地环境根目录" class="headerlink" title="2.2.5、使用Hexo初始化本地环境根目录"></a><strong>2.2.5、使用Hexo初始化本地环境根目录</strong></h4><p>具体是执行如下系列命令[5]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;RootFolder&gt;</span><br><span class="line">cd &lt;RootFolder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="2-3、写文章，本地预览"><a href="#2-3、写文章，本地预览" class="headerlink" title="2.3、写文章，本地预览"></a><strong>2.3、写文章，本地预览</strong></h3><p>进入“RootFolder”目录，使用<code>hexo new &lt;title&gt;</code>[6]命令，新建一个空白的文章内容文件，该文件置于“_post”子目录下，在该文件中使用Markdown语言完成编辑内容。<br>接着执行下列系列命令就可以在本地进行预览：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#　生成最终的HTML文件</span><br><span class="line">hexo generate</span><br><span class="line">#　开启本地Web服务，可以访问生成的静态站点内容</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h3 id="2-4、发布静态站点的内容到Github-Pages"><a href="#2-4、发布静态站点的内容到Github-Pages" class="headerlink" title="2.4、发布静态站点的内容到Github Pages"></a><strong>2.4、发布静态站点的内容到Github Pages</strong></h3><p>要想发布静态站点内容到Github Pages，首先得对“RootFolder”下的“_config.yml”配置文件进行修改：</p>
<ol>
<li>由于静态站点的在线访问网址为<code>https://dslztx.github.io/blogtest/</code>，因此需要配置“_config.yml”配置文件“URL”小节下的“root”属性值为“&#x2F;blogtest&#x2F;”</li>
<li>需要配置发布目的地参数，具体是替换原有“deploy”小节的内容，改成如下形式内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repo: git@github.com:dslztx/blogtest.git</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>

<p>其中“repo”值是“blogtest repository”的允许以SSH形式访问的地址，“branch”表示发布到相应“repository”的“gh-pages”这个分支。<br>接着执行<code>hexo deploy</code>命令，进行发布。出现如下所示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: github</span><br></pre></td></tr></table></figure>

<p>相应的解决方案[7]是将上述“_config.yml”配置文件“deploy”小节的“type”属性值改为“git”。另外安装“hexo-deployer-git”这个模块依赖。具体是在“RootFolder”下执行<code>npm install hexo-deployer-git --save</code>命令，安装的模块被置于“node_modules”子目录下。<br>此时再执行<code>hexo deploy</code>命令，发现出现如下所示错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure>

<p>以上错误信息跟Hexo无关，跟Git相关，按照提示信息进行配置即可。<br>再次执行<code>hexo deploy</code>命令，发布成功。此时可通过<code>https://dslztx.github.io/blogtest/</code>网址进行在线访问。</p>
<br/>
参考文献:
[1]https://help.github.com/articles/what-is-github-pages/
[2]http://jekyllcn.com/docs/posts/
[3]https://hexo.io/zh-cn/
[4]http://nfeng.cc/2016/03/08/npm-legacy-binary-node/
[5]https://hexo.io/zh-cn/docs/setup.html
[6]https://hexo.io/zh-cn/docs/writing.html
[7]https://github.com/hexojs/hexo/issues/1040
[8]https://hexo.io/zh-cn/docs/index.html
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Pages搭建个人博客之图床</title>
    <url>/blog/2016/06/26/%E4%BD%BF%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>参考<a href="/blog/2016/06/25/%E4%BD%BF%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="使用Github Pages搭建个人博客">《使用Github Pages搭建个人博客
》</a>，可搭建一个简单的基本可用的个人博客。但是使用Github Pages搭建个人博客需要考虑一点：Github Pages服务只免费提供1GB的站点托管空间[1]，故而我们需要将站点内的图片资源文件（图片资源文件相较文本资源文件空间使用量一般大几个数量级）存放在其他网络空间，这样才可避免站点空间使用量快速增长并超过1GB限制。<br>满足以上条件，可用来存储图片资源文件的其他网络空间，称之为“图床”。“图床”的百度百科定义如下[2]：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图床：专门用来存放图片，同时允许以外链地址访问这些图片的网络空间。</span><br></pre></td></tr></table></figure>

<h2 id="一、图床选择"><a href="#一、图床选择" class="headerlink" title="一、图床选择"></a><strong>一、图床选择</strong></h2><p>国外知名的图床有：imgur等；国内知名的图床有：又拍云，七牛云等。经过综合比较，作者选择七牛云作为图床。<br>对于标准用户，七牛云免费提供图1所示资源：</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20160626-0-1.png"></p>
<h2 id="二、使用七牛云图床"><a href="#二、使用七牛云图床" class="headerlink" title="二、使用七牛云图床"></a><strong>二、使用七牛云图床</strong></h2><h3 id="2-1、网页端使用七牛云图床"><a href="#2-1、网页端使用七牛云图床" class="headerlink" title="2.1、网页端使用七牛云图床"></a><strong>2.1、网页端使用七牛云图床</strong></h3><p>需要有以下3个步骤：</p>
<ol>
<li>网页上登录七牛云个人空间管理界面</li>
<li>上传图片文件</li>
<li>生成图片文件外链，并复制</li>
</ol>
<br/>
参考文献：
[1]https://help.github.com/articles/what-is-github-pages/
[2]http://baike.baidu.com/view/620100.htm
[3]https://www.zhihu.com/question/20115323
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Pages搭建个人博客之扩展定制</title>
    <url>/blog/2016/06/26/%E4%BD%BF%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%89%A9%E5%B1%95%E5%AE%9A%E5%88%B6/</url>
    <content><![CDATA[<p>参考<a href="/blog/2016/06/25/%E4%BD%BF%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="使用Github Pages搭建个人博客">《使用Github Pages搭建个人博客》</a>，可搭建一个简单的基本可用的个人博客。本文介绍深入的扩展定制。</p>
<h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a><strong>一、基本介绍</strong></h2><p>个人博客的“外在整体效果，选用的‘theme’和所选用‘theme’的配置控制等”主要由Hexo配置。<br>配置Hexo，可参见Hexo官方文档[1]。<br>经过比较，作者选用“NexT”这个“theme”，配置NexT，可参见NexT官方文档[2]。<br>Hexo主要配置文件路径为：<code>RootFolder/_config.yml</code>。<br>NexT主要配置文件路径为：<code>RootFolder/themes/next/_config.yml</code>。</p>
<h2 id="二、扩展定制内容"><a href="#二、扩展定制内容" class="headerlink" title="二、扩展定制内容"></a><strong>二、扩展定制内容</strong></h2><p>作者所作的扩展定制内容列表如下：</p>
<ol>
<li>配置Hexo改用“NexT”这个“theme”</li>
<li>配置Hexo，设定站点语言，站点名称，头像图片路径，作者昵称，站点描述。作者设定的站点语言为“zh-Hans”，其他略</li>
<li>配置Hexo，设定“URL”小节下的“url”属性值为站点一级域名地址</li>
<li>配置NexT，设定具体的主题模式，作者选定“Mist”主题模式</li>
<li>集成第三方服务：集成Disqus评论系统服务，集成百度站点统计服务，集成“Local Search”站内搜索服务</li>
<li>启用“分类”和“标签”栏目</li>
<li>配置NexT，设定“toc”小节下的“number”属性值为“false”，关闭生成文章目录结构时的自动编号机制</li>
<li>配置NexT，设定“auto_excerpt”小节下的“enable”属性值为“true”，使得不在首页显示文章的全部内容，而是只显示部分内容，再加上一个“阅读全文”按钮[3]</li>
<li>配置NexT，设定“use_motion”属性值为“false”，关闭加载博客时的动画效果。需要注意的是，关闭该动画效果有一个副作用：现在即使博客文章有“目录层次结构”，“侧边栏”也不再自动展现[4]</li>
</ol>
<br/>
参考文献：
[1]https://hexo.io/zh-cn/docs/
[2]http://theme-next.iissnan.com/
[3]http://theme-next.iissnan.com/faqs.html
[4]https://github.com/iissnan/hexo-theme-next/issues/441
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建的Github Pages静态站点突然不能访问vendors目录下资源</title>
    <url>/blog/2016/11/04/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E7%9A%84Github-Pages%E7%AA%81%E7%84%B6%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AEvendors%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="一、现象描述"><a href="#一、现象描述" class="headerlink" title="一、现象描述"></a><strong>一、现象描述</strong></h2><p>作者使用Hexo静态站点生成器搭建了一个基于Github Pages服务的静态站点，一直都能够正常使用。昨天突然发现不能正常使用，提示信息是<code>vendors</code>目录下的资源获取不了，报404错误。<br>浏览器控制台返回信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET 404 https://dslztx.github.io/blog/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5</span><br></pre></td></tr></table></figure>
<h2 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a><strong>二、原因</strong></h2><p>通过向Github客服求助，得知的具体原因和解决方案是：<br>Github Pages服务最近升级了静态站点生成器Jekyll的版本（Github Pages服务默认支持Jekyll静态站点生成器），最新版本是v3.3。该版本默认忽略<code>vendors</code>目录，因此其下的资源都不能被顺利获取到。<br>要想解决该问题，可通过在根目录下添加一个名为<code>.nojekyll</code>的文件，从而使得能够顺利获取<code>vendors</code>目录下的资源，并且正常使用非Jekyll生成的静态站点。</p>
<h2 id="三、具体解决方案"><a href="#三、具体解决方案" class="headerlink" title="三、具体解决方案"></a><strong>三、具体解决方案</strong></h2><p>使用Hexo命令部署静态站点的过程可描述为：</p>
<ol>
<li>使用<code>hexo generate</code>命令生成静态站点所有文件，这些文件被置于<code>public</code>子目录下</li>
<li>使用<code>hexo deploy</code>命令进行具体部署。它首先清空<code>.deploy_git</code>子目录下所有以非<code>.</code>开头的文件，然后从<code>public</code>子目录下复制所有以非<code>.</code>开头的文件到<code>.deploy_git</code>子目录下。最后将<code>.deploy_git</code>子目录下除了<code>.git</code>文件之外的所有文件（包括其他以<code>.</code>开头的文件）提交到相应的Github Repository完成静态站点的部署</li>
</ol>
<p>根据上述过程描述，我们可以在<code>.deploy_git</code>子目录下添加一个名为<code>.nojekyll</code>的文件，在具体部署时，该文件被提交到相应的Github Repository，从而使得能够正常使用Hexo生成的静态站点。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Markdown制作Slide</title>
    <url>/blog/2018/11/08/%E4%BD%BF%E7%94%A8Markdown%E5%88%B6%E4%BD%9CSlide/</url>
    <content><![CDATA[<p>Slide，即“幻灯片”。狭义的幻灯片只包括PPT文档（一般由Microsoft Office PowerPoint软件制作），广义的幻灯片包括了PPT文档，KEY文档（一般由Keynote软件制作），演示用HTML文档（比如可由html+css+js直接制作或者如本文主题——结合转换框架使用Markdown制作），演示用PDF文档（比如可通过LaTeX之Beamer制作）等。</p>
<p>显而易见，本文所指Slide是广义范畴上的。</p>
<p>下表列出一系列使用Markdown制作Slide的产品及其介绍。</p>
<table>
<thead>
<tr>
<th>产品</th>
<th>收费</th>
<th>使用简单</th>
<th>功能强大</th>
<th>转换成PDF</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://prezi.com/">prezi</a></td>
<td>收费</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><a href="https://www.swipe.to/markdown/">swipe</a></td>
<td>收费</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><a href="https://github.com/impress/impress.js">impressjs</a></td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>不使用Markdown</td>
</tr>
<tr>
<td><a href="https://gitpitch.com/">gitpitch</a></td>
<td>免费</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>需要公开数据</td>
</tr>
<tr>
<td><a href="http://slidify.org/">slidify</a></td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>基于RMarkdown</td>
</tr>
<tr>
<td><a href="https://rmarkdown.rstudio.com/lesson-11.html">R Markdown</a></td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>基于RMarkdown</td>
</tr>
<tr>
<td><a href="https://github.com/ksky521/nodePPT">nodeppt</a></td>
<td>免费</td>
<td>使用复杂</td>
<td>功能强大</td>
<td>转换成PDF支持不完美</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><a href="https://yhatt.github.io/marp/">marp</a></td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>需要额外安装一个编辑器</td>
</tr>
<tr>
<td><a href="https://github.com/jdan/cleaver">cleaver</a></td>
<td>免费</td>
<td>使用极度简单，面向黑客</td>
<td>具备核心功能，没有花哨功能</td>
<td>转换成PDF支持不完美</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><a href="https://github.com/gsuitedevs/md2googleslides">md2googleslides</a></td>
<td>免费</td>
<td>使用简单</td>
<td>功能强大</td>
<td>&#x2F;</td>
<td>需要登录Google帐号，由于众所周知的原因，容易导致失败</td>
</tr>
<tr>
<td><a href="https://github.com/gnab/remark">remarkjs</a></td>
<td>免费</td>
<td>使用简单</td>
<td>功能强大</td>
<td>转换成PDF支持不完美，但是借助于<a href="https://github.com/astefanutti/decktape">DeckTape</a>能够制作完美PDF</td>
<td>较难安装<a href="https://github.com/astefanutti/decktape">DeckTape</a></td>
</tr>
<tr>
<td><a href="https://github.com/adamzap/landslide">landslide</a></td>
<td>免费</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>存在bug</td>
</tr>
<tr>
<td><a href="https://github.com/hakimel/reveal.js">revealjs</a></td>
<td>免费</td>
<td>使用简单</td>
<td>功能强大</td>
<td>直接支持制作完美PDF</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><a href="http://webpro.github.io/reveal-md/">reveal.md</a></td>
<td>免费</td>
<td>使用简单</td>
<td>功能强大</td>
<td>直接支持制作完美PDF</td>
<td>基于<a href="https://github.com/hakimel/reveal.js">revealjs</a>，使用更加简单，隐藏不常用复杂功能。<br/>按下<code>s</code>键进入“speaker view”视图。<br/>安装命令：<pre>sudo apt-get install nodejs && sudo apt-get install npm && sudo npm install -g reveal-md</pre></td>
</tr>
</tbody></table>
<br/>
**备注：**
Google中通过`markdown slide`或者`markdown ppt`关键词搜索得到上述产品
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>使用Socks协议穿越防火墙</title>
    <url>/blog/2024/02/06/%E4%BD%BF%E7%94%A8Socks%E5%8D%8F%E8%AE%AE%E7%A9%BF%E8%B6%8A%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<p>现在有如下情形：<br>有机器A，B，防火墙C，A在防火墙C内，B在防火墙C外，防火墙C控制防火墙外能够与A进行连接的只有B，而且A与B的连接中禁止出现一些特定的关键词。</p>
<p>问现在该如何配置，使得A能够与防火墙外除了B以外的机器进行连接，而且可以传输前述的关键词而不被防火墙C发现。</p>
<h2 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a><strong>一、原理分析</strong></h2><p>根据<a href="/blog/2024/02/06/Socks%E5%8D%8F%E8%AE%AE/" title="Socks协议">《Socks协议》</a>，可以在A上安装运行Socks Client，在B上安装运行Socks Server，接下来可以通过Socks Client和Socks Server之间的连接将A的对外连接通过B进行，这样A就能够与防火墙外除了B以外的机器进行连接了；另外由于Socks Client和Socks Server之间的连接可以采用加密算法加密，因而传输的内容不能被防火墙C识别出来，那么可以传输任意内容，自然也可以包含被防火墙C禁止的那些关键词。</p>
<h2 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a><strong>二、具体步骤</strong></h2><p>根据<a href="/blog/2024/02/06/Socks%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/" title="Socks协议实现">《Socks协议实现》</a>，Socks Client的实现和Socks Server的实现可以选择OpenSSH软件套装，也可以选择ShadowSocks软件套装。</p>
<p>这里以ShadowSocks软件套装为例：</p>
<ol>
<li>在A上安装运行ShadowSocks Client，在B上安装运行ShadowSocks Server </li>
<li>在A上安装运行ShadowSocks Client之后，对于A上的应用软件来说，ShadowSocks Client相当于一个“本地代理服务器”</li>
<li>在A上配置代理转发。根据<a href="/blog/2024/02/06/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/" title="代理转发">《代理转发》</a>，可以配置局部代理转发和全局代理转发，以SwitchyOmega这个局部代理转发插件为例，此时可以配置SwitchyOmega的代理服务器为本机上的ShadowSocks Client，此时浏览器的对外连接请求由ShadowSocks Client代理进行</li>
<li>在完成以上配置后，此时如果A上的浏览器想与防火墙C外的机器D进行连接，整体流程的示意图如图1所示：</li>
</ol>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20150831-0-0.svg"></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>使用jstack命令排查问题</title>
    <url>/blog/2021/01/13/%E4%BD%BF%E7%94%A8jstack%E5%91%BD%E4%BB%A4%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文的描述基于Linux操作系统。</p>
<h2 id="一、jstack命令结果格式说明"><a href="#一、jstack命令结果格式说明" class="headerlink" title="一、jstack命令结果格式说明"></a><strong>一、jstack命令结果格式说明</strong></h2><p>为便于叙述，运行“示例代码1”，使用jstack命令打印对应进程的线程栈信息，得到“线程栈信息示例1”。</p>
<p>示例代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>线程栈信息示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-13 21:02:17</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #12 daemon prio=9 os_prio=0 tid=0x00007f0584001000 nid=0x5112 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #11 prio=5 os_prio=0 tid=0x00007f05bc00a800 nid=0x50e1 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;threadB&quot; #10 prio=5 os_prio=0 tid=0x00007f05bc0f0000 nid=0x50f1 waiting for monitor entry [0x00007f05a589d000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at Main$2.run(Main.java:32)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;threadA&quot; #9 prio=5 os_prio=0 tid=0x00007f05bc0ee000 nid=0x50f0 waiting for monitor entry [0x00007f05a599e000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at Main$1.run(Main.java:18)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #8 daemon prio=9 os_prio=0 tid=0x00007f05bc0d2000 nid=0x50ed runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread2&quot; #7 daemon prio=9 os_prio=0 tid=0x00007f05bc0bd000 nid=0x50ec waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #6 daemon prio=9 os_prio=0 tid=0x00007f05bc0bb000 nid=0x50eb waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=0 tid=0x00007f05bc0b8800 nid=0x50ea waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=0 tid=0x00007f05bc0b7000 nid=0x50e9 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f05bc084000 nid=0x50e8 in Object.wait() [0x00007f05a6e83000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000786608ed0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">	- locked &lt;0x0000000786608ed0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f05bc081800 nid=0x50e7 in Object.wait() [0x00007f05a6f84000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000786606bf8&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">	- locked &lt;0x0000000786606bf8&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=0 tid=0x00007f05bc078000 nid=0x50e6 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f05bc01f800 nid=0x50e2 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f05bc021000 nid=0x50e3 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f05bc023000 nid=0x50e4 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f05bc024800 nid=0x50e5 runnable </span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f05bc0dd000 nid=0x50ee waiting on condition </span><br><span class="line"></span><br><span class="line">JNI global references: 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f058c002418 (object 0x000000078665b048, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadA&quot;</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f058c0064b8 (object 0x000000078665b058, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadB&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">	at Main$2.run(Main.java:32)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">	at Main$1.run(Main.java:18)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h3 id="1-1、线程栈信息主体"><a href="#1-1、线程栈信息主体" class="headerlink" title="1.1、线程栈信息主体"></a><strong>1.1、线程栈信息主体</strong></h3><p>主体就是对一个个Java线程打印时状态的信息描述，在“线程栈信息示例1”中就是从<code>&quot;Attach Listener&quot; #12 daemon prio=9 os_prio=0 tid=0x00007f0584001000 nid=0x5112 waiting on condition [0x0000000000000000]</code>到<code>&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f05bc0dd000 nid=0x50ee waiting on condition</code>的部分。</p>
<p>在一个Java进程中，线程分为“业务线程”和“VM线程”两种。<br>在“线程栈信息示例1”中，业务线程有：</p>
<ul>
<li>threadA</li>
<li>threadB</li>
</ul>
<p>在“线程栈信息示例1”中，VM线程有：</p>
<ul>
<li>Attach Listener</li>
<li>DestroyJavaVM</li>
<li>Service Thread</li>
<li>C1 CompilerThread2</li>
<li>C2 CompilerThread1</li>
<li>C2 CompilerThread0</li>
<li>Signal Dispatcher</li>
<li>Finalizer</li>
<li>Reference Handler</li>
<li>VM Thread</li>
<li>GC task thread#0 (ParallelGC)</li>
<li>GC task thread#1 (ParallelGC)</li>
<li>GC task thread#2 (ParallelGC)</li>
<li>GC task thread#3 (ParallelGC)</li>
<li>VM Periodic Task Thread</li>
</ul>
<h4 id="1-1-1、线程名"><a href="#1-1-1、线程名" class="headerlink" title="1.1.1、线程名"></a><strong>1.1.1、线程名</strong></h4><p>含义：线程名，就是java.lang.Thread类实例的name属性值。<br>重要性：<font color='red'>重要</font>。<br>示例：比如“threadB”，“threadA”，“Finalizer”。</p>
<h4 id="1-1-2、Thread实例ID"><a href="#1-1-2、Thread实例ID" class="headerlink" title="1.1.2、Thread实例ID"></a><strong>1.1.2、Thread实例ID</strong></h4><p>含义：就是java.lang.Thread类实例的tid属性值。在创建java.lang.Thread实例时自动创建，在线程存活期内不可变，在线程死亡后其tid可被其他线程复用。<br>重要性：不重要。<br>示例：比如“#12”中的“12”。</p>
<h4 id="1-1-3、是否为后台线程"><a href="#1-1-3、是否为后台线程" class="headerlink" title="1.1.3、是否为后台线程"></a><strong>1.1.3、是否为后台线程</strong></h4><p>含义：表征该线程是否为后台线程，对应java.lang.Thread类实例的daemon属性值。默认为非后台线程，使用“daemon”表征后台线程。<br>重要性：不重要。<br>示例：比如<code>&quot;Service Thread&quot; #8 daemon prio=9 os_prio=0 tid=0x00007f05bc0d2000 nid=0x50ed runnable [0x0000000000000000]</code>中的“daemon”。</p>
<h4 id="1-1-4、prio"><a href="#1-1-4、prio" class="headerlink" title="1.1.4、prio"></a><strong>1.1.4、prio</strong></h4><p>含义：Java线程的优先级，对应java.lang.Thread类实例的priority属性值。<br>重要性：不重要。<br>示例：比如“prio&#x3D;9”。</p>
<h4 id="1-1-5、os-prio"><a href="#1-1-5、os-prio" class="headerlink" title="1.1.5、os_prio"></a><strong>1.1.5、os_prio</strong></h4><p>含义：Java线程所映射到Linux原生线程的优先级。<br>重要性：不重要。<br>示例：比如“os_prio&#x3D;0”。</p>
<h4 id="1-1-6、tid"><a href="#1-1-6、tid" class="headerlink" title="1.1.6、tid"></a><strong>1.1.6、tid</strong></h4><p>含义：java.lang.Thread类实例背后的C++数据结构实例的内存地址。注意不要跟“1.1.2、Thread实例ID”小节中的tid混淆。<br>重要性：不重要。<br>示例：比如“tid&#x3D;0x00007f05bc0d2000”。</p>
<h4 id="1-1-7、nid"><a href="#1-1-7、nid" class="headerlink" title="1.1.7、nid"></a><strong>1.1.7、nid</strong></h4><p>含义：所映射到Linux原生线程的ID。排查高CPU占用线程问题时经常用到，参见<a href="/blog/2022/10/19/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8DJava%E8%BF%9B%E7%A8%8B%E5%86%85CPU%E6%B6%88%E8%80%97%E6%9C%80%E5%A4%9A%E7%9A%84Java%E7%BA%BF%E7%A8%8B/" title="Linux下如何定位Java进程内CPU消耗最多的Java线程">《Linux下如何定位Java进程内CPU消耗最多的Java线程》</a>。<br>重要性：<font color='red'>重要</font>。<br>示例：比如“nid&#x3D;0x50ed”。</p>
<h4 id="1-1-8、基本描述"><a href="#1-1-8、基本描述" class="headerlink" title="1.1.8、基本描述"></a><strong>1.1.8、基本描述</strong></h4><p>含义：线程打印时状态的基本描述。<br>重要性：不重要。<font color='red'>需要注意的是，可能跟详细描述不一致</font>。<br>示例：比如<code>runnable</code>，<code>waiting for monitor entry</code>，<code>waiting on condition</code>和<code>in Object.wait()</code>。</p>
<h4 id="1-1-9、最后已知栈指针"><a href="#1-1-9、最后已知栈指针" class="headerlink" title="1.1.9、最后已知栈指针"></a><strong>1.1.9、最后已知栈指针</strong></h4><p>含义：最后已知的栈帧指针，具体含义笔者也不是很清楚。<br>重要性：不重要。<br>示例：比如“[0x00007f05a599e000]”。</p>
<h4 id="1-1-10、详细描述"><a href="#1-1-10、详细描述" class="headerlink" title="1.1.10、详细描述"></a><strong>1.1.10、详细描述</strong></h4><p>含义：线程打印时状态的详细描述。第一行给出了线程的状态，有<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITING</code>和<code>TIMED_WAITING</code>4种可能（完整的线程状态列表可见<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a>，使用jstack命令打印线程栈信息时并不会包含<code>NEW</code>和<code>TERMINATED</code>状态的线程）；接下来几行打印了执行路径栈。<br>重要性：<font color='red'>重要</font>。<br>示例：如下都是示例。</p>
<p><strong>1、RUNNABLE</strong><br>处于<code>IO_WAIT</code>情形的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">     at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">     at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">     at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)</span><br><span class="line">     at java.io.BufferedInputStream.read(BufferedInputStream.java:265)</span><br><span class="line">     - locked &lt;0x000000078661b698&gt; (a java.io.BufferedInputStream)</span><br><span class="line">     at Main.main(Main.java:10)</span><br></pre></td></tr></table></figure>

<p>处于<code>RUNNING</code>或者<code>READY</code>情形的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">     at Main.main(Main.java:9)</span><br></pre></td></tr></table></figure>

<p><strong>2、BLOCKED</strong><br>已申请获得一个synchronized锁，再尝试申请另外一个synchronized锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">     at Main$1.run(Main.java:18)</span><br><span class="line">     - waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">     - locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">     at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>
<p>以上示例中，“&lt;0x000000078665b058&gt;”和“&lt;0x000000078665b048&gt;”是synchronized锁对应的Java对象在某个维度的内存地址，可能是Java对象维度的内存地址，也可能是Java对象背后C++数据结构实例的内存地址。对于其明确含义“不求甚解”，不影响问题排查。<font color='red'>接下来简称该内存地址为<code>synchronized锁锁标记</code></font>。</p>
<p><strong>3、WAITING</strong><br>调用Object类的<code>wait()</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">     at java.lang.Object.wait(Native Method)</span><br><span class="line">     - waiting on &lt;0x000000078665adc8&gt; (a java.lang.Object)</span><br><span class="line">     at java.lang.Object.wait(Object.java:502)</span><br><span class="line">     at Main.main(Main.java:11)</span><br><span class="line">     - locked &lt;0x000000078665adc8&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>调用LockSupport类的<code>park()</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: WAITING (parking)</span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">     at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">     at Main.main(Main.java:7)</span><br></pre></td></tr></table></figure>

<p>调用LockSupport类的<code>park(Object blocker)</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: WAITING (parking)</span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">     - parking to wait for  &lt;0x000000078665ad88&gt; (a java.lang.Object)</span><br><span class="line">     at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">     at Main.main(Main.java:7)</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：</p>
<ul>
<li>在以上最后一个例子中，“&lt;0x000000078665ad88&gt;”是传入blocker这个Java对象在某个维度的内存地址，可能是Java对象维度的内存地址，也可能是Java对象背后C++数据结构实例的内存地址。对于其明确含义“不求甚解”，不影响问题排查。<font color='red'>接下来简称该内存地址为<code>Park锁锁标记</code></font></li>
<li>在<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a>中我们知道，LockSupport类的方法<code>park()</code>和相应的重载方法<code>park(Object blocker)</code>核心语义一致，他们的差别也仅在于：在jstack命令打印结果中，包含后者的执行路径栈与包含前者的执行路径栈相比，额外多了一句形如<code>- parking to wait for  &lt;0x000000078665ad88&gt; (a java.lang.Object)</code>的描述</li>
<li>需要对调用LockSupport类<code>park(Object blocker)</code>方法时的形如<code>- parking to wait for  &lt;0x000000078665ad88&gt; (a java.lang.Object)</code>描述与申请synchronized锁时的形如<code>- waiting to lock &lt;0x00000007ab3f31b8&gt; (a java.lang.Object)</code>描述作区分：后者中的<code>0x00000007ab3f31b8</code>指代一个synchronized锁对象，线程因申请该synchronized锁对象不得而挂起，因此描述具有具体明确的语法语义；前者中的<code>0x000000078665ad88</code>指代传入的blocker对象，该blocker对象与线程挂起不一定有关系，因此描述不具有具体明确的语法语义，只是起到打印上下文信息的日志作用</li>
</ul>
<p><strong>4、TIMED_WAITING</strong><br>调用Thread类<code>sleep(long millis)</code>&#x2F;<code>sleep(long millis, int nanos)</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">     at java.lang.Thread.sleep(Native Method)</span><br><span class="line">     at Main.main(Main.java:8)</span><br></pre></td></tr></table></figure>

<p>调用Object类<code>wait(long timeout)</code>&#x2F;<code>wait(long timeout, int nanos)</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">     at java.lang.Object.wait(Native Method)</span><br><span class="line">     - waiting on &lt;0x000000078665ad70&gt; (a java.lang.Object)</span><br><span class="line">     at Main.main(Main.java:6)</span><br><span class="line">     - locked &lt;0x000000078665ad70&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>调用LockSupport类<code>parkNanos(long nanos)</code>&#x2F;<code>parkUntil(long deadline)</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338)</span><br><span class="line">     at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>

<p>调用LockSupport类<code>parkNanos(Object blocker, long nanos)</code>&#x2F;<code>parkUntil(Object blocker, long deadline)</code>方法的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">     - parking to wait for  &lt;0x000000078665ad28&gt; (a java.lang.Object)</span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">     at Main.main(Main.java:6)</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：</p>
<ul>
<li>对以上最后一个例子中形如<code>- parking to wait for  &lt;0x000000078665ad28&gt; (a java.lang.Object)</code>描述的说明参见上一小节的备注</li>
</ul>
<h3 id="1-2、线程栈信息其他"><a href="#1-2、线程栈信息其他" class="headerlink" title="1.2、线程栈信息其他"></a><strong>1.2、线程栈信息其他</strong></h3><h4 id="1-2-1、头部"><a href="#1-2-1、头部" class="headerlink" title="1.2.1、头部"></a><strong>1.2.1、头部</strong></h4><p>比如“线程栈信息示例1”中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-12 21:50:42</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2、尾部"><a href="#1-2-2、尾部" class="headerlink" title="1.2.2、尾部"></a><strong>1.2.2、尾部</strong></h4><p>比如“线程栈信息示例1”中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JNI global references: 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f058c002418 (object 0x000000078665b048, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadA&quot;</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f058c0064b8 (object 0x000000078665b058, a java.lang.Object),</span><br><span class="line">  which is held by &quot;threadB&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;threadB&quot;:</span><br><span class="line">	at Main$2.run(Main.java:32)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;threadA&quot;:</span><br><span class="line">	at Main$1.run(Main.java:18)</span><br><span class="line">	- waiting to lock &lt;0x000000078665b058&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000078665b048&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上述描述“发现死锁”的部分内容（从<code>Found one Java-level deadlock:</code>开始到<code>Found 1 deadlock.</code>为止）只在探测到存在该种简单死锁情形时才会出现。</p>
<h2 id="二、排查问题"><a href="#二、排查问题" class="headerlink" title="二、排查问题"></a><strong>二、排查问题</strong></h2><p>排查Java线程相关问题围绕“jstack命令打印的线程栈信息文件”进行，其是一切的源头，相较最为权威。分析上述线程栈信息文件，可使用辅助工具（比如下面会谈及的“XSheepdog”，“TDA开源工具”等）但也须对“辅助工具本身可能存在各种问题，甚至造成困扰，不可过度依赖”保持清醒。</p>
<h3 id="2-1、排查Java线程运行卡滞问题"><a href="#2-1、排查Java线程运行卡滞问题" class="headerlink" title="2.1、排查Java线程运行卡滞问题"></a><strong>2.1、排查Java线程运行卡滞问题</strong></h3><p>Java线程运行卡滞的含义是：大部分时间处于<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>BLOCKED</code>状态，或者是<code>RUNNABLE</code>状态的<code>IO_WAIT</code>情形。</p>
<p>卡滞问题其实并不好排查，最好排查的卡滞情形是：一个Java线程T0申请获取到synchronized锁S0，其他大量Java线程Tx尝试申请S0不得而进入BLOCKED状态，T0长时间非正常持有，导致Tx出现卡滞现象。<br>排查上述卡滞情形问题的路径是：聚合分析jstack命令的打印结果，定位被最多线程等待获取的synchronized锁，并找出持有该synchronized锁的线程。尝试了几种方案，对方案的评价如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>线上方案，比如“XSheepdog”[3]</td>
<td>存在数据安全风险</td>
</tr>
<tr>
<td>TDA开源工具[4]</td>
<td>能够快速方便定位被最多线程等待的synchronized锁（在“Monitors”页面中会标红被怀疑的synchronized锁），紧接着也能快速方便找到持有该synchronized锁的线程。<br/>不过对于该工具，笔者感觉有两个小瑕疵：1）“State”列采用了“基本描述”字段值，而没有采用来自“详细描述”字段中第一行的精确的线程状态值；2）将形如<code>- parking to wait for  &lt;0x000000078665ad88&gt; (a java.lang.Object)</code>描述中的<code>Park锁锁标记</code>与<code>synchronized锁锁标记</code>混淆</td>
</tr>
<tr>
<td>个人脚本</td>
<td>1、对jstack命令打印结果文件“jstack.out”执行<code>grep -E &quot;waiting to lock&quot; jstack.out | awk -F&quot;&lt;&quot; &#39;&#123;print $(2)&#125;&#39; | awk -F&quot;&gt;&quot; &#39;&#123;print $(1)&#125;&#39; | sort | uniq -c</code>命令找到疑似synchronized锁锁标记<br/>2、然后再在“jstack.out”文件中搜索<code>locked &lt;步骤1中获取到的疑似synchronized锁锁标记&gt;</code>找到持有相应synchronized锁的线程。<font color='red'>特别需要注意的是</font>：以<code>locked &lt;步骤1中获取到的疑似synchronized锁锁标记&gt;</code>方式去搜索持有疑似synchronized锁的线程需要排除调用Object.wait或者Thread.join（本质通过调用Object.wait实现）方法的情形[6]</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://dzone.com/articles/how-to-read-a-thread-dump">https://dzone.com/articles/how-to-read-a-thread-dump</a><br>[2]<a href="https://gist.github.com/rednaxelafx/843622">https://gist.github.com/rednaxelafx/843622</a><br>[3]<a href="https://www.perfma.com/docs/thread/thread-guide">https://www.perfma.com/docs/thread/thread-guide</a><br>[4]<a href="https://github.com/irockel/tda">https://github.com/irockel/tda</a><br>[5]<a href="https://dzone.com/articles/how-analyze-java-thread-dumps">https://dzone.com/articles/how-analyze-java-thread-dumps</a><br>[6]<a href="/blog/2020/07/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java并发编程基础">《Java并发编程基础》</a>中“6.6、调用Object.wait或者Thread.join方法挂起查看所打印jstack命令结果的一个注意点”小节</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>使用lscpu命令查看CPU信息</title>
    <url>/blog/2023/02/17/%E4%BD%BF%E7%94%A8lscpu%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8BCPU%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>关于CPU的基本概念、架构和核心参数可参见<a href="/blog/2019/06/03/CPU/" title="CPU">《CPU》</a>。</p>
<p>在<a href="/blog/2023/02/16/%E4%BD%BF%E7%94%A8-proc-cpuinfo%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8BCPU%E4%BF%A1%E6%81%AF/" title="使用&#x2F;proc&#x2F;cpuinfo文件查看CPU信息">《使用&#x2F;proc&#x2F;cpuinfo文件查看CPU信息》</a>中介绍了使用“&#x2F;proc&#x2F;cpuinfo”文件查看CPU信息，本文介绍使用<code>lscpu</code>命令查看CPU信息（可以与官网根据CPU具体型号查得的信息进行比对验证）。<br><code>lscpu</code>命令汇集了“&#x2F;proc&#x2F;cpuinfo文件”，“sysfs文件系统”等来源中的CPU相关信息，处理后以强可读性形式进行呈现。<br>本文介绍所基于的<code>lscpu</code>命令版本为“util-linux 2.34”。</p>
<h2 id="一、核心参数获取"><a href="#一、核心参数获取" class="headerlink" title="一、核心参数获取"></a><strong>一、核心参数获取</strong></h2><h3 id="1-1、CPU数量相关"><a href="#1-1、CPU数量相关" class="headerlink" title="1.1、CPU数量相关"></a><strong>1.1、CPU数量相关</strong></h3><ol>
<li>物理CPU数量：执行<code>lscpu</code>命令结果中的<code>Socket(s)</code>字段</li>
<li>物理CPU Core数量：执行<code>lscpu</code>命令结果中的<code>Core(s) per socket</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core所在物理CPU上的物理CPU Core数量，其他物理CPU上的物理CPU Core数量可能不同</font>）</li>
<li>逻辑CPU Core数量：执行<code>lscpu</code>命令结果中的<code>CPU(s)</code>字段</li>
</ol>
<h3 id="1-2、主频"><a href="#1-2、主频" class="headerlink" title="1.2、主频"></a><strong>1.2、主频</strong></h3><ol>
<li>工作实际主频：执行<code>lscpu</code>命令结果中的<code>CPU MHz</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core的工作实际主频</font>）</li>
</ol>
<h3 id="1-3、缓存大小"><a href="#1-3、缓存大小" class="headerlink" title="1.3、缓存大小"></a><strong>1.3、缓存大小</strong></h3><ol>
<li>L1d cache（用于存储指令的一级高速缓存）：执行<code>lscpu</code>命令结果中的<code>L1d cache</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core所在物理CPU Core的L1d cache</font>）</li>
<li>L1i cache（用于存储数据的一级高速缓存）：执行<code>lscpu</code>命令结果中的<code>L1i cache</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core所在物理CPU Core的L1i cache</font>）</li>
<li>L2 cache（二级高速缓存）：执行<code>lscpu</code>命令结果中的<code>L2 cache</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core所在物理CPU Core的L2 cache</font>）</li>
<li>L3 cache（三级高速缓存）：执行<code>lscpu</code>命令结果中的<code>L3 cache</code>字段（<font color='red'>准确来说，该值只是第一个逻辑CPU Core所在物理CPU的L3 cache</font>）</li>
</ol>
<h2 id="二、lscpu命令使用说明"><a href="#二、lscpu命令使用说明" class="headerlink" title="二、lscpu命令使用说明"></a><strong>二、<code>lscpu</code>命令使用说明</strong></h2><h3 id="2-1、执行lscpu命令"><a href="#2-1、执行lscpu命令" class="headerlink" title="2.1、执行lscpu命令"></a><strong>2.1、执行<code>lscpu</code>命令</strong></h3><h4 id="2-1-1、一个样例结果"><a href="#2-1-1、一个样例结果" class="headerlink" title="2.1.1、一个样例结果"></a><strong>2.1.1、一个样例结果</strong></h4><p>执行<code>lscpu</code>命令的一个样例结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    2</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 63</span><br><span class="line">Model name:            Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz</span><br><span class="line">Stepping:              2</span><br><span class="line">CPU MHz:               2600.092</span><br><span class="line">BogoMIPS:              5199.90</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              20480K</span><br><span class="line">NUMA node0 CPU(s):     0,2,4,6</span><br><span class="line">NUMA node1 CPU(s):     1,3,5,7</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36</span><br><span class="line">                       clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdt</span><br><span class="line">                       scp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonst</span><br><span class="line">                       op_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 s</span><br><span class="line">                       sse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt</span><br><span class="line">                       tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb invpcid_s</span><br><span class="line">                       ingle tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 av</span><br><span class="line">                       x2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida</span><br><span class="line">                       arat pln pts</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2、执行lscpu命令结果字段说明"><a href="#2-1-2、执行lscpu命令结果字段说明" class="headerlink" title="2.1.2、执行lscpu命令结果字段说明"></a><strong>2.1.2、执行<code>lscpu</code>命令结果字段说明</strong></h4><p>在执行<code>lscpu</code>命令的结果中，除了<code>CPU(s)</code>，<code>On-line CPU(s) list</code>，<code>Socket(s)</code>，<code>NUMA node(s)</code>，<code>NUMA node0 CPU(s)</code>，<code>NUMA node1 CPU(s)</code>字段表征整个CPU架构的统计值外，其他字段都表征第一个逻辑CPU Core的相关参数值。</p>
<p>接下来为方便叙述，以“CPU0”代指第一个逻辑CPU Core。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
<th>样例中的对应</th>
<th>参数层次说明</th>
</tr>
</thead>
<tbody><tr>
<td>Architecture</td>
<td>CPU0的CPU架构</td>
<td>x86_64</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>CPU op-mode(s)</td>
<td>CPU0的CPU运行模式</td>
<td>32-bit, 64-bit</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>Byte Order</td>
<td>CPU0的CPU字节序</td>
<td>Little Endian</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>CPU(s)</font></td>
<td>逻辑CPU Core数量</td>
<td>8</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>On-line CPU(s) list</td>
<td>在线（即生效的）逻辑CPU Core编号列表</td>
<td>0-7</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><font color='red'>Thread(s) per core</font></td>
<td>CPU0所在物理CPU Core允许同时执行的线程数，当值为P时，即P路SMT</td>
<td>2</td>
<td>继承自所在物理CPU Core</td>
</tr>
<tr>
<td><font color='red'>Core(s) per socket</font></td>
<td>CPU0所在物理CPU上的物理CPU Core数量</td>
<td>2</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>Socket(s)</font></td>
<td>座数，即物理CPU数量</td>
<td>2</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>NUMA node(s)</td>
<td>NUMA节点数量</td>
<td>2</td>
<td>&#x2F;</td>
</tr>
<tr>
<td><font color='red'>Vendor ID</font></td>
<td>CPU0的制造厂商ID</td>
<td>GenuineIntel（表示英特尔公司）</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>CPU family</td>
<td>CPU0的CPU系列，即“微处理器架构代号”</td>
<td>6</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>Model</td>
<td>CPU0的在具体CPU系列中的CPU具体型号，搜索时须转换成十六进制</td>
<td>63，即<code>0x3f</code></td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>Model Name</font></td>
<td>CPU0的型号名称，包括“品牌商标”，“具体产品编号”，“CPU额定主频”等信息</td>
<td>“Intel(R) Xeon(R)”：英特尔公司的至强品牌（英特尔品牌商标另外还有<code>Intel(R) Core(TM)-英特尔酷睿品牌</code>，<code>Intel(R) Pentium(TM)-英特尔奔腾品牌</code>，<code>Intel(R) Celeron(TM)-英特尔赛扬品牌</code>等）<br/>“E5-2650 v3”：具体产品编号<br/>“2.30GHz”：额定主频</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td>Stepping</td>
<td>CPU0的更新步进，表示版本小升级编号</td>
<td>2</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU</td>
</tr>
<tr>
<td><font color='red'>CPU MHz</font></td>
<td>CPU0的工作实际主频</td>
<td>2600.092</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>BogoMIPS</td>
<td>CPU0在系统内核启动时粗略测算的速度（Million Instructions Per Second）</td>
<td>5199.90</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>Virtualization</td>
<td>CPU0是否支持虚拟化</td>
<td>VT-x</td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
<tr>
<td>L1d cache</td>
<td>CPU0的L1d Cache大小</td>
<td>32K</td>
<td>继承自所在物理CPU Core</td>
</tr>
<tr>
<td>L1i cache</td>
<td>CPU0的L1i Cache大小</td>
<td>32K</td>
<td>继承自所在物理CPU Core</td>
</tr>
<tr>
<td>L2 cache</td>
<td>CPU0的L2 Cache</td>
<td>256K</td>
<td>继承自所在物理CPU Core</td>
</tr>
<tr>
<td>L3 cache</td>
<td>CPU0的L3 Cache大小</td>
<td>20480K</td>
<td>继承自所在物理CPU</td>
</tr>
<tr>
<td>NUMA node0 CPU(s)</td>
<td>NUMA node0节点管控的逻辑CPU Core列表</td>
<td>0,2,4,6</td>
<td></td>
</tr>
<tr>
<td>NUMA node1 CPU(s)</td>
<td>NUMA node1节点管控的逻辑CPU Core列表</td>
<td>1,3,5,7</td>
<td></td>
</tr>
<tr>
<td>Flags</td>
<td>CPU0支持的功能</td>
<td><code>fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36...</code></td>
<td>不确定继承自所在物理CPU Core还是所在物理CPU，一般继承自所在物理CPU Core</td>
</tr>
</tbody></table>
<h3 id="2-2、执行lscpu-e命令"><a href="#2-2、执行lscpu-e命令" class="headerlink" title="2.2、执行lscpu -e命令"></a><strong>2.2、执行<code>lscpu -e</code>命令</strong></h3><h4 id="2-2-1、一个样例结果"><a href="#2-2-1、一个样例结果" class="headerlink" title="2.2.1、一个样例结果"></a><strong>2.2.1、一个样例结果</strong></h4><p>执行<code>lscpu -e</code>命令的一个样例结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU NODE SOCKET CORE L1d:L1i:L2:L3 ONLINE</span><br><span class="line">0   0    0      0    0:0:0:0       yes</span><br><span class="line">1   1    1      1    1:1:1:1       yes</span><br><span class="line">2   0    0      2    2:2:2:0       yes</span><br><span class="line">3   1    1      3    3:3:3:1       yes</span><br><span class="line">4   0    0      0    0:0:0:0       yes</span><br><span class="line">5   1    1      1    1:1:1:1       yes</span><br><span class="line">6   0    0      2    2:2:2:0       yes</span><br><span class="line">7   1    1      3    3:3:3:1       yes</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2、执行lscpu-e命令结果字段说明"><a href="#2-2-2、执行lscpu-e命令结果字段说明" class="headerlink" title="2.2.2、执行lscpu -e命令结果字段说明"></a><strong>2.2.2、执行<code>lscpu -e</code>命令结果字段说明</strong></h4><table>
<thead>
<tr>
<th>列名称</th>
<th>列含义</th>
<th>样例中的对应</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>逻辑CPU Core编号</td>
<td>0-7</td>
</tr>
<tr>
<td>NODE</td>
<td>NUMA节点编号</td>
<td>0-1</td>
</tr>
<tr>
<td>SOCKET</td>
<td>物理CPU编号</td>
<td>0-1</td>
</tr>
<tr>
<td>CORE</td>
<td>物理CPU Core编号，须注意，编号规则跟“&#x2F;proc&#x2F;cpuinfo”中不一致，详见备注1</td>
<td>0-3</td>
</tr>
<tr>
<td>L1d:L1i:L2:L3</td>
<td><code>L1d，L1i，L2，L3 Cache</code>的所属情况说明：<br/>1)<code>L1d，L1i，L2</code>指明所属物理CPU Core<br/>2)<code>L3</code>指明所属物理CPU</td>
<td><code>3:3:3:1</code>：<br/>1)<code>L1d:L1i:L2</code>属于编号为3的物理CPU Core<br/>2)<code>L3</code>属于编号为1的物理CPU</td>
</tr>
<tr>
<td>ONLINE</td>
<td>表明逻辑CPU Core是否在线</td>
<td>yes</td>
</tr>
</tbody></table>
<br/>

<p><strong>[备注1]</strong> 对于物理CPU Core编号，<code>/proc/cpuinfo</code>和<code>lscpu -e</code>中两处编号规则不一致，以<code>两个物理CPU（CPU-A和CPU-B）：CPU-A内两个物理CPU Core（CPU-A-0和CPU-A-1）；CPU-B内两个物理CPU Core（CPU-B-0和CPU-B-1）</code>为例进行说明：1）在“&#x2F;proc&#x2F;cpuinfo”中，以单物理CPU为单元，在其内进行编号，故有一种编号方案<code>[CPU-A-0]:0;[CPU-A-1]:1;[CPU-B-0]:0;[CPU-B-1]:1</code>；2）在“lscpu -e”中，以所有物理CPU为单元，在其内进行编号，故有一种编号方案<code>[CPU-A-0]:0;[CPU-A-1]:1;[CPU-B-0]:2;[CPU-B-1]:3</code></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2019/06/03/CPU/" title="CPU">《CPU》</a><br>[2]<a href="https://www.tecmint.com/check-linux-cpu-information/">https://www.tecmint.com/check-linux-cpu-information/</a><br>[3]man lscpu<br>[4]<a href="https://blog.csdn.net/weixin_39974409/article/details/110893710">https://blog.csdn.net/weixin_39974409/article/details/110893710</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>侵袭性纤维瘤</title>
    <url>/blog/2019/05/07/%E4%BE%B5%E8%A2%AD%E6%80%A7%E7%BA%A4%E7%BB%B4%E7%98%A4/</url>
    <content><![CDATA[<h2 id="一、肿瘤分类"><a href="#一、肿瘤分类" class="headerlink" title="一、肿瘤分类"></a><strong>一、肿瘤分类</strong></h2><p>肿瘤的分类和命名非常复杂，下面是一个简化的分类方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">肿瘤=良性肿瘤+恶性肿瘤+交界性肿瘤</span><br><span class="line">恶性肿瘤=癌+肉瘤</span><br><span class="line">恶性肿瘤=癌症</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong></p>
<ul>
<li>交界性肿瘤：组织形态和生物学行为介于“良性肿瘤”和“恶性肿瘤”之间</li>
</ul>
<h3 id="1-1、恶性肿瘤特点"><a href="#1-1、恶性肿瘤特点" class="headerlink" title="1.1、恶性肿瘤特点"></a><strong>1.1、恶性肿瘤特点</strong></h3><ul>
<li>生长失去控制</li>
<li>容易复发</li>
<li>局部浸润。<font color='red'>恶性肿瘤的最基本特征之一</font>，指侵蚀和破坏临近的与当前组织器官不同的组织器官。比如“如果乳腺癌细胞只在乳房中生长，那就没有发生局部浸润，如果侵蚀乳腺的皮肤，肋骨组织，胸壁组织等，那就发生了局部浸润”，“如果直肠癌细胞只在直肠中生长，那就没有发生局部浸润，如果侵蚀前列腺，膀胱组织等，那就发生了局部浸润”</li>
<li>远处转移。<font color='red'>恶性肿瘤的最基本特征之一</font>，指远处转移到全身其他组织器官，与“局部浸润”相比，“局部浸润”强调“局部”，“远处转移”强调“远处”，远处转移有3种途径：1）血行转移；2）淋巴结转移；3）种植转移。“是否远处转移”是区分“恶性肿瘤”和“良性肿瘤”最为核心的特征</li>
<li>主要危害在于会破坏组织器官。比如会造成“出血”，“坏死”，“溃疡”等</li>
</ul>
<h3 id="1-2、良性肿瘤特点"><a href="#1-2、良性肿瘤特点" class="headerlink" title="1.2、良性肿瘤特点"></a><strong>1.2、良性肿瘤特点</strong></h3><ul>
<li>生长速度缓慢</li>
<li>不易复发</li>
<li>不会<code>局部浸润</code></li>
<li>不会<code>远处转移</code></li>
<li>主要危害在于会压迫和阻塞组织器官，但不会破坏组织器官。比如“长在肠子里的良性肿瘤可导致肠梗阻”，“长在大脑里的良性肿瘤会压迫神经导致严重的后果”</li>
<li><font color='red'>少数的良性肿瘤在一定条件下，可能会恶变为恶性肿瘤，因此，对于良性肿瘤还是不能掉以轻心</font></li>
</ul>
<h2 id="二、侵袭性纤维瘤"><a href="#二、侵袭性纤维瘤" class="headerlink" title="二、侵袭性纤维瘤"></a><strong>二、侵袭性纤维瘤</strong></h2><p>侵袭性纤维瘤（aggressive fibromatosis，AF），或称“硬纤维瘤（desmoid tumor，DT）”，或称“韧带样型纤维瘤（desmoid type fibromatosis，DTFT）”，或称“肌腱膜纤维瘤（musculoaponeurotic fibromatosis，MF）”，是成纤维细胞克隆性增生性病变，位于深部软组织，较少见，极难根治，具有<code>浸润性生长、局部易复发（即意味着生长快）、无远处转移、罕见恶变（国内仅有1例恶变为纤维肉瘤的报道，该例恶变考虑可能与反复手术刺激、放射治疗有关）</code>的特点，根据上述特点可知属于“交界性肿瘤”，轻度恶性。</p>
<p>据统计，每年在百万人口中可发生3-5个新病例，侵袭性纤维瘤5年内复发率高达50%左右，而且在术后2年内最容易出现复发，复发最迟可到术后12年，因此，有学者建议病人术后前3年内应该每3月复查，之后两年每半年复查，再之后一年复查一次。</p>
<h2 id="三、几个问题"><a href="#三、几个问题" class="headerlink" title="三、几个问题"></a><strong>三、几个问题</strong></h2><ul>
<li>不会远处转移？</li>
<li>对于恶变概率，是小概率事件吗？</li>
<li>因为不会远处转移下次检查只需在原部位做个B超？</li>
<li>阴性切缘？</li>
<li>各类活检（包括穿刺活检）均有促使恶性肿瘤扩散的潜在可能性，需要在术前短期内或术中施行活检？</li>
</ul>
<h2 id="四、侵袭性纤维瘤的最新进展"><a href="#四、侵袭性纤维瘤的最新进展" class="headerlink" title="四、侵袭性纤维瘤的最新进展"></a><strong>四、侵袭性纤维瘤的最新进展</strong></h2><ul>
<li>全国侵袭性纤维瘤诊疗研究中心在河北燕达医院成立<sup>[4]</sup></li>
<li>一种新的手术治疗方式——海扶聚焦超声手术治疗，该治疗方式的最大特色是“无创”</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.zhihu.com/question/30985501">https://www.zhihu.com/question/30985501</a><br>[2]<a href="http://lxjk.people.cn/n1/2018/0301/c404177-29841601.html">http://lxjk.people.cn/n1/2018/0301/c404177-29841601.html</a><br>[3]<a href="http://oncol.dxy.cn/article/520768">http://oncol.dxy.cn/article/520768</a><br>[4]<a href="http://health.people.com.cn/n1/2019/0121/c14739-30582129.html?spm=smpc.content.content.1.1548460800023WRl5Apr">http://health.people.com.cn/n1/2019/0121/c14739-30582129.html?spm=smpc.content.content.1.1548460800023WRl5Apr</a><br>[5]<a href="http://www.zpwz.net/CN/Y2008/V17/I10/28">http://www.zpwz.net/CN/Y2008/V17/I10/28</a><br>[6]<a href="https://zhuanlan.zhihu.com/p/63683715">https://zhuanlan.zhihu.com/p/63683715</a><br>[7]<a href="https://www.haodf.com/zhuanjiaguandian/lishudoctor_6075400959.htm">https://www.haodf.com/zhuanjiaguandian/lishudoctor_6075400959.htm</a><br>[8]<a href="https://www.haodf.com/zhuanjiaguandian/jitao_5884727167.htm">https://www.haodf.com/zhuanjiaguandian/jitao_5884727167.htm</a><br>[9]<a href="https://www.zhihu.com/question/21244077">https://www.zhihu.com/question/21244077</a><br>[10]<a href="https://zhuanlan.zhihu.com/p/50243932">https://zhuanlan.zhihu.com/p/50243932</a><br>[11]<a href="https://baike.baidu.com/item/%E9%9F%A7%E5%B8%A6%E6%A0%B7%E5%9E%8B%E7%BA%A4%E7%BB%B4%E7%98%A4%E7%97%85">https://baike.baidu.com/item/%E9%9F%A7%E5%B8%A6%E6%A0%B7%E5%9E%8B%E7%BA%A4%E7%BB%B4%E7%98%A4%E7%97%85</a><br>[12]《侵袭性纤维瘤病的非手术治疗》罗恒，张石川</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>停止解析Linux命令选项</title>
    <url>/blog/2018/09/29/%E5%81%9C%E6%AD%A2%E8%A7%A3%E6%9E%90Linux%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>在解析Linux命令时，默认将以“-”开头的内容解析为“Linux命令选项”，通过“–”（连续两个横杠）可告知解析器停止解析Linux命令选项，从而使得以“-”开头的内容可作为Linux命令参数合法存在。<br>比如有个案例：目录A下有文件“-hello”，此时在A下如果执行<code>ls -hello</code>命令，命令失败，提示信息如下；如果执行<code>ls -- -hello</code>命令，成功执行获得预期结果。<br>命令失败提示信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls：无效选项 -- e</span><br><span class="line">Try &#x27;ls --help&#x27; for more information.</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://liam0205.me/2016/11/11/ways-to-parse-arguments-in-shell-script/
[2]https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean-also-known-as-bare-double-dash
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>光</title>
    <url>/blog/2023/01/30/%E5%85%89/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p>光：</p>
<ul>
<li>本质是电磁波</li>
<li>常见光是复合光，复合光由不同波长（频率）的光组合而成。复合光的光谱就是依照所有构成光的波长（或频率）的大小顺次排列形成的图案。两个复合光完全一致当且仅当两者的光谱完全一致</li>
</ul>
<h3 id="1-1、可见光与不可见光"><a href="#1-1、可见光与不可见光" class="headerlink" title="1.1、可见光与不可见光"></a><strong>1.1、可见光与不可见光</strong></h3><p>视见率：表征人眼对不同频率光的反应灵敏度，取人眼对波长为555nm的黄绿光的视见率为最大，取为1；其他波长的可见光的视见率均小于1；红外光和紫外光的视见率为0。</p>
<p>可见光即视见率大于0的光，不可见光即视见率等于0的光。</p>
<h3 id="1-2、光危害"><a href="#1-2、光危害" class="headerlink" title="1.2、光危害"></a><strong>1.2、光危害</strong></h3><p>有些波长的光会对人体造成伤害，以下列出常见的光危害。</p>
<table>
<thead>
<tr>
<th>光</th>
<th>危害</th>
</tr>
</thead>
<tbody><tr>
<td>蓝光（并不是所有蓝光都对人体有危害，400-460nm的高能短波蓝光才是影响人体健康的主要波段，其中415-460nm波段的蓝光引起了80%的损伤）</td>
<td>蓝光的主要危害是对视网膜造成光化学损害，加速黄斑区细胞的氧化损伤。同时，蓝光还可引起视疲劳、泪膜稳定性下降等</td>
</tr>
<tr>
<td>紫外线</td>
<td>可导致灼伤、皮质性白内障等伤害，引发皮肤恶性黑素瘤、皮肤鳞状细胞癌、皮肤基底细胞癌等疾病</td>
</tr>
<tr>
<td>红外线</td>
<td>红外线可引起白内障、角膜损伤和日光性视网膜脉络膜烧伤等</td>
</tr>
</tbody></table>
<h3 id="1-3、色温"><a href="#1-3、色温" class="headerlink" title="1.3、色温"></a><strong>1.3、色温</strong></h3><p>色温：与此光源发出相似的光的黑体辐射体所具有的开尔文温度（符合为K），用来量化表征光的颜色，比如“4000K对应自然白”。但是需要注意的是具有相同色温的两个复合光可能具有不同的光谱（因此色温相同的两个光其他属性不同十分正常），比如“色温相同的两个光A和B，A相较B含有更多的蓝光成分”。</p>
<p>在不同场景中，人眼的适宜色温不同[1]。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>人眼的适宜色温（K）</th>
</tr>
</thead>
<tbody><tr>
<td>家庭，住宅，宿舍，宾馆</td>
<td>3300以下</td>
</tr>
<tr>
<td>商店，医院，办公室，饭店，餐厅，候车室</td>
<td>3300-5300</td>
</tr>
<tr>
<td>办公室，会议室，教室，绘图室，设计室，图书馆的阅览室，展览橱窗</td>
<td>5300以上</td>
</tr>
</tbody></table>
<h3 id="1-4、显色指数"><a href="#1-4、显色指数" class="headerlink" title="1.4、显色指数"></a><strong>1.4、显色指数</strong></h3><p>显色指数（Ra）：表征光源对物体的显色能力，其数值越大（最大值为100），显色性越好。<br>但是需要注意的是具有相同显色指数的两个复合光可能具有不同的光谱（因此显色指数相同的两个光其他属性不同十分正常），比如“显色指数相同的两个光A和B，A的色温高于B”。</p>
<p>在不同场景中，人眼的需求显色指数不同[2]。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>人眼的需求显色指数</th>
</tr>
</thead>
<tbody><tr>
<td>需要色彩精确对比的场所</td>
<td>90-100</td>
</tr>
<tr>
<td>需要色彩正确判断的场所</td>
<td>80-89</td>
</tr>
<tr>
<td>需要中等显色性的场所</td>
<td>60-79</td>
</tr>
<tr>
<td>对显色性的要求较低，色差较小的场所</td>
<td>40-59</td>
</tr>
<tr>
<td>对显色性无具体要求的场所</td>
<td>20-39</td>
</tr>
</tbody></table>
<p><strong>[备注]</strong> 为保护眼睛，工作学习照明显色指数须至少大于80。</p>
<h2 id="二、光通量、光强、照度和亮度"><a href="#二、光通量、光强、照度和亮度" class="headerlink" title="二、光通量、光强、照度和亮度"></a><strong>二、光通量、光强、照度和亮度</strong></h2><h3 id="2-1、概念厘清"><a href="#2-1、概念厘清" class="headerlink" title="2.1、概念厘清"></a><strong>2.1、概念厘清</strong></h3><p>关于“光通量”，“光强”，“照度”和“亮度”这4个概念的权威完整介绍可参见大学教材《工程光学》中的“光度学”章节内容。</p>
<h4 id="2-1-1、光通量"><a href="#2-1-1、光通量" class="headerlink" title="2.1.1、光通量"></a><strong>2.1.1、光通量</strong></h4><p>光源单位时间发出的通过周围球面的人眼可感知光总能量，即<code>∑ 某一波长光的光能量 * 该波长光的相对视见率（见备注）</code>：</p>
<ul>
<li>光的发射是立体的，故光通量的定义基于周围球面 </li>
<li>光通量跟“光源与周围球面的距离”无关，离光源1m的周围球面与离相同光源10m的周围球面通过光通量相等</li>
<li>人眼可感知光总能量联接了“光能量”和“人眼对光的感受能力”</li>
</ul>
<p>光通量的单位为<code>流明（lm）</code>。</p>
<p><strong>[备注]</strong> 相对视见率：视见率的定义见“1.1、可见光与不可见光”小节，而相对视见率是指某波长光的视见率与555nm黄绿光的视见率的比值。由于后者的值为1，故在数值上，相对视见率与视见率相等。</p>
<h4 id="2-1-2、光强"><a href="#2-1-2、光强" class="headerlink" title="2.1.2、光强"></a><strong>2.1.2、光强</strong></h4><p>点光源在给定方向上，单位立体角内发出的光通量，用来描述在给定方向上人眼可感知光能量的强弱。比如“有两个点光源A和B，A和B的光通量一致，A在各个方向上的光强均匀一致（以a指代），B在有些方向上的光强大于a，有些方向上的光强小于a”，“有一个白炽灯灯泡光源A，假定在均匀照射时各个方向的光强都为a，此时在A上装一个不透光、开口向下的伞形灯罩，这会使得各个方向的光线都被灯罩向下反射，向下方向的单位立体角内光通量的空间密度增大，故向下方向的光强会大于a”。</p>
<p>光强单位为<code>坎德拉（cd）</code>，根据定义有<code>1 cd = 1 lm / 1 sr</code>，其中<code>sr</code>是单位立体角的单位符号。</p>
<p><strong>[备注]</strong></p>
<ul>
<li>平面角：以两射线交点为圆心的圆被射线所截的弧长与半径之比，即<code>弧长 / r</code></li>
<li>立体角[3]：一个物体对特定点的三维空间的角度，是平面角在三维空间中的类比。具体是：以观测点为球心，构造一个以“观测点与物体距离”为半径r的球面，任意物体投影到该球面上的投影面积A，即为该物体相对于该观测点的立体角，有计算公式<code>Ω = A / r*r</code></li>
</ul>
<h4 id="2-1-3、照度"><a href="#2-1-3、照度" class="headerlink" title="2.1.3、照度"></a><strong>2.1.3、照度</strong></h4><p>光源照射到单位面积上的光通量，描述的是拟观察物体（比如“书本”）单位面积上真正接收的光通量。</p>
<p>照度跟“拟观察物体与光源的距离”相关——拟观察物体距离光源越远照度越低：距离越远，光通量空间密度越小，单位面积上的光通量自然越小。</p>
<p>照度单位为<code>勒克斯（lx）</code>，有计算公式：<code>1 lx = 1 lm / 1 m*m</code>。</p>
<p>在不同场景中，人眼的适宜照度不同。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>人眼的适宜照度（lx）</th>
</tr>
</thead>
<tbody><tr>
<td>书房、办公室</td>
<td>500-1000</td>
</tr>
<tr>
<td>餐桌</td>
<td>300-500</td>
</tr>
<tr>
<td>浴室、更衣室</td>
<td>200-500</td>
</tr>
<tr>
<td>客厅（不阅读书报）</td>
<td>150-300</td>
</tr>
<tr>
<td>电梯、走道</td>
<td>100-200</td>
</tr>
<tr>
<td>走廊、楼梯</td>
<td>35-75</td>
</tr>
<tr>
<td>车库、仓储</td>
<td>30-75</td>
</tr>
</tbody></table>
<p><strong>[备注]</strong> 根据GB&#x2F;T 9473-2017《读写作业台灯性能要求》，合格的读写作业台灯照度有两个等级：1）国A：要求离圆心半径距离在50cm的三分之一扇形区域内照度为250lx以上；2）国AA：要求离圆心半径距离在50cm的三分之一扇形区域内照度为500lx以上。显而易见，国AA等级高于国A。</p>
<h4 id="2-1-4、亮度"><a href="#2-1-4、亮度" class="headerlink" title="2.1.4、亮度"></a><strong>2.1.4、亮度</strong></h4><p>描述拟观察物体反射后的光强，跟拟观察物体表面性质相关。</p>
<p>亮度单位为<code>尼特（nit）</code>，有计算公式<code>1 nit = 1 cd / 1 m*m</code>。</p>
<p><strong>[备注]</strong> 本处对于亮度的理解较为浅层次，待做深层次理解，比如“为何显示屏将亮度作为一个衡量指标”。</p>
<h3 id="2-2、扩展"><a href="#2-2、扩展" class="headerlink" title="2.2、扩展"></a><strong>2.2、扩展</strong></h3><h4 id="2-2-1、总结与类比"><a href="#2-2-1、总结与类比" class="headerlink" title="2.2.1、总结与类比"></a><strong>2.2.1、总结与类比</strong></h4><p><strong>1、总结</strong><br>“光通量”和“光强”涉及“光源能量”和“人眼对光的感受能力”；“照度”和“亮度”涉及“光源能量”，“人眼对光的感受能力”和“拟观察物体”。</p>
<p><strong>2、类比</strong><br>类比水龙头出水，具体如下表。</p>
<table>
<thead>
<tr>
<th>光学度量</th>
<th>概念类比</th>
</tr>
</thead>
<tbody><tr>
<td>光通量</td>
<td>水龙头单位时间内总出水量</td>
</tr>
<tr>
<td>光强</td>
<td>水龙头单位时间内单位角向出水量</td>
</tr>
<tr>
<td>照度</td>
<td>接水盆单位面积接水量</td>
</tr>
<tr>
<td>亮度</td>
<td>接水盆反弹水，单位时间内单位面积反弹水量</td>
</tr>
</tbody></table>
<h4 id="2-2-2、生活中的光学度量"><a href="#2-2-2、生活中的光学度量" class="headerlink" title="2.2.2、生活中的光学度量"></a><strong>2.2.2、生活中的光学度量</strong></h4><p>生活中的光学度量：</p>
<ul>
<li>投影仪，选择“光通量”作为衡量指标之一</li>
<li>投影仪幕布，使用投影仪幕布能让你获得相比墙面更好的“亮度”</li>
<li>读写作业台灯，选择“照度”作为衡量指标之一</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E6%B8%A9">https://zh.wikipedia.org/wiki/%E8%89%B2%E6%B8%A9</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/56286569">https://zhuanlan.zhihu.com/p/56286569</a><br>[3]<a href="https://zhajiman.github.io/post/solid_angle">https://zhajiman.github.io/post/solid_angle</a><br>[4]<a href="https://zhuanlan.zhihu.com/p/153355588">https://zhuanlan.zhihu.com/p/153355588</a><br>[5]<a href="https://www.zhihu.com/question/263533167">https://www.zhihu.com/question/263533167</a><br>[6]<a href="https://zhuanlan.zhihu.com/p/539740506">https://zhuanlan.zhihu.com/p/539740506</a></p>
]]></content>
      <categories>
        <category>物理</category>
      </categories>
  </entry>
  <entry>
    <title>六死八活七半</title>
    <url>/blog/2023/12/15/%E5%85%AD%E6%AD%BB%E5%85%AB%E6%B4%BB%E4%B8%83%E5%8D%8A/</url>
    <content><![CDATA[<p>棋形，是棋子在棋盘上组合成的各种形状。<br>本文介绍3种基础死活棋形——“六死八活七半”。</p>
<br/>

<p>在介绍之前先作两点说明：</p>
<ol>
<li>双方都按照最强落子原则进行探讨，否则毫无实际意义</li>
<li>本文案例讨论中以黑棋为守方，白棋为攻方。故：<ul>
<li>黑子的目标是：尽量能做活</li>
<li>白子的目标是：尽量能阻止黑棋做活</li>
</ul>
</li>
</ol>
<h2 id="一、死活棋形"><a href="#一、死活棋形" class="headerlink" title="一、死活棋形"></a><strong>一、死活棋形</strong></h2><h3 id="1-1、死形之“六死”"><a href="#1-1、死形之“六死”" class="headerlink" title="1.1、死形之“六死”"></a><strong>1.1、死形之“六死”</strong></h3><p>守方必不能做活，故“攻守双方都无需落子”。</p>
<img src=https://blog.dslztx.top/imgs/20231215-0-1.svg width=30% height=30% />

<p>具体分析过程（轴对称，基于A、B和C点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必不能做活。</p>
<ol>
<li><del>黑A -&gt; 白F：黑做活失败</del></li>
<li><del>黑B -&gt; 白F：黑做活失败</del></li>
<li><del>黑C -&gt; 白F：黑做活失败</del></li>
<li><del>[与1对称]黑F -&gt; 白A：黑做活失败</del></li>
<li><del>[与2对称]黑E -&gt; 白A：黑做活失败</del></li>
<li><del>[与3对称]黑D -&gt; 白A：黑做活失败</del></li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活：无需先落子，黑落子后必能按照“1、黑先”小节阻止黑做活。</p>
<h3 id="1-2、活形之“八活”"><a href="#1-2、活形之“八活”" class="headerlink" title="1.2、活形之“八活”"></a><strong>1.2、活形之“八活”</strong></h3><p>守方必能做活，故“攻守双方都无需落子”。</p>
<img src=https://blog.dslztx.top/imgs/20231215-0-2.svg width=30% height=30% />

<p>具体分析过程（轴对称，基于A、B、C和D点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li>黑A -&gt; 白H：黑做活成功</li>
<li>黑B -&gt; 白H：黑做活成功</li>
<li>黑C -&gt; 白H：黑做活成功</li>
<li>黑D -&gt; 白H：黑做活成功</li>
<li>[与1对称]黑H -&gt; 白A：黑做活成功</li>
<li>[与2对称]黑G -&gt; 白A：黑做活成功</li>
<li>[与3对称]黑F -&gt; 白A：黑做活成功</li>
<li>[与4对称]黑E -&gt; 白A：黑做活成功</li>
</ol>
<p><strong>2、白先</strong><br>黑必能做活（没有一种下法能够成功阻止做活）：</p>
<ol>
<li><del>白A -&gt; 黑B：阻止黑做活失败</del></li>
<li><del>白B -&gt; 黑C：阻止黑做活失败</del></li>
<li><del>白C -&gt; 黑D：阻止黑做活失败</del></li>
<li><del>白D -&gt; 黑E：阻止黑做活失败</del></li>
<li><del>[与1对称]白H -&gt; 黑G：阻止黑做活失败</del></li>
<li><del>[与2对称]白G -&gt; 黑F：阻止黑做活失败</del></li>
<li><del>[与3对称]白F -&gt; 黑E：阻止黑做活失败</del></li>
<li><del>[与4对称]白E -&gt; 黑D：阻止黑做活失败</del></li>
</ol>
<h3 id="1-3、半死不活形之“七半”"><a href="#1-3、半死不活形之“七半”" class="headerlink" title="1.3、半死不活形之“七半”"></a><strong>1.3、半死不活形之“七半”</strong></h3><p>守方先落子，存在一种下法能成功做活；攻方先落子，存在一种下法能够成功阻止做活。</p>
<img src=https://blog.dslztx.top/imgs/20231215-0-3.svg width=30% height=30% />

<p>结论：攻方先，抢到A和G点，成功阻止做活；守方先，抢到A、D和G点，成功做活。为了减少记忆成本，把关键点统一记为A和G。</p>
<p>具体分析过程（轴对称，基于A、B、C和D点进行探讨，其他属于对称情形）分为“黑先”和“白先”两种情形。</p>
<p><strong>1、黑先</strong><br>黑必能做活（存在一种做活下法即可）：</p>
<ol>
<li>黑A -&gt; 白G -&gt; 黑F：黑做活成功</li>
<li><del>黑B -&gt; 白G：黑做活失败</del></li>
<li><del>黑C -&gt; 白A：黑做活失败</del></li>
<li>黑D -&gt; 黑后续只要一边做一只真眼：黑做活成功</li>
<li>[与1对称]黑G -&gt; 白A -&gt; 黑B：黑做活成功</li>
<li><del>[与2对称]黑F -&gt; 白A：黑做活失败</del></li>
<li><del>[与3对称]黑E -&gt; 白G：黑做活失败</del></li>
</ol>
<p><strong>2、白先</strong><br>黑必不能做活（存在一种能够成功阻止做活下法即可）：</p>
<ol>
<li>白A -&gt; 黑G：阻止黑做活成功</li>
<li><del>白B -&gt; 黑A：阻止黑做活失败</del></li>
<li><del>白C -&gt; 黑D：阻止黑做活失败</del></li>
<li><del>白D：阻止黑做活失败</del></li>
<li>[与1对称]白G -&gt; 黑A：阻止黑做活成功</li>
<li><del>[与2对称]白F -&gt; 黑G：阻止黑做活失败</del></li>
<li><del>[与3对称]白E -&gt; 黑D：阻止黑做活失败</del></li>
</ol>
<h2 id="二、死活棋形之劫材"><a href="#二、死活棋形之劫材" class="headerlink" title="二、死活棋形之劫材"></a><strong>二、死活棋形之劫材</strong></h2><p>劫材再回顾下是“彼之弱点，我之劫材”。</p>
<h3 id="2-1、死形"><a href="#2-1、死形" class="headerlink" title="2.1、死形"></a><strong>2.1、死形</strong></h3><p>死形的劫材如果存在必属于守方：<code>守方落子 -&gt; 攻方必须应劫，否则守方做活成功</code>。</p>
<img src=https://blog.dslztx.top/imgs/20231215-0-1.svg width=30% height=30% />

<p>结论：A、C、D和F四个点都是守方的劫材。</p>
<p>具体分析过程：</p>
<ol>
<li>黑A -&gt; 白必须应劫落子F，否则黑做活成功</li>
<li><del>黑B -&gt; 白无须立即落子应对：不是黑的劫材</del></li>
<li>黑C -&gt; 白必须应劫落子A，否则黑做活成功</li>
<li>[与1对称]黑F -&gt; 白必须应劫落子A，否则黑做活成功</li>
<li><del>[与2对称]黑E -&gt; 白无须立即落子应对：不是黑的劫材</del></li>
<li>[与3对称]黑D -&gt; 白必须应劫落子F，否则黑做活成功</li>
</ol>
<h3 id="2-2、活形"><a href="#2-2、活形" class="headerlink" title="2.2、活形"></a><strong>2.2、活形</strong></h3><p>活形的劫材如果存在必属于攻方：<code>攻方落子 -&gt; 守方必须应劫，否则攻方阻止做活成功</code>。</p>
<img src=https://blog.dslztx.top/imgs/20231215-0-2.svg width=30% height=30% />

<p>结论：A和H两个点是攻方的劫材。</p>
<p>具体分析：</p>
<ol>
<li>白A -&gt; 黑必须立即落子应对，否则白继续落子H，黑做活失败：是白的劫材</li>
<li><del>白B -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>白C -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>白D -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li>[与1对称]白H -&gt; 黑必须立即落子应对，否则白继续落子A，黑做活失败：是白的劫材</li>
<li><del>[与2对称]白G -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与3对称]白F -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
<li><del>[与4对称]白E -&gt; 黑无须立即落子应对：不是白的劫材</del></li>
</ol>
<h3 id="2-3、半死不活形"><a href="#2-3、半死不活形" class="headerlink" title="2.3、半死不活形"></a><strong>2.3、半死不活形</strong></h3><p>按照劫材定义——“逼迫对方应对”，半死不活形没有劫材，因为：</p>
<ol>
<li>守方先<ul>
<li>如果抢占做活关键点成功做活，无法逼迫对方应对</li>
<li>如果不下做活关键点只能引诱（而不是逼迫）攻方抢占关键点阻止做活</li>
</ul>
</li>
<li>攻方先<ul>
<li>如果抢占做活关键点成功阻止做活，无法逼迫对方应对</li>
<li>如果不下做活关键点引诱（而不是逼迫）守方抢占关键点成功做活</li>
</ul>
</li>
</ol>
<p>但是也可将劫材定义广义化，将以上引诱作为劫材情形。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h2><table>
<thead>
<tr>
<th>棋形</th>
<th>死活类型</th>
<th>守方</th>
<th>攻方</th>
<th>劫材</th>
</tr>
</thead>
<tbody><tr>
<td>六死</td>
<td>死形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>A、C、D和F属于守方的劫材点</td>
</tr>
<tr>
<td>八活</td>
<td>活形</td>
<td>无需主动落子</td>
<td>无需主动落子</td>
<td>A和H两个点都是攻方的劫材点</td>
</tr>
<tr>
<td>七半</td>
<td>半死不活形</td>
<td>立即做活，关键点是边界两点</td>
<td>立即阻止做活，关键点是边界两点</td>
<td>边界两点是广义的劫材点</td>
</tr>
</tbody></table>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://mp.weixin.qq.com/s/zgcWunj_J9Tbttp0PJYYQQ">https://mp.weixin.qq.com/s/zgcWunj_J9Tbttp0PJYYQQ</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>六色</title>
    <url>/blog/2010/08/15/%E5%85%AD%E8%89%B2/</url>
    <content><![CDATA[<p>喜欢浅浅的绿，一种内敛沉稳的气质！<br>他不似浓绿那般张狂与跋扈，时时透着一股逼人之势！<br>他只是汲取天地的精气，张驰着自己的生命！清新透凉，无限的生机浅藏于恬淡之中！</p>
<hr>
<p>对紫情有独钟！<br>那是怎样的一种令人心驰的意境，辽远安宁，深邃无极！<br>远处飘着一缕袅袅青烟，近处摆列着古色古香的茶具，透射庄严力量的紫砂壶，彰显哲理和智慧的紫茶杯，安静地管窥凡世，心中却蕴涵整个宇宙！<br>凡尘俗世的一切繁芜纷争注定只能是他的奴隶，永远不敢走进主人的府邸！玷污这样一种仙境是何等的一种罪过！</p>
<hr>
<p>黄也不俗啊！<br>照亮阴暗的角落，挥洒光明的元素！<br>你热情洋溢，和着生命的节奏，蹒跚起舞！<br>你曾经是尊贵与平凡的界碑！凡夫俗子拥有了你却要被冠以僭越之名！今天你终于走出了封建的牢笼！更多的人享受到你带来的温馨和喜气！</p>
<hr>
<p>蓝，时间与空间的见证！<br>一切的跨度却不能翻跃你的掌心！<br>天拥有你，成其广袤；海拥有你，成其无垠！<br>你是如此的宽广，一切罪恶和丑陋，在你这里瞬间化于无形！<br>喜悦邂逅了你，才能重拾理智，归于淡定！<br>痛苦遇见了你，扫除烦闷和忧虑，再现生活的阳光！</p>
<hr>
<p>橙，你褪去黄的浓妆艳抹，归于清新和淡定！<br>既有激情与向往，也不失理性和智慧！<br>既有一种令人兴奋的钝感力，也不乏使人淡宁如水的张弛力！</p>
<hr>
<p>黑，你深观人生百态，见识种种丑恶，孕育着一种具有内涵和张力的精神！<br>你代表着严肃与庄重，生命有了你，才显得井井有条！<br>你代表着安静与思考，伟人的智慧在你的心中碰撞出灵感的火花！</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>诗</category>
      </categories>
  </entry>
  <entry>
    <title>内存屏障</title>
    <url>/blog/2020/02/13/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    <content><![CDATA[<p>内存屏障，英文名为“memory barrier”，又可被称为“内存栅栏”，“内存栅障”等，用来指代内存同步原语。</p>
<h2 id="一、内存屏障的作用"><a href="#一、内存屏障的作用" class="headerlink" title="一、内存屏障的作用"></a><strong>一、内存屏障的作用</strong></h2><p>内存屏障的作用：</p>
<ul>
<li>禁止重排序</li>
<li>刷新缓存到主存</li>
<li>使缓存失效</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>内存屏障可具有上述作用，但不一定需要具备上述所有作用</li>
</ul>
<h2 id="二、内存屏障的存在形式"><a href="#二、内存屏障的存在形式" class="headerlink" title="二、内存屏障的存在形式"></a><strong>二、内存屏障的存在形式</strong></h2><p><font color='red'>本节内容属于笔者自我理解，如有错误，敬请指正。</font></p>
<p>内存屏障的存在形式分为“独立型”和“绑定型”两种：</p>
<ul>
<li>独立型。“内存屏障指令”独立于“业务指令”存在，比如“在X86指令集中的<code>lfence</code>指令”</li>
<li>绑定型。“内存屏障指令”与“业务指令”绑定在一起，比如“在X86指令集中，给一条业务汇编指令加上<code>LOCK汇编指令前缀</code>，则其既为汇编指令，也为内存屏障指令”</li>
</ul>
<p>对于“独立型内存屏障指令”，与“业务指令”之间可能被插入其他指令；而对于“绑定型内存屏障指令”，与“其绑定的业务指令”之间不允许被插入其他指令。</p>
<h2 id="三、不同指令-语言层级的内存屏障"><a href="#三、不同指令-语言层级的内存屏障" class="headerlink" title="三、不同指令&#x2F;语言层级的内存屏障"></a><strong>三、不同指令&#x2F;语言层级的内存屏障</strong></h2><p>对应于指令&#x2F;语言层级，内存屏障一般分为3类：机器指令集中的内存屏障，汇编指令集中的内存屏障，程序语言中的内存屏障。</p>
<h3 id="3-1、机器指令集中的内存屏障"><a href="#3-1、机器指令集中的内存屏障" class="headerlink" title="3.1、机器指令集中的内存屏障"></a><strong>3.1、机器指令集中的内存屏障</strong></h3><p>不同的机器指令集具有不同的“内存屏障机器指令”。</p>
<h3 id="3-2、汇编指令集中的内存屏障"><a href="#3-2、汇编指令集中的内存屏障" class="headerlink" title="3.2、汇编指令集中的内存屏障"></a><strong>3.2、汇编指令集中的内存屏障</strong></h3><p>不同的汇编指令集具有不同的“内存屏障汇编指令”。<br>比如在X86指令集中，内存屏障汇编指令有：</p>
<ul>
<li>lfence，sfence，mfence</li>
<li>给汇编指令加上<code>LOCK汇编指令前缀</code>便使得具有内存屏障效果</li>
<li>…</li>
</ul>
<h3 id="3-3、程序语言中的内存屏障"><a href="#3-3、程序语言中的内存屏障" class="headerlink" title="3.3、程序语言中的内存屏障"></a><strong>3.3、程序语言中的内存屏障</strong></h3><p>不同的程序语言具有不同的“内存屏障语言指令”，“内存屏障语言指令”是一个<code>逻辑虚概念</code>，不像“内存屏障机器指令”和“内存屏障汇编指令”是<code>客观实概念</code>。编译器编译或者解释器解释时根据“语言关键词”和“语言设计机制”达成<code>语言语句禁止重排序</code>和<code>插入“内存屏障汇编指令”</code>效果，等价于存在一个“内存屏障语言指令”。</p>
<p><strong>备注</strong>：</p>
<ul>
<li>JVM语言字节码形式中的“内存屏障字节码指令”也是类似的<code>逻辑虚概念</code></li>
</ul>
<h4 id="3-3-1、Java中的内存屏障"><a href="#3-3-1、Java中的内存屏障" class="headerlink" title="3.3.1、Java中的内存屏障"></a><strong>3.3.1、Java中的内存屏障</strong></h4><p>在Java程序语言中，有4种内存屏障。</p>
<table>
<thead>
<tr>
<th>内存屏障名称</th>
<th>使用示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保Load1数据的装载执行完成之后再执行Load2及所有后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据对其他处理器可见（即刷新到主存）执行完成之后再执行Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>确保Load1数据装载执行完成之后再执行Store2及所有后续存储指令的刷新到主存</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保Store1数据对其他处理器变得可见（即刷新到主存）执行完成之后再执行Load2及所有后续装载指令的装载。<br/><font color='red'>StoreLoad会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令，这个特性使得本内存屏障同时具有其他3个内存屏障的效果，故被称为“全能型”内存屏障</font></td>
</tr>
</tbody></table>
<p>上述内存屏障都是<code>逻辑虚概念</code>，但经过编译&#x2F;解释后最终会映射到汇编指令集&#x2F;机器指令集中<code>客观实概念</code>的内存屏障。因此，接下来看似针对“Java中内存屏障”的讨论，实则针对最终所映射到的汇编指令集&#x2F;机器指令集中的内存屏障：</p>
<ul>
<li>StoreLoad内存屏障被大多现代的多处理器支持，其他3个内存屏障则不然</li>
<li>执行StoreLoad内存屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到主存中</li>
</ul>
<h2 id="四、最终形态"><a href="#四、最终形态" class="headerlink" title="四、最终形态"></a><strong>四、最终形态</strong></h2><p>相应于“程序语言 -&gt; 汇编语言 -&gt; 机器语言”的编译&#x2F;解释过程，存在“内存屏障语言指令 -&gt; 内存屏障汇编指令 -&gt; 内存屏障机器指令”的内存屏障编译&#x2F;解释过程。<br>我们知道，编译&#x2F;解释得到的汇编指令&#x2F;机器指令，跟具体平台相关，这自然也涵盖内存屏障，故而编译&#x2F;解释得到的内存屏障汇编指令&#x2F;机器指令也跟具体平台相关。<font color='red'>特别需要注意的是</font>，在有些平台上，内存屏障汇编指令&#x2F;机器指令可能会被优化消除掉，比如“在X86体系架构中，除了“StoreLoad”内存屏障所映射到的内存屏障汇编指令&#x2F;机器指令需要保留外，其他内存屏障都无需保留，因为相应的重排序在该体系架构中根本不会发生”。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]《Java并发编程的艺术》<br>[2]<a href="http://read.pudn.com/downloads100/doc/project/409708/IA-32%BE%ED3%A3%BA%CF%B5%CD%B3%B1%E0%B3%CC%D6%B8%C4%CF[123457%2011%2012].pdf">http://read.pudn.com/downloads100/doc/project/409708/IA-32%BE%ED3%A3%BA%CF%B5%CD%B3%B1%E0%B3%CC%D6%B8%C4%CF[123457%2011%2012].pdf</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>分界线</title>
    <url>/blog/2024/03/01/%E5%88%86%E7%95%8C%E7%BA%BF/</url>
    <content><![CDATA[<p>之后的是最新系统的博文！</p>
]]></content>
  </entry>
  <entry>
    <title>创建JVM进程虚拟机参数配置最佳实践</title>
    <url>/blog/2018/09/29/%E5%88%9B%E5%BB%BAJVM%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、打印GC日志"><a href="#一、打印GC日志" class="headerlink" title="一、打印GC日志"></a><strong>一、打印GC日志</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCID -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -Xloggc:file</span><br></pre></td></tr></table></figure>
<h2 id="二、OutOfMemoryError发生时生成堆转存快照"><a href="#二、OutOfMemoryError发生时生成堆转存快照" class="headerlink" title="二、OutOfMemoryError发生时生成堆转存快照"></a><strong>二、OutOfMemoryError发生时生成堆转存快照</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]<a href="/blog/2017/04/12/java%E5%91%BD%E4%BB%A4/" title="java命令">java命令</a>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>判定胜负</title>
    <url>/blog/2023/10/16/%E5%88%A4%E5%AE%9A%E8%83%9C%E8%B4%9F/</url>
    <content><![CDATA[<p>围棋胜负的判定方式为：终局后，占地盘多的一方获胜。</p>
<p>常用的数地盘方法有：</p>
<ul>
<li>数子法（中国采用）</li>
<li>数目法（日韩采用）</li>
</ul>
<p>本文介绍数子法。</p>
<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a><strong>一、背景</strong></h2><p>数子是数：棋盘上活着的棋子 + 这些活着的棋子所围住的交叉点。</p>
<p>一共是<code>19 * 19 = 361</code>个交叉点，故只要数一方就行。</p>
<p>由于黑棋先下，占了便宜，黑棋必须倒贴几个子给白棋才公平。经过研究，现代中国围棋规定黑棋须贴3.75子，即黑棋的地盘胜负阈值为<code>361 / 2 + 3.75 = 184.25</code>个交叉点，相应的白棋的地盘胜负阈值为<code>361 - 184.25 = 176.25</code>个交叉点。</p>
<p>总结：</p>
<ul>
<li><code>黑棋数得的子 - 184.25 = ××子</code>：为正数，则黑胜××子；为负数，则黑输××子</li>
<li><code>白棋数得的子 - 176.75 = ××子</code>：为正数，则白胜××子；为负数，则白输××子</li>
</ul>
<h2 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a><strong>二、具体步骤</strong></h2><p>具体步骤：</p>
<ol>
<li>选定数子方——黑子或者白子，后续：以A方代指数子方，B方代指非数子方</li>
<li>清除死棋：根据<a href="/blog/2023/10/15/%E6%B4%BB%E6%A3%8B%E5%92%8C%E6%AD%BB%E6%A3%8B/" title="活棋和死棋">《活棋和死棋》</a>，死棋包括“已经没有气的棋子”和“有气，但无法做活的棋子”</li>
<li>开始计数：可通过“块数”的方式加快计数，即最终是“块数 + 点数”的混合计数方式，比如<code>19 * 6 + 10 = 124</code>。对于活棋：<ul>
<li>双真眼活棋：1）属于A方，计数给A；2）属于B方，计数给B</li>
<li>双活棋形：属于A方的部分计数给A，属于B方的部分计数给B，双方的公气部分平分计数给双方，比如<code>图1双活中的黑子（9个）计数给黑方，白子（9个）计数给白方，双方公气（x点两个）平分计数给双方（黑方1个，白方1个）</code>，<code>图2双活中的黑子（13个，其中1个是B）计数给黑方，白子（13个，其中一个是A）计数给白方，双方公气（x点1个）平分计数给双方（黑方0.5个，白方0.5个）</code></li>
</ul>
</li>
<li>计算胜负：跟A方对应的地盘胜负阈值进行比较</li>
</ol>
<p>图1</p>
<img src=https://blog.dslztx.top/imgs/20231016-0-1.svg width=30% height=30% />

<p>图2</p>
<img src=https://blog.dslztx.top/imgs/20231016-0-2.svg width=30% height=30% />
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>前期绑定和后期绑定的经典例子</title>
    <url>/blog/2018/04/14/%E5%89%8D%E6%9C%9F%E7%BB%91%E5%AE%9A%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h2 id="一、简单例子"><a href="#一、简单例子" class="headerlink" title="一、简单例子"></a><strong>一、简单例子</strong></h2><p><strong><code>com.dslztx.package1</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>com.dslztx.package2</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dslztx.package1.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前期绑定：绑定到B.a，打印50</span></span><br><span class="line">    System.out.println(b.a);</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前期绑定：绑定到A.a，打印100</span></span><br><span class="line">    System.out.println(a.a);</span><br><span class="line"></span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前期绑定：绑定C.b，打印60</span></span><br><span class="line">    System.out.println(c.b);</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前期绑定：绑定A.a，打印100</span></span><br><span class="line">    System.out.println(aa.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50</span><br><span class="line">100</span><br><span class="line">60</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="二、基于后期绑定突破访问控制"><a href="#二、基于后期绑定突破访问控制" class="headerlink" title="二、基于后期绑定突破访问控制"></a><strong>二、基于后期绑定突破访问控制</strong></h2><p>访问控制判断只在编译期进行，因此可采用“前期绑定绑定到可通过访问控制的方法，后期绑定绑定到本不可通过访问控制的方法”的方式在运行期突破访问控制。<br><strong><code>chapter8.package1</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chapter8.package2.B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    a.f();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="comment">//不能直接访问该方法</span></span><br><span class="line">    <span class="comment">//b.f();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过多态访问了本不能访问的方法</span></span><br><span class="line">    print(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>chapter8.package2</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8.package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chapter8.package1.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">World</span><br></pre></td></tr></table></figure>
<h2 id="三、构造器方法调用过程中的多态"><a href="#三、构造器方法调用过程中的多态" class="headerlink" title="三、构造器方法调用过程中的多态"></a><strong>三、构造器方法调用过程中的多态</strong></h2><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line"></span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    System.out.println(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Glyph.draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  RoundGlyph(<span class="type">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    System.out.println(<span class="string">&quot;RoundGlyph.RoundGlyph(),radius=&quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;RoundGlyph.draw(),radius=&quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyConstructors</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RoundGlyph</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw(),radius=0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph(),radius=5</span><br></pre></td></tr></table></figure>
<h2 id="四、后期绑定的递归"><a href="#四、后期绑定的递归" class="headerlink" title="四、后期绑定的递归"></a><strong>四、后期绑定的递归</strong></h2><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeLevel</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GrandFather</span> <span class="variable">grandFather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    grandFather.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;GrandFather&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Child</span><br></pre></td></tr></table></figure>
<h2 id="五、非覆盖被误以为覆盖"><a href="#五、非覆盖被误以为覆盖" class="headerlink" title="五、非覆盖被误以为覆盖"></a><strong>五、非覆盖被误以为覆盖</strong></h2><p>由于E中的<code>f()</code>和<code>g()</code>方法不能被F继承，因此E中的<code>f()</code>方法和F中的<code>f()</code>方法不是“被覆盖”和“覆盖”的关系，E中的<code>g()</code>方法和F中的<code>g()</code>方法也不是“被覆盖”和“覆盖”的关系，进而导致E中的<code>f()</code>和<code>g()</code>方法不能被后期绑定到F中的<code>f()</code>和<code>g()</code>方法。<br><strong><code>com.dslztx.package3</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dslztx.package2.F;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">F</span>();</span><br><span class="line">    e.f();</span><br><span class="line">    e.g();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>com.dslztx.package2</code>包下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dslztx.package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dslztx.package3.E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>剪贴板的本质</title>
    <url>/blog/2018/06/05/%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="一、剪贴板的本质"><a href="#一、剪贴板的本质" class="headerlink" title="一、剪贴板的本质"></a><strong>一、剪贴板的本质</strong></h2><p>剪贴板的本质是“一块存储区域”，由具体应用程序具体实现。剪贴板的底层存储“可以是硬盘、可以是内存或者也可以是硬盘内存混合体”，剪贴板存放内容“可以是内容本身或者也可以是内容的引用地址（比如复制文件中文件的地址）”等等细节都由具体应用程序具体实现时具体设计决定。</p>
<h2 id="二、具体案例"><a href="#二、具体案例" class="headerlink" title="二、具体案例"></a><strong>二、具体案例</strong></h2><p>具体案例如下：</p>
<ul>
<li>Windows系统有自己的剪贴板体系</li>
<li>Linux的X Window System系统有自己的剪贴板体系</li>
<li>Tmux有自己的剪贴板体系</li>
<li>Vim有自己的剪贴板体系</li>
<li>Emacs有自己的剪贴板体系</li>
<li>VMware虚拟机用于主机和客户机通讯的程序有自己的剪贴板体系</li>
<li><code>Ctrl+c</code>和<code>Ctrl+v</code>组合对应一个剪贴板体系</li>
<li><code>Ctrl+Insert</code>和<code>Shift+Insert</code>组合对应一个剪贴板体系</li>
<li><code>Shift+Ctrl+c</code>和<code>Shift+Ctrl+v</code>组合对应一个剪贴板体系</li>
<li>…</li>
</ul>
<p>图1[1]是Ubuntu系统下不同剪贴板体系存在和交互的猜想示意图，这里引用该图不关注该猜想是否正确，而只是为了说明剪贴板体系的多样性。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180605-0-1.svg"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h2><p>由于剪贴板体系的实现多样性，虽然可通过“配置有些应用程序对剪贴板体系的选择或者借助于<code>xclip</code>，<code>xsel</code>等第三方工具”而对剪贴板体系作一定整合，<font color='red'>但是要想完全统一剪贴板体系还是不太现实，因此不要花费过多精力在这上面</font>。</p>
<br/>
参考文献：
[1]https://blog.csdn.net/nicekwell/article/details/40063817
[2]https://blog.csdn.net/fnzsjt/article/details/46368733
[3]https://stackoverflow.com/questions/31905680/vim-yanking-with-xclip-getting-rid-of-escape-characters
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>单体程序开发全貌</title>
    <url>/blog/2018/10/25/%E5%8D%95%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%85%A8%E8%B2%8C/</url>
    <content><![CDATA[<p>单体程序开发（特指Java单体程序开发）全貌如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20181025-0-1.png"></p>
<p><font color='red'>备注：</font></p>
<ul>
<li>分布式系统本质上是单体程序的有机集合体</li>
<li>大数据平台下的用户程序本质上还是单体程序，只不过遵循大数据平台的开发接口，并且由大数据平台负责“分布式化”</li>
<li>综合以上两点，可知：单体程序的开发是核心</li>
</ul>
<h2 id="一、程序开发"><a href="#一、程序开发" class="headerlink" title="一、程序开发"></a><strong>一、程序开发</strong></h2><h3 id="1-1、核心功能开发"><a href="#1-1、核心功能开发" class="headerlink" title="1.1、核心功能开发"></a><strong>1.1、核心功能开发</strong></h3><h4 id="1-1-1、操作系统"><a href="#1-1-1、操作系统" class="headerlink" title="1.1.1、操作系统"></a><strong>1.1.1、操作系统</strong></h4><h4 id="1-1-2、网络原理"><a href="#1-1-2、网络原理" class="headerlink" title="1.1.2、网络原理"></a><strong>1.1.2、网络原理</strong></h4><p>可使用“tcpdump+Wireshark”工具组合进行网络协议数据分析。</p>
<h4 id="1-1-3、JDK"><a href="#1-1-3、JDK" class="headerlink" title="1.1.3、JDK"></a><strong>1.1.3、JDK</strong></h4><h4 id="1-1-4、Java语言语法"><a href="#1-1-4、Java语言语法" class="headerlink" title="1.1.4、Java语言语法"></a><strong>1.1.4、Java语言语法</strong></h4><h4 id="1-1-5、第三方库使用"><a href="#1-1-5、第三方库使用" class="headerlink" title="1.1.5、第三方库使用"></a><strong>1.1.5、第三方库使用</strong></h4><h4 id="1-1-6、中间件使用"><a href="#1-1-6、中间件使用" class="headerlink" title="1.1.6、中间件使用"></a><strong>1.1.6、中间件使用</strong></h4><p>消息队列：ActiveMQ，Kafka，RocketMQ，…<br>数据库：Mysql，Redis，MongoDB，…<br>其他：ZooKeeper，BookKeeper，…</p>
<h4 id="1-1-7、数据结构和算法"><a href="#1-1-7、数据结构和算法" class="headerlink" title="1.1.7、数据结构和算法"></a><strong>1.1.7、数据结构和算法</strong></h4><h3 id="1-2、日志系统"><a href="#1-2、日志系统" class="headerlink" title="1.2、日志系统"></a><strong>1.2、日志系统</strong></h3><p>作用：记录程序运行现场信息，展现程序运行状态信息，提供程序运行问题排查线索，提供程序运行状态量化指标等。</p>
<p>推荐使用“SLF4J+Log4j&#x2F;Log4j 2”组合方案。<br>选型范围：Java Logging API，JCL，Log4j，Log4j 2，Logback。</p>
<p>备注：</p>
<ul>
<li>日志系统可直接连接Kafka等中间件，但导致权责不明晰，故不推荐这种方案</li>
</ul>
<h3 id="1-3、测试系统"><a href="#1-3、测试系统" class="headerlink" title="1.3、测试系统"></a><strong>1.3、测试系统</strong></h3><p>作用：确保迭代质量不会后退，提升迭代信心，加快迭代效率。<br>测试方案有很多种，比如“单元测试，集成测试，系统测试，回归测试，用户验收测试，压力测试”等。<br><strong>1、单元测试</strong><br>推荐使用：JUnit+JMockit[1]。<br>选型范围：JMockit，Mockito。</p>
<h3 id="1-4、配置机制"><a href="#1-4、配置机制" class="headerlink" title="1.4、配置机制"></a><strong>1.4、配置机制</strong></h3><p>配置机制包括：硬编码，配置文件，数据库配置，独立的配置中心。<br>根据具体需求选取实际应用的配置机制。</p>
<h3 id="1-5、监控报警系统"><a href="#1-5、监控报警系统" class="headerlink" title="1.5、监控报警系统"></a><strong>1.5、监控报警系统</strong></h3><p>监控报警分类：存活监控报警，性能监控报警，业务监控报警。<br>主要实现形式：1）自实现（监控逻辑完全在被监控进程内部实现）；2）独立进程实现（包括“平台实现”，“平台实现”是特殊的“独立进程实现”。监控进程独立于被监控进程，一部分监控逻辑可能仍需存在于被监控进程中）。</p>
<h4 id="1-5-1、存活监控报警"><a href="#1-5-1、存活监控报警" class="headerlink" title="1.5.1、存活监控报警"></a><strong>1.5.1、存活监控报警</strong></h4><p>既然是监控“存活”，那么自然不能使用“自实现”形式，即只能使用“独立进程实现”形式。<br>具体实现时又可细分为：1）主动注册（比如“向心跳中心注册”）；2）被动监测（比如“提供一个存活接口，供调用监测”）。</p>
<h4 id="1-5-2、性能监控报警"><a href="#1-5-2、性能监控报警" class="headerlink" title="1.5.2、性能监控报警"></a><strong>1.5.2、性能监控报警</strong></h4><p>作用：监控Java进程运行状态，有利于排查问题，提供一个性能优化的量化指标。<br>当被监控进程性能存在问题时，能否继续正常运行是未可知的，因此，不能使用“自实现”形式，而只能使用“独立进程实现”形式。<br>具体实现举例：1）运行一个第三方独立进程进行监控，使用jstat等工具进行监测；2）借助于Java字节码增强技术对被监控进程进行零侵入监控，单独运行一个监控数据收集展示进程（比如有相应平台：CAT[2]，JavaMelody[3]）。</p>
<h4 id="1-5-3、业务监控报警"><a href="#1-5-3、业务监控报警" class="headerlink" title="1.5.3、业务监控报警"></a><strong>1.5.3、业务监控报警</strong></h4><p>业务报警：比如“日志错误数量超过一定阈值”。<br>既可使用“自实现”形式，也可使用“独立进程实现”形式。</p>
<h2 id="二、版本管理"><a href="#二、版本管理" class="headerlink" title="二、版本管理"></a><strong>二、版本管理</strong></h2><p>推荐使用：Git。<br>选型范围：Git，SVN。</p>
<h2 id="三、项目管理"><a href="#三、项目管理" class="headerlink" title="三、项目管理"></a><strong>三、项目管理</strong></h2><p>推荐使用：Maven。<br>选型范围：Ant，Maven，Gradle。</p>
<br/>
**参考文献：**
[1]https://www.slant.co/topics/259/~best-mock-frameworks-for-java#1
[2]https://github.com/dianping/cat
[3]https://github.com/javamelody/javamelody
]]></content>
      <categories>
        <category>工程师进阶</category>
      </categories>
  </entry>
  <entry>
    <title>单例</title>
    <url>/blog/2020/07/26/%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a><strong>一、含义</strong></h2><p>“单例”的书面含义是：在一个Java进程中，某个给定类的实例只允许存在一个。</p>
<h2 id="二、实现方案"><a href="#二、实现方案" class="headerlink" title="二、实现方案"></a><strong>二、实现方案</strong></h2><p>实现“单例”方案须满足两个核心目标：</p>
<ul>
<li>的确是“单例”</li>
<li>线程安全</li>
</ul>
<p>常见的单例实现方案有6种，具体可细分为3类：静态初始化锁机制，内置锁&#x2F;高级锁，枚举。</p>
<p>接下来基于以下几个维度对上述6种单例实现方案进行评价：</p>
<ul>
<li>实现可读性，用5分制来进行评价</li>
<li>性能</li>
<li>是采用“懒汉模式（在获取单例实例时才生成）”还是“饿汉模式（在获取单例实例前已生成）”</li>
</ul>
<h3 id="2-1、静态初始化锁机制"><a href="#2-1、静态初始化锁机制" class="headerlink" title="2.1、静态初始化锁机制"></a><strong>2.1、静态初始化锁机制</strong></h3><p>利用静态初始化锁机制来获得“确保单例”和“线程安全”。<br><strong>1、方案1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>好</td>
<td>饿汉模式</td>
</tr>
</tbody></table>
<p><strong>2、方案2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单变种。</p>
<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>好</td>
<td>饿汉模式</td>
</tr>
</tbody></table>
<p><strong>3、方案3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用懒汉模式，代价是损失一点可读性。</p>
<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>好</td>
<td>懒汉模式</td>
</tr>
</tbody></table>
<h3 id="2-2、内置锁-高级锁"><a href="#2-2、内置锁-高级锁" class="headerlink" title="2.2、内置锁&#x2F;高级锁"></a><strong>2.2、内置锁&#x2F;高级锁</strong></h3><p>利用“内置锁（即synchronized锁）”或者高级锁来获得“线程安全”，利用条件判断获得“确保单例”。<br><strong>4、方案4</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次获取单例都需要申请锁和释放锁，大部分情况是不必要的，性能较差。</p>
<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>差</td>
<td>懒汉模式</td>
</tr>
</tbody></table>
<p><strong>5、方案5</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line"></span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的双重检查锁定方式，“init”变量需要用<code>volatile</code>修饰的原因在于：否则，由于重排序&#x2F;狭义可见性，外层的<code>if (!init)</code>语句返回false时，“instance”变量可能还未完成初始化。</p>
<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>好</td>
<td>懒汉模式</td>
</tr>
</tbody></table>
<p>在以下简单变种中，“instance”变量仍然需要用<code>volatile</code>修饰的原因在于：否则，由于重排序的存在，外层的<code>if (instance == null)</code>返回false时，“instance”变量可能还未完成初始化，只不过是由于重排序先返回了变量引用而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton55</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton55 instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton55</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton55 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton55.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton55</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、枚举"><a href="#2-3、枚举" class="headerlink" title="2.3、枚举"></a><strong>2.3、枚举</strong></h3><p>利用枚举自身的语法特性，来获得“确保单例”和“线程安全”。<br><strong>6、方案6</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    Singleton6() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        d = <span class="number">20D</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>实现可读性</th>
<th>性能</th>
<th>懒汉模式&#x2F;饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>好</td>
<td>饿汉模式</td>
</tr>
</tbody></table>
<h2 id="三、反单例攻击"><a href="#三、反单例攻击" class="headerlink" title="三、反单例攻击"></a><strong>三、反单例攻击</strong></h2><p>“反单例攻击”含义：通过某种手段，在“单例”之外创建生成新实例。</p>
<p>常见的反单例攻击手段有：</p>
<ul>
<li>使用<code>new + 构造方法</code>创建新实例</li>
<li>使用<code>克隆</code>创建新实例</li>
<li>使用<code>反射</code>创建新实例</li>
<li>使用<code>序列化-反序列化</code>创建新实例</li>
<li>使用<code>多类加载器加载</code>创建新实例</li>
</ul>
<h3 id="3-1、new-构造方法"><a href="#3-1、new-构造方法" class="headerlink" title="3.1、new + 构造方法"></a><strong>3.1、new + 构造方法</strong></h3><p>构造方法暴露给外部，使得外部可直接使用<code>new + 构造方法</code>的形式创建新实例。</p>
<p>实验代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    C() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> C <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        d = <span class="number">20D</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> B <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewConstructorAttack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(A.getInstance() == <span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(B.getInstance() == <span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不被允许</span></span><br><span class="line">        <span class="comment">//new C();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ul>
<li>由于枚举类不支持使用<code>new + 构造方法</code>的形式创建新实例，因此方案6天然防御该形式攻击</li>
<li>方案1-5为防御<code>new + 构造方法</code>攻击，可将构造方法设为由<code>private</code>修饰</li>
</ul>
<h3 id="3-2、克隆"><a href="#3-2、克隆" class="headerlink" title="3.2、克隆"></a><strong>3.2、克隆</strong></h3><p>类继承<code>java.lang.Cloneable</code>接口，并覆盖实现<code>clone()</code>方法，调用<code>clone()</code>方法可以创建生成一个新的实例。</p>
<p>实验代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">F</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    F() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> F <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        d = <span class="number">20D</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许覆盖实现Object类的clone()方法</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Object clone() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">D</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">D</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> D <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> E instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> E <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (E.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"></span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneAttack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> D.getInstance();</span><br><span class="line">        <span class="type">D</span> <span class="variable">dClone</span> <span class="operator">=</span> (D) d.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(d == dClone);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> E.getInstance();</span><br><span class="line">        <span class="type">E</span> <span class="variable">eClone</span> <span class="operator">=</span> (E) e.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(e == eClone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F实例不能访问clone()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ul>
<li>枚举类不能覆盖实现<code>clone()</code>方法，因此方案6天然防御该形式攻击</li>
<li>方案1-5为防御<code>克隆</code>攻击，可禁止继承<code>java.lang.Cloneable</code>接口，或者在继承的情况下，在覆盖实现的<code>clone()</code>方法中返回已经生成的实例，而不是重新生成，类似如下代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、反射"><a href="#3-3、反射" class="headerlink" title="3.3、反射"></a><strong>3.3、反射</strong></h3><p>通过反射获取<code>Constructor</code>对象，然后调用<code>newInstance()</code>方法生成实例。</p>
<p>实验代码3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">L</span> &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    L() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> L <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        d = <span class="number">20D</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">J</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">J</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">J</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">J</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> J <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">K</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> K instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">K</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> K <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (E.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">K</span>();</span><br><span class="line"></span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionAttack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">jConstructor</span> <span class="operator">=</span> J.class.getDeclaredConstructor();</span><br><span class="line">        jConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(J.getInstance() == jConstructor.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">kConstructor</span> <span class="operator">=</span> K.class.getDeclaredConstructor();</span><br><span class="line">        kConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(K.getInstance() == kConstructor.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举类的默认构造方法有“String和int”两个参数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">lConstructor</span> <span class="operator">=</span> L.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        lConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(L.getInstance() == lConstructor.newInstance(<span class="string">&quot;AnotherInstance&quot;</span>, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ul>
<li>对于枚举类，在获得其<code>Constructor</code>对象，然后调用<code>newInstance()</code>方法时会直接抛出<code>java.lang.IllegalArgumentException</code>异常，查看方法实现源码可知“枚举类直接被限定不能调用该方法”，因此方案6天然防御该形式攻击</li>
<li>方案1-5为防御<code>反射</code>攻击，对于“饿汉方案”，可在构造方法中增加“重复生成则抛出异常”的判断逻辑，类似如下代码；而对于“懒汉方案”，则无能为力</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;the instance exists&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、序列化-反序列化"><a href="#3-4、序列化-反序列化" class="headerlink" title="3.4、序列化-反序列化"></a><strong>3.4、序列化-反序列化</strong></h3><p>序列化存在多种形式，这里讨论常见的JDK序列化和JSON序列化（以Fastjson序列化为例）。</p>
<p>实验代码4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">I</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    I() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> I <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        d = <span class="number">20D</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">G</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">G</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">G</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> G <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> H instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">H</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> H <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (E.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line"></span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationAttack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">        jdkDeserializationAttack();</span><br><span class="line"></span><br><span class="line">        fastjsonDeserializationAttack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">jdkDeserializationAttack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">G</span> <span class="variable">g</span> <span class="operator">=</span> G.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">G</span> <span class="variable">anotherG</span> <span class="operator">=</span> (G) serializeAndDeserializeObjectJDK(g);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(g == anotherG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line"></span><br><span class="line">        <span class="type">H</span> <span class="variable">h</span> <span class="operator">=</span> H.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">H</span> <span class="variable">anotherH</span> <span class="operator">=</span> (H) serializeAndDeserializeObjectJDK(h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(h == anotherH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line">        <span class="type">I</span> <span class="variable">i</span> <span class="operator">=</span> I.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">I</span> <span class="variable">anotherI</span> <span class="operator">=</span> (I) serializeAndDeserializeObjectJDK(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(i == anotherI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">serializeAndDeserializeObjectJDK</span><span class="params">(Serializable serializable)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">oo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(oo);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(serializable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(oo.toByteArray()));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastjsonDeserializationAttack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">G</span> <span class="variable">g</span> <span class="operator">=</span> G.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">G</span> <span class="variable">anotherG</span> <span class="operator">=</span> (G) serializeAndDeserializeObjectFastjson(g, G.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(g == anotherG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line"></span><br><span class="line">        <span class="type">H</span> <span class="variable">h</span> <span class="operator">=</span> H.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">H</span> <span class="variable">anotherH</span> <span class="operator">=</span> (H) serializeAndDeserializeObjectFastjson(h, H.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(h == anotherH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---分割线---</span></span><br><span class="line">        <span class="type">I</span> <span class="variable">i</span> <span class="operator">=</span> I.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">I</span> <span class="variable">anotherI</span> <span class="operator">=</span> (I) serializeAndDeserializeObjectFastjson(i, I.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(i == anotherI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">serializeAndDeserializeObjectFastjson</span><span class="params">(Object obj, Class clz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> JSON.parseObject(jsonStr, clz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-1、JDK序列化"><a href="#3-4-1、JDK序列化" class="headerlink" title="3.4.1、JDK序列化"></a><strong>3.4.1、JDK序列化</strong></h4><p>类继承<code>java.lang.Serializable</code>接口，通过对一个实例序列化和反序列化，得到一个新的实例。</p>
<p><strong>结论</strong>：</p>
<ul>
<li>JDK序列化&#x2F;反序列化对枚举类特殊处理，经过<code>序列化-反序列化</code>过程，不会生成一个新的实例，因此方案6天然防御该形式攻击</li>
<li>方案1-5为防御<code>JDK序列化</code>攻击，可禁止继承<code>java.io.Serializable</code>接口；或者在继承的情况下，覆盖实现<code>readResolve()</code>方法，在该方法中直接返回已经生成的实例。<font color='red'>另外需要特别注意的一点是，JDK的反序列化过程无需调用构造方法，因此，不能采用“Fastjson序列化攻击防御”中的“排除定义无参构造方法”方案</font></li>
</ul>
<h4 id="3-4-2、Fastjson序列化"><a href="#3-4-2、Fastjson序列化" class="headerlink" title="3.4.2、Fastjson序列化"></a><strong>3.4.2、Fastjson序列化</strong></h4><p>通过对一个实例进行Fastjson序列化和反序列化，得到一个新的实例。</p>
<p><strong>结论</strong>：</p>
<ul>
<li>Fastjson序列化&#x2F;反序列化对枚举类特殊处理，经过<code>序列化-反序列化</code>过程，不会生成一个新的实例，因此方案6天然防御该形式攻击</li>
<li>方案1-5为防御<code>Fastjson序列化</code>攻击，可采用“排除定义无参构造方法（比如显式定义一个有参构造方法）”方案，本质原因在于Fastjson反序列化时需要调用无参构造方法</li>
</ul>
<h3 id="3-5、多类加载器加载"><a href="#3-5、多类加载器加载" class="headerlink" title="3.5、多类加载器加载"></a><strong>3.5、多类加载器加载</strong></h3><p>多个类加载器加载生成多个不同的Class对象，再生成多个不同的实例对象。</p>
<p>实验代码5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiClassLoaderAttack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意先把类路径下的single/Singleton1.class，single/Singleton5.class，single/Singleton6.class文件删除，否则会被优先加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/dslztx/Desktop/ca/&quot;</span>).toURI().toURL()&#125;);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/dslztx/Desktop/cb/&quot;</span>).toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">m01</span> <span class="operator">=</span> loader1.loadClass(<span class="string">&quot;single.Singleton1&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">m02</span> <span class="operator">=</span> loader2.loadClass(<span class="string">&quot;single.Singleton1&quot;</span>);</span><br><span class="line">        comp(m01, m02);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">n01</span> <span class="operator">=</span> loader1.loadClass(<span class="string">&quot;single.Singleton5&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n02</span> <span class="operator">=</span> loader2.loadClass(<span class="string">&quot;single.Singleton5&quot;</span>);</span><br><span class="line">        comp(n01, n02);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">o01</span> <span class="operator">=</span> loader1.loadClass(<span class="string">&quot;single.Singleton6&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o02</span> <span class="operator">=</span> loader2.loadClass(<span class="string">&quot;single.Singleton6&quot;</span>);</span><br><span class="line">        comp(o01, o02);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">comp</span><span class="params">(Class a, Class b)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 以下结果都为false，因为同一个类被不同类加载器加载得到的Class对象不同</span></span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodA</span> <span class="operator">=</span> a.getMethod(<span class="string">&quot;getInstance&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodB</span> <span class="operator">=</span> b.getMethod(<span class="string">&quot;getInstance&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(methodA == methodB);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> methodA.invoke(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> methodB.invoke(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(objA == objB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下结果都为true，因为在一个Class对象范畴中，存在“单例”语义，Class对象也只有一个</span></span><br><span class="line">        System.out.println(methodA.invoke(<span class="literal">null</span>) == objA);</span><br><span class="line">        System.out.println(methodB.invoke(<span class="literal">null</span>) == objB);</span><br><span class="line"></span><br><span class="line">        System.out.println(objA.getClass() == a);</span><br><span class="line">        System.out.println(objB.getClass() == b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ul>
<li>所有方案都不能避免该形式攻击</li>
</ul>
<h2 id="四、狭义单例和广义单例"><a href="#四、狭义单例和广义单例" class="headerlink" title="四、狭义单例和广义单例"></a><strong>四、狭义单例和广义单例</strong></h2><p>上面所说的单例是“狭义单例”，我们日常所说的单例实际上是“广义单例”，两者的区别在于：</p>
<ul>
<li>狭义单例，客观确保单例，防止恶意攻击</li>
<li>广义单例，主观确保单例，不考虑恶意攻击，比如“使用Spring框架中的Bean单例模式，实际上Bean对应类的构造方法是public的”</li>
</ul>
<h2 id="五、“单例”与“只执行一次”"><a href="#五、“单例”与“只执行一次”" class="headerlink" title="五、“单例”与“只执行一次”"></a><strong>五、“单例”与“只执行一次”</strong></h2><p>“单例”与“只执行一次”的关系：实现“单例”必然涉及到“只执行一次”，但是“只执行一次”不必然是为了实现“单例”。比如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (KafkaProducerFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ConfigLoadAssist.propConfig(CONFIG_FILE);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// doSomething1()</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// doSomething2()</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// doSomething3()</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        init = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用哪种“只执行一次”方案来实现“单例”或者用于其他用途，具体情况具体分析。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://cloud.tencent.com/developer/article/1446979">https://cloud.tencent.com/developer/article/1446979</a><br>[2]<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</a><br>[3]<a href="https://juejin.im/post/5b50b0dd6fb9a04f932ff53f">https://juejin.im/post/5b50b0dd6fb9a04f932ff53f</a><br>[4]<a href="http://www.hollischuang.com/archives/2498">http://www.hollischuang.com/archives/2498</a><br>[5]<a href="http://ifeve.com/from-singleton-happens-before/">http://ifeve.com/from-singleton-happens-before/</a><br>[6]<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a><br>[7]<a href="https://www.hollischuang.com/archives/1144">https://www.hollischuang.com/archives/1144</a><br>[8]<a href="https://www.hollischuang.com/archives/205">https://www.hollischuang.com/archives/205</a><br>[9]<a href="https://juejin.im/post/6844903753540173831">https://juejin.im/post/6844903753540173831</a><br>[10]<a href="https://www.cnblogs.com/giserxiaoliang/p/4922879.html">https://www.cnblogs.com/giserxiaoliang/p/4922879.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>博文导航</title>
    <url>/blog/2020/09/09/%E5%8D%9A%E6%96%87%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p><img src="https://blog.dslztx.top/imgs/20200909-0-0.svg"></p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>博文规划</title>
    <url>/blog/2018/09/07/%E5%8D%9A%E6%96%87%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="一、一篇博文对应一个知识模块"><a href="#一、一篇博文对应一个知识模块" class="headerlink" title="一、一篇博文对应一个知识模块"></a><strong>一、一篇博文对应一个知识模块</strong></h2><p><font color='red'>一篇博文对应一个知识模块，知识模块小而专化</font>。<br>因应于知识模块小而专化的好处，上述对应关系具有好处如下：</p>
<ul>
<li>更快速完成一篇博文，更即时收获成就感</li>
<li>博文具有更高可复用性</li>
<li>博文迭代成本大幅度降低</li>
</ul>
<h2 id="二、博文TAG系统"><a href="#二、博文TAG系统" class="headerlink" title="二、博文TAG系统"></a><strong>二、博文TAG系统</strong></h2><p>博文TAG系统具有两个维度：专题和标签。</p>
<h3 id="2-1、专题"><a href="#2-1、专题" class="headerlink" title="2.1、专题"></a><strong>2.1、专题</strong></h3><p>围绕“专题”集聚相关博文（数学原理介绍，专题聚焦问题描述，…），避免人为割裂。<br>正面例子：《时区》和《Java中日期时间相关核心类》两篇博文都归于“日期时间”专题。<br>反面例子：《时区》归于“日期时间”专题，《Java中日期时间相关核心类》归于“语言”专题。<br>对于博文专题归类模棱两可的情形，具体情况具体分析，比如关于“Java语言并发内容”的博文既可归于“语言”专题，也可归于“并发”专题，分析后还是归于“并发”专题更为合适。</p>
<p>常见专题比如有：语言，数据库，操作系统，网络原理，编译原理，中间件，书籍文档，…</p>
<h3 id="2-2、标签"><a href="#2-2、标签" class="headerlink" title="2.2、标签"></a><strong>2.2、标签</strong></h3><p>在实际使用中发现“标签”没有多大用处（直接可通过搜索实现），因此，废弃“标签”，节省思考“标签”的时间和精力。</p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>原子操作与锁</title>
    <url>/blog/2020/07/21/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<p>在X86中，加上<code>LOCK指令前缀</code>，不仅使得“原子化”，也使得“禁止重排序”，“刷新缓存到内存”和“使缓存失效”，但是这里只讨论“原子化”效果。</p>
<h2 id="一、原子操作"><a href="#一、原子操作" class="headerlink" title="一、原子操作"></a><strong>一、原子操作</strong></h2><p>原子操作的本质描述是：当且仅当操作物理或者逻辑不可中断（不可中断：操作所涉内存不可被<font color='red'>读取</font>和修改）时，该操作才是原子的。<br>原子操作存在于各个指令&#x2F;语言层级，比如“机器指令层级的原子操作”，“汇编指令层级的原子操作”，“Java语言层级的原子操作”等。</p>
<br/>

<p>关于原子操作的一些具体描述如下：</p>
<ul>
<li>在机器指令层级，大多数机器指令是非原子的，只有一些机器指令是原子的（又可被称为“天生原子机器指令”）</li>
<li>关于机器指令“原子”与“中断”的关系：在单核中，不可中断的机器指令是原子的，可中断的机器指令不一定是原子的；在多核中，可中断的机器指令不一定是原子的，<font color='red'>不可中断的机器指令也不一定是原子的</font>，比如“不可中断指令M在CPU核C1上执行，在CPU核C2上执行的指令可观察到M指令的中间过程，此时M指令不是原子的”</li>
<li>高级语言语句A&#x2F;汇编指令B最终被编译&#x2F;解释成一段机器指令C，A&#x2F;B是否是原子的取决于C是否是原子的</li>
<li>通过加锁，可将“非原子操作”原子化。比如：给非原子汇编指令A加上<code>LOCK指令前缀</code>将其原子化，在这里<code>LOCK指令前缀</code>是作为一种锁机制的，<code>LOCK指令前缀</code>会带来以下效果：1）被修饰的汇编指令在执行期间，会在内存总线上声言一个<code>#LOCK</code>信号导致内存被锁住，直到该汇编指令执行完成。因此，A执行期间不可能发生涉及到的内存值被读取和修改的情形，故此时A的执行是原子的；2）方案1锁住内存，期间内存不能被读取和修改，代价非常大，因此，现在一般是采用“缓存锁定”的方案，避免降低内存的存取速度。具体是：在指令执行期间锁住所涉及到的Cache Line，此时其他CPU核不能存取其内缓存中对应的Cache Line</li>
<li>“缓存一致性协议”与“指令操作的原子性”关系：缓存一致性协议（比如“MESI”）只能用来保证多CPU核内的缓存一致性，并不能保证“指令操作的原子性”。比如“现有CPU核A和B，执行相同的‘自增1’指令C，可分别以AC和BC代指，C所涉及的变量V在Cache Line D上，可分别以AD&#x2F;AC和BD&#x2F;BC代指，假定AV和BV的初始值为0，并发执行AC和BC，由于AD和BD并未被锁住，因此AC和BC获取得到的AV和BV的值可能都为0，此时AC和BC的执行结果都为1，在整个过程中，缓存一致性协议正常工作，可发现其并不能使得C的执行是原子的，否则AC和BC的执行结果应该分别是[1,2]或者[2,1]”</li>
</ul>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a><strong>二、锁</strong></h2><p>锁是一种同步机制，类似于“原子操作”，锁也存在于各个指令&#x2F;语言层级中，比如“机器指令层级的锁”，“汇编指令层级的锁”，“Java语言层级的锁”等。</p>
<h3 id="2-1、原子操作与锁"><a href="#2-1、原子操作与锁" class="headerlink" title="2.1、原子操作与锁"></a><strong>2.1、原子操作与锁</strong></h3><p>“原子操作”与“锁”的关系：实现“原子操作”必借助于“锁”，使用“锁”不一定能够实现“原子操作”。<br>比如：</p>
<ul>
<li>“天生原子机器指令”使用隐式锁机制</li>
<li>X86处理器的<code>LOCK指令前缀+CMPXCHG汇编指令</code>构成一个CAS原子指令，这里<code>LOCK指令前缀</code>是作为一种锁机制</li>
<li>在Java程序中，可借助“synchronized关键词&#x2F;高级锁”实现一段Java代码，如果实现得好，该段Java代码是一个原子操作；但是如果实现得不好（比如“中间状态可被他人存取”），该段Java代码就不是一个原子操作</li>
</ul>
<h3 id="2-2、锁分类"><a href="#2-2、锁分类" class="headerlink" title="2.2、锁分类"></a><strong>2.2、锁分类</strong></h3><p>可基于各种角度对锁进行分类。<br>常见的锁有：</p>
<ul>
<li>Java语言层级的“synchronized锁”和“高级锁”</li>
<li>C++，Rust，Go语言层级的内置锁</li>
<li>CAS自旋锁，其本质是<code>CAS+自旋（不断循环）</code>，它跟通常所理解的锁有点不一样，但是从用于解决原子操作问题的角度，它跟通常所理解的锁又无二致</li>
<li><code>LOCK指令前缀</code></li>
<li>“天生原子机器指令”使用的隐式锁</li>
</ul>
<p>常见的锁分类有：</p>
<ul>
<li>悲观锁 vs 乐观锁</li>
<li>阻塞锁 vs 非阻塞锁</li>
<li>公平锁 vs 非公平锁</li>
<li>可重入锁 vs 非可重入锁</li>
<li>共享锁 vs 排他锁</li>
</ul>
<h4 id="2-2-1、悲观锁-vs-乐观锁"><a href="#2-2-1、悲观锁-vs-乐观锁" class="headerlink" title="2.2.1、悲观锁 vs 乐观锁"></a><strong>2.2.1、悲观锁 vs 乐观锁</strong></h4><p>分类角度：对同步资源的并发修改是否频繁，不关心对同步资源的读取（当然，如果对同步资源的读取产生了线程安全问题，可能仍然得用锁的方式予以解决，只不过“悲观锁”和“乐观锁”的分类不关注对同步资源的读取）。</p>
<p><strong>悲观锁</strong>：对同步资源的并发修改十分频繁，修改前先加锁，适合“同步资源竞争激烈”的场景，比如“synchronized锁”。<br><strong>乐观锁</strong>：对同步资源的并发修改不频繁，修改前无需加锁，到真正修改时才去尝试处理竞争修改的情形，适合“同步资源竞争不激烈”的场景，<font color='red'>一般就是“CAS自旋锁”</font>。</p>
<h4 id="2-2-2、阻塞锁-vs-非阻塞锁"><a href="#2-2-2、阻塞锁-vs-非阻塞锁" class="headerlink" title="2.2.2、阻塞锁 vs 非阻塞锁"></a><strong>2.2.2、阻塞锁 vs 非阻塞锁</strong></h4><p>分类角度：申请锁而不得时，申请线程是否需要阻塞。</p>
<p><strong>阻塞锁</strong>：申请锁而不得时，申请线程需要阻塞，具有“阻塞-唤醒”过程成本，比如“synchronized锁”。<br><strong>非阻塞锁</strong>：申请锁而不得时，申请线程不需要阻塞，具有“持续占用分配到的CPU时间片”的成本，<font color='red'>一般就是“CAS自旋锁”</font>。</p>
<h4 id="2-2-3、公平锁-vs-非公平锁"><a href="#2-2-3、公平锁-vs-非公平锁" class="headerlink" title="2.2.3、公平锁 vs 非公平锁"></a><strong>2.2.3、公平锁 vs 非公平锁</strong></h4><p>分类角度：多个线程是否按照申请锁的顺序来获取锁。</p>
<p><strong>公平锁</strong>：多个线程是按照申请锁的顺序来获取锁，比如“ReentrantLock内的FairSync锁”。</p>
<ul>
<li>优点：等待锁的线程不会饿死</li>
<li>缺点：对于每个申请线程，都要付出“阻塞-唤醒”过程成本，由此导致整体吞吐效率相对于<code>非公平锁</code>要低</li>
</ul>
<p><strong>非公平锁</strong>：多个线程不是按照申请锁的顺序来获取锁，比如“synchronized锁”、“ReentrantLock内的NonfairSync锁”。</p>
<ul>
<li>优点：对于每个申请线程，可能可避免付出“阻塞-唤醒”过程成本，由此导致整体吞吐效率相对于<code>公平锁</code>要高</li>
<li>缺点：处于等待队列中的线程可能会饿死，或者，等很久才能获得锁</li>
</ul>
<h4 id="2-2-4、可重入锁-vs-非可重入锁"><a href="#2-2-4、可重入锁-vs-非可重入锁" class="headerlink" title="2.2.4、可重入锁 vs 非可重入锁"></a><strong>2.2.4、可重入锁 vs 非可重入锁</strong></h4><p>分类角度：已获得锁的线程在不释放该锁的前提下是否可再次获得该锁。</p>
<p><strong>可重入锁</strong>：已获得锁的线程在不释放该锁的前提下可再次获得该锁，比如“synchronized锁”、“ReentrantLock锁”。<br><strong>非可重入锁</strong>：已获得锁的线程在不释放该锁的前提下不可再次获得该锁，除非先释放掉该锁，比如“NonReentrantLock锁”。</p>
<h4 id="2-2-5、共享锁-vs-排他锁"><a href="#2-2-5、共享锁-vs-排他锁" class="headerlink" title="2.2.5、共享锁 vs 排他锁"></a><strong>2.2.5、共享锁 vs 排他锁</strong></h4><p>分类角度：锁是否只能被一个线程所获取。</p>
<p><strong>共享锁</strong>：锁能被多个线程同时所获取，比如“读写锁中的读锁”。<br><strong>排他锁</strong>：锁只能被一个线程所获取，比如“synchronized锁”、“读写锁中的写锁”。</p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><h3 id="3-1、原子操作与事务"><a href="#3-1、原子操作与事务" class="headerlink" title="3.1、原子操作与事务"></a><strong>3.1、原子操作与事务</strong></h3><p>原子操作与事务的关系是：“事务”是“原子操作”；“原子操作”不一定是“事务”，因为“原子操作”不一定有“回滚”语义。</p>
<h3 id="3-2、无锁化编程"><a href="#3-2、无锁化编程" class="headerlink" title="3.2、无锁化编程"></a><strong>3.2、无锁化编程</strong></h3><p>对于“无锁化编程”，完整的语境是：在并发环境中，以“无锁”的方式解决原子操作问题。而根据<code>实现“原子操作”必借助于“锁”</code>可知，<code>以“无锁”的方式解决原子操作问题</code>不可能，所以“无锁化编程”只是玩个文字游戏，本质还是需要锁的。<br>因此，我们平常在讨论“无锁化编程”时，实际上说的是：</p>
<ul>
<li>使用CAS自旋锁</li>
<li>使用“天生原子机器指令”，比如“在JDK 8的AtomicLong类，<code>VM_SUPPORTS_LONG_CAS</code>变量的JavaDoc中有提到一个天生原子机器指令，它实现了针对long变量的CAS操作”</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>原子操作类</title>
    <url>/blog/2020/07/30/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<p>本文介绍<code>java.util.concurrent.atomic</code>包下的原子操作类，使用的JDK是JDK 8。</p>
<h2 id="一、前导知识"><a href="#一、前导知识" class="headerlink" title="一、前导知识"></a><strong>一、前导知识</strong></h2><p>为理解本文，需要的前导知识列表如下：</p>
<ul>
<li>volatile变量的内存语义，参见<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a></li>
<li>Unsafe类中的一些方法，参见<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a>，具体有：<ul>
<li>3个CAS操作方法（<code>compareAndSwapInt</code>，<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>）</li>
<li>9个<code>put*Volatile</code>方法和9个<code>get*Volatile</code>方法</li>
<li><code>putOrderedInt/putOrderedLong/putOrderedObject</code>方法</li>
</ul>
</li>
<li>原子操作与锁，参见<a href="/blog/2020/07/21/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%94%81/" title="原子操作与锁">《原子操作与锁》</a></li>
<li>final关键词内存可见语义，参见<a href="/blog/2020/07/25/synchronized-volatile-final%E5%85%B3%E9%94%AE%E8%AF%8D/" title="synchronized-volatile-final关键词">《synchronized-volatile-final关键词》</a></li>
</ul>
<h2 id="二、java-util-concurrent-atomic包下的原子操作类"><a href="#二、java-util-concurrent-atomic包下的原子操作类" class="headerlink" title="二、java.util.concurrent.atomic包下的原子操作类"></a><strong>二、<code>java.util.concurrent.atomic</code>包下的原子操作类</strong></h2><p>可分成4类：</p>
<ul>
<li>基本类型或者引用类型原子修改操作类</li>
<li>数组元素原子修改操作类</li>
<li>对象字段原子修改操作类</li>
<li>原子计数&#x2F;累加操作类</li>
</ul>
<h3 id="2-1、基本类型或者引用类型原子修改操作类"><a href="#2-1、基本类型或者引用类型原子修改操作类" class="headerlink" title="2.1、基本类型或者引用类型原子修改操作类"></a><strong>2.1、基本类型或者引用类型原子修改操作类</strong></h3><p>一共有6个类，可分为两类：</p>
<ul>
<li>第一类：AtomicInteger，AtomicLong，AtomicReference，AtomicBoolean。我们知道Java数据类型可分为“基本类型（boolean，byte，char，short，int，float，long，double）”和“引用类型”，在Unsafe类下有3个CAS操作方法（<code>compareAndSwapInt</code>，<code>compareAndSwapLong</code>和<code>compareAndSwapObject</code>），直接对应3个原子修改操作类，另外通过一定设计（以int型的“1|0”分别代表boolean型的“true|false”）获得对应于“boolean”基本类型的原子修改操作类<code>AtomicBoolean</code></li>
<li>第二类：AtomicStampedReference和AtomicMarkableReference。这两个类被设计用来解决CAS操作的ABA问题</li>
</ul>
<h4 id="2-1-1、第一类"><a href="#2-1-1、第一类" class="headerlink" title="2.1.1、第一类"></a><strong>2.1.1、第一类</strong></h4><p>AtomicInteger，AtomicLong，AtomicReference，AtomicBoolean这4个类的实现大同小异，接下来以AtomicInteger类为例进行说明。</p>
<p>AtomicInteger有两个成员变量：</p>
<ul>
<li>实例成员变量value，核心操作变量</li>
<li>类成员变量valueOffset，它保存了AtomicInteger类实例对象的内存起始地址到其内value变量内存起始地址的偏移值，之所以需要这个偏移值是因为所涉及到的几个Unsafe类下方法是以这样的方式去操作value变量的内存</li>
</ul>
<p>在类中比较重要的两个方法是<code>addAndGet</code>和<code>lazySet</code>。<br><strong>1、addAndGet(int delta)</strong><br>AtomicInteger类中的<code>addAndGet(int delta)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe类中的<code>getAndAddInt(Object var1, long var2, int var4)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合<code>getIntVolatile方法具有volatile变量内存语义</code>和<code>compareAndSwapInt方法具有voltile变量内存语义</code>的前导知识，可知正确实现“增加且返回操作”的原子化。</p>
<br/>

<p>以上是JDK 8版本的实现，接下来对比JDK 6版本的实现。<br>JDK 6中，AtomicInteger类中的<code>addAndGet(int delta)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 6中，AtomicInteger类中的<code>get()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者最大的不同之处在于：具有volatile变量读语义限制地读取value变量，虽然最终等价，但是使用的方式不同——JDK 8使用<code>getIntVolatile</code>方法，JDK 6直接返回value变量，而该变量本就由volatile修饰。</p>
<p><strong>2、lazySet(int newValue)</strong><br>基于Unsafe类下的<code>putOrderedInt</code>方法实现。根据<code>Unsafe类下putOrderedInt/putOrderedLong/putOrderedObject方法的含义</code>前导知识，我们知道<code>Unsafe.putOrderedInt(Object var1, long var2, int var4)</code>介于“普通变量写语义”和“volatile变量写语义”之间，虽然不具有<code>volatile变量写语义</code>，但是在有些场景中能够获得很大的性能提升，比如“大量写之后，再有一个读，写和读之间的可见性确保由其他机制提供，例如‘synchronized内存语义’，‘volatile内存语义’等”。</p>
<h4 id="2-1-2、第二类"><a href="#2-1-2、第二类" class="headerlink" title="2.1.2、第二类"></a><strong>2.1.2、第二类</strong></h4><p>我们知道CAS原子操作存在ABA问题，解决ABA问题的常见方案是增加一个版本号，在<code>java.util.concurrent.atomic</code>包下有两个类用于解决这个问题：</p>
<ul>
<li>AtomicMarkableReference，引入一个boolean类型的标记位，作为简化形式的版本号，也即只有“true”和“false”两个版本号，它只能解决偶数ABA问题，而不能解决奇数ABA问题，比如“A-B-C-A，假定标记位的变化为‘true-false-true-false’，此时(A,false)并非预期的(A,true)，故修改尝试会失败；A-B-A，假定标记位的变化为‘true-false-true’，此时(A,true)为预期的(A,true)，故修改尝试会成功”</li>
<li>AtomicStampedReference，引入一个int类型的版本号，正统彻底的解决方案，既能解决偶数ABA问题，也能解决奇数ABA问题</li>
</ul>
<p>接下来就主要介绍AtomicStampedReference类。</p>
<p>首先介绍封装<code>引用变量reference</code>和<code>版本号变量stamp</code>的内部类Pair，它们都由final修饰且都在构造方法中赋值，显而易见满足了<code>final关键词内存可见语义规则</code>的条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> stamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reference = reference;</span><br><span class="line">        <span class="built_in">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后介绍<code>compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>这个核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V expectedReference, V newReference, <span class="type">int</span> expectedStamp, <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    AtomicStampedReference.Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span> expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp</span><br><span class="line">        &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp)</span><br><span class="line">            || casPair(current, AtomicStampedReference.Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法的语义是：只有当“旧值”和“旧版本号”都匹配时，才进行“新值”和“新版本号”的更新，其中<code>(newReference == current.reference &amp;&amp; newStamp == current.stamp)</code>逻辑表示在“旧值”和“新值”，“旧版本号”和“新版本号”都相同的情形下，无需做实际的更新操作，从而避免无必要的CAS原子操作。</p>
<h3 id="2-2、数组元素原子修改操作类"><a href="#2-2、数组元素原子修改操作类" class="headerlink" title="2.2、数组元素原子修改操作类"></a><strong>2.2、数组元素原子修改操作类</strong></h3><p>包括3个类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray。这3个类的实现大同小异，接下来以AtomicIntegerArray类为例进行说明。</p>
<p>AtomicIntegerArray有3个成员变量：</p>
<ul>
<li>实例成员变量int[] array，核心操作变量。由final修饰，在构造方法中赋值，显而易见满足了<code>final关键词内存可见语义规则</code>的条件</li>
<li>类成员变量base，这里保存了array数组引用对象“内存起始地址”与“数组对象内元素内存起始地址”的偏移量，即数组引用对象对象头的字节数。它的计算方法是<code>Unsafe.arrayBaseOffset(int[].class)</code>。需要注意的是，是否开启指针压缩会影响该值</li>
<li>类成员变量shift，它的值为2，<code>2^2=4</code>，4是int型所占据的字节大小。它的计算方法是<code>scale=Unsafe.arrayIndexScale(int[].class)</code>和<code>shift=31 - Integer.numberOfLeadingZeros(scale)</code>：前者确定int型所占据的字节大小，后者计算以2为底的<code>log(4)</code>对数值</li>
</ul>
<p>通过阅读源码可以发现，对数组中某个元素进行原子修改操作的“路径”是：</p>
<ol>
<li>先定位该数组元素的内存地址</li>
<li>再调用Unsafe类中的操作方法，比如<code>compareAndSwapInt</code>，<code>putIntVolatile</code>等。<font color='red'>本步实现与“基本类型或者引用类型原子修改操作类”的实现并无二致；同时佐证了Unsafe类下CAS方法，<code>put*Volatile</code>和<code>get*Volatile</code>方法的volatile变量内存语义并不要求变量是由volatile修饰的，因为这里的数组元素并非由volatile修饰的</font></li>
</ol>
<p>另外有一点值得说明的是：在AtomicReferenceArray类中有一个独有的<code>readObject()</code>方法（与“AtomicIntegerArray”和“AtomicLongArray”类相比），它是为了确保在反序列化时传入的数组类型的确是Object[]类型，而非其他虽然不会报错的数组类型，比如“String[]”，这是作为一个安全补丁而引入的[1]；而在AtomicIntegerArray&#x2F;AtomicLongArray类中，如果传入的数组类型不是int[]&#x2F;long[]则会立即报错。</p>
<h3 id="2-3、对象字段原子修改操作类"><a href="#2-3、对象字段原子修改操作类" class="headerlink" title="2.3、对象字段原子修改操作类"></a><strong>2.3、对象字段原子修改操作类</strong></h3><p>包括3个类：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater。这3个类的实现大同小异，接下来以AtomicIntegerFieldUpdater类为例进行说明。</p>
<p>通过阅读源码可以发现，对对象中某个字段进行原子修改操作的“路径”是：</p>
<ol>
<li>先定位对象中该字段的内存地址</li>
<li>再调用Unsafe类中的操作方法，比如<code>compareAndSwapInt</code>，<code>putIntVolatile</code>等</li>
</ol>
<p>这里有两点需要说明：</p>
<ul>
<li>在这个使用场景中，字段的操作入口不只限于AtomicIntegerFieldUpdater类，故当混杂其他操作入口时，不能保证所涉及字段操作的有序性、可见性和原子性。比如“对于一个字段A，一处使用AtomicIntegerFieldUpdater类实例进行修改，另外一处直接进行修改”</li>
<li>在AtomicIntegerFieldUpdater类的JavaDoc中要求所操作字段是由volatile修饰的，而且构造方法也直接作了相应的限定，但其实使用Unsafe类下CAS方法，<code>put*Volatile</code>和<code>get*Volatile</code>方法获得volatile变量内存语义并不要求变量是由volatile修饰的</li>
</ul>
<h3 id="2-4、原子计数-累加操作类"><a href="#2-4、原子计数-累加操作类" class="headerlink" title="2.4、原子计数&#x2F;累加操作类"></a><strong>2.4、原子计数&#x2F;累加操作类</strong></h3><p>包括5个类：Striped64，LongAdder，LongAccumulator，DoubleAdder和DoubleAccumulator。<br>Striped64是父类，LongAdder&#x2F;DoubleAdder分别是(LongAdder，LongAccumulator)&#x2F;(DoubleAdder，DoubleAccumulator)系列的代表类，故接下来介绍“Striped64”，“LongAdder”和“DoubleAdder”这3个类。</p>
<h4 id="2-4-1、Striped64"><a href="#2-4-1、Striped64" class="headerlink" title="2.4.1、Striped64"></a><strong>2.4.1、Striped64</strong></h4><p>基本原理是：通过两处进行计数&#x2F;累加，一处是使用base变量进行基本计数&#x2F;累加，另外一处是通过cells数组进行多线程分段计数&#x2F;累加。</p>
<p>核心方法是<code>longAccumulate</code>和<code>doubleAccumulate</code>，两者类似，以<code>longAccumulate</code>为例进行说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as;</span><br><span class="line">        Cell a;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123; <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x); <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123; <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs;</span><br><span class="line">                            <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended) <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>; <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>; <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123; <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法的主体流程是十分清晰的，就是“通过两处进行计数&#x2F;累加”，但由于需要考虑各种并发情形，且为无锁编程实现方案（使用CAS自旋锁），因此相对来说理解起来较为费劲，牢记“多线程环境存在各种并发可能，关键操作通过CAS方法进行”这点可帮助理解。</p>
<p>接下来介绍方法中几个关键变量的含义：</p>
<ul>
<li><code>cellsBusy</code>变量用作锁用途，<code>cellsBusy=0</code>时表示未锁住态，<code>cellsBusy=1</code>时表示锁住态，使用CAS方法操作该变量</li>
<li><code>wasUncontended</code>变量，用于一个小性能优化，当其值为false时，表示在调用该方法前已经失败执行<code>a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))</code>的等价语句，故可不执行后续最临近一次的<code>a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))</code>语句</li>
<li>当<code>collide</code>变量的值为true的时候，表示允许扩展<code>cells</code>数组</li>
</ul>
<h4 id="2-4-2、LongAdder"><a href="#2-4-2、LongAdder" class="headerlink" title="2.4.2、LongAdder"></a><strong>2.4.2、LongAdder</strong></h4><p>Long类型的计数类，核心方法在父类Striped64中，本身主要提供获取计数结果&#x2F;重置计数的方法，需要注意的是，<font color='red'>它不是线程安全的计数数据结构</font>，原因参见如下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sumThenReset</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; </span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时的计数数据丢失</span></span><br><span class="line"></span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += a.value;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此时的计数数据丢失</span></span><br><span class="line"></span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3、DoubleAdder"><a href="#2-4-3、DoubleAdder" class="headerlink" title="2.4.3、DoubleAdder"></a><strong>2.4.3、DoubleAdder</strong></h4><p>Double类型的计数类，跟LongAddr类似。一个实现要点是：将Double类型存储成Long类型，可操作的基础是两者都是8个字节大小。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://stackoverflow.com/questions/64622143/why-need-the-readobject-overriding-method-in-atomicreferencearray">https://stackoverflow.com/questions/64622143/why-need-the-readobject-overriding-method-in-atomicreferencearray</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>变量的异步定时加载之线程安全</title>
    <url>/blog/2020/07/27/%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>在变量的异步定时加载场景中，存在线程安全问题，接下来根据“单变量”和“多变量”这两种类型进行分别讨论。</p>
<h2 id="一、单变量"><a href="#一、单变量" class="headerlink" title="一、单变量"></a><strong>一、单变量</strong></h2><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleVariableAsyncLoadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> data;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        asyncLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步加载线程加载</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                data = System.currentTimeMillis() % <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法会被工作线程持续调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单变量场景又可细分为“基本类型”和“引用类型”两种子类型。</p>
<h3 id="1-1、基本类型"><a href="#1-1、基本类型" class="headerlink" title="1.1、基本类型"></a><strong>1.1、基本类型</strong></h3><p>对于基本类型，只需考虑赋值操作的线程安全问题，无需探讨其他形式的线程安全问题。在8种基本类型中，“boolean，byte，char，short，int，float”这6种基本类型变量的赋值操作是原子的，故不存在赋值操作线程安全问题；而对于“long”和“double”这两种基本类型变量的赋值操作，不一定是原子的，故存在赋值操作的线程安全问题，可通过加上<code>volatile</code>修饰符加以解决。</p>
<h3 id="1-2、引用类型"><a href="#1-2、引用类型" class="headerlink" title="1.2、引用类型"></a><strong>1.2、引用类型</strong></h3><p>引用类型的赋值操作是原子的，但存在另外一种形式的线程安全问题，即“重排序导致的实例构造未完成问题”。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleVariableAsyncLoadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        asyncLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步加载线程加载</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                person = <span class="keyword">new</span> <span class="title class_">Person</span>((<span class="type">int</span>) (System.currentTimeMillis() % <span class="number">100</span>), </span><br><span class="line">                        <span class="string">&quot;dslztx&quot;</span> + (System.currentTimeMillis() % <span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法会被工作线程持续调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">localPerson</span> <span class="operator">=</span> person;                       <span class="comment">//4 </span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[Name]:&quot;</span> + localPerson.name);  <span class="comment">//5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Age]:&quot;</span> + localPerson.age);    <span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体存在的线程安全问题是：由于重排序，当“&#x2F;&#x2F;4”处的localPerson变量指向新实例对象时，该新实例对象的成员变量可能仍未完成构造，故此时“&#x2F;&#x2F;5”和“&#x2F;&#x2F;6”打印成员变量的默认值。<br>可通过加上<code>volatile</code>修饰符加以解决，修改后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleVariableAsyncLoadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Person person;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        asyncLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                person = <span class="keyword">new</span> <span class="title class_">Person</span>((<span class="type">int</span>) (System.currentTimeMillis() % <span class="number">100</span>),</span><br><span class="line">                        <span class="string">&quot;dslztx&quot;</span> + (System.currentTimeMillis() % <span class="number">10</span>));   <span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法会被持续调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">localPerson</span> <span class="operator">=</span> person;                        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[Name]:&quot;</span> + localPerson.name);   <span class="comment">//5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Age]:&quot;</span> + localPerson.age);     <span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;      <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;    <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据happens-before规则之<code>程序顺序规则</code>，有“1 happens-before 2，2 happens-before 3”和“4 happens-before 5，5 happens-before 6”。当<code>print()方法</code>中localPerson未指向新实例对象时，使用旧的成员变量值；否则指向新实例对象，根据happens-before规则之<code>volatile变量规则</code>，有“3 hasppens-before 4”，然后再根据happens-before规则之<code>传递性规则</code>，有“1 happens-before 5，2 happens-before 5，1 happens-before 6，2 happens-before 6”，不会出现上述“重排序导致的实例构造未完成问题”。</p>
<h2 id="二、多变量"><a href="#二、多变量" class="headerlink" title="二、多变量"></a><strong>二、多变量</strong></h2><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiVariableAsyncLoadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        asyncLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步加载线程加载</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                age = (<span class="type">int</span>) (System.currentTimeMillis() % <span class="number">100</span>);</span><br><span class="line">                name = <span class="string">&quot;dslztx&quot;</span> + (System.currentTimeMillis() % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法会被工作线程持续调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Age]:&quot;</span> + age);       <span class="comment">//1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Name]:&quot;</span> + name);     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多变量场景中，除了上述单变量导致的线程安全性问题之外，还存在另外一种形式的线程安全问题，即“多变量异步加载进度不一致问题”，比如“1处读取到新值，2处读取到旧值”。</p>
<p>解决方案是创建一个临时类，将相关变量作为该临时类的成员变量，最后化“多变量问题”为“单变量问题”。<br>改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiVariableAsyncLoadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Person person;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        asyncLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步加载线程加载</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                person = <span class="keyword">new</span> <span class="title class_">Person</span>((<span class="type">int</span>) (System.currentTimeMillis() % <span class="number">100</span>), </span><br><span class="line">                        <span class="string">&quot;dslztx&quot;</span> + (System.currentTimeMillis() % <span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法会被工作线程持续调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">localPerson</span> <span class="operator">=</span> person;                        </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[Name]:&quot;</span> + localPerson.name);   </span><br><span class="line">        System.out.println(<span class="string">&quot;[Age]:&quot;</span> + localPerson.age);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>只需关注Java并发语法抽象</title>
    <url>/blog/2019/10/15/%E5%8F%AA%E9%9C%80%E5%85%B3%E6%B3%A8Java%E5%B9%B6%E5%8F%91%E8%AF%AD%E6%B3%95%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<p>只需关注Java并发语法抽象，无需关注Java并发语法实现，不过可以作简单了解以加深理解。<br>Java语法中除了“并发”部分之外的其他部分也是如此，其他语言（比如C&#x2F;C++，Go，Rust）语法同样如此。</p>
<p>语言语法实现有很多细节性工作要做，比如“语言语法实现跟具体处理器架构相关，Java语言中的volatile关键词语义在X86和IA64处理器架构上的实现不同”。</p>
<p>过于关注语言语法实现是“主要矛盾”和“次要矛盾”不分。</p>
<p>本博文主要是提醒作者在“探究Java语言volatile关键词语义实现”上花费了过多精力，卡住了过久。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>可见性与有序性</title>
    <url>/blog/2019/11/08/%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、可见性"><a href="#一、可见性" class="headerlink" title="一、可见性"></a><strong>一、可见性</strong></h2><h3 id="1-1、狭义内存可见性"><a href="#1-1、狭义内存可见性" class="headerlink" title="1.1、狭义内存可见性"></a><strong>1.1、狭义内存可见性</strong></h3><p>导致“内存可见性”问题的本质原因是：在现代多CPU&#x2F;CPU核处理器架构下，为提升存储性能，引入了<code>高速缓存-写缓冲器-失效队列</code>机制，但是该机制会使得<code>当线程A和线程B分别在不同的CPU/CPU核上运行，A欲对主存作的修改操作并非直接作用于主存而是首先作用于本地的高速缓存，此时B所在CPU/CPU核内的高速缓存并不能感知到这个修改操作</code>。</p>
<p>另外，根据以上描述可知，“内存可见性”问题的产生源于“处理器架构”，故而，其他语言都存在“内存可见性”问题，比如Go，Rust等。</p>
<h3 id="1-2、广义内存可见性"><a href="#1-2、广义内存可见性" class="headerlink" title="1.2、广义内存可见性"></a><strong>1.2、广义内存可见性</strong></h3><p>以上描述的内存可见性是“狭义内存可见性”，接下来叙述“广义内存可见性”：</p>
<blockquote>
<p>即“操作A对操作B逻辑内存可见”，当A和B（操作A和操作B可属于同一线程，也可属于不同线程）操作同一份内存时，除了“A写B读，B读不能感知A的写”不是A对B内存可见之外，其余的（即“A写B读，B能感知A的写”，“A写B写”，“A读B读”和“A读B写”）都是A对B内存可见；当A和B操作不同内存时，则A对B内存可见恒成立</p>
</blockquote>
<p>另外，关于“广义内存可见性”有以下两点说明：</p>
<ul>
<li>与“狭义内存可见性”的关系：“广义内存可见性”涵盖“狭义内存可见性”，这是显而易见的，“狭义内存可见性”描述的内存不可见，属于“操作同一份内存时，A写B读，B读不能感知A的写”情形</li>
<li>与“重排序”的关系：重排序也是导致内存不可见的一种情形，但需要明确的是，只有“编写时，A写操作先于B读操作，A和B操作同一份内存，重排序A和B，B读不能感知A的写”这种重排序情形才会导致内存不可见（此时，属于“操作同一份内存时，A写B读，B读不能感知A的写”情形），其他的重排序情形并不会导致内存不可见</li>
</ul>
<p><font color='red'>后续无特殊说明，“可见性”指的都是“广义内存可见性”。</font></p>
<h2 id="二、有序性"><a href="#二、有序性" class="headerlink" title="二、有序性"></a><strong>二、有序性</strong></h2><h3 id="2-1、狭义有序性"><a href="#2-1、狭义有序性" class="headerlink" title="2.1、狭义有序性"></a><strong>2.1、狭义有序性</strong></h3><p>导致“有序性”问题的本质原因有3个：</p>
<ul>
<li>在编译器&#x2F;解释器的层面，为优化程序执行速度，在遵循一定限制条件前提下，<code>编译器编译/解释器解释</code>得到的目标指令代码可能是经过重排序的</li>
<li>在处理器的层面，为优化指令执行速度，在遵循一定限制条件前提下，指令最终可能重排序执行</li>
</ul>
<p>另外，根据以上描述可知，“有序性”问题的产生源于“编译器&#x2F;解释器”和“处理器架构”，既然涉及到“处理器架构”，那么其他语言显然同样会存在“有序性”问题，比如Go，Rust等。</p>
<h3 id="2-2、广义有序性"><a href="#2-2、广义有序性" class="headerlink" title="2.2、广义有序性"></a><strong>2.2、广义有序性</strong></h3><p>以上描述的有序性是“狭义有序性”，其特点是“强调物理有序，不允许重排序”。接下来叙述“广义有序性”：</p>
<blockquote>
<p>强调逻辑有序，即允许重排序，只要执行结果跟物理有序一致即可</p>
</blockquote>
<p><font color='red'>后续无特殊说明，“有序性”指的都是“广义有序性”。</font></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a><strong>三、其他</strong></h2><p>“广义内存可见性”与“广义有序性”等价，即“存在可见性问题即存在有序性问题，存在有序性问题也即存在可见性问题”，“狭义内存可见性&#x2F;狭义有序性”是“广义内存可见性&#x2F;广义有序性”的子集，“狭义内存可见性”和“狭义有序性”不等价。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://juejin.im/post/5d67e78d5188251e073a39e5">https://juejin.im/post/5d67e78d5188251e073a39e5</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>吃子方法</title>
    <url>/blog/2023/10/15/%E5%90%83%E5%AD%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、吃子方法"><a href="#一、吃子方法" class="headerlink" title="一、吃子方法"></a><strong>一、吃子方法</strong></h2><table>
<thead>
<tr>
<th>吃子方法</th>
<th>定义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>双打吃</td>
<td>我方下子之后，对手两块棋都只有一口气，我方必定能吃到其中一块</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>门吃</td>
<td>像关门一样把对方围住的吃子方法</td>
<td>被门吃的白棋，逃跑的方向上，是没有黑棋的</td>
</tr>
<tr>
<td>抱吃</td>
<td>赶对方棋子去己方棋子那边</td>
<td>被抱吃的白棋，逃跑方向上，有一颗黑棋</td>
</tr>
<tr>
<td>枷吃</td>
<td>将对方的棋子，像渔网一样罩住</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>倒扑</td>
<td>扑（扑的含义见备注）一颗子，如果对方吃掉，己方再下进去吃掉对方许多棋</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>接不归</td>
<td>打吃对方，对方即便连&#x2F;粘一个子仍然失败</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>征吃&#x2F;扭羊头</td>
<td>一种利用对方棋子只有一口气，通过不断扭拐打吃的吃子方法</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>吃子方向</td>
<td>1、往边线吃棋；2、往己方强的方向吃棋</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<br/>

<p><strong>[备注]</strong></p>
<ul>
<li>扑：故意往对方虎口里落一颗子，以达成“减少对方的气”或者“破对方的眼”目标</li>
</ul>
<h2 id="二、扩展"><a href="#二、扩展" class="headerlink" title="二、扩展"></a><strong>二、扩展</strong></h2><h3 id="2-1、征吃"><a href="#2-1、征吃" class="headerlink" title="2.1、征吃"></a><strong>2.1、征吃</strong></h3><p>根据征吃的特点，千万要避免失败的征吃，否则可能导致己方多处棋子被双打吃。</p>
<p>失败的征吃包括：</p>
<ul>
<li>假的征吃</li>
<li>真的征吃，在征吃过程中失败</li>
</ul>
<p><strong>1、假的征吃</strong><br>一种假的征吃：对方棋子气数在&gt;&#x3D;2和&gt;&#x3D;3之间交替轮换，如图1（A点的气漏掉了）。</p>
<p>图1</p>
<img src=https://blog.dslztx.top/imgs/20231015-1-1.svg width=30% height=30% />

<p><strong>[备注]</strong> 真的征吃，对方棋子气数在1和2之间交替轮换。</p>
<p><strong>2、真的征吃，征吃失败</strong><br>真的征吃，征吃失败的原因有两个：</p>
<ul>
<li>对方棋子得到接应，对方棋子气数&gt;2，如图2</li>
<li>对方棋子得到接应，己方棋子被打吃，如图3</li>
</ul>
<p>图2</p>
<img src=https://blog.dslztx.top/imgs/20231015-1-2.svg width=30% height=30% />

<p>图3</p>
<img src=https://blog.dslztx.top/imgs/20231015-1-3.svg width=30% height=30% />
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>名言名句</title>
    <url>/blog/2016/09/10/%E5%90%8D%E8%A8%80%E5%90%8D%E5%8F%A5/</url>
    <content><![CDATA[<p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma - which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary</p>
<div align='right'>---苹果CEO乔布斯</div>
勤奋、数学逻辑能力强、高智商
<div align='right'>---唐骏挑选员工的准则</div>
勤奋、数学逻辑能力强、高智商和高情商
<div align='right'>---微软CEO鲍尔默挑选员工的准则</div>
做事就想着怎么把事情做漂亮，赚钱那是副产品，成天总想着怎么多赚钱反而不容易赚大钱，因为你看见小钱就跑了（<font color='red'>用心做事，钱财上门</font>）
<div align='right'>---摘自网上</div>
有时候人成长最大的阻力来自于过去的成功经验
<div align='right'>---摘自网上</div>
我懂得了，勇气不是没有恐惧，而是战胜恐惧。勇者不是感觉不到害怕的人，而是克服自身恐惧的人
<div align='right'>---曼德拉</div>
其实比起很多我以往交流过的青年才俊，我不是那么刻苦。我只不过是想得特别仔细，考虑好了才去做。<font color='red'>思考也是勤奋的一部分，人最大的懒惰是思想懒惰</font>
<div align='right'>---韩春雨</div>
自由从何而来？从自信来，而自信则是从自律来！先学会克制自己，用严格的日程表控制生活，才能在这种自律中不断磨练出自信
<div align='right'>---苹果CEO乔布斯</div>
看书重要，看世界也重要：读万卷书，行万里路，见世界上各种各样的人，听各种各样不同的看法。但是最重要的是，最后一定要用自己的脑袋去进行分析思考
<div align='right'>---马云谈读书</div>
思考是解决问题最重要的武器
<div align='right'>---曼德拉</div>
工匠们喜欢不断雕琢自己的产品，不断改善自己的工艺，享受产品在双手中升华的过程。工匠们对细节有很高的要求，追求完美和极致，对精品有着执着的坚持和追求，把品质从99%提高到99.99%， 其利虽微，却长久造福于世
<div align='right'>---工匠精神</div>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>长期维护</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆</title>
    <url>/blog/2010/06/15/%E5%9B%9E%E5%BF%86/</url>
    <content><![CDATA[<p>没有了喧嚣和浮躁，只有一片沁人的安静！夜深的时候也许最是感伤的时候！</p>
<p>躺在床上让自己裸露在黑暗与静谧之中！眼前不觉中翻腾一幅幅生动的画面！</p>
<p>或让我欢喜，或让我唏嘘，或让我感慨时光荏苒，抑或让我惊奇曾经的我也经历了如此多的痛苦和快乐！</p>
<p>那一切的一切既显得那样真实与亲切，又显得那样虚无飘渺，毕竟我已不再是他们的主人，只不过拥有了他们的拷贝而已！</p>
<p>时常在愚笨地思考，假如人没有了回忆，生活一定会变得简单和快乐！</p>
<p>但也明白，这种靠忘却换来的幸福只是无源之水，免不了枯竭的命运！只有跨过艰难险阻，追溯着源头，时时回忆着曾经的痛苦和喜悦，才有勇气和能量向大海奔腾而去！</p>
<p>回忆着过去，你能从中汲取很多生命的养分！<br>回忆着过去，你能明白时间的神奇，他能让你曾经的的确确地拥有，也能让你现在实实在在地怀念，你却永远无可奈何！<br>回忆着过去，你能看到你应该去做什么样的事情才能让你生命中的人不至于失望和怅然！</p>
<p>回忆中寻找生命的足迹！</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>诗</category>
      </categories>
  </entry>
  <entry>
    <title>围棋基础</title>
    <url>/blog/2023/10/09/%E5%9B%B4%E6%A3%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、围棋定义"><a href="#一、围棋定义" class="headerlink" title="一、围棋定义"></a><strong>一、围棋定义</strong></h2><p>围棋是黑白双方的对弈。</p>
<h2 id="二、围棋棋盘"><a href="#二、围棋棋盘" class="headerlink" title="二、围棋棋盘"></a><strong>二、围棋棋盘</strong></h2><p>围棋棋盘：</p>
<ul>
<li>标准正式的大小是<code>19*19</code></li>
<li>棋盘有两套坐标系（参见图1）：<ol>
<li>X路线坐标系（<font color='red'>常用</font>）：棋盘边缘的第一条线叫做一路线，由此往中央的方向数，分别是二路线，三路线…</li>
<li>X-Y坐标系（<font color='red'>不常用</font>）：(10,D)，(19,A)…</li>
</ol>
</li>
<li>一路线是死亡线，二路线是失败线：尽量不要把棋下在一路线和二路线</li>
<li>棋盘可分为3块区域（参见图2）：角、边和肚皮（中腹）。对于不同区域的价值描述有<code>金角银边草肚皮</code></li>
<li>有9个星位，中间的星位又叫天元，在X路线坐标系下的坐标分别为：<ul>
<li>4个角星位：4个(4,4)</li>
<li>4个边星位：(10,4)和(4,10)各2个</li>
<li>1个天元：1个(10,10)</li>
</ul>
</li>
<li>有8个小目、4个三三、8个目外、8个高目（参见图3和图4），在X路线坐标系下的坐标分别为：<ul>
<li>8个小目：(3,4)和(4,3)各4个</li>
<li>4个三三：4个(3,3)</li>
<li>8个目外：(3,5)和(5,3)各4个</li>
<li>8个高目：(4,5)和(5,4)各4个</li>
</ul>
</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20231009-0-1.jpg"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20231009-0-2.jpg"></p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20231009-0-3.jpg"></p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20231009-0-4.jpg"></p>
<h2 id="三、围棋基本规则"><a href="#三、围棋基本规则" class="headerlink" title="三、围棋基本规则"></a><strong>三、围棋基本规则</strong></h2><p>围棋基本规则：</p>
<ul>
<li>棋子要下在交叉点上 </li>
<li>黑先下，白后下，轮流下子，每次只能下一个子</li>
<li>棋子下在棋盘上后不能再移动，即落子无悔</li>
<li>没有气的棋子一定要从棋盘上拿下去</li>
<li>禁入点不能放子</li>
<li>打劫时，不能马上提子，要在其他地方下一手后方可提子</li>
<li>终局后，占地盘多的一方获胜</li>
</ul>
<h3 id="2-1、禁入点"><a href="#2-1、禁入点" class="headerlink" title="2.1、禁入点"></a><strong>2.1、禁入点</strong></h3><p>落子后，导致该棋子（或者和该棋子相连己方的整块棋）气数为0，则禁止落子。这个点，就叫做禁着点&#x2F;禁入点。<br>但是，如果导致双方气数都为0，则按提吃处理，不属于禁着点。</p>
<h3 id="2-2、打劫"><a href="#2-2、打劫" class="headerlink" title="2.2、打劫"></a><strong>2.2、打劫</strong></h3><h4 id="2-2-1、打劫含义"><a href="#2-2-1、打劫含义" class="headerlink" title="2.2.1、打劫含义"></a><strong>2.2.1、打劫含义</strong></h4><p>打劫：A方下在点a吃掉B方点b棋子，B方接着下在点b反吃掉A方点a棋子，A方再下在点a吃掉B方点b棋子，…。为避免这种死循环，人为规定——碰到以上情形，一方提子后，另外一方不能在打劫位置立即反提子，须在其他地方先下一手。</p>
<p>打一还一才是合法的打劫情形，其他的打M还N（M和N不同时为1）都不会陷入死循环，故不是合法的打劫情形。</p>
<h4 id="2-2-2、找劫材和应劫"><a href="#2-2-2、找劫材和应劫" class="headerlink" title="2.2.2、找劫材和应劫"></a><strong>2.2.2、找劫材和应劫</strong></h4><p>劫材：在打劫上下文语境中，一方的弱点（比如“打吃”，“破眼”、“分断”等）是另一方的劫材，比如“黑子的弱点是白子的劫材”。<font color='red'>须注意，弱点存在即存在，不在打劫上下文语境，只不过不叫劫材而已。</font></p>
<p>A打劫，B想要反提子，但是又限于打劫规则不能立即反提子，此时可以找B的劫材（A的弱点），然后在劫材处落子，使得A必须应对（应劫），然后就可以实现最初的目标，B反提子。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]《白小夕围棋》</p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>围棋定式</title>
    <url>/blog/2023/12/28/%E5%9B%B4%E6%A3%8B%E5%AE%9A%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、定式基本概念"><a href="#一、定式基本概念" class="headerlink" title="一、定式基本概念"></a><strong>一、定式基本概念</strong></h2><p>定式是根据经验总结出来的一种约定俗成的行棋方式：</p>
<ol>
<li>定式范围一般在角部，也存在少数范围很大（比如“涉及半个棋盘”）的大型定式</li>
<li>黑白双方遵照定式行棋，在定式范围内，最终形成大体安定、得失差不多的基本棋形</li>
</ol>
<h2 id="二、记忆定式"><a href="#二、记忆定式" class="headerlink" title="二、记忆定式"></a><strong>二、记忆定式</strong></h2><p>是否需要记忆定式：</p>
<ol>
<li>定式具有一定价值，可减少相应场景中的计算量</li>
<li>定式千千万，切忌贪多，记忆经典定式即可</li>
<li>记忆定式注重理解，切忌死记硬背</li>
</ol>
<p><font color='red'>须注意</font>：在实际行棋中，对方可能不遵循定式。此时返璞归真，须完全依靠计算力</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://mp.weixin.qq.com/s/9SWUoYza6I2_efK8Q8DhYg">https://mp.weixin.qq.com/s/9SWUoYza6I2_efK8Q8DhYg</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>围棋对杀</title>
    <url>/blog/2023/12/16/%E5%9B%B4%E6%A3%8B%E5%AF%B9%E6%9D%80/</url>
    <content><![CDATA[<h2 id="一、围棋对杀基本概念"><a href="#一、围棋对杀基本概念" class="headerlink" title="一、围棋对杀基本概念"></a><strong>一、围棋对杀基本概念</strong></h2><p>对杀，是指和对方棋子，互相包围，并且都没有做成活棋。只有去杀对方，才能做活，也会出现双活等特殊情况。</p>
<h2 id="二、对杀技巧"><a href="#二、对杀技巧" class="headerlink" title="二、对杀技巧"></a><strong>二、对杀技巧</strong></h2><p>在介绍对杀技巧之前，先介绍关于“气”的3个概念：</p>
<ul>
<li>公气：在对杀棋子中，既属于黑棋，又属于白棋的气，叫做公气</li>
<li>外气：在对杀棋子中，只属于某一方的气，叫做外气</li>
<li>内气：一方棋子，所围住的交叉点，就是内气</li>
</ul>
<h3 id="2-1、对杀进攻"><a href="#2-1、对杀进攻" class="headerlink" title="2.1、对杀进攻"></a><strong>2.1、对杀进攻</strong></h3><p>首先找到须“对杀进攻”对象：</p>
<ul>
<li>对方死棋不必对杀进攻</li>
<li>对方活棋不必对杀进攻</li>
<li>在可对杀进攻的对方棋子中优先选择重要棋子进行对杀进攻</li>
</ul>
<p>具体对杀进攻技巧：</p>
<ul>
<li>气长杀气短</li>
<li>同气先拔刀<ul>
<li>有1口公气：一定要收外气，再收公气</li>
<li>大于1口公气：都要先收外气，然后就是双活[1]</li>
</ul>
</li>
<li>在对杀进攻的时候，在吃对方棋子的同时，要注意自己棋子的安全，帮助弱小的棋子</li>
</ul>
<h3 id="2-2、对杀防守"><a href="#2-2、对杀防守" class="headerlink" title="2.2、对杀防守"></a><strong>2.2、对杀防守</strong></h3><p>首先找到须“对杀防守”对象：</p>
<ul>
<li>己方死棋不必对杀防守</li>
<li>己方活棋不必对杀防守</li>
<li>在可对杀防守的己方棋子中优先选择重要棋子进行对杀防守</li>
</ul>
<p>具体对杀防守技巧：</p>
<ul>
<li>往开阔（气多）的方向逃</li>
<li>往有自己棋子的方向逃</li>
<li>往对方弱的方向逃</li>
<li>弃子出逃，能逃一个是一个，逃出重要的子</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2023/10/15/%E6%B4%BB%E6%A3%8B%E5%92%8C%E6%AD%BB%E6%A3%8B/" title="活棋和死棋">《活棋和死棋》</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>围棋布局</title>
    <url>/blog/2024/02/02/%E5%9B%B4%E6%A3%8B%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>围棋布局是对最终棋局胜负至关重要的开局几十手的走法。</p>
<p><font color='red'>须注意</font>：围棋布局是根据经验的最大概率，而不是必然，故不必过于死板拘泥，不要限制思路，它具有很强的开放性，可以选择适合自己的风格。</p>
<br/>

<p>接下来介绍一种常见的围棋布局理论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据经验，围棋布局一般是：抢夺角和边，且优先在三线和四线抢，不在一线和二线落子。具体是因为：</span><br><span class="line">1）金角银边草肚皮</span><br><span class="line">2）一路线是死亡线，二路线是失败线，三路线是实地线，四路线是势力线</span><br></pre></td></tr></table></figure>

<h2 id="一、抢夺角和边"><a href="#一、抢夺角和边" class="headerlink" title="一、抢夺角和边"></a><strong>一、抢夺角和边</strong></h2><h3 id="1-1、抢夺角"><a href="#1-1、抢夺角" class="headerlink" title="1.1、抢夺角"></a><strong>1.1、抢夺角</strong></h3><h4 id="1-1-1、占角"><a href="#1-1-1、占角" class="headerlink" title="1.1.1、占角"></a><strong>1.1.1、占角</strong></h4><p>有3种占角类型：三三、小目和星位。</p>
<p>基于“控制角部”和“向外发展”维度，对上述3种占角类型进行打分。</p>
<table>
<thead>
<tr>
<th>占角类型</th>
<th>控制角部</th>
<th>向外发展</th>
</tr>
</thead>
<tbody><tr>
<td>三三</td>
<td>+3</td>
<td>+1</td>
</tr>
<tr>
<td>小目</td>
<td>+2</td>
<td>+2</td>
</tr>
<tr>
<td>星位</td>
<td>+1</td>
<td>+3</td>
</tr>
</tbody></table>
<p>结论：他们的得分都是4分。所以，没有谁最好，根据自己风格选择一个即可。</p>
<h4 id="1-1-2、守角-挂角"><a href="#1-1-2、守角-挂角" class="headerlink" title="1.1.2、守角&#x2F;挂角"></a><strong>1.1.2、守角&#x2F;挂角</strong></h4><p>占角之后，双方对该角的继续攻防即挂角&#x2F;守角：</p>
<ul>
<li>挂角：占角方对手欲争夺该角，有“小飞”，“大飞”，“单关”和“二间”4种挂角类型</li>
<li>守角：守角方继续防守巩固优势，根据<code>敌之要点，我之要点</code>，有“小飞”，“大飞”，“单关”和“二间”4种守角类型</li>
</ul>
<p>接下来以守角为例进行说明（以三角形标记的两落子是正确的守角）。</p>
<h5 id="1-1-2-1、“三三”占角后守角"><a href="#1-1-2-1、“三三”占角后守角" class="headerlink" title="1.1.2.1、“三三”占角后守角"></a><strong>1.1.2.1、“三三”占角后守角</strong></h5><p>图1</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-1.svg width=30% height=30% />

<ul>
<li>小飞：见图1左下角，A，C，B，G，H，F不在三线或者四线，不是正确的小飞守角</li>
<li>大飞：见图1右下角，K，L不在三线或者四线，不是正确的大飞守角</li>
<li>单关：见图1左上角，J，I不在三线或者四线，不是正确的单关守角</li>
<li>二间：见图1右上角</li>
</ul>
<h5 id="1-1-2-2、“小目”占角后守角"><a href="#1-1-2-2、“小目”占角后守角" class="headerlink" title="1.1.2.2、“小目”占角后守角"></a><strong>1.1.2.2、“小目”占角后守角</strong></h5><p>图2</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-2.svg width=30% height=30% />

<ul>
<li>小飞：见图2左下角，A，B，C，D，E，F不在三线或者四线，G相对最终答案离角区域更远，故都不是正确的小飞守角</li>
<li>大飞：见图2右下角，O，P，Q，M不在三线或者四线，N相对最终答案离角区域更远，故都不是正确的大飞守角</li>
<li>单关：见图2左上角，H，I不在三线或者四线，J相对最终答案离角区域更远，故都不是正确的单关守角</li>
<li>二间：见图2右上角，K不在三线或者四线，L相对最终答案离角区域更远，不是正确的二间守角</li>
</ul>
<h5 id="1-1-2-3、“星位”占角后守角"><a href="#1-1-2-3、“星位”占角后守角" class="headerlink" title="1.1.2.3、“星位”占角后守角"></a><strong>1.1.2.3、“星位”占角后守角</strong></h5><p>图3</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-3.svg width=30% height=30% />

<ul>
<li>小飞：见图3左下角，A，B，C，D，E，F不在三线或者四线，不是正确的小飞守角</li>
<li>大飞：见图3右下角，K，L，M，N，O，P不在三线或者四线，不是正确的大飞守角</li>
<li>单关：见图3左上角，G，H不在三线或者四线，不是正确的单关守角</li>
<li>二间：见图3右上角，I，J不在三线或者四线，不是正确的二间守角</li>
</ul>
<h3 id="1-2、抢夺边"><a href="#1-2、抢夺边" class="headerlink" title="1.2、抢夺边"></a><strong>1.2、抢夺边</strong></h3><p>首先介绍“拆”的概念，拆也叫“拆边”、“开拆”，是沿着边，在三四线上，间隔落子，为布阵所用：</p>
<ol>
<li>在三线拆称为“低拆”，在四线拆称为“高拆”</li>
<li>一般情况下，“拆”的最小限度为拆一，最大为拆五。拆的大小限度，要根据它背后的势力决定——背后势力大，可以拆大点；背后势力小，应该拆小点</li>
</ol>
<p>在“抢夺角”后，具体的“抢夺边”过程可遵循以下策略：</p>
<ol>
<li>根据具体情况选择“扩张拆”或者“安定拆”：<ul>
<li>安定拆：当我们处境危险，想要建立根据地，当我们想把棋下得安稳，减少弱点的时候，就应该拆小一点，一般情况拆二，特殊情况可以拆一或者拆三。图4中D相对C是拆二</li>
<li>扩张拆：当我们没有危险，需要扩大势力范围的时候，可以拆大一点，可以是拆四，也可以是拆五。图4中的B相对A是拆五</li>
</ul>
</li>
<li>拆的时候应该高低配合。图5中的A、B和C是高低配合拆，D，E和F不是高低配合拆</li>
<li>对于“拆”的方向，以<code>拆边方向跟守角方向不同（称为“立体形状拆”）</code>优于<code>拆边方向跟守角方向相同（称为“平面形状拆”）</code>，几个示例如下：<ul>
<li>图6中<code>A，B，C（A小目占角、B小飞守角、C拆五）</code>中的C拆是一个立体形状拆</li>
<li>图6中<code>D，E，F（D星位占角、E小飞守角、F拆五）</code>中的F拆是一个立体形状拆</li>
<li>图6中<code>G，H，I（G三三占角、H小飞守角、I拆六）</code>中的I拆是一个平面形状拆</li>
</ul>
</li>
</ol>
<p>图4</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-4.svg width=30% height=30% />

<p>图5</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-5.svg width=30% height=30% />

<p>图6</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-6.png width=30% height=30% />

<h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a><strong>二、总结</strong></h2><h3 id="2-1、总结"><a href="#2-1、总结" class="headerlink" title="2.1、总结"></a><strong>2.1、总结</strong></h3><p>我们把围棋布局分为三个部分：抢占空角、挂角或者守角、拆边<br>一般布局过程：</p>
<ol>
<li>占角</li>
<li>守角、挂角</li>
<li>拆边</li>
</ol>
<p>当然，双方都可以不按照上述过程来的。</p>
<h3 id="2-2、常见的布局方式"><a href="#2-2、常见的布局方式" class="headerlink" title="2.2、常见的布局方式"></a><strong>2.2、常见的布局方式</strong></h3><h4 id="2-2-1、二连星"><a href="#2-2-1、二连星" class="headerlink" title="2.2.1、二连星"></a><strong>2.2.1、二连星</strong></h4><p>图7</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-7.svg width=30% height=30% />

<p>二连星，本质还没涉及到占边，不是完整意义的布局。</p>
<h4 id="2-2-2、中国流"><a href="#2-2-2、中国流" class="headerlink" title="2.2.2、中国流"></a><strong>2.2.2、中国流</strong></h4><p>图8</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-8.svg width=30% height=30% />

<p>图9（高中国流，即“三连星”）</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-9.svg width=30% height=30% />

<h4 id="2-2-3、宇宙流"><a href="#2-2-3、宇宙流" class="headerlink" title="2.2.3、宇宙流"></a><strong>2.2.3、宇宙流</strong></h4><p>图10（宇宙流是高中国流（三连星）的拓展延伸）</p>
<img src=https://blog.dslztx.top/imgs/20240202-0-10.svg width=30% height=30% />
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>围棋术语</title>
    <url>/blog/2023/12/27/%E5%9B%B4%E6%A3%8B%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<p>本文介绍一些常见的围棋术语。</p>
<p>须注意：</p>
<ol>
<li>很多围棋术语的定义仍存在歧义，但无需苛求，因为围棋术语的最大作用只是为了便于交流</li>
<li>存在“一个术语客体可由不同术语描述”的情形，选择最精准的描述即可，比如：<ul>
<li><code>接、立、拐、贴和退</code>都是特殊的<code>长</code></li>
<li>如果<code>拐</code>在1到4路线，那么其也是一个<code>立</code></li>
</ul>
</li>
</ol>
<h2 id="一、手筋"><a href="#一、手筋" class="headerlink" title="一、手筋"></a><strong>一、手筋</strong></h2><p>手筋，是在对局过程中，某个局部的最佳走法，也可以理解为一种妙手。</p>
<h2 id="二、官子"><a href="#二、官子" class="headerlink" title="二、官子"></a><strong>二、官子</strong></h2><p>当棋局进行到一定阶段后，敌我双方的地盘，已经基本成形。但是边界，还有很多没有确定下来。边界上，还可以继续争夺的地盘，就称为“官子”。</p>
<h2 id="三、先手和后手"><a href="#三、先手和后手" class="headerlink" title="三、先手和后手"></a><strong>三、先手和后手</strong></h2><h3 id="3-1、先手和脱先"><a href="#3-1、先手和脱先" class="headerlink" title="3.1、先手和脱先"></a><strong>3.1、先手和脱先</strong></h3><p>先手：在某个局部，你下了，对方不得不应对。如果它不应，将会损失惨重。</p>
<p>脱先：对方下了一个“先手”，经过计算你觉得其他地方的价值更大，而选择承受该处损失放弃回应这个“先手”，这被称为“脱先”。</p>
<h3 id="3-2、后手"><a href="#3-2、后手" class="headerlink" title="3.2、后手"></a><strong>3.2、后手</strong></h3><p>相对于先手而言，先手是强迫对方应棋，后手就是，对方没必要应。</p>
<h2 id="四、动作"><a href="#四、动作" class="headerlink" title="四、动作"></a><strong>四、动作</strong></h2><h3 id="4-1、长、接、立、拐、贴和退"><a href="#4-1、长、接、立、拐、贴和退" class="headerlink" title="4.1、长、接、立、拐、贴和退"></a><strong>4.1、长、接、立、拐、贴和退</strong></h3><h4 id="4-1-1、长"><a href="#4-1-1、长" class="headerlink" title="4.1.1、长"></a><strong>4.1.1、长</strong></h4><p>紧靠自己原有的棋子，继续向前延伸。</p>
<p>图1（黑A为<code>长</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-1.svg width=30% height=30% />

<h4 id="4-1-2、接"><a href="#4-1-2、接" class="headerlink" title="4.1.2、接"></a><strong>4.1.2、接</strong></h4><p>一种特殊的<code>长</code>：把己方的两块棋子结结实实地连起来，即<code>直接连接</code>，又称<code>粘</code>。</p>
<p>图2（黑落在点A是<code>接</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-2.svg width=30% height=30% />

<h4 id="4-1-3、立"><a href="#4-1-3、立" class="headerlink" title="4.1.3、立"></a><strong>4.1.3、立</strong></h4><p>一种特殊的<code>长</code>：</p>
<ol>
<li><code>立</code>这步棋，只能下在1到4路线上</li>
<li><code>立</code>的方向，是相对于棋盘边线来说的：<ul>
<li>行棋方向是靠近边线，称为<code>下立</code></li>
<li>行棋方向是远离边线，称为<code>上立</code></li>
</ul>
</li>
</ol>
<p>图3（白A是<code>下立</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-3.svg width=30% height=30% />

<p>图4（白A是<code>上立</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-4.svg width=30% height=30% />

<h4 id="4-1-4、拐"><a href="#4-1-4、拐" class="headerlink" title="4.1.4、拐"></a><strong>4.1.4、拐</strong></h4><p>一种特殊的<code>长</code>（以黑子为例进行说明）：</p>
<ol>
<li>黑子原来存在<code>长</code>方向D，即最后两颗直接连接的黑子的行棋方向为D</li>
<li>黑子继续<code>长</code>，只不过<code>长</code>的方向跟D成90度</li>
</ol>
<p>图5（黑A是<code>拐</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-5.svg width=30% height=30% />

<h4 id="4-1-5、贴"><a href="#4-1-5、贴" class="headerlink" title="4.1.5、贴"></a><strong>4.1.5、贴</strong></h4><p>一种特殊的<code>长</code>：</p>
<ol>
<li>黑棋和白棋已经接触</li>
<li>继续紧贴对方的棋子<code>长</code></li>
</ol>
<p>图6（黑A是<code>贴</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-6.svg width=30% height=30% />

<h4 id="4-1-6、退"><a href="#4-1-6、退" class="headerlink" title="4.1.6、退"></a><strong>4.1.6、退</strong></h4><p>一种特殊的<code>长</code>：</p>
<ol>
<li>黑棋和白棋已经接触</li>
<li>远离对方，靠近己方<code>长</code></li>
</ol>
<p>图7（黑A是<code>退</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-7.svg width=30% height=30% />

<h3 id="4-2、跳"><a href="#4-2、跳" class="headerlink" title="4.2、跳"></a><strong>4.2、跳</strong></h3><h4 id="4-2-1、小跳"><a href="#4-2-1、小跳" class="headerlink" title="4.2.1、小跳"></a><strong>4.2.1、小跳</strong></h4><p>和自己原有的棋子，在同一条直线上，隔1路落子。我们常说的<code>跳</code>，一般指<code>小跳</code>。</p>
<h4 id="4-2-2、大跳"><a href="#4-2-2、大跳" class="headerlink" title="4.2.2、大跳"></a><strong>4.2.2、大跳</strong></h4><p>和自己原有的棋子，在同一条直线上，隔2路落子。</p>
<h3 id="4-3、飞"><a href="#4-3、飞" class="headerlink" title="4.3、飞"></a><strong>4.3、飞</strong></h3><h4 id="4-3-1、小飞"><a href="#4-3-1、小飞" class="headerlink" title="4.3.1、小飞"></a><strong>4.3.1、小飞</strong></h4><p>在自己原有棋子，<code>日</code>字形对角位置落子，这手棋叫做<code>小飞</code>。一般来说，我们说的<code>飞</code>，是指<code>小飞</code>。</p>
<h4 id="4-3-2、大飞"><a href="#4-3-2、大飞" class="headerlink" title="4.3.2、大飞"></a><strong>4.3.2、大飞</strong></h4><p>在自己原有棋子，<code>目</code>字形对角位置落子，这手棋叫做<code>大飞</code>。</p>
<h3 id="4-4、象步"><a href="#4-4、象步" class="headerlink" title="4.4、象步"></a><strong>4.4、象步</strong></h3><p>在自己原有棋子，<code>田</code>字形对角位置落子，这手棋叫做<code>象步飞</code>。</p>
<h3 id="4-5、尖和扳"><a href="#4-5、尖和扳" class="headerlink" title="4.5、尖和扳"></a><strong>4.5、尖和扳</strong></h3><h4 id="4-5-1、尖"><a href="#4-5-1、尖" class="headerlink" title="4.5.1、尖"></a><strong>4.5.1、尖</strong></h4><p>尖（常被称为<code>小尖</code>）：</p>
<ol>
<li>在原棋子的<code>口</code>字对角位置落子</li>
<li>且这个<code>口</code>字的另外两个角，没有棋子</li>
</ol>
<p>图8（黑A和黑B互为对方的<code>尖</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-8.svg width=30% height=30% />

<h4 id="4-5-2、扳"><a href="#4-5-2、扳" class="headerlink" title="4.5.2、扳"></a><strong>4.5.2、扳</strong></h4><p><code>扳</code>有以下两个特征：</p>
<ol>
<li>以<code>尖</code>的形状，斜向拦住对方棋子的另一面</li>
<li><code>扳</code>虽具有<code>尖</code>的形状，但不是<code>尖</code>，不符合“4.5.1、尖”中<code>尖</code>定义的第2个条件</li>
</ol>
<p>图9（黑A是<code>扳</code>）</p>
<img src=https://blog.dslztx.top/imgs/20231227-0-9.svg width=30% height=30% />

<h3 id="4-6、挡"><a href="#4-6、挡" class="headerlink" title="4.6、挡"></a><strong>4.6、挡</strong></h3><p>在对方向外冲出时，迎头堵住它的去路，阻止对方的棋子越过，称为<code>挡</code>。</p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>在没有安装fcitx的Ubuntu上安装fcitx-googlepinyin输入法</title>
    <url>/blog/2016/11/04/%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85fcitx%E7%9A%84Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85fcitx-googlepinyin%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a><strong>一、安装</strong></h2><h3 id="1-1、安装汉语语言包"><a href="#1-1、安装汉语语言包" class="headerlink" title="1.1、安装汉语语言包"></a><strong>1.1、安装汉语语言包</strong></h3><p>执行以下命令，安装所需要的汉语语言包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install language-pack-zh-hans</span><br></pre></td></tr></table></figure>
<h3 id="1-2、安装fcitx输入法框架和谷歌拼音输入法"><a href="#1-2、安装fcitx输入法框架和谷歌拼音输入法" class="headerlink" title="1.2、安装fcitx输入法框架和谷歌拼音输入法"></a><strong>1.2、安装fcitx输入法框架和谷歌拼音输入法</strong></h3><p>执行以下命令，安装fcitx输入法框架和谷歌拼音输入法（同时会安装一些用于配置fcitx输入法框架的工具）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-googlepinyin</span><br></pre></td></tr></table></figure>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a><strong>二、配置</strong></h2><h3 id="2-1、配置fcitx作为默认输入法框架"><a href="#2-1、配置fcitx作为默认输入法框架" class="headerlink" title="2.1、配置fcitx作为默认输入法框架"></a><strong>2.1、配置fcitx作为默认输入法框架</strong></h3><p>打开“系统设置”下的“语言支持”，选择“键盘输入方式系统”为fcitx，将fcitx配置作为默认输入法框架。如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20161104-0-1.png"></p>
<h3 id="2-2、输入法配置"><a href="#2-2、输入法配置" class="headerlink" title="2.2、输入法配置"></a><strong>2.2、输入法配置</strong></h3><p>执行<code>fcitx-configtool</code>命令，打开fcitx配置工具，进行输入法配置。配置界面如图2所示。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20161104-0-2.png"></p>
<p>具体配置项目是增加谷歌拼音输入法，如图3所示。</p>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20161104-0-3.png"></p>
<p>经过以上步骤，fcitx-googlepinyin输入法的安装和配置已经完成，可以正常使用。此时，图4中的“文本输入”下的相关配置无需设置。</p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20161104-0-4.png"></p>
<p><font color='red'>需要注意的是，为了使输入法安装和配置生效，需要注销重新登录系统。</font></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/blog/2018/04/05/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>谈论“多态”需要首先涉及“前期绑定”和“后期绑定”。</p>
<h2 id="一、前期绑定"><a href="#一、前期绑定" class="headerlink" title="一、前期绑定"></a><strong>一、前期绑定</strong></h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a><strong>1.1、概念</strong></h3><p>在编译期，完成前期绑定。</p>
<h4 id="1-1-1、“实例对象访问成员”形式的前期绑定"><a href="#1-1-1、“实例对象访问成员”形式的前期绑定" class="headerlink" title="1.1.1、“实例对象访问成员”形式的前期绑定"></a><strong>1.1.1、“实例对象访问成员”形式的前期绑定</strong></h4><p>实例对象访问成员，参见如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(a.a);</span><br><span class="line">    System.out.println(a.b);</span><br><span class="line">    System.out.println(a.f());</span><br><span class="line">    System.out.println(a.g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前期绑定描述：</p>
<ul>
<li>确定实例对象对应的声明Java类（<font color='red'>注意不是实例对象对应的实际Java类</font>），基于该声明Java类的实际定义进行访问成员的绑定</li>
<li>当该声明Java类的实际定义中含有0个匹配的候选项时，前期绑定失败，编译报错；当该声明Java类的实际定义中含有大于0个匹配的候选项时，依据一定的策略进行选取绑定（笔者不在这里探讨详细的策略），比如“原生成员优先级高于继承成员”，如果由于“违反约束条件”等原因导致不能顺利选取绑定则前期绑定失败，编译报错，否则前期绑定成功</li>
</ul>
<h4 id="1-1-2、“直接通过类访问成员”形式的前期绑定"><a href="#1-1-2、“直接通过类访问成员”形式的前期绑定" class="headerlink" title="1.1.2、“直接通过类访问成员”形式的前期绑定"></a><strong>1.1.2、“直接通过类访问成员”形式的前期绑定</strong></h4><p>直接通过类访问成员，参见如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(A.b);</span><br><span class="line">    System.out.println(A.g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前期绑定描述：</p>
<ul>
<li>基于所使用Java类的实际定义进行访问成员的绑定</li>
<li>当该使用Java类的实际定义中含有0个匹配的候选项时，前期绑定失败，编译报错；当该使用Java类的实际定义中含有大于0个匹配的候选项时，依据一定的策略进行选取绑定（笔者不在这里探讨详细的策略），比如“原生成员优先级高于继承成员”，如果由于“违反约束条件”等原因导致不能顺利选取绑定则前期绑定失败，编译报错，否则前期绑定成功</li>
</ul>
<h3 id="1-2、几个例子"><a href="#1-2、几个例子" class="headerlink" title="1.2、几个例子"></a><strong>1.2、几个例子</strong></h3><h4 id="1-2-1、例子1"><a href="#1-2-1、例子1" class="headerlink" title="1.2.1、例子1"></a><strong>1.2.1、例子1</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic1</span> <span class="keyword">extends</span> <span class="title class_">A1</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A1</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为10</span></span><br><span class="line">    System.out.println(a1.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2、例子2"><a href="#1-2-2、例子2" class="headerlink" title="1.2.2、例子2"></a><strong>1.2.2、例子2</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic2</span> <span class="keyword">extends</span> <span class="title class_">A3</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic2</span> <span class="variable">polymorphic2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为30</span></span><br><span class="line">    System.out.println(polymorphic2.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A3</span> <span class="keyword">extends</span> <span class="title class_">A2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3、例子3"><a href="#1-2-3、例子3" class="headerlink" title="1.2.3、例子3"></a><strong>1.2.3、例子3</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A5</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic3</span> <span class="keyword">extends</span> <span class="title class_">A4</span> <span class="keyword">implements</span> <span class="title class_">A5</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic3</span> <span class="variable">polymorphic3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示： Reference to &#x27;a&#x27; is ambiguous, both &#x27;A4.a&#x27; and &#x27;A5.a&#x27; match</span></span><br><span class="line">    System.out.println(polymorphic3.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A4</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4、例子4"><a href="#1-2-4、例子4" class="headerlink" title="1.2.4、例子4"></a><strong>1.2.4、例子4</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic9</span> <span class="keyword">extends</span> <span class="title class_">A15</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//结果为10</span></span><br><span class="line">    System.out.println(Polymorphic9.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A15</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、后期绑定"><a href="#二、后期绑定" class="headerlink" title="二、后期绑定"></a><strong>二、后期绑定</strong></h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a><strong>2.1、概念</strong></h3><p>在运行期，完成后期绑定。<br><font color='red'>后期绑定只针对“一般方法”成员，因此只有“实例对象访问成员”形式的后期绑定。</font><br>后期绑定描述：</p>
<ul>
<li><font color='red'>需要特别注意的是</font>，在后期绑定之前已经完成了前期绑定，如果后期绑定未作重新绑定，则使用前期绑定的结果</li>
<li>确定实例对象对应的实际Java类，基于该实际Java类的实际定义查找<font color='red'>覆盖</font>欲访问一般方法的方法</li>
<li>当该实际Java类的实际定义中含有0个匹配的候选项时，后期绑定未作重新绑定，使用前期绑定的结果，<font color='red'>运行不报错</font>；当该实际Java类的实际定义中含有大于0个匹配的候选项时，依据一定的策略进行选取绑定（笔者不在这里探讨详细的策略），比如“必须是非虚方法”，“原生一般方法优先级高于继承一般方法”等，如果由于“违反约束条件”等原因导致不能顺利选取绑定则后期绑定失败，运行报错，否则后期绑定成功，后期绑定作重新绑定</li>
</ul>
<h3 id="2-2、几个例子"><a href="#2-2、几个例子" class="headerlink" title="2.2、几个例子"></a><strong>2.2、几个例子</strong></h3><h4 id="2-2-1、例子1"><a href="#2-2-1、例子1" class="headerlink" title="2.2.1、例子1"></a><strong>2.2.1、例子1</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic4</span> <span class="keyword">extends</span> <span class="title class_">A6</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic4</span> <span class="variable">polymorphic4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为20</span></span><br><span class="line">    System.out.println(polymorphic4.f());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A6</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、例子2"><a href="#2-2-2、例子2" class="headerlink" title="2.2.2、例子2"></a><strong>2.2.2、例子2</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic5</span> <span class="keyword">extends</span> <span class="title class_">A8</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A7</span> <span class="variable">a7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic5</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为30</span></span><br><span class="line">    System.out.println(a7.f());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A7</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A8</span> <span class="keyword">extends</span> <span class="title class_">A7</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3、例子3"><a href="#2-2-3、例子3" class="headerlink" title="2.2.3、例子3"></a><strong>2.2.3、例子3</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A9</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic6</span> <span class="keyword">extends</span> <span class="title class_">A10</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic6</span> <span class="variable">polymorphic6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic6</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为30</span></span><br><span class="line">    System.out.println(polymorphic6.f());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A10</span> <span class="keyword">implements</span> <span class="title class_">A9</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4、例子4"><a href="#2-2-4、例子4" class="headerlink" title="2.2.4、例子4"></a><strong>2.2.4、例子4</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic7</span> <span class="keyword">extends</span> <span class="title class_">A11</span> <span class="keyword">implements</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic7</span> <span class="variable">polymorphic7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Polymorphic7</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为30</span></span><br><span class="line">    System.out.println(polymorphic7.f());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A11</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5、例子5"><a href="#2-2-5、例子5" class="headerlink" title="2.2.5、例子5"></a><strong>2.2.5、例子5</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Polymorphic8</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Polymorphic8</span> <span class="variable">polymorphic8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A13</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为40</span></span><br><span class="line">    System.out.println(polymorphic8.f());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果为30</span></span><br><span class="line">    <span class="type">A13</span> <span class="variable">a13</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A13</span>();</span><br><span class="line">    System.out.println(a13.f());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A13</span> <span class="keyword">extends</span> <span class="title class_">Polymorphic8</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 未继承覆盖Polymorphic8中的“int f()”方法，因此关于该一般方法无后期绑定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br/>
综上，多态的本质为：访问“一般方法”成员，后期绑定可以改变前期绑定的结果。
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多模块Maven项目</title>
    <url>/blog/2018/10/24/%E5%A4%9A%E6%A8%A1%E5%9D%97Maven%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="一、父模块和子模块"><a href="#一、父模块和子模块" class="headerlink" title="一、父模块和子模块"></a><strong>一、父模块和子模块</strong></h2><p>父模块视角：被子模块继承依赖，知晓继承关系<br>子模块视角：跟非“多模块Maven项目”一致，完全独立的模块</p>
<h2 id="二、单独发布父模块"><a href="#二、单独发布父模块" class="headerlink" title="二、单独发布父模块"></a><strong>二、单独发布父模块</strong></h2><p>增加“-N”选项，即<code>mvn -N</code>。</p>
<h2 id="三、多模块Maven项目版本便捷管理"><a href="#三、多模块Maven项目版本便捷管理" class="headerlink" title="三、多模块Maven项目版本便捷管理"></a><strong>三、多模块Maven项目版本便捷管理</strong></h2><p>使用“Versions”插件可便捷管理多模块Maven项目的版本配置，详见<a href="http://www.mojohaus.org/versions-maven-plugin/index.html">Versions Maven Plugin</a>。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>如何获取执行脚本所在目录的绝对路径</title>
    <url>/blog/2018/11/28/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><strong>1、方式1</strong><br>获取得到绝对路径，且解析遇到的软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORK_DIR=$(dirname $(readlink -f $0))</span><br></pre></td></tr></table></figure>

<p><strong>2、方式2</strong><br>获取得到绝对路径，不解析遇到的软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORK_DIR=$(dirname $0)</span><br><span class="line">cd $WORK_DIR</span><br><span class="line">WORK_DIR=$(pwd)</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]https://blog.csdn.net/qq_18150497/article/details/76600828
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>婴儿哭的应对</title>
    <url>/blog/2018/06/21/%E5%A9%B4%E5%84%BF%E5%93%AD%E7%9A%84%E5%BA%94%E5%AF%B9/</url>
    <content><![CDATA[<p>婴儿表达需求的唯一途径就是“哭”，因此，只有了解“哭”背后的需求，才能有效应对“哭”。</p>
<table>
<thead>
<tr>
<th>需求</th>
<th>表现特征</th>
<th>应对</th>
</tr>
</thead>
<tbody><tr>
<td>饿</td>
<td>哭的时间较有规律，小嘴做出吮吸的动作</td>
<td>喂奶</td>
</tr>
<tr>
<td>困</td>
<td>哭的同时打哈欠</td>
<td>安抚哄睡</td>
</tr>
<tr>
<td>撒尿&#x2F;拉屎</td>
<td>&#x2F;</td>
<td>换尿不湿</td>
</tr>
<tr>
<td>热了&#x2F;冷了</td>
<td>&#x2F;</td>
<td>降低环境温度&#x2F;提升环境温度</td>
</tr>
<tr>
<td>体温升高（发烧，打疫苗免疫反应等导致）</td>
<td>&#x2F;</td>
<td>多喝水，物理降温，安抚</td>
</tr>
<tr>
<td>撒娇</td>
<td>&#x2F;</td>
<td>安抚</td>
</tr>
<tr>
<td>打嗝&#x2F;胀气</td>
<td>&#x2F;</td>
<td>拍嗝</td>
</tr>
</tbody></table>
<br/>
参考文献：
[1]https://yuer.pcbaby.com.cn/318/3187425.html
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>育儿</category>
      </categories>
      <tags>
        <tag>哭</tag>
      </tags>
  </entry>
  <entry>
    <title>存储设备</title>
    <url>/blog/2019/06/06/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="一、存储设备分类"><a href="#一、存储设备分类" class="headerlink" title="一、存储设备分类"></a><strong>一、存储设备分类</strong></h2><p>存储设备包括有：“硬盘”、“内存”、“寄存器”、“缓存”和“缓冲”等。需要注意的是，有些存储设备常被归类到其他类别，比如“寄存器归类到CPU”，“CPU&#x2F;CPU核内高速缓存归类到CPU”，“磁盘写缓冲区归类到磁盘”，但从本质上来说，它们的确属于存储设备。</p>
<h3 id="1-1、硬盘"><a href="#1-1、硬盘" class="headerlink" title="1.1、硬盘"></a><strong>1.1、硬盘</strong></h3><p>可分为：机械硬盘，固态硬盘。</p>
<h3 id="1-2、内存"><a href="#1-2、内存" class="headerlink" title="1.2、内存"></a><strong>1.2、内存</strong></h3><p>内存的特点是“成本小于高速缓存大于硬盘，容量大于高速缓存小于硬盘，速度小于高速缓存大于硬盘”。</p>
<h3 id="1-3、寄存器"><a href="#1-3、寄存器" class="headerlink" title="1.3、寄存器"></a><strong>1.3、寄存器</strong></h3><p>位于CPU。</p>
<h3 id="1-4、缓存和缓冲"><a href="#1-4、缓存和缓冲" class="headerlink" title="1.4、缓存和缓冲"></a><strong>1.4、缓存和缓冲</strong></h3><p>缓存和缓冲的区别是：假如设备之间不存在存取速度鸿沟，那么缓存就没有存在的必要，比如当内存的存取速度跟高速缓存一样快时，高速缓存就没有存在的价值；但是缓冲在可预见的将来仍然具有存在的必要，因为时序请求流量天然需要进行整形，以延长目标设备的寿命。</p>
<h4 id="1-4-1、缓存"><a href="#1-4-1、缓存" class="headerlink" title="1.4.1、缓存"></a><strong>1.4.1、缓存</strong></h4><p>英文名：Cache。<br>用途：基于“时间局部性”和“空间局部性”原理，弥补高速设备和低速设备之间的存取速度鸿沟，提高存取速度。<br>常见实际应用：</p>
<ul>
<li>高速缓存，CPU Cache</li>
<li>TLB，Translation Lookaside Buffer，虽然英文名称中含有“Buffer”，但实际上却是一个为加快虚地址到物理地址转换过程的<code>缓存</code></li>
</ul>
<h4 id="1-4-2、缓冲"><a href="#1-4-2、缓冲" class="headerlink" title="1.4.2、缓冲"></a><strong>1.4.2、缓冲</strong></h4><p>英文名：Buffer。<br>用途：主要用于流量整形，即把突发大数量较小规模的I&#x2F;O整理成平稳小数量较大规模的I&#x2F;O，以减少对目标设备的请求次数。比如“写一份文件数据到磁盘，先将文件数据写到磁盘缓冲区，在满足一定条件（基于累积数据量或者基于时间周期）后，再将磁盘缓冲区内的数据写到磁盘，如果写一个字节就要直接写到磁盘，那么磁盘的寿命很快就会耗尽”，“消息队列本质上也可以认为是一个缓冲”。<br>常见实际应用：</p>
<ul>
<li>磁盘缓冲区</li>
<li>写缓冲器，Write Buffer，为提升CPU Cache一致性过程性能而引入</li>
</ul>
<h2 id="二、存储设备“成本”与“速度”关系"><a href="#二、存储设备“成本”与“速度”关系" class="headerlink" title="二、存储设备“成本”与“速度”关系"></a><strong>二、存储设备“成本”与“速度”关系</strong></h2><p>金字塔式存储设备成本与速度关系如图1所示。</p>
<p>图1<sup>[1]</sup></p>
<p><img src="https://blog.dslztx.top/imgs/20190606-0-0.png"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.itread01.com/content/1505138297.html">https://www.itread01.com/content/1505138297.html</a><br>[2]<a href="https://www.zhihu.com/question/26190832">https://www.zhihu.com/question/26190832</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>安装运行SSH Server</title>
    <url>/blog/2017/02/15/%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8CSSH-Server/</url>
    <content><![CDATA[<h2 id="一、安装运行SSH-Server"><a href="#一、安装运行SSH-Server" class="headerlink" title="一、安装运行SSH Server"></a><strong>一、安装运行SSH Server</strong></h2><p>SSH Server对应于“openssh-server”软件包。Ubuntu 16.04默认只安装“openssh-client”，而没有安装“openssh-server”，执行以下命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>
<p>执行以上命令安装“openssh-server”后，会自动运行SSH Server（主程序名称为“sshd”），此后也会开机自动运行。</p>
<h2 id="而、配置SSH-Server端的公钥"><a href="#而、配置SSH-Server端的公钥" class="headerlink" title="而、配置SSH Server端的公钥"></a><strong>而、配置SSH Server端的公钥</strong></h2><p>1、使用“ssh-keygen程序”生成一个公钥&#x2F;私钥对<br>2、将公钥内容追加导入到SSH Server端所在机器的“&#x2F;home&#x2F;欲登录用户名&#x2F;.ssh&#x2F;”目录下的“authorized_keys”文件中，文件内可以保存0到多个公钥内容<br>3、当客户机A想要登录该SSH Server的时候，凭借A所带的私钥和“authorized_keys”中的公钥是否匹配来进行验证</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>完整的Java类继承体系</title>
    <url>/blog/2018/03/27/%E5%AE%8C%E6%95%B4%E7%9A%84Java%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>根据前导叙述，本质上，“类”只包括“具体类和接口”两种，因此，完整的Java类继承体系分为3种：只包含具体类，只包含接口，包含具体类和接口。<br><font color='red'>具体类继承（<code>extends</code>）且只继承1个父具体类（除了<code>java.lang.Object</code>类，它是根具体类），可以继承（<code>implements</code>）0到多个接口；接口只能继承（<code>extends</code>）0到多个接口。</font></p>
<h2 id="一、只包含具体类"><a href="#一、只包含具体类" class="headerlink" title="一、只包含具体类"></a><strong>一、只包含具体类</strong></h2><p>完整的Java类继承体系示意图如图1。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20180317-0-1.svg"></p>
<h2 id="二、只包含接口"><a href="#二、只包含接口" class="headerlink" title="二、只包含接口"></a><strong>二、只包含接口</strong></h2><p>完整的Java类继承体系示意图如图2。</p>
<p>图2<br><img src="https://blog.dslztx.top/imgs/20180317-0-2.svg"></p>
<h2 id="三、包含具体类和接口"><a href="#三、包含具体类和接口" class="headerlink" title="三、包含具体类和接口"></a><strong>三、包含具体类和接口</strong></h2><p>完整的Java类继承体系示意图如图3。</p>
<p>图3<br><img src="https://blog.dslztx.top/imgs/20180317-0-3.svg"></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常使用Maven命令和选项</title>
    <url>/blog/2018/01/17/%E5%B8%B8%E4%BD%BF%E7%94%A8Maven%E5%91%BD%E4%BB%A4%E5%92%8C%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="一、“-N”选项"><a href="#一、“-N”选项" class="headerlink" title="一、“-N”选项"></a><strong>一、“-N”选项</strong></h2><p>子目录不递归进行。<br>比如在多模块项目中，当处于父项目时，执行<code>mvn -N install</code>命令，表示只发布（本地发布）父项目，而不递归进行子项目的发布。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>并发List</title>
    <url>/blog/2021/09/24/%E5%B9%B6%E5%8F%91List/</url>
    <content><![CDATA[<p>本文介绍并发List，有几点说明：</p>
<ul>
<li>其在Java容器中的划分位置见[1]</li>
<li>根接口为List，其内元素允许为<code>NULL</code></li>
<li>并发List的常见使用场景不太用到迭代器，故本文对迭代器不作深入叙述</li>
<li>并发List可被用于“生产者-消费者模型”，当然“生产者-消费者模型”最常使用并发Queue</li>
<li>接下来介绍其常见的3个子类：<ul>
<li>CopyOnWriteArrayList</li>
<li>Vector</li>
<li>SynchronizedList</li>
</ul>
</li>
</ul>
<br/>

<p>接下来对具体实现子类的介绍，主要基于以下几个维度：</p>
<ul>
<li>是否有界，分为“设计是否有界”和“实际是否有界”，实际有“设计有界，实际有界”，“设计无界，实际无界”和“设计无界，实际有界，可称为假性无界”这3种情况</li>
<li>底层数据结构基于“数组”，还是“链表”</li>
<li>实现操作的线程安全策略</li>
<li>生成的迭代器性质[1]</li>
</ul>
<h2 id="一、CopyOnWriteArrayList"><a href="#一、CopyOnWriteArrayList" class="headerlink" title="一、CopyOnWriteArrayList"></a><strong>一、CopyOnWriteArrayList</strong></h2><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际有界（在扩增数组时，目标大小如果大于等于<code>Integer.MAX_VALUE</code>，会抛出异常）</li>
<li>基于数组</li>
<li>对于修改操作使用<code>ReentrantLock lock</code>锁实现操作的线程安全，即会阻塞加锁，默认是一个“非公平锁”，具体实现修改的策略是“实例变量array指向底层元素对象数组，修改时首先将当下对应的元素对象数组复制到新元素对象数组，然后在新元素对象数组上进行修改操作，最后将array赋值为指向新元素对象数组”；对于读取操作，不加锁，始终基于array指向的当前元素对象数组。<font color='red'>综合以上两点，其适用场景如下：</font><ul>
<li>写少读多</li>
<li>集合不大，否则复制操作较为耗时</li>
<li>实时性要求不高，因为读取时可能读取到旧元素对象数组</li>
</ul>
</li>
<li>生成特殊的“快照式”迭代器，其特殊性体现在：一般的“快照式”迭代器在生成迭代器时复制内容，而它在生成迭代器时不进行复制而是直接指向原内容，等到后续CopyOnWriteArrayList实例进行修改操作如上所述指向新内容时，它指向的内容才与CopyOnWriteArrayList实例指向的内容被动完成脱钩</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
<li><code>E[] toCopyIn</code>：初始化元素来源集合</li>
</ul>
<h2 id="二、Vector"><a href="#二、Vector" class="headerlink" title="二、Vector"></a><strong>二、Vector</strong></h2><p>Vector有子类Stack，Stack中“栈数据结构”的方法（比如<code>push()</code>，<code>pop()</code>，<code>peek()</code>等）通过调用Vector的方法实现。</p>
<p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际有界</li>
<li>基于数组</li>
<li>使用<code>synchronized</code>实现读写时的线程安全，故属于<code>同步容器</code></li>
<li>生成“快速失败”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
<li><code>int initialCapacity</code>：初始容量大小</li>
<li><code>int capacityIncrement</code>：扩容增量大小</li>
</ul>
<h2 id="三、SynchronizedList"><a href="#三、SynchronizedList" class="headerlink" title="三、SynchronizedList"></a><strong>三、SynchronizedList</strong></h2><p><code>java.util.Collections</code>类中的内部类。</p>
<p><strong>1、核心原理</strong></p>
<ul>
<li>基于所传入的List实例，有界性也依赖于它</li>
<li>使用<code>synchronized</code>实现操作的线程安全，故属于<code>同步容器</code></li>
<li>生成所传入List实例的迭代器，故迭代器性质须具体情况具体分析</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>List&lt;E&gt; list</code>：SynchronizedList实例所基于的底层List实例，注意其跟“初始化元素来源集合”不一样，后者在复制后就不再有关联</li>
<li><code>Object mutex</code>：传入的锁对象</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/06/21/Java%E5%AE%B9%E5%99%A8/" title="Java容器">《Java容器》</a><br>[2]<a href="https://juejin.cn/post/6844903576339218440">https://juejin.cn/post/6844903576339218440</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发Map</title>
    <url>/blog/2021/12/04/%E5%B9%B6%E5%8F%91Map/</url>
    <content><![CDATA[<p>本文介绍并发Map，有几点说明：</p>
<ul>
<li>其在Java容器中的划分位置见[1]</li>
<li>根接口为Map，“键”和“键值”是否允许<code>NULL</code>值由具体实现子类决定</li>
<li>根接口为Map，它不像Collection接口继承Iterable接口，故本身没有<code>iterator()</code>方法获取迭代器，但是通过<code>Set&lt;K&gt; keySet()</code>，<code>Collection&lt;V&gt; values()</code>和<code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>方法获取到的3个视图的类型分别为<code>Set</code>，<code>Collection</code>和<code>Set</code>，它们属于Collection接口体系，有<code>iterator()</code>方法获取迭代器（迭代器类型跟具体实现相关），这些间接的迭代器在这里不是主要矛盾，因此本文不作介绍</li>
<li>接下来介绍其常见的三个子类：<ul>
<li>Hashtable</li>
<li>SynchronizedMap</li>
<li>ConcurrentHashMap</li>
</ul>
</li>
</ul>
<br/>

<p>接下来对具体实现子类的介绍，主要基于以下几个维度：</p>
<ul>
<li>“键”和“键值”是否允许<code>NULL</code>值</li>
<li>实现映射表的核心机制，比如“节点数组+哈希”，“树”</li>
<li>实现操作的线程安全策略及该种线程安全策略下的并发性能</li>
</ul>
<h2 id="一、Hashtable"><a href="#一、Hashtable" class="headerlink" title="一、Hashtable"></a><strong>一、Hashtable</strong></h2><p>核心原理：</p>
<ul>
<li>“键”和“键值”都不允许<code>NULL</code>值</li>
<li>实现映射表的核心机制：基于“节点数组+哈希”</li>
<li>使用<code>synchronized</code>锁实现操作的线程安全，故属于<code>同步容器</code>。锁粒度为“整体”，所有并发操作（比如“put”，“remove”，“get”，“size”等）都要竞争同一把锁，并发性能较差</li>
</ul>
<br/>

<p>接下来主要介绍“哈希和碰撞”和“大小”两个问题。<font color='red'>需要说明的两点是：1）接下来的时间复杂度分析不考虑获取synchronized锁，如果考虑的话便会不可分析；2）“时间复杂度分析”跟“并发性能”属于两个维度</font>。</p>
<h3 id="1-1、哈希和碰撞"><a href="#1-1、哈希和碰撞" class="headerlink" title="1.1、哈希和碰撞"></a><strong>1.1、哈希和碰撞</strong></h3><p><strong>1、哈希算法</strong></p>
<ol>
<li>第一次哈希：键的<code>hashCode()</code>方法值</li>
<li>第二次哈希：其源代码为<code>hash &amp; 0x7FFFFFFF</code>（<code>hash</code>为第一次哈希的结果值），其含义是：去掉最高位1，避免第三次哈希出现“负数取余操作”情形</li>
<li>第三次哈希：本次哈希是为了散列到槽，其计算公式为<code>p % n</code>[假定节点数组大小为n，经过前两次哈希的结果值为p]</li>
</ol>
<p><strong>2、碰撞解决策略</strong><br>碰撞可通过“链地址法”解决，对应的链可称之为“碰撞冲突链”，假定链表的长度为K，此时增删改查的时间复杂度为<code>O(K)</code>。</p>
<h3 id="1-2、大小"><a href="#1-2、大小" class="headerlink" title="1.2、大小"></a><strong>1.2、大小</strong></h3><p>Hashtable涉及到两类大小：映射记录大小和节点数组大小。</p>
<h4 id="1-2-1、映射记录大小"><a href="#1-2-1、映射记录大小" class="headerlink" title="1.2.1、映射记录大小"></a><strong>1.2.1、映射记录大小</strong></h4><p>指Hashtable中映射记录数量，比如“节点数组大小为8，在且只在第3个节点（槽）有一个长度为4的链表（碰撞冲突链），则映射记录大小为4”：</p>
<ul>
<li>对应于实例成员变量<code>private transient int count</code></li>
<li>对应于实例成员方法<code>public synchronized int size()</code>的返回值（不考虑映射记录大小大于<code>Integer.MAX_VALUE</code>的情形），该方法直接返回成员变量<code>count</code>的值，因此时间复杂度是<code>O(1)</code></li>
</ul>
<h4 id="1-2-2、节点数组大小"><a href="#1-2-2、节点数组大小" class="headerlink" title="1.2.2、节点数组大小"></a><strong>1.2.2、节点数组大小</strong></h4><p>指Hashtable中节点数组大小，即成员变量<code> private transient Entry&lt;?,?&gt;[] table</code>的大小。</p>
<p>接下来介绍“初始化节点数组大小”和“扩容节点数组大小”，在介绍之前首先作以下几点说明：</p>
<ul>
<li>为简化描述和便于理解，不考虑极值大小的情况，比如<code>节点数组大小&gt;=MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)</code></li>
<li>成员变量<code>loadFactor</code>的语义是：负载因子，当<code>映射记录大小 &gt;= 节点数组大小*loadFactor</code>时扩容节点数组</li>
<li>成员变量<code>threshold</code>的语义是：<code>threshold=节点数组大小*loadFactor</code>，即<code>当映射记录大小 &gt;= threshold</code>时扩容节点数组</li>
</ul>
<h5 id="1-2-2-1、初始化"><a href="#1-2-2-1、初始化" class="headerlink" title="1.2.2.1、初始化"></a><strong>1.2.2.1、初始化</strong></h5><p>即时初始化。</p>
<p><strong>1、构造方法</strong><br>构造方法初始化节点数组，设置成员变量<code>loadFactor</code>和<code>threshold</code>的值，具体描述如下表。</p>
<table>
<thead>
<tr>
<th>构造方法\设置</th>
<th>节点数组初始化大小</th>
<th>loadFactor</th>
<th>threshold</th>
</tr>
</thead>
<tbody><tr>
<td><code>Hashtable(int initialCapacity, float loadFactor)</code></td>
<td>等于传入的<code>initialCapacity</code></td>
<td>等于传入的<code>loadFactor</code></td>
<td>等于<code>initialCapacity * loadFactor</code></td>
</tr>
<tr>
<td><code>Hashtable(int initialCapacity)</code></td>
<td>等于传入的<code>initialCapacity</code></td>
<td>等于默认的<code>0.75f</code></td>
<td>等于<code>initialCapacity * loadFactor</code></td>
</tr>
<tr>
<td><code>Hashtable()</code></td>
<td>等于默认的<code>11</code></td>
<td>等于默认的<code>0.75f</code></td>
<td>等于<code>initialCapacity * loadFactor</code></td>
</tr>
<tr>
<td><code>Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code></td>
<td>等于<code>max(2*t.size(), 11)</code></td>
<td>等于默认的<code>0.75f</code></td>
<td>等于<code>initialCapacity * loadFactor</code></td>
</tr>
</tbody></table>
<p><strong>有一点说明</strong>：后续可知，扩容操作十分耗费性能（申请新节点数组内存资源，对原映射记录进行rehash操作），因此在创建Hashtable实例时最好能够根据预估的“映射记录大小”预计算“节点数组的初始化大小”。由于当<code>映射记录大小 &gt;= 节点数组大小*loadFactor</code>时进行扩容，故为尽量避免扩容，须使得满足<code>节点数组大小 &gt; 映射记录大小/loadFactor</code>不等式，上述第4个构造方法中的<code>max(2*t.size(),11)</code>就是在<code>loadFactor</code>取常见默认值<code>0.75f</code>情况下符合该不等式的一个等式，我们自己在创建Hashtable实例时也应该使用该等式预计算传入的节点数组初始化大小。</p>
<h5 id="1-2-2-2、扩容"><a href="#1-2-2-2、扩容" class="headerlink" title="1.2.2.2、扩容"></a><strong>1.2.2.2、扩容</strong></h5><p>节点数组只有“扩容”，没有“收缩”，扩容条件为：<code>映射记录大小 &gt;= threshold</code>。</p>
<p>扩容过程描述如下：</p>
<ul>
<li>假定节点数组原大小为<code>N</code>，则扩容后大小为<code>M=N*2+1</code>。成员变量<code>threshold</code>的值为<code>M * loadFactor</code>（语义不变）</li>
<li>对原映射记录进行rehash操作</li>
</ul>
<h2 id="二、SynchronizedMap"><a href="#二、SynchronizedMap" class="headerlink" title="二、SynchronizedMap"></a><strong>二、SynchronizedMap</strong></h2><p><code>java.util.Collections</code>类中的内部类。</p>
<p><strong>1、核心原理</strong></p>
<ul>
<li>由所传入的Map实例，决定“键”和“键值”是否允许<code>NULL</code>值</li>
<li>由所传入的Map实例，确定实现映射表的核心机制</li>
<li>使用<code>synchronized</code>锁实现操作的线程安全，故属于<code>同步容器</code>。锁粒度为“整体”，所有并发操作（比如“put”，“remove”，“get”，“size”等）都要竞争同一把锁，并发性能较差</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Map&lt;K,V&gt; m</code>：SynchronizedMap实例所基于的底层Map实例，注意其跟“初始化元素来源集合”不一样，后者在复制后就不再有关联</li>
<li><code>Object mutex</code>：传入的锁对象</li>
</ul>
<h2 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a><strong>三、ConcurrentHashMap</strong></h2><p>详见<a href="/blog/2021/11/30/HashMap%E5%92%8CConcurrentHashMap/" title="HashMap和ConcurrentHashMap">《HashMap和ConcurrentHashMap》</a>博文中对ConcurrentHashMap的介绍。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/06/21/Java%E5%AE%B9%E5%99%A8/" title="Java容器">《Java容器》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发Set</title>
    <url>/blog/2021/09/29/%E5%B9%B6%E5%8F%91Set/</url>
    <content><![CDATA[<p>本文介绍并发Set，有几点说明：</p>
<ul>
<li>其在Java容器中的划分位置见[1]</li>
<li>根接口为Set，其内元素允许为<code>NULL</code></li>
<li>并发Set的常见使用场景不太用到迭代器，故本文对迭代器不作深入叙述</li>
<li><font color='red'>如果实在不行，可用并发Map实现并发Set的功能，只要将“键值”取为某个特殊值即可</font></li>
<li>接下来介绍其常见的两个子类：<ul>
<li>CopyOnWriteArraySet</li>
<li>SynchronizedSet</li>
</ul>
</li>
</ul>
<br/>

<p>接下来对具体实现子类的介绍，主要基于以下几个维度：</p>
<ul>
<li>是否有界，分为“设计是否有界”和“实际是否有界”，实际有“设计有界，实际有界”，“设计无界，实际无界”和“设计无界，实际有界，可称为假性无界”这3种情况</li>
<li>底层数据结构基于“数组”，还是“链表”</li>
<li>实现操作的线程安全策略</li>
<li>生成的迭代器性质[1]</li>
</ul>
<h2 id="一、CopyOnWriteArraySet"><a href="#一、CopyOnWriteArraySet" class="headerlink" title="一、CopyOnWriteArraySet"></a><strong>一、CopyOnWriteArraySet</strong></h2><p><strong>1、核心原理</strong></p>
<ul>
<li>基于<code>CopyOnWriteArrayList</code></li>
<li>有界性与<code>CopyOnWriteArrayList</code>一致</li>
<li>实现操作的线程安全策略借助于<code>CopyOnWriteArrayList</code></li>
<li>生成的迭代器就是所基于<code>CopyOnWriteArrayList</code>生成的迭代器</li>
<li>由于基于<code>CopyOnWriteArrayList</code>，所以其增删改查操作的时间复杂度劣于<code>HashSet</code></li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h2 id="二、SynchronizedSet"><a href="#二、SynchronizedSet" class="headerlink" title="二、SynchronizedSet"></a><strong>二、SynchronizedSet</strong></h2><p><code>java.util.Collections</code>类中的内部类。</p>
<p><strong>1、核心原理</strong></p>
<ul>
<li>基于所传入的Set实例，有界性也依赖于它</li>
<li>使用<code>synchronized</code>实现操作的线程安全，故属于<code>同步容器</code></li>
<li>生成所传入Set实例的迭代器，故迭代器性质须具体情况具体分析</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Set&lt;E&gt; s</code>：SynchronizedSet实例所基于的底层Set实例，注意其跟“初始化元素来源集合”不一样，后者在复制后就不再有关联</li>
<li><code>Object mutex</code>：传入的锁对象</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/06/21/Java%E5%AE%B9%E5%99%A8/" title="Java容器">《Java容器》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发Queue</title>
    <url>/blog/2021/08/11/%E5%B9%B6%E5%8F%91Queue/</url>
    <content><![CDATA[<p>本文介绍并发Queue，有几点说明：</p>
<ul>
<li>其在Java容器中的划分位置见[1]</li>
<li>根接口为Queue，Queue接口文档声明其内元素不得为<code>NULL</code>（<code>NULL</code>用作特殊含义，比如“当队列为空时，调用<code>poll()</code>方法返回<code>NULL</code>”），故并发Queue内的元素也不得为<code>NULL</code></li>
<li>并发Queue的常见使用场景不太用到迭代器，故本文对迭代器不作深入叙述</li>
<li>并发Queue常用于“生产者-消费者模型”，当然“生产者-消费者模型”也可以不用并发Queue，比如还可以用并发List，Disruptor[2]等</li>
</ul>
<p>接下来主要介绍并发Queue的常见实现类，分为两类：“阻塞队列”和“非阻塞队列”。</p>
<p>这里的“阻塞”有两个维度的语义：</p>
<ul>
<li>实现操作线程安全时是否阻塞</li>
<li>是否有“队列满时，添加元素失败阻塞”的“添加元素”阻塞方法<code>offer(E e, long timeout, TimeUnit unit)/put(E e)</code>；是否有“队列空时，获取且移除队首元素失败阻塞”的“获取且移除队首元素”阻塞方法<code>poll(long timeout, TimeUnit unit)/take()</code></li>
</ul>
<p>“阻塞队列”和“非阻塞队列”在以上两个维度的表现如下表。</p>
<table>
<thead>
<tr>
<th>并发Queue\语义</th>
<th>实现线程安全时是否阻塞</th>
<th>是否有<code>offer(E e, long timeout, TimeUnit unit)/put(E e)</code>阻塞方法；是否有<code>poll(long timeout, TimeUnit unit)/take()</code>阻塞方法</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞队列</td>
<td>阻塞</td>
<td>实现<code>offer(E e, long timeout, TimeUnit unit)/put(E e)</code>阻塞方法；实现<code>poll(long timeout, TimeUnit unit)/take()</code>阻塞方法</td>
</tr>
<tr>
<td>非阻塞队列</td>
<td>不阻塞</td>
<td>没有</td>
</tr>
</tbody></table>
<h2 id="一、阻塞队列"><a href="#一、阻塞队列" class="headerlink" title="一、阻塞队列"></a><strong>一、阻塞队列</strong></h2><h3 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a><strong>1.1、基本介绍</strong></h3><p>额外继承实现BlockingQueue接口。</p>
<p>Queue接口主要有“添加元素”，“获取且移除队首元素”和“获取队首元素”三个方法家族，额外继承实现BlockingQueue接口，则引入了分别属于“添加元素”和“获取且移除队首元素”两个方法家族的<code>offer(E e, long timeout, TimeUnit unit)/put(E e)</code>和<code>poll(long timeout, TimeUnit unit)/take()</code>方法。</p>
<p>对BlockingQueue接口的三个方法家族进行混淆阐明，具体如下表：</p>
<table>
<thead>
<tr>
<th>方法\失败处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞（响应中断）</th>
<th>阻塞指定时间（响应中断），超时退出返回特殊值；否则返回正常值</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td><code>add(E e)</code></td>
<td><code>offer(E e)</code></td>
<td><code>put(E e)</code></td>
<td><code>offer(E e,long timeout,TimeUnit unit)</code></td>
</tr>
<tr>
<td>获取且移除队首元素</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(long timeout,TimeUnit unit)</code></td>
</tr>
<tr>
<td>获取队首元素</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：</p>
<ul>
<li>注意<code>remove()</code>方法和<code>remove(Object o)</code>方法的区别</li>
</ul>
<h3 id="1-2、具体实现子类"><a href="#1-2、具体实现子类" class="headerlink" title="1.2、具体实现子类"></a><strong>1.2、具体实现子类</strong></h3><p>BlockingQueue接口的常见实现类如下，类继承结构图如图1：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue</li>
<li>DelayedWorkQueue</li>
<li>PriorityBlockingQueue</li>
<li>LinkedBlockingDeque</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
</ul>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20210811-0-0.svg"></p>
<br/>

<p>对接下来的具体实现子类介绍，主要基于以下几个维度：</p>
<ul>
<li>是否有界，分为“设计是否有界”和“实际是否有界”，实际有“设计有界，实际有界”，“设计无界，实际无界”和“设计无界，实际有界，可称为假性无界”这3种情况。设计无界有个特点就是<code>remainingCapacity()</code>方法恒返回<code>Integer.MAX_VALUE</code></li>
<li>底层数据结构基于“数组”，还是“链表”，或是“堆（堆的实现最终仍然基于数组&#x2F;链表）”</li>
<li>实现操作的线程安全策略</li>
<li>实现“添加元素”和“获取且移除队首元素”阻塞方法的策略</li>
<li>生成的迭代器性质[1]</li>
</ul>
<h4 id="1-2-1、ArrayBlockingQueue"><a href="#1-2-1、ArrayBlockingQueue" class="headerlink" title="1.2.1、ArrayBlockingQueue"></a><strong>1.2.1、ArrayBlockingQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计有界，实际有界</li>
<li>基于循环数组</li>
<li>使用<code>ReentrantLock lock</code>实现操作的线程安全，即会阻塞，默认是一个“非公平锁”，根据构造参数可显式指定是“公平锁”，还是“非公平锁”</li>
<li>使用<code>Condition notFull</code>和<code>Condition notEmpty</code>分别实现<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>和<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“弱一致性”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>int capacity</code>：队列容量</li>
<li><code>boolean fair</code>：显式指定<code>ReentrantLock lock</code>对应的锁是“公平锁”还是“非公平锁”，默认是“非公平锁”</li>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="1-2-2、LinkedBlockingQueue"><a href="#1-2-2、LinkedBlockingQueue" class="headerlink" title="1.2.2、LinkedBlockingQueue"></a><strong>1.2.2、LinkedBlockingQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计有界，实际有界</li>
<li>基于链表</li>
<li>使用<code>ReentrantLock takeLock</code>和<code>ReentrantLock putLock</code>实现操作的线程安全，即会阻塞，默认都是“非公平锁”</li>
<li>使用<code>Condition notFull</code>和<code>Condition notEmpty</code>分别实现<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>和<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“弱一致性”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>int capacity</code>：队列容量</li>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="1-2-3、DelayQueue"><a href="#1-2-3、DelayQueue" class="headerlink" title="1.2.3、DelayQueue"></a><strong>1.2.3、DelayQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际有界，故是“假性无界”</li>
<li>基于<code>PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;()</code>优先级队列实例，PriorityQueue是假性无界的，故DelayQueue也是假性无界的</li>
<li>使用<code>ReentrantLock lock</code>实现操作的线程安全，即会阻塞，默认是“非公平锁”</li>
<li>使用<code>Condition available</code>实现<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞；假性无界不需要考虑<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“快照式”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="1-2-4、DelayedWorkQueue"><a href="#1-2-4、DelayedWorkQueue" class="headerlink" title="1.2.4、DelayedWorkQueue"></a><strong>1.2.4、DelayedWorkQueue</strong></h4><p>ScheduledThreadPoolExecutor类的静态内部类。</p>
<p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际有界，故是“假性无界”</li>
<li>基于数组实现的堆</li>
<li>使用<code>ReentrantLock lock</code>实现操作的线程安全，即会阻塞，默认是“非公平锁”</li>
<li>使用<code>Condition available</code>实现<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞；假性无界不需要考虑<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“快照式”迭代器</li>
</ul>
<p><strong>2、构造参数</strong><br>无</p>
<h4 id="1-2-5、PriorityBlockingQueue"><a href="#1-2-5、PriorityBlockingQueue" class="headerlink" title="1.2.5、PriorityBlockingQueue"></a><strong>1.2.5、PriorityBlockingQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际有界，故是“假性无界”</li>
<li>基于数组实现的堆</li>
<li>使用<code>ReentrantLock lock</code>实现操作的线程安全，即会阻塞，默认是“非公平锁”</li>
<li>使用<code>Condition notEmpty</code>实现<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞；假性无界不需要考虑<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“快照式”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>int initialCapacity</code>：队列<font color='red'>初始容量</font></li>
<li><code>Comparator&lt;? super E&gt; comparator</code>：堆内元素比较所基于的比较器</li>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="1-2-6、LinkedBlockingDeque"><a href="#1-2-6、LinkedBlockingDeque" class="headerlink" title="1.2.6、LinkedBlockingDeque"></a><strong>1.2.6、LinkedBlockingDeque</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计有界，实际有界</li>
<li>基于链表</li>
<li>使用<code>ReentrantLock lock</code>实现操作的线程安全，即会阻塞，默认是“非公平锁”</li>
<li>使用<code>Condition notFull</code>和<code>Condition notEmpty</code>分别实现<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>和<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“弱一致性”迭代器</li>
<li>另外继承实现<code>BlockingDeque</code>接口，对于本文来说不是重点，不作叙述</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>int capacity</code>：队列容量</li>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="1-2-7、SynchronousQueue"><a href="#1-2-7、SynchronousQueue" class="headerlink" title="1.2.7、SynchronousQueue"></a><strong>1.2.7、SynchronousQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计有界，实际有界，容量为0（其实背后的支撑列表设计和实际都为无界）</li>
<li>基于链表。但与<code>LinkedBlockingQueue</code>和<code>LinkedBlockingDeque</code>不同，链表节点既包含“元素内容信息”，也包含“操作类型信息”</li>
<li>使用<code>CAS自旋 + LockSupport.parkNanos/park</code>阻塞实现操作的线程安全，可广义认为是<code>CAS自旋阻塞锁</code>（与[3]中的<code>CAS自旋锁</code>不同，后者没有阻塞，两者的相同之处在于都是广义的锁），即会阻塞，此时无谓“公平锁还是非公平锁”</li>
<li>使用<code>LockSupport.parkNanos/park</code>实现<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞；使用<code>LockSupport.parkNanos/park</code>实现<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“空”迭代器</li>
<li>几个方法的行为见下表</li>
</ul>
<table>
<thead>
<tr><th>大方法</th><th>小方法</th><th>描述</th></tr>
</thead>

<tbody>
<tr><td rowspan=5>添加元素</td></tr>

<tr><td>add(E e)</td><td>如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回true；否则，添加元素失败，抛出异常</td></tr>
<tr><td>offer(E e)</td><td>如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回true；否则，添加元素失败，返回false</td></tr>
<tr><td>put(E e)</td><td>如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回；否则，往链表中添加一个表征“添加元素”操作的节点，阻塞直到被两两匹配</td></tr>
<tr><td>offer(E e,long timeout,TimeUnit unit)</td><td>如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回true；否则，往链表中添加一个表征“添加元素”操作的节点，阻塞指定时间，最终结果是：成功被两两匹配，添加元素成功，返回true；超时返回，添加元素失败，返回false</td></tr>


<tr><td rowspan=5>获取且移除队首元素</td></tr>
<tr><td>remove()</td><td>如果在链表中正好有一个表征“添加元素”操作的节点，两两匹配，获取且移除队首元素成功，返回队首元素，即表征“添加元素”操作节点对应的元素；否则，获取且移除队首元素失败，抛出异常</td></tr>
<tr><td>poll()</td><td>如果在链表中正好有一个表征“添加元素”操作的节点，两两匹配，获取且移除队首元素成功，返回队首元素，即表征“添加元素”操作节点对应的元素；否则，获取且移除队首元素失败，返回NULL</td></tr>
<tr><td>take()</td><td>如果在链表中正好有一个表征“添加元素”操作的节点，两两匹配，获取且移除队首元素成功，返回队首元素，即表征“添加元素”操作节点对应的元素；否则，往链表中添加一个表征“获取且移除队首元素”操作的节点，阻塞直到被两两匹配，被唤醒后返回匹配的队首元素</td></tr>
<tr><td>poll(long timeout,TimeUnit unit)</td><td>如果在链表中正好有一个表征“添加元素”操作的节点，两两匹配，获取且移除队首元素成功，返回队首元素，即表征“添加元素”操作节点对应的元素；否则，往链表中添加一个表征“获取且移除队首元素”操作的节点，阻塞指定时间，最终结果是：成功被两两匹配，被唤醒后返回匹配的队首元素；超时返回，获取且移除队首元素失败，返回NULL</td></tr>


<tr><td rowspan=3>获取队首元素</td></tr>
<tr><td>element()</td><td>抛出异常</td></tr>
<tr><td>peek()</td><td>返回NULL</td></tr>


<tr><td rowspan=5>其他</td></tr>
<tr><td>remove(Object o)</td><td>返回false，表示不存在这个元素，删除失败</td></tr>
<tr><td>size()</td><td>返回0</td></tr>
<tr><td>remainingCapacity()</td><td>返回0</td></tr>
<tr><td>iterator()</td><td>返回“空”迭代器</td></tr>

</tbody>
</table>


<p><strong>2、构造参数</strong></p>
<ul>
<li><code>boolean fair</code>：如果为true，表征“添加元素”&#x2F;“获取且移除队首元素”操作的节点操作顺序为“先进先出FIFO”，对应于源码中的TransferQueue数据结构；否则，节点操作顺序为“后进先出LIFO”，对应于源码中的TransferStack数据结构。需要注意的是，在源码中有提及TransferStack对应的顺序不定，怎么理解这个矛盾呢？其实本质上是讨论的范畴不同，有“节点操作”和“节点匹配”两个范畴，TransferQueue和TransferStack在两个范畴下的顺序描述如下表</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构\范畴</th>
<th>节点操作</th>
<th>节点匹配</th>
</tr>
</thead>
<tbody><tr>
<td>TransferQueue</td>
<td>FIFO</td>
<td>FIFO</td>
</tr>
<tr>
<td>TransferStack</td>
<td>LIFO</td>
<td>不定，比如“<code>PUT-A PUT-B GET（跟PUT-B匹配） PUT-C GET（跟PUT-C匹配） GET（跟PUT-A匹配）</code>匹配流并不是后入先匹配”</td>
</tr>
</tbody></table>
<h4 id="1-2-8、LinkedTransferQueue"><a href="#1-2-8、LinkedTransferQueue" class="headerlink" title="1.2.8、LinkedTransferQueue"></a><strong>1.2.8、LinkedTransferQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际无界</li>
<li>基于链表。但与<code>LinkedBlockingQueue</code>和<code>LinkedBlockingDeque</code>不同，链表节点既包含“元素内容信息”，也包含“操作类型信息”</li>
<li>使用<code>CAS自旋 + LockSupport.parkNanos/park</code>阻塞实现操作的线程安全，可广义认为是<code>CAS自旋阻塞锁</code>（与[3]中的<code>CAS自旋锁</code>不同，后者没有阻塞，两者的相同之处在于都是广义的锁），即会阻塞，此时无谓“公平锁还是非公平锁”</li>
<li>使用<code>LockSupport.parkNanos/park</code>实现<code>take()/poll(long timeout,TimeUnit unit)</code>阻塞方法的阻塞；无界不需要考虑<code>put(E e)/offer(E e,long timeout,TimeUnit unit)</code>阻塞方法的阻塞</li>
<li>生成“弱一致性”迭代器</li>
<li>由于是无界队列，调用<code>add(E e)/offer(E e)/put(E e)/offer(E e,long timeout,TimeUnit unit)</code>方法都会立即成功，另外有3个继承自<code>TransferQueue</code>接口的“添加元素”方法，这3个方法的行为与SynchronousQueue中“添加元素”方法的行为类似：<ul>
<li><code>transfer(E e)</code>，如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功；否则，往链表中添加一个表征“添加元素”操作的节点，阻塞直到被两两匹配</li>
<li><code>tryTransfer(E e)</code>，如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回true；否则，添加元素失败，返回false</li>
<li><code>tryTransfer(E e, long timeout, TimeUnit unit)</code>，如果在链表中正好有一个表征“获取且移除队首元素”操作的节点，两两匹配，添加元素成功，返回true；否则，往链表中添加一个表征“添加元素”操作的节点，阻塞指定时间，最终结果是：成功被两两匹配，添加元素成功，返回true；超时返回，添加元素失败，返回false</li>
</ul>
</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h3 id="1-3、总结"><a href="#1-3、总结" class="headerlink" title="1.3、总结"></a><strong>1.3、总结</strong></h3><h4 id="1-3-1、方法的时间复杂度分析"><a href="#1-3-1、方法的时间复杂度分析" class="headerlink" title="1.3.1、方法的时间复杂度分析"></a><strong>1.3.1、方法的时间复杂度分析</strong></h4><p>在时间复杂度分析中，对于ReentrantLock锁的获取操作，可予以忽略而进行正常分析，而对于CAS自旋阻塞锁的获取操作，难以忽略而不可分析。</p>
<table>
<thead>
<tr>
<th>方法家族</th>
<th>方法</th>
<th>ArrayBlockingQueue</th>
<th>LinkedBlockingQueue</th>
<th>DelayQueue</th>
<th>DelayedWorkQueue</th>
<th>PriorityBlockingQueue</th>
<th>LinkedBlockingDeque</th>
<th>SynchronousQueue</th>
<th>LinkedTransferQueue</th>
</tr>

</thead>
<tbody>
<tr><td rowspan=5>添加元素</td></tr>
<tr><td>add(E e)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td>offer(E e)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>

</tr>

<tr><td>put(E e)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>


<tr><td>offer(E e,long timeout,TimeUnit unit)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td rowspan=5>获取且移除队首元素</td></tr>

<tr><td>remove()</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td>poll()</td>

<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td>take()</td>

<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td>poll(long timeout,TimeUnit unit)</td>

<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>O(1)</td>
<td>/</td>
<td>/</td>
</tr>

<tr><td rowspan=3>获取队首元素</td></tr>
<tr><td>element()</td>

<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(N)</td>
</tr>
<tr><td>peek()</td>

<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(N)</td>
</tr>


<tr><td rowspan=5>其他</td></tr>
<tr><td>remove(Object o)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(1)</td>
<td>O(N)</td>

</tr>
<tr><td>size()</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(N)</TD>

</tr>
<tr><td>remainingCapacity()</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>

<tr><td>iterator()</td>
<td>O(1)，弱一致性</td>
<td>O(1)，弱一致性</td>
<td>O(N)，快照式</td>
<td>O(N)，快照式</td>
<td>O(N)，快照式</td>
<td>O(1)，弱一致性</td>
<td>O(1)，空</td>
<td>O(1)，弱一致性</td>


</tr>


</tbody>
</table>


<h4 id="1-3-2、常见选型"><a href="#1-3-2、常见选型" class="headerlink" title="1.3.2、常见选型"></a><strong>1.3.2、常见选型</strong></h4><p><strong>1、ArrayBlockingQueue vs LinkedBlockingQueue</strong><br>跟选型有关的主要差异有两点：</p>
<ul>
<li>并发性能。前者对于“添加元素”、“获取且移除队首元素”和“获取队首元素”等操作使用同一把锁，后者对于“添加元素”、“获取且移除队首元素”和“获取队首元素”等操作使用独立的两把锁，后者的并发性能好</li>
<li>前者提前分配好数组的固定内存，后者按需动态申请链表节点内存，当然元素对象本身的内存都是动态分配的</li>
</ul>
<h2 id="二、非阻塞队列"><a href="#二、非阻塞队列" class="headerlink" title="二、非阻塞队列"></a><strong>二、非阻塞队列</strong></h2><h3 id="2-1、基本介绍"><a href="#2-1、基本介绍" class="headerlink" title="2.1、基本介绍"></a><strong>2.1、基本介绍</strong></h3><p>不额外继承实现BlockingQueue接口。</p>
<p>Queue接口主要有“添加元素”，“获取且移除队首元素”和“获取队首元素”三个方法家族。</p>
<p>对Queue接口的三个方法家族进行混淆阐明，具体如下表：</p>
<table>
<thead>
<tr>
<th>方法\失败处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td><code>add(E e)</code></td>
<td><code>offer(E e)</code></td>
</tr>
<tr>
<td>获取且移除队首元素</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
</tr>
<tr>
<td>获取队首元素</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
</tr>
</tbody></table>
<p><strong>备注</strong>：</p>
<ul>
<li>注意<code>remove()</code>方法和<code>remove(Object o)</code>方法的区别</li>
</ul>
<h3 id="2-2、具体实现子类"><a href="#2-2、具体实现子类" class="headerlink" title="2.2、具体实现子类"></a><strong>2.2、具体实现子类</strong></h3><p>Queue接口的并发非阻塞常见实现类如下，类继承结构图如图2：</p>
<ul>
<li>ConcurrentLinkedDeque</li>
<li>ConcurrentLinkedQueue</li>
</ul>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20210811-0-1.svg"></p>
<p>对接下来的具体实现子类介绍，主要基于以下几个维度：</p>
<ul>
<li>是否有界，分为“设计是否有界”和“实际是否有界”，实际有“设计有界，实际有界”，“设计无界，实际无界”和“设计无界，实际有界，可称之为假性无界”这3种情况。设计无界有个特点就是<code>remainingCapacity()</code>方法恒返回<code>Integer.MAX_VALUE</code>，假性无界也是这个返回值</li>
<li>底层数据结构基于“数组”，还是“链表”，或是“堆（堆的实现最终仍然基于数组&#x2F;链表）”</li>
<li>实现操作线程安全的策略</li>
<li>实现“添加元素”和“获取且移除队首元素”阻塞方法的策略</li>
<li>生成的迭代器性质[1]</li>
</ul>
<h4 id="2-2-1、ConcurrentLinkedQueue"><a href="#2-2-1、ConcurrentLinkedQueue" class="headerlink" title="2.2.1、ConcurrentLinkedQueue"></a><strong>2.2.1、ConcurrentLinkedQueue</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际无界</li>
<li>基于链表</li>
<li>使用CAS自旋锁（注意是纯粹的CAS自旋锁，没有阻塞，跟上述的CAS自旋阻塞锁不一样）实现操作的线程安全，即不会阻塞，此时无谓“公平锁还是非公平锁”</li>
<li>没有“添加元素”和“获取且移除队首元素”的阻塞方法</li>
<li>生成“弱一致性”迭代器</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h4 id="2-2-2、ConcurrentLinkedDeque"><a href="#2-2-2、ConcurrentLinkedDeque" class="headerlink" title="2.2.2、ConcurrentLinkedDeque"></a><strong>2.2.2、ConcurrentLinkedDeque</strong></h4><p><strong>1、核心原理</strong></p>
<ul>
<li>设计无界，实际无界</li>
<li>基于链表</li>
<li>使用CAS自旋锁（注意是纯粹的CAS自旋锁，没有阻塞，跟上述的CAS自旋阻塞锁不一样）实现操作的线程安全，即不会阻塞，此时无谓“公平锁还是非公平锁”</li>
<li>没有“添加元素”和“获取且移除队首元素”的阻塞方法</li>
<li>生成“弱一致性”迭代器</li>
<li>另外继承实现<code>Deque</code>接口，对于本文来说不是重点，不作叙述</li>
</ul>
<p><strong>2、构造参数</strong></p>
<ul>
<li><code>Collection&lt;? extends E&gt; c</code>：初始化元素来源集合</li>
</ul>
<h3 id="2-3、总结"><a href="#2-3、总结" class="headerlink" title="2.3、总结"></a><strong>2.3、总结</strong></h3><h4 id="2-3-1、方法的时间复杂度分析"><a href="#2-3-1、方法的时间复杂度分析" class="headerlink" title="2.3.1、方法的时间复杂度分析"></a><strong>2.3.1、方法的时间复杂度分析</strong></h4><p>在时间复杂度分析中，对于CAS自旋锁的获取操作，难以忽略而不可分析。</p>
<table>
<thead>
<tr><th>大方法</th><th>小方法</th>
<th>ConcurrentLinkedQueue</th>
<th>ConcurrentLinkedDeque</th>
</tr>

</thead>
<tbody>
<tr><td rowspan=3>添加元素</td></tr>
<tr><td>add(E e)</td>
<td>/</td>
<td>/</td>
</tr>
<tr><td>offer(E e)</td>
<td>/</td>
<td>/</td>

</tr>

<tr><td rowspan=3>获取且移除队首元素</td></tr><tr><td>remove()</td><td>/</td><td>/</td></tr>
<tr><td>poll()</td>
<td>/</td>
<td>/</td>

</tr>

<tr><td rowspan=3>获取队首元素</td></tr>
<tr><td>element()</td>
<td>/</td>
<td>/</td>

</tr>
<tr><td>peek()</td>
<td>/</td>
<td>/</td>

</tr>


<tr><td rowspan=4>其他</td></tr>
<tr><td>remove(Object o)</td>
<td>/</td>
<td>/</td>

</tr>
<tr><td>size()</td>
<td>/</td>
<td>/</td>

</tr>
<tr><td>iterator()</td>
<td>O(1)，弱一致性</td>
<td>O(1)，弱一致性</td>


</tr>


</tbody>
</table>


<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/06/21/Java%E5%AE%B9%E5%99%A8/" title="Java容器">《Java容器》</a><br>[2]<a href="https://tech.meituan.com/2016/11/18/disruptor.html">https://tech.meituan.com/2016/11/18/disruptor.html</a><br>[3]<a href="/blog/2020/07/21/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%94%81/" title="原子操作与锁">《原子操作与锁》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发工具类</title>
    <url>/blog/2021/04/25/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="一、CountDownLatch"><a href="#一、CountDownLatch" class="headerlink" title="一、CountDownLatch"></a><strong>一、CountDownLatch</strong></h2><h3 id="1-1、语义和使用示例"><a href="#1-1、语义和使用示例" class="headerlink" title="1.1、语义和使用示例"></a><strong>1.1、语义和使用示例</strong></h3><p>对于CountDownLatch实例对象，构造时传入一个计数值<code>int count</code>：</p>
<ul>
<li>一般用法：调用<code>await()</code>和<code>await(long timeout, TimeUnit unit)</code>方法排队挂起，直到调用<code>count</code>次<code>countDown()</code>方法（每次调用<code>countDown()</code>方法，都会对计数值减1）</li>
<li>调用<code>await()</code>方法排队挂起，除了上述的正常退出机制，退出机制还有：“线程被中断，抛出InterruptedException异常”；调用<code>await(long timeout, TimeUnit unit)</code>方法排队挂起，除了上述的正常退出机制，退出机制还有：“设定的超时时间到期，返回false”或者“线程被中断，抛出InterruptedException异常”</li>
<li>当计数值已减为0，调用<code>countDown()</code>方法没有任何效果，调用<code>await()/await(long timeout, TimeUnit unit)</code>方法立即成功返回</li>
<li>不支持复位计数值进行新一轮使用</li>
</ul>
<p>一般用法使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="number">3</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>“1 2 3”和“4 5”的打印顺序不定，但是“1 2 3”的打印<font color='red'>必定先于</font>“4 5”。这个<font color='red'>必定先于</font>基于后续的“1.3、happens-before关系”小节，而不是根据“3个countDown()没执行之前，await()挂起，所以1 2 3在4 5之前”，因为“1 2 3理论上都可能重排序到countDown()后面，4 5先执行再执行1 2 3”。</p>
<h3 id="1-2、源码实现"><a href="#1-2、源码实现" class="headerlink" title="1.2、源码实现"></a><strong>1.2、源码实现</strong></h3><p>核心基于AQS实现，AQS的<code>state</code>字段被赋值为所传入的<code>count</code>值：</p>
<ul>
<li>调用<code>countDown()</code>方法，转发调用AQS的<code>releaseShared(1)</code>方法，见CountDownLatch.Sync中的<code>tryReleaseShared(int releases)</code>方法，可知这里的重载实现逻辑是：字段值减1，当减为0时，唤醒等待队列中的所有线程</li>
<li>调用<code>await()</code>方法，转发调用AQS的<code>acquireSharedInterruptibly(1)</code>方法，见CountDownLatch.Sync中的<code>tryAcquireShared(int acquires)</code>方法，可知这里的重载实现逻辑是：只有当<code>state</code>字段值为0时，表示成功；否则失败，挂起排队</li>
<li>调用<code>await(long timeout, TimeUnit unit)</code>方法，转发调用AQS的<code>tryAcquireSharedNanos(1, unit.toNanos(timeout))</code>方法，见CountDownLatch.Sync中的<code>tryAcquireShared(int acquires)</code>方法，可知这里的重载实现逻辑是：只有当<code>state</code>字段值为0时，表示成功；否则失败，挂起排队</li>
</ul>
<h3 id="1-3、happens-before关系"><a href="#1-3、happens-before关系" class="headerlink" title="1.3、happens-before关系"></a><strong>1.3、happens-before关系</strong></h3><p>存在一个happens-before关系：对于前<code>count</code>次对<code>state</code>字段成功减1的<code>countDown()</code>方法调用，其前面的操作 happens-before 于任何<code>await()/await(long timeout, TimeUnit unit)</code>方法调用成功返回后的操作。</p>
<p>JavaDoc原叙述是：<code>Memory consistency effects: Until the count reaches zero, actions in a thread prior to calling countDown() happen-before actions following a successful return from a corresponding await() in another thread.</code></p>
<p>几点说明：</p>
<ul>
<li>当<code>state</code>字段值为1时，并发调用两个<code>countDown()</code>方法，分别以A和B代指，假如A成功减1，那么此时B必然不能成功减1，此时A属于上述叙述中的<code>countDown()</code>方法调用，B不属于上述叙述中的<code>countDown()</code>方法调用</li>
<li>上述叙述中的“成功返回”指的是：<code>state</code>字段值为0返回，而不是设定的超时时间到期返回或者中断返回</li>
<li>除了上述情形，“调用<code>countDown()</code>方法之前的操作”和“调用<code>await()/await(long timeout, TimeUnit unit)</code>方法之后的操作”两者之间的happens-before关系不必然，须具体情况具体分析</li>
<li>主要基于<code>volatile变量</code>happens-before规则推导上述happens-before关系，<code>state</code>字段是一个volatile变量。详细证明可参见[1]</li>
</ul>
<h2 id="二、CyclicBarrier"><a href="#二、CyclicBarrier" class="headerlink" title="二、CyclicBarrier"></a><strong>二、CyclicBarrier</strong></h2><h3 id="2-1、语义和使用示例"><a href="#2-1、语义和使用示例" class="headerlink" title="2.1、语义和使用示例"></a><strong>2.1、语义和使用示例</strong></h3><p>对于CyclicBarrier实例对象，构造时传入一个计数值<code>int parties</code>，其使用有一个“轮”概念：</p>
<ul>
<li>一般用法，调用<code>await()/await(long timeout, TimeUnit unit)</code>方法，对本轮计数值减1，挂起直到“本轮计数值减为0”。本轮结束后会进入新一轮</li>
<li>在调用<code>await()/await(long timeout, TimeUnit unit)</code>方法时，除了上述正常退出机制，异常退出机制有：<ul>
<li>线程被中断，抛出InterruptedException异常，本轮被置为非法态</li>
<li>设定的超时时间到期，抛出TimeoutException异常，本轮被置为非法态</li>
<li>本轮已被置为非法态，则抛出BrokenBarrierException异常</li>
</ul>
</li>
<li>支持复位计数值进行新一轮使用</li>
<li>构造方法还支持传入一个<code>Runnable barrierAction</code>，在一轮中它只被调用执行1次，它的调用执行时机为：假定将本轮计数值减为0的执行<code>await()/await(long timeout, TimeUnit unit)</code>方法的线程为T，在T中，将本轮计数值减为0后，调用执行<code>barrierAction</code>的<code>run()</code>方法</li>
</ul>
<p>一般用法使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        barrier = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(N, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(i));</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ID-[&quot;</span> + id + <span class="string">&quot;] before&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ID-[&quot;</span> + id + <span class="string">&quot;] after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID-[0] before</span><br><span class="line">ID-[1] before</span><br><span class="line">ID-[3] before</span><br><span class="line">ID-[2] before</span><br><span class="line">ID-[4] before</span><br><span class="line">hello world</span><br><span class="line">ID-[4] after</span><br><span class="line">ID-[0] after</span><br><span class="line">ID-[1] after</span><br><span class="line">ID-[3] after</span><br><span class="line">ID-[2] after</span><br></pre></td></tr></table></figure>

<p>“ID-[0] before，ID-[1] before，ID-[2] before，ID-[3] before，ID-[4] before”的打印顺序不定，“ID-[0] after，ID-[1] after，ID-[2] after，ID-[3] after，ID-[4] after”的打印顺序也不定，但是有happens-before关系链：“ID-[0~4] before” –hb–&gt; “hello world” –hb–&gt; “ID-[0~4] after”。<font color='red'>这个关系链基于后续的“2.3、happens-before关系”小节</font>。</p>
<h3 id="2-2、源码实现"><a href="#2-2、源码实现" class="headerlink" title="2.2、源码实现"></a><strong>2.2、源码实现</strong></h3><p>基于ReentrantLock锁和其关联的Condition实例对象实现，核心方法是<code>dowait(boolean timed, long nanos)</code>。</p>
<p>详见<a href="https://github.com/dslztx/jdk8_study/blob/master/src/main/java/java/util/concurrent/CyclicBarrier.java">CyclicBarrier.java</a>源码文件内对<code>dowait(boolean timed, long nanos)</code>方法的注释。</p>
<h3 id="2-3、happens-before关系"><a href="#2-3、happens-before关系" class="headerlink" title="2.3、happens-before关系"></a><strong>2.3、happens-before关系</strong></h3><p>存在happens-before关系：</p>
<ul>
<li>一般使用情形中，即不抛出异常，包括“中断”和“超时”。当执行<code>await()/await(long timeout, TimeUnit unit)</code>方法的线程数量等于所传入的<code>parties</code>时，有一个happens-before关系链：所有<code>await()/await(long timeout, TimeUnit unit)</code>方法之前的操作 –hb–&gt; barrierAction实例对象的<code>run()</code>方法（如果barrierAction实例对象存在） –hb–&gt; 所有<code>await()/await(long timeout, TimeUnit unit)</code>方法之后的操作</li>
<li>在异常使用情形中，即会抛出异常，包括“中断”和“超时”。上述三者的happens-before关系不必然，须具体情况具体分析</li>
</ul>
<p>JavaDoc原叙述是：<code>Actions in a thread prior to calling await() happen-before actions that are part of the barrier action, which in turn happen-before actions following a successful return from the corresponding await() in other threads</code>。</p>
<p>证明过程如下。<br><strong>1、一般情形</strong><br>先做几个假定：</p>
<ul>
<li>在<code>dowait(boolean timed, long nanos)</code>核心方法中，<code>lock.lock();</code>处和<code>lock.unlock();</code>处的申请锁和释放锁操作分别以a和b代指，<code>trip.await();</code>处或者<code>nanos = trip.awaitNanos(nanos);</code>处所隐含的释放锁和申请锁操作分别以B和A代指。需要注意的是，在<a href="/blog/2021/04/02/AQS/" title="AQS">《AQS》</a>中我们知道，调用<code>await()/await(long time, TimeUnit unit)/awaitNano(long nanosTimeout)/awaitUntil(Date deadline)</code>后，如果立即中断，则不会进行隐含的释放锁和申请锁操作，但是这里是一般情形，无需考虑该种可能</li>
<li><code>N=传入的parties</code>，<code>N&gt;=1</code></li>
<li>线程数为TN</li>
<li>线程Tx调用<code>await()/await(long timeout, TimeUnit unit)</code>方法之前的操作以“Tx-ActionBefore”代指，之后的操作以“Tx-ActionAfter”代指</li>
<li>传入了<code>barrierAction</code>实例对象，以P代指</li>
</ul>
<p>证明如下：</p>
<ol start="0">
<li>当<code>N=1</code>时，<ul>
<li>如果<code>TN&lt;N</code>，即<code>TN=0</code>，无意义</li>
<li>如果<code>TN=N</code>，即<code>TN=1</code>，根据“程序顺序”happens-before规则，直接可证</li>
<li>如果<code>TN&gt;N</code>，每个调用都是新一轮，每轮根据“程序顺序”happens-before规则，简单可证</li>
</ul>
</li>
<li>当<code>N&gt;1</code>时，<ul>
<li>如果<code>TN&lt;N</code>，如果<code>TN=0</code>，无意义；如果<code>TN&gt;0</code>，则<code>await()/await(long timeout, TimeUnit unit)</code>方法调用恒挂起</li>
<li>如果<code>TN=N</code>，假定第一个在a获得锁的线程为T0，执行第N次<code>int index = --count;</code>代码的线程为Tn，则至此的申请锁和释放锁动作过程必然类似于<code>T0a T0B Tpa TpB Tqa TqB ... Tna</code>（如果考虑虚假唤醒，可能还存在形如<code>TjB TkA</code>过程，不影响证明，况且ReentrantLock类关联的Condition实例对象是AQS中的ConditionObject，实现不会出现虚假唤醒[2]），Tn继续执行，执行P，最后直到在<code>Tnb</code>释放锁，后续的申请锁和释放锁动作必然类似于<code>TgA Tgb ThA Thb TiA Tib ...</code>。现在对于任意两个线程Te和Tr，基于3个happens-before规则——“程序顺序”，“监视器锁”和“传递性”，结合上述锁申请和释放动作序列，总能构造出“Te-ActionBefore –hb–&gt; P –hb–&gt; Tr-ActionAfter”和“Tr-ActionBefore –hb–&gt; P –hb–&gt; Te-ActionAfter”关系链，故此得证</li>
<li>如果<code>TN&gt;N</code>，参照<code>TN=N</code>叙述，当Tn执行后，除了即将被唤醒的N-1个线程，其他线程执行进入新一轮，递归下去最后必然落于<code>TN&lt;N</code>或者<code>TN=N</code>情形</li>
</ul>
</li>
</ol>
<p><strong>2、异常情形</strong><br>在异常情形下没有必然的happens-before关系，须具体情况具体分析。<br>比如：</p>
<ul>
<li>当<code>TN=N&gt;1</code>，有线程T1和T2，T1调用<code>await()/await(long timeout, TimeUnit unit)</code>方法时直接抛出异常，T1退出上述方法后，T2才运行，根据3个happens-before规则——“程序顺序”，“监视器锁”和“传递性”，有“T1-ActionBefore –hb–&gt; T2-ActionAfter”，没有“T2-ActionBefore –hb–&gt; T1-ActionAfter”，而且此时P未被调用执行</li>
</ul>
<h2 id="三、Semaphore"><a href="#三、Semaphore" class="headerlink" title="三、Semaphore"></a><strong>三、Semaphore</strong></h2><h3 id="3-1、语义和使用示例"><a href="#3-1、语义和使用示例" class="headerlink" title="3.1、语义和使用示例"></a><strong>3.1、语义和使用示例</strong></h3><p>对于Semaphore实例对象，构造时传入一个计数值<code>int permits</code>表征该信号量的许可证数量，构造时还允许传入<code>boolean fair</code>表征采用“非公平&#x2F;公平”分配策略，默认是“非公平”分配策略：</p>
<ul>
<li>一般用法：调用<code>acquire()</code>，<code>acquire(int permits)</code>，<code>acquireUninterruptibly()</code>，<code>acquireUninterruptibly(int permits)</code>方法排队挂起直到获得申请的<code>1/permits</code>个许可证；调用<code>release()</code>，<code>release(int permits)</code>方法释放<code>1/permits</code>个许可证</li>
<li>调用<code>acquire()</code>和<code>acquire(int permits)</code>方法除了上述正常的退出机制，还有退出机制：“线程被中断，抛出InterruptedException异常”；调用<code>acquireUninterruptibly()</code>和<code>acquireUninterruptibly(int permits)</code>方法只有上述正常的退出机制，没有“响应中断”退出机制</li>
<li>调用<code>tryAcquire()</code>和<code>tryAcquire(int permits)</code>方法尝试获取<code>1/permits</code>个许可证，无论获取成功与否，直接返回，获取时的策略恒为“非公平”策略，而不管生成Semaphore实例对象时选取的分配策略；调用<code>tryAcquire(long timeout, TimeUnit unit)</code>和<code>tryAcquire(int permits, long timeout, TimeUnit unit)</code>方法尝试获取<code>1/permits</code>个许可证，获取时的策略为生成Semaphore实例对象时选取的分配策略，成功则立即返回；否则排队挂起直到获取成功，或者“设定的超时时间到期”，或者“响应中断”</li>
</ul>
<p>一般用法使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化：当前有&quot;</span> + (<span class="number">3</span> - sp.availablePermits() + <span class="string">&quot;个并发&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO</span> <span class="operator">=</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取1个许可证</span></span><br><span class="line">                        sp.acquire();</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可证&quot;</span> + <span class="string">&quot;，剩余：&quot;</span> + sp.availablePermits());</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 释放1个许可证</span></span><br><span class="line">                        sp.release();</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span> + <span class="string">&quot;，剩余：&quot;</span> + sp.availablePermits());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(run, <span class="string">&quot;thread-&quot;</span> + index).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化：当前有0个并发</span><br><span class="line">thread-0获取许可证，剩余：2</span><br><span class="line">thread-1获取许可证，剩余：1</span><br><span class="line">thread-2获取许可证，剩余：0</span><br><span class="line">thread-0释放许可证，剩余：1</span><br><span class="line">thread-3获取许可证，剩余：0</span><br><span class="line">thread-1释放许可证，剩余：1</span><br><span class="line">thread-4获取许可证，剩余：0</span><br><span class="line">thread-2释放许可证，剩余：1</span><br><span class="line">thread-6获取许可证，剩余：0</span><br><span class="line">thread-3释放许可证，剩余：1</span><br><span class="line">thread-7获取许可证，剩余：0</span><br><span class="line">thread-4释放许可证，剩余：1</span><br><span class="line">thread-8获取许可证，剩余：0</span><br><span class="line">thread-6释放许可证，剩余：1</span><br><span class="line">thread-9获取许可证，剩余：0</span><br><span class="line">thread-7释放许可证，剩余：1</span><br><span class="line">thread-8释放许可证，剩余：2</span><br><span class="line">thread-5获取许可证，剩余：1</span><br><span class="line">thread-9释放许可证，剩余：2</span><br><span class="line">thread-5释放许可证，剩余：3</span><br></pre></td></tr></table></figure>

<h3 id="3-2、源码实现"><a href="#3-2、源码实现" class="headerlink" title="3.2、源码实现"></a><strong>3.2、源码实现</strong></h3><p>核心基于AQS实现：AQS的<code>state</code>字段被赋值为所传入的<code>permits</code>值：</p>
<ul>
<li>调用<code>acquire()</code>方法，转发调用AQS的<code>acquireSharedInterruptibly(1)</code>方法，然后分为两种情形：<ul>
<li>“公平策略”情形。判断是否获取成功的核心方法是Semaphore.FairSync中的<code>tryAcquireShared(int acquires)</code>方法，可知这里的重载实现逻辑是：当<code>state</code>字段值大于所需的许可证数量，表示成功；否则失败，挂起排队</li>
<li>“非公平策略”情形。判断是否获取成功的核心方法是Semaphore.NonfairSync中的<code>tryAcquireShared(int acquires)</code>方法，然后转发调用Semaphore.Sync中的<code>nonfairTryAcquireShared(int acquires)</code>方法，可知这里的重载实现逻辑是：当<code>state</code>字段值大于所需的许可证数量，表示成功；否则失败，挂起排队</li>
</ul>
</li>
<li>调用<code>release()</code>方法，转发调用AQS的<code>releaseShared(1)</code>方法，没有“公平&#x2F;非公平”策略之分，最后都转发到Semaphore.Sync中的<code>tryReleaseShared(int releases)</code>方法，可知这里的重载实现逻辑是：<code>state</code>字段值增加归还的许可证数量值</li>
<li><code>acquire(int permits)</code>，<code>acquireUninterruptibly()</code>，<code>acquireUninterruptibly(int permits)</code>，<code>release(int permits)</code>，<code>tryAcquire()</code>，<code>tryAcquire(int permits)</code>，<code>tryAcquire(long timeout, TimeUnit unit)</code>和<code>tryAcquire(int permits, long timeout, TimeUnit unit)</code>方法的调用也都是转发到AQS，这里略</li>
</ul>
<h3 id="3-3、happens-before关系"><a href="#3-3、happens-before关系" class="headerlink" title="3.3、happens-before关系"></a><strong>3.3、happens-before关系</strong></h3><p><code>release</code>和<code>acquire/acquireUninterruptibly/tryAcquire</code>两类之间没有必然的happens-before关系，接下来讨论几种具体情形下的happens-before关系。</p>
<p>在许可证耗尽前提下，此时两类的happens-before关系分为3类：</p>
<ol start="0">
<li>对于<code>release()/release(int permits)</code>和<code>acquire()/acquire(int permits)/acquireUninterruptibly()/acquireUninterruptibly(int permits)</code>，<ul>
<li><code>acquire()/acquire(int permits)</code>是正常退出而不是中断退出，<code>acquireUninterruptibly()/acquireUninterruptibly(int permits)</code>只能是正常退出而不允许是中断退出。此时，调用<code>release()/release(int permits)</code>方法之前的操作 happens-before 于调用<code>acquire()/acquire(int permits)/acquireUninterruptibly()/acquireUninterruptibly(int permits)</code>方法之后的操作。JavaDoc中的原叙述<code>Memory consistency effects: Actions in a thread prior to calling a &quot;release&quot; method such as release() happen-before actions following a successful &quot;acquire&quot; method such as acquire() in another thread</code>其实指的就是这种情形</li>
<li><code>acquire()/acquire(int permits)</code>是中断退出。此时，两类之间没有必然的happens-before关系，须具体情况具体分析</li>
</ul>
</li>
<li>对于<code>release()/release(int permits)</code>和<code>tryAcquire(long timeout, TimeUnit unit)/tryAcquire(int permits, long timeout, TimeUnit unit)</code>，<ul>
<li><code>tryAcquire(long timeout, TimeUnit unit)/tryAcquire(int permits, long timeout, TimeUnit unit)</code>是正常退出而不是中断或者超时退出。此时，调用<code>release()/release(int permits)</code>方法之前的操作 happens-before 于调用<code>tryAcquire(long timeout, TimeUnit unit)/tryAcquire(int permits, long timeout, TimeUnit unit)</code>方法之后的操作</li>
<li><code>tryAcquire(long timeout, TimeUnit unit)/tryAcquire(int permits, long timeout, TimeUnit unit)</code>是中断或者超时退出。此时，两类之间没有必然的happens-before关系，须具体情况具体分析</li>
</ul>
</li>
<li>对于<code>release()/release(int permits)</code>和<code>tryAcquire()/tryAcquire(int permits)</code>。此时，两类之间没有必然的happens-before关系，须具体情况具体分析</li>
</ol>
<p>一点说明：</p>
<ul>
<li>主要基于<code>volatile变量</code>happens-before规则推导上述happens-before关系，<code>state</code>字段是一个volatile变量。详细证明可参见[1]</li>
</ul>
<h2 id="四、Exchanger"><a href="#四、Exchanger" class="headerlink" title="四、Exchanger"></a><strong>四、Exchanger</strong></h2><h3 id="4-1、语义和使用示例"><a href="#4-1、语义和使用示例" class="headerlink" title="4.1、语义和使用示例"></a><strong>4.1、语义和使用示例</strong></h3><p>对于Exchanger实例对象：</p>
<ul>
<li>一般用法：两个线程调用<code>exchange()</code>方法，完成数据交互</li>
<li>允许多余2个的线程调用<code>exchange()</code>方法，但最终必然是一对线程完成真正的数据交换</li>
</ul>
<p>一般用法使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Exchanger</span> <span class="variable">exchanger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exchanger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                doExchangeWork(data1, exchanger);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                doExchangeWork(data1, exchanger);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doExchangeWork</span><span class="params">(String data1, Exchanger exchanger)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在把数据 &quot;</span> + data1 + <span class="string">&quot; 交换出去&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">            Thread.sleep((<span class="type">long</span>)(Math.random() * <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">data2</span> <span class="operator">=</span> (String)exchanger.exchange(data1); <span class="comment">// 2</span></span><br><span class="line">            </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;交换到数据  &quot;</span> + data2); <span class="comment">// 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种程序运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1正在把数据 Hello 交换出去</span><br><span class="line">T2正在把数据 World 交换出去</span><br><span class="line">T1交换到数据  World</span><br><span class="line">T2交换到数据  Hello</span><br></pre></td></tr></table></figure>


<p>“&#x2F;&#x2F;T1-1 &#x2F;&#x2F;T2-1”和“&#x2F;&#x2F;T1-3 &#x2F;&#x2F;T2-3”的执行顺序不定，但是“&#x2F;&#x2F;T1-1 &#x2F;&#x2F;T2-1”的执行<font color='red'>必定先于</font>“&#x2F;&#x2F;T1-3 &#x2F;&#x2F;T2-3”。这个<font color='red'>必定先于</font>基于后续的“4.3、happens-before关系”小节，而不是根据“在T1-2和T2-2没同时执行完之前，两者阻塞，故T1-1和T2-1先执行，再执行T1-2和T2-2，最后执行T1-3和T2-3”，因为“&#x2F;&#x2F;1理论上可能重排序到&#x2F;&#x2F;3后面，最后先执行T1-3和T2-3，再执行T1-1和T2-1”。</p>
<h3 id="4-2、源码实现"><a href="#4-2、源码实现" class="headerlink" title="4.2、源码实现"></a><strong>4.2、源码实现</strong></h3><p>核心流程是：</p>
<ul>
<li>并发竞争不激烈时，使用<code>Node slot</code>作为交换数据槽</li>
<li>并发竞争激烈时，使用<code>Node[] arena</code>作为交换数据槽集合</li>
</ul>
<p>对应核心流程的核心方法是<code>slotExchange()</code>和<code>arenaExchange()</code>。</p>
<p>详见<a href="https://github.com/dslztx/jdk8_study/blob/master/src/main/java/java/util/concurrent/Exchanger.java">Exchanger.java</a>源码文件内对<code>slotExchange()</code>和<code>arenaExchange()</code>方法的注释说明。</p>
<h3 id="4-3、happens-before关系"><a href="#4-3、happens-before关系" class="headerlink" title="4.3、happens-before关系"></a><strong>4.3、happens-before关系</strong></h3><p>对于执行<code>exchange</code>方法的两个线程T1和T2，两者之间存在happens-before关系：</p>
<ul>
<li>T1和T2的<code>exchange</code>不配对，两者之间没有必然的happens-before关系，须具体情况具体分析 </li>
<li>T1和T2的<code>exchange</code>配对，<ul>
<li>一般使用情形中，T1和T2成功返回，而不是“中断返回”或者“超时返回”，此时有：所有<code>exchange</code>方法之前的操作 happens-before 于所有<code>exchange</code>方法之后的操作。JavaDoc原叙述<code>For each pair of threads that successfully exchange objects via an Exchanger, actions prior to the exchange() in each thread happen-before those subsequent to a return from the corresponding exchange() in the other thread</code>其实指的就是这种情形</li>
<li>在异常使用情形中，至少1个线程是非成功返回，而是“中断返回”或者“超时返回”，此时T1和T2的配对关系不再成立，两者之间没有必然的happens-before关系，须具体情况具体分析</li>
</ul>
</li>
</ul>
<p>一点说明：</p>
<ul>
<li>主要基于<code>volatile变量</code>happens-before规则推导上述happens-before关系，对槽元素的CAS操作具有volatile变量内存语义[3]，<code>Node.match</code>字段是一个volatile变量，对其的读写当然具有volatile变量语义</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2021/04/02/Lock%E6%8E%A5%E5%8F%A3/" title="Lock接口">《Lock接口》</a>博文“2.1.2、源码实现”小节中对于ReentrantLock锁的happens-before规则证明<br>[2]<a href="/blog/2021/04/02/AQS/" title="AQS">《AQS》</a>博文“2、‘基于此处AQS实现的高级排他锁’情形”小节内容<br>[3]<a href="/blog/2020/07/29/Unsafe%E7%B1%BB/" title="Unsafe类">《Unsafe类》</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>开车</title>
    <url>/blog/2016/04/09/%E5%BC%80%E8%BD%A6/</url>
    <content><![CDATA[<p>开车主要有4个环节：启动，行驶，停入停车位和停止。</p>
<h2 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a><strong>一、启动</strong></h2><ol>
<li>踩住刹车</li>
<li>插入钥匙，点火</li>
<li>挂好档位（从停车档到行驶档）</li>
<li>松掉刹车</li>
</ol>
<h2 id="二、行驶"><a href="#二、行驶" class="headerlink" title="二、行驶"></a><strong>二、行驶</strong></h2><p>主要有以下几方面内容：控制方向盘，估算车身与分道线的距离，估算与前车的距离，判断是否能够变道而不与后来车相撞等。</p>
<h3 id="2-1、控制方向盘"><a href="#2-1、控制方向盘" class="headerlink" title="2.1、控制方向盘"></a><strong>2.1、控制方向盘</strong></h3><p>为了便于说明，首先对方向盘不同位置进行标记，如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160409-0-1.jpg"></p>
<p>很明显，方向盘控制模型可以简化为360度内方向盘控制模型，接下来是方向盘控制的几条原则：</p>
<ul>
<li>3点和9点是两个主着力点，这两个位置非常关键。左手要么不放，要么放在9点这个位置；同理，右手要么不放，要么就放在3点这个位置。千万注意，这里的3点，6点，9点，12点指代的是方向盘上处于初始状态下的绝对位置，不会随着方向盘的转动而变化。</li>
<li>方向盘控制的360度范围内，由于生理限制，不可能由双手控制转过180度角度，因而设定“一只手控制180度角度的转动，另外一只手控制另外180度角度的转动”，处于控制状态的手称为“控制手”，处于非控制状态的手称为“辅助手”，由“控制手”发力，“辅助手”只是用来作为安全保障。</li>
</ul>
<p>下面是一套确定“控制手”（确定了“控制手”自然就确定了“辅助手”）的逻辑规则：</p>
<ol>
<li>在方向盘处于0度，180度，负180度，360度，-360度状态时，确定“控制手”</li>
<li>当欲从左向右转时，左侧主着力点绑定的手成为“控制手”；当欲从右向左转时，右侧主着力点绑定的手成为“控制手”。比如方向盘处于0度状态时，欲从左向右转，此时9点是主着力点，9点绑定的手是左手，因而左手是“控制手”；当方向盘处于0度状态时，欲从右向左转，此时3点是主着力点，3点绑定的手是右手，因而右手是“控制手”。（当然也可以是另外一套相反的确定“控制手”的逻辑规则：当欲从左向右转时，右侧主着力点绑定的手成为“控制手”；当欲从右向左转时，左侧主着力点绑定的手成为“控制手”）<font color='red'>在实际中，只需要刚开始确定“控制手”，接下来“控制手”的确定会由于生理限制的存在而发生得很自然。</font></li>
</ol>
<h3 id="2-2、估算车身与分道线的距离"><a href="#2-2、估算车身与分道线的距离" class="headerlink" title="2.2、估算车身与分道线的距离"></a><strong>2.2、估算车身与分道线的距离</strong></h3><h3 id="2-3、估算与前车的距离"><a href="#2-3、估算与前车的距离" class="headerlink" title="2.3、估算与前车的距离"></a><strong>2.3、估算与前车的距离</strong></h3><h3 id="2-4、判断是否能够变道而不与后来车相撞"><a href="#2-4、判断是否能够变道而不与后来车相撞" class="headerlink" title="2.4、判断是否能够变道而不与后来车相撞"></a><strong>2.4、判断是否能够变道而不与后来车相撞</strong></h3><h2 id="三、停入停车位"><a href="#三、停入停车位" class="headerlink" title="三、停入停车位"></a><strong>三、停入停车位</strong></h2><h2 id="四、停止"><a href="#四、停止" class="headerlink" title="四、停止"></a><strong>四、停止</strong></h2><p>完全是“启动”环节的逆向操作。（注意跟“一、启动”的比照）：</p>
<ol>
<li>不要“松掉刹车”，就是“踩住刹车”</li>
<li>不要“挂好档位（从停车档到行驶档）”，就是“挂好档位（从行驶档到停车档）”</li>
<li>不要“插入钥匙，点火”，就是“拔出钥匙，熄火”</li>
<li>不要“踩住刹车”，就是“松掉刹车”</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://www.autohome.com.cn/use/201203/306279.html">http://www.autohome.com.cn/use/201203/306279.html</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>思维导图之JVM</title>
    <url>/blog/2022/01/04/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BJVM/</url>
    <content><![CDATA[<p>JVM：虚拟机。</p>
<h2 id="一、思维导图之JVM"><a href="#一、思维导图之JVM" class="headerlink" title="一、思维导图之JVM"></a><strong>一、思维导图之JVM</strong></h2><p><img src="https://blog.dslztx.top/imgs/20220104-0-0.svg"></p>
<h2 id="二、几点说明"><a href="#二、几点说明" class="headerlink" title="二、几点说明"></a><strong>二、几点说明</strong></h2><h3 id="2-1、JVM支持的语言"><a href="#2-1、JVM支持的语言" class="headerlink" title="2.1、JVM支持的语言"></a><strong>2.1、JVM支持的语言</strong></h3><p>JVM起初源于Java语言生态，彼时JVM只用于支持Java语言，随着演化，JVM支持越来越多的语言，比如“Scala”，“Groovy”，“Kotlin”等，这些语言可被统称为JVM语言，从而形成如下3层结构关系（借助于“字节码”这个中间层，JVM作为JVM语言的通用基础设施层）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java Scala Groovy Kotlin</span><br><span class="line"></span><br><span class="line">   Class字节码文件</span><br><span class="line"></span><br><span class="line">         JVM</span><br></pre></td></tr></table></figure>
<h3 id="2-2、JVM规范和实现"><a href="#2-2、JVM规范和实现" class="headerlink" title="2.2、JVM规范和实现"></a><strong>2.2、JVM规范和实现</strong></h3><p>讨论JVM时，需要区分“JVM规范”和“JVM实现”：</p>
<ul>
<li>JVM规范，参见<a href="https://docs.oracle.com/javase/specs/">链接</a>中的“The Java Virtual Machine Specification”</li>
<li>JVM实现，比如有“HotSpot”，“JRockit”和“IBM J9”等，一般指“HotSpot”</li>
</ul>
<p>对于介绍JVM的本系列博文，基于64位的JDK 8（其虚拟机实现是HotSpot），除非作特别说明。一个明确的JDK版本，明确了所遵循的JVM规范且是一个具体的JVM实现，比如“64位的JDK 1.8.0_301遵循JVM规范——《The Java Virtual Machine Specification-Java SE 8 Edition》，它是一个具体的JVM实现”，“64位的JDK 1.8.0_312遵循JVM规范——《The Java Virtual Machine Specification-Java SE 8 Edition》，它是一个具体的实现”。</p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>思维导图之Java并发</title>
    <url>/blog/2019/08/02/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BJava%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="一、思维导图之Java并发"><a href="#一、思维导图之Java并发" class="headerlink" title="一、思维导图之Java并发"></a><strong>一、思维导图之Java并发</strong></h2><p><img src="https://blog.dslztx.top/imgs/20190802-0-0.svg"></p>
<h2 id="二、并发源码阅读说明"><a href="#二、并发源码阅读说明" class="headerlink" title="二、并发源码阅读说明"></a><strong>二、并发源码阅读说明</strong></h2><p>阅读“源码”很难，阅读“并发源码”更难，因为“并发源码”相对“非并发源码”需要考虑更多细节，比如“以CAS自旋形式实现乐观锁”的并发源码。</p>
<h3 id="2-1、明确阅读目标"><a href="#2-1、明确阅读目标" class="headerlink" title="2.1、明确阅读目标"></a><strong>2.1、明确阅读目标</strong></h3><p>阅读“并发源码”时，首先须明确阅读目标：</p>
<ul>
<li>目标是“理解核心基本流程”，那么就没必要追究太多细节，比如“阅读AQS”，“阅读Exchanger”</li>
<li>目标是“彻底掌握”，那么就不只需要理解，也要追究清楚所有细节，即便需要花费很多时间和精力</li>
</ul>
<h3 id="2-2、具体阅读指南"><a href="#2-2、具体阅读指南" class="headerlink" title="2.2、具体阅读指南"></a><strong>2.2、具体阅读指南</strong></h3><p>并发源码阅读指南：阅读源码主体，需要考虑到“可见性”、“有序性”和“原子性”这3个问题，可使用语言提供的语义确保机制和隐含的内存屏障，比如：</p>
<ul>
<li>volatile关键词语义</li>
<li>final关键词语义</li>
<li>volatile变量写操作之前有LoadStore和StoreStore内存屏障</li>
<li>volatile变量读操作之后有LoadStore和LoadLoad内存屏障</li>
<li><font color='red'>happens-before规则，使用happens-before规则进行分析最简单，但小心不要踩“混用”的坑，可参见<a href="/blog/2019/12/17/happens-before%E8%A7%84%E5%88%99/" title="happens-before规则">《happens-before规则》</a>中的“5.1、例子1”小节</font></li>
</ul>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>思维导图之围棋</title>
    <url>/blog/2023/10/08/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E5%9B%B4%E6%A3%8B/</url>
    <content><![CDATA[<h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a><strong>一、思维导图</strong></h2><p><img src="https://blog.dslztx.top/imgs/20231009-1-0.svg"></p>
<h2 id="二、画棋谱"><a href="#二、画棋谱" class="headerlink" title="二、画棋谱"></a><strong>二、画棋谱</strong></h2><ol>
<li>棋谱文件格式为<code>Smart Game Format (SGF)</code>[1]</li>
<li>在线画棋谱[2]</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://en.wikipedia.org/wiki/Smart_Game_Format">https://en.wikipedia.org/wiki/Smart_Game_Format</a><br>[2]<a href="https://www.jeudego.org/maxiGos/_maxigos/_sample/?lang=en#edit">https://www.jeudego.org/maxiGos/_maxigos/_sample/?lang=en#edit</a></p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>思维导图之网络原理</title>
    <url>/blog/2024/02/06/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、思维导图之网络原理"><a href="#一、思维导图之网络原理" class="headerlink" title="一、思维导图之网络原理"></a><strong>一、思维导图之网络原理</strong></h2><p><img src="https://blog.dslztx.top/imgs/20230113-0-0.svg"></p>
<h2 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a><strong>二、说明</strong></h2><h3 id="2-1、重点在于协议、策略和算法，不在于硬件和软件"><a href="#2-1、重点在于协议、策略和算法，不在于硬件和软件" class="headerlink" title="2.1、重点在于协议、策略和算法，不在于硬件和软件"></a><strong>2.1、重点在于协议、策略和算法，不在于硬件和软件</strong></h3><p>重点在于协议、策略和算法，不在于硬件和软件，硬件和软件只是协议、策略和算法的落地载体，比如：</p>
<ul>
<li>个人计算机（硬件+软件）对网络协议、网络防火墙策略等的实现</li>
<li>交换机（硬件+软件）对网络协议、MAC地址学习算法等的实现</li>
<li>路由器（硬件+软件）对网络协议、路由算法等的实现</li>
<li>个人计算机（硬件+软件）上通过软件实现虚拟交换机和虚拟路由器</li>
<li>交换机（硬件+软件）实现数据帧转发可通过软件方式，也可通过专用硬件芯片方式，前者称为软转发，后者称为硬转发，后者转发性能大大优于前者</li>
</ul>
<h3 id="2-2、网络问题排查的最大原则"><a href="#2-2、网络问题排查的最大原则" class="headerlink" title="2.2、网络问题排查的最大原则"></a><strong>2.2、网络问题排查的最大原则</strong></h3><p>网络连接已然十分复杂，从源端A到目的端B的网络通路需要经过众多网络设备，但是一旦出现从A到B网络不通的情形，问题最大可能性还是出在离A较近的网络设备（比如“个人计算机网络策略配置有误”，“A的出口路由器的防火墙策略拒绝了某些网络连接”），因为离A越远的网络设备出现问题概率更小或者说出现问题被及时修复的概率更大。</p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>思维导图之计算机组成原理</title>
    <url>/blog/2019/06/02/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://blog.dslztx.top/imgs/20190602-0-0.svg"></p>
]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
  </entry>
  <entry>
    <title>性能调优导论</title>
    <url>/blog/2020/08/28/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="一、调优目标"><a href="#一、调优目标" class="headerlink" title="一、调优目标"></a><strong>一、调优目标</strong></h2><p>性能调优首先需要明确目标，性能调优目标一般由3部分组成：</p>
<ul>
<li>调优对象</li>
<li>调优范围</li>
<li>调优指标</li>
</ul>
<p>比如“降低Go进程的总体内存占用”，“降低Java进程某个偶发个例的RT”。</p>
<h3 id="1-1、调优对象"><a href="#1-1、调优对象" class="headerlink" title="1.1、调优对象"></a><strong>1.1、调优对象</strong></h3><p>比如：</p>
<ul>
<li>分布式系统</li>
<li>Java进程</li>
<li>Go进程</li>
<li>Rust进程</li>
<li>Linux系统</li>
</ul>
<h3 id="1-2、调优范围"><a href="#1-2、调优范围" class="headerlink" title="1.2、调优范围"></a><strong>1.2、调优范围</strong></h3><p>分为两种：</p>
<ul>
<li>总体，比如“总体TPS”</li>
<li>个体数据点，比如“一个请求的RT”</li>
</ul>
<h3 id="1-3、调优指标"><a href="#1-3、调优指标" class="headerlink" title="1.3、调优指标"></a><strong>1.3、调优指标</strong></h3><p>有常见的调优指标，也有自定义的调优指标。<br>比如：</p>
<ul>
<li>降低CPU</li>
<li>降低磁盘IO</li>
<li>降低网络IO</li>
<li>降低内存</li>
<li>降低RT</li>
<li>减少内部超时数和外部超时数</li>
<li>提升系统可用率</li>
<li>降低对MySQL的读写负载</li>
<li>降低对Redis的读写负载</li>
<li>降低对Dubbo服务的调用负载</li>
</ul>
<h2 id="二、具体手段"><a href="#二、具体手段" class="headerlink" title="二、具体手段"></a><strong>二、具体手段</strong></h2><p>具体手段分为两步：先“定位”，再“优化”。</p>
<h3 id="2-1、定位"><a href="#2-1、定位" class="headerlink" title="2.1、定位"></a><strong>2.1、定位</strong></h3><p>定位是性能调优的核心环节。</p>
<p>定位可分为3类：“事前”、“事中”和“事后”。关于这3者的描述见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>定位类别</th>
<th>步骤</th>
<th>使用工具&#x2F;组件</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>事前</td>
<td>预先进行日志埋点</td>
<td>除了“自实现埋点”之外可使用APM组件埋点。<font color='red'>埋点位置跟“具体调优指标”和“调优经验”有关</font></td>
<td>必能进行“事前”定位，灵活性差，因为只能记录预埋点相关日志</td>
</tr>
<tr>
<td>事中</td>
<td>保存现场信息，使用工具进行分析</td>
<td>使用工具进行分析，比如“对于Java进程，使用‘jstat’，‘jstack’，‘jmap+CAT’等工具进行分析”</td>
<td>一些性能调优场景不能进行“事中”定位；在能进行“事中”定位的性能调优场景中，“事中”定位，灵活性稍好，因为可使用工具灵活自由分析</td>
</tr>
<tr>
<td>事后</td>
<td>使用测试数据进行回放，在回放前可自定义埋点，可进行单步调试，可使用工具进行分析</td>
<td>使用工具进行分析，比如“对于Java进程，使用‘jstat’，‘jstack’，‘jmap+CAT’等工具进行分析”</td>
<td>一些性能调优场景不能进行“事后”定位；在能进行“事后”定位的性能调优场景中，“事后”定位，灵活性最好，因为可回放，自定义埋点，使用工具灵活自由分析，单步调试</td>
</tr>
</tbody></table>
<br/>

<p>总结来说：</p>
<ul>
<li>进行定位需要有大局观，即&#96;调优对象本身及所在环境都有可能影响调优指标，比如“在调优Java进程的RT时，Java进程本身、CPU、内存、IO、操作系统配置等都有可能影响RT”</li>
<li>对于“现场信息记录能力”，跟具体性能调优场景有关，比如“在小型简单系统中，3类定位也许都能够获取最完整的现场信息，而在大型复杂系统中，3类定位中可能只有“事后”定位能够最完整记录现场信息”</li>
<li>总结来看，“事前”、“事中”和“事后”定位能力没有强弱之分，各有所适应的性能调优场景，综合使用最佳。<font color='red'>但是也如上所述，在大型复杂的系统中，“事前”定位一般必不可少</font></li>
</ul>
<br/>

<p><strong>备注</strong>：</p>
<ul>
<li>APM组件，即“应用性能管理组件”，APM的英文全称为“Application Performance Management”。常见的APM组件有“Pinpoint”，“Zipkin”，“CAT”等</li>
</ul>
<h3 id="2-2、优化"><a href="#2-2、优化" class="headerlink" title="2.2、优化"></a><strong>2.2、优化</strong></h3><p>一般有两种方案：</p>
<ul>
<li>优化设计</li>
<li>优化算法和数据结构</li>
</ul>
<h2 id="三、事前定位-vs-监控报警"><a href="#三、事前定位-vs-监控报警" class="headerlink" title="三、事前定位 vs 监控报警"></a><strong>三、事前定位 vs 监控报警</strong></h2><p>“事前”定位是为了揭露问题的原因所在。<br>“传统的监控报警”是为了告警问题的存在，并不侧重于揭示问题的原因所在。</p>
<p>而我们在接收到报警之后，自然而然地期望能够快速定位到问题的原因所在，这就导致了“APM组件”和“监控报警组件”之间的界限越来越模糊，“APM组件”和“监控报警组件”大有合流之势。</p>
<h2 id="四、性能调优-vs-性能测试"><a href="#四、性能调优-vs-性能测试" class="headerlink" title="四、性能调优 vs 性能测试"></a><strong>四、性能调优 vs 性能测试</strong></h2><p>“性能调优”和“性能测试（比如使用‘JMeter’工具）”的异同点在于：“性能调优”在上线之后，而“性能测试”在上线之前进行；但是两者的“调优目标”和“具体手段”完全一致。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.zhihu.com/question/27994350">https://www.zhihu.com/question/27994350</a></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
  </entry>
  <entry>
    <title>总线</title>
    <url>/blog/2019/06/05/%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>总线的本质含义是：计算机各组成部件之间的数据或者指令通路。<br>总线的分类非常混乱，同时也在不断发展变化中，最主要是弄清楚准确的总线分类并没有多大价值，因此无需探求准确的总线分类。</p>
<p>基于不同角度的总线分类如下：</p>
<ul>
<li>数据总线，地址总线，控制总线</li>
<li>串行总线，并行总线</li>
<li>同步总线，异步总线</li>
<li>内部总线，外部总线</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>打造称手的工具链</title>
    <url>/blog/2017/08/08/%E6%89%93%E9%80%A0%E7%A7%B0%E6%89%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
    <content><![CDATA[<h2 id="一、电脑"><a href="#一、电脑" class="headerlink" title="一、电脑"></a><strong>一、电脑</strong></h2><ol>
<li>操作系统：Windows 7上安装VMware，VMware中安装Ubuntu。再安装VMware Tools，使得“客户机的屏幕分辨率可调整，客户机与宿主机之间可进行文件传输”等。VMware的“查看——自动调整大小”下勾选“自动适应客户机”。虚拟机设置中不勾选“加速3D图形”，否则虚拟机内屏幕易闪烁</li>
<li>生产力工具：Git，VIM，Tmux，ThunderBird（安装Nostalgy插件），Fcitx+谷歌拼音输入法，aria2c</li>
<li>浏览器：Chrome，SwitchyOmega，Surfingkeys，The Great Suspender，Adblock Plus</li>
<li>穿越火线：<a href="https://github.com/shadowsocksr-backup/shadowsocksr">ShadowSocksR</a></li>
<li>Java开发：JDK，Maven，IntelliJ IDEA</li>
<li>压缩工具：p7zip</li>
<li>学习工具：WPS，Pandoc</li>
<li>GTD工具：todo.txt</li>
</ol>
<h2 id="二、手机"><a href="#二、手机" class="headerlink" title="二、手机"></a><strong>二、手机</strong></h2><ol>
<li>操作系统：Android</li>
<li>通讯：TIM，微信（接收新邮件提醒），微信电话本</li>
<li>出行：曹操专车，滴滴出行，ofo共享单车，高铁管家，腾讯地图</li>
<li>资讯：蜻蜓FM</li>
<li>生产力工具：下厨房</li>
<li>系统工具：夸克浏览器，LBE安全大师，Nova桌面，QQ输入法，豌豆荚</li>
<li>学习工具：有道词典，WPS</li>
<li>休闲：网易云音乐，来吧停车</li>
<li>金融：招商银行，支付宝</li>
<li>穿越火线：<a href="http://shiyu.pro/archives/ssr-apk.html">ShadowSocksR-Android</a></li>
<li>其他：倒数日</li>
</ol>
<h2 id="三、打造过程"><a href="#三、打造过程" class="headerlink" title="三、打造过程"></a><strong>三、打造过程</strong></h2><h3 id="3-1、Java-IDE"><a href="#3-1、Java-IDE" class="headerlink" title="3.1、Java IDE"></a><strong>3.1、Java IDE</strong></h3><ul>
<li>相较于Eclipse：IntellJ IDEA功能更加强大完整；使用习惯更加符合人性；页面布局更加干净整洁</li>
</ul>
<h3 id="3-2、文本编辑器"><a href="#3-2、文本编辑器" class="headerlink" title="3.2、文本编辑器"></a><strong>3.2、文本编辑器</strong></h3><ul>
<li>相较于Emacs：VIM运行占用资源更少；操作更加灵活快捷且对小拇指伤害相对较小（Emacs需要大量使用快捷建，操作笨重且对小拇指伤害大，非常反人性）；VIM作为Linux下默认文本编辑器，直接掌握VIM，可大大节约学习成本</li>
<li>相较于Neovim：Neovim是VIM的分支，到现在为止还没有革命性的创新功能，故没有足够的吸引力驱动迁移</li>
<li>相较于Spacemacs：Spacemacs本质上是“Emacs+模仿VIM的配置”，完全就是杂牌，不伦不类</li>
</ul>
<h3 id="3-3、Linux操作系统"><a href="#3-3、Linux操作系统" class="headerlink" title="3.3、Linux操作系统"></a><strong>3.3、Linux操作系统</strong></h3><p>选择Ubuntu系操作系统，比如“Ubuntu，XUbuntu，KUbuntu，LUbuntu”等。</p>
<ul>
<li>相较于Debian系操作系统：Ubuntu系操作系统更加“开箱即用”</li>
</ul>
<h3 id="3-4、浏览器键盘化操作插件"><a href="#3-4、浏览器键盘化操作插件" class="headerlink" title="3.4、浏览器键盘化操作插件"></a><strong>3.4、浏览器键盘化操作插件</strong></h3><ul>
<li>相较于cVim和Vimium：Surfingkeys功能更加强大，不能处理的场景更少</li>
</ul>
<h3 id="3-5、GTD工具"><a href="#3-5、GTD工具" class="headerlink" title="3.5、GTD工具"></a><strong>3.5、GTD工具</strong></h3><ul>
<li>相较于Wunderlist：todo.txt基于文本，数据更易迁移，操作更灵活，功能更易扩展</li>
<li>相较于Emacs Org Mode：Emacs Org Mode基于Emacs，如上所述，Emacs的操作非常反人性，另外它只是作为GTD工具显得笨重，而todo.txt则显得灵活小巧</li>
</ul>
<br/>
**参考：**
[1]https://www.slant.co
[2]http://alternativeto.net
[3]http://www.wandoujia.com/award
[4]http://todotxt.com
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/blog/2018/08/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、排序算法总结"><a href="#一、排序算法总结" class="headerlink" title="一、排序算法总结"></a><strong>一、排序算法总结</strong></h2><table><thead><tr><th rowspan=2>排序算法</th><th colspan=3>时间复杂度</th><th rowspan=2>空间复杂度</th><th rowspan=2>稳定性</th><th rowspan=2>基本原理</th></tr><tr><th>最坏性能</th><th>最好性能</th><th>平均性能</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n&#42;n)</td><td>O(n)</td><td>O(n&#42;n)</td><td>O(1)</td><td>稳定</td><td>A[1...j]已经排好序，现在将A[j+1]插入到合适位置</td></tr><tr><td>堆排序</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>O(1)</td><td>不稳定</td><td>维护一个最大堆，每次把堆首元素放入最终正确位置</td></tr><tr><td>归并排序</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>稳定</td><td>递归对左子序列和右子序列进行排序，然后合并</td></tr><tr><td>快速排序</td><td>O(n&#42;n)</td><td>O(n&#42;lgn)</td><td>O(n&#42;lgn)</td><td>O(1)</td><td>不稳定</td><td>根据某个划分值划分得到左右两个子序列，递归排序</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td><td>在每个元素的值介于0-k的前提下，统计小于等于每个元素的总个数，这个总个数也是该元素的最终正确位置</td></tr><tr><td>基数排序</td><td>O(d(k+n))</td><td>O(d(k+n))</td><td>O(d(k+n))</td><td>O(d(k+n))</td><td>稳定</td><td>一个d位元素，然后从低位到高位进行计数排序</td></tr><tr><td>桶排序</td><td>O(n&#42;n)</td><td>O(n)</td><td>O(n)</td><td>O(n+k)</td><td>稳定</td><td>先对数据进行乘等某种处理，将之分到有序桶中，第一层排序；然后对每个桶中的元素进行插入排序，第二层排序</td></tr><tr><td>冒泡排序</td><td>O(n&#42;n)</td><td>O(n)</td><td>O(n&#42;n)</td><td>O(1)</td><td>稳定</td><td>左右交换，接力棒似地传导，把最大的元素放在最后正确的位置</td></tr></tbody></table>

<h2 id="二、几点说明"><a href="#二、几点说明" class="headerlink" title="二、几点说明"></a><strong>二、几点说明</strong></h2><h3 id="2-1、空间复杂度"><a href="#2-1、空间复杂度" class="headerlink" title="2.1、空间复杂度"></a><strong>2.1、空间复杂度</strong></h3><p>空间复杂度是指额外还需要多少空间，本来保存元素的数组不算在内。</p>
<h3 id="2-2、归并排序"><a href="#2-2、归并排序" class="headerlink" title="2.2、归并排序"></a><strong>2.2、归并排序</strong></h3><p>归并排序的空间复杂度是O(n&#42;lgn)：空间复杂度的递归式为T(n)&#x3D;2T(n&#x2F;2)+n，因此根据主定理可得到最终的空间复杂度即为O(n&#42;lgn)。<br>优化以上空间复杂度有两个方案：</p>
<ul>
<li>优化方案一，建立三个长度为n的数组，一个保存最终结果[S]，一个保存左递归结果[L]，另外一个保存右递归结果[R]，那么在每次递归中，先左递归调用，然后把S中的内容复制到L，再右递归调用，把S的内容复制到R，最后将结果合并到S，进行返回，这样就优化成O(n)，但是代价是计算复杂性提升了，因为需要有复制操作</li>
<li>优化方案二，也可以优化成O(1)，但是随之而来的是更大的计算复杂性的提升</li>
</ul>
<h3 id="2-3、快速排序"><a href="#2-3、快速排序" class="headerlink" title="2.3、快速排序"></a><strong>2.3、快速排序</strong></h3><p>快速排序如果按照《算法导论》进行实现，那么可以是稳定的；如果按照从左右两个方向相向而行的方法实现，那么是不稳定的（快速排序有两个方向，左边的i下标一直往右走，当a[i]&lt;&#x3D;a[center_index]，其中center_index是中枢元素的数组下标，而右边的j下标一直往左走，当a[j]&gt;a[center_index]。如果i和j都走不动了，i&lt;&#x3D;j， 交换a[i]和a[j]，重复上面的过程，直到i&gt;j）。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/blog/2018/05/05/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>定义“接口”的关键词为<code>interface</code>。</p>
<h2 id="一、字段"><a href="#一、字段" class="headerlink" title="一、字段"></a><strong>一、字段</strong></h2><p>字段允许的修饰符：</p>
<ul>
<li>public</li>
<li>static</li>
<li>final</li>
</ul>
<p>默认具有“public static final”修饰符组合，且不允许修改。</p>
<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a><strong>二、方法</strong></h2><p>方法允许的修饰符：</p>
<ul>
<li>public</li>
<li>abstract</li>
</ul>
<p>默认具有“public abstract”修饰符，且不允许修改。</p>
<h2 id="三、构造方法"><a href="#三、构造方法" class="headerlink" title="三、构造方法"></a><strong>三、构造方法</strong></h2><p>Java语言设计不能从“接口”生成实例对象，因此没有“构造方法”。</p>
<h2 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a><strong>四、继承</strong></h2><p>接口继承关键词为<code>extends</code>，允许“大于1”继承，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AAA</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BBB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExperiment</span> <span class="keyword">extends</span> <span class="title class_">AAA</span>, BBB &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索软件的历史版本</title>
    <url>/blog/2018/04/16/%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>添加搜索关键词“archive”，比如“jdk archive”，“mysql download archive”等。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建读高可用Nexus集群</title>
    <url>/blog/2018/01/25/%E6%90%AD%E5%BB%BA%E8%AF%BB%E9%AB%98%E5%8F%AF%E7%94%A8Nexus%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a><strong>一、架构</strong></h2><p>工作需要自己搭建维护一个Nexus集群，设计读高可用Nexus集群架构，参考[1]得到版本1架构设计如图1，版本2架构设计如图2，最终选用版本2架构设计，具体原因见“1.2、解决的问题及存在的问题”。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20180125-0-1.png"></p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20180125-0-2.png"></p>
<h3 id="1-1、架构描述"><a href="#1-1、架构描述" class="headerlink" title="1.1、架构描述"></a><strong>1.1、架构描述</strong></h3><h4 id="1-1-1、版本1"><a href="#1-1-1、版本1" class="headerlink" title="1.1.1、版本1"></a><strong>1.1.1、版本1</strong></h4><p>设计有3个Nexus节点A，B，C，由于Nexus支持冷拷贝，因此通过冷拷贝进行A，B，C三个Nexus节点之间的同步，作者具体采用“rsync同步机制”作为同步实现。<br>节点A作为写入节点，Jenkins持续构建得到的包或者手动提交的包被写入到A，定时通过“rsync同步机制”保持B，C节点与A节点的同步，B，C节点作为读取节点，Maven客户端从B，C节点读取包数据。<br>为了获得读高可用，负载均衡和IP访问控制，在B，C节点与Maven客户端之间嵌入一个Nginx层。</p>
<h4 id="1-1-2、版本2"><a href="#1-1-2、版本2" class="headerlink" title="1.1.2、版本2"></a><strong>1.1.2、版本2</strong></h4><p>设计有3个Nexus节点A，B，C，Jenkins持续构建得到的包或者手动提交的包写入时，重复写3份分别到A，B，C，读取A，B，C节点上包数据时通过Nginx反向代理，获得读高可用，负载均衡和IP访问控制。</p>
<h3 id="1-2、解决的问题及存在的问题"><a href="#1-2、解决的问题及存在的问题" class="headerlink" title="1.2、解决的问题及存在的问题"></a><strong>1.2、解决的问题及存在的问题</strong></h3><h4 id="1-2-1、版本1"><a href="#1-2-1、版本1" class="headerlink" title="1.2.1、版本1"></a><strong>1.2.1、版本1</strong></h4><p>以上架构设计解决问题如下：</p>
<ul>
<li>读取高可用</li>
<li>数据丢失风险小</li>
</ul>
<p>以上架构设计存在问题如下：</p>
<ul>
<li>Jenkins存在单点故障风险</li>
<li>写节点存在单点故障风险</li>
<li>Nginx存在单点故障风险</li>
<li><font color='red'>虽然Nexus支持冷拷贝，但是冷拷贝后存在数据与Nexus进程内存数据不一致问题，导致不能实时同步，甚至导致不能正常运行，因此冷拷贝只适用于“冷拷贝，冷重启”场景，因此版本1架构设计存在致命缺陷</font></li>
</ul>
<h4 id="1-2-2、版本2"><a href="#1-2-2、版本2" class="headerlink" title="1.2.2、版本2"></a><strong>1.2.2、版本2</strong></h4><p>以上架构设计解决问题如下：</p>
<ul>
<li>读取高可用</li>
<li>数据丢失风险小</li>
</ul>
<p>以上架构设计存在问题如下：</p>
<ul>
<li>Jenkins存在单点故障风险</li>
<li>Nginx存在单点故障风险</li>
</ul>
<h2 id="二、具体搭建"><a href="#二、具体搭建" class="headerlink" title="二、具体搭建"></a><strong>二、具体搭建</strong></h2><h3 id="2-1、搭建Jenkins"><a href="#2-1、搭建Jenkins" class="headerlink" title="2.1、搭建Jenkins"></a><strong>2.1、搭建Jenkins</strong></h3><p>在D上搭建Jenkins具体流程如下：</p>
<ol>
<li>从官网下载最新的WAR包</li>
<li>执行<code>java -jar jenkins.war --httpPort=&#123;自定义端口&#125;</code>命令运行Jenkins，使用“httpPort”选项配置自定义端口</li>
<li>访问“D:9091”，首次登录需要进行初始化配置，选择安装推荐插件，“admin”管理员用户的默认密码在“~&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword”文件内</li>
<li>可在“系统管理–&gt;全局工具配置”下个性化配置JDK，Maven，Git等工具，否则使用默认配置</li>
</ol>
<p>新建一个持续构建任务示例如下：</p>
<ol>
<li>输入“任务名称”，选择“构建一个自由风格的软件项目”</li>
<li>在“源码管理”分栏下填写源码地址</li>
<li>在“构建触发器”分栏下选择构建触发逻辑类型，一般为“Poll SCM（定时查看源码是否有更新，如果有更新就进行一次构建）”，比如<code>H/10 * * * *</code>表示每隔10分钟查看源码是否有更新</li>
<li>在“构建环境”分栏下选择“Delete workspace before build starts”，避免旧构建结果对新构建的影响</li>
<li>在“构建”分栏下选择“Execute Shell”，输入构建命令，见构建命令示例1</li>
<li>在“构建后操作”分栏下选择“Archive the artifacts”，填写待打包资源的路径，比如<code>target/*.jar</code></li>
</ol>
<p>构建命令示例1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn deploy -Dmaven.test.skip=true -DaltDeploymentRepository=maven-releases::default::http://A:8081/repository/maven-releases/</span><br><span class="line">mvn deploy -Dmaven.test.skip=true -DaltDeploymentRepository=maven-releases::default::http://B:8081/repository/maven-releases/</span><br><span class="line">mvn deploy -Dmaven.test.skip=true -DaltDeploymentRepository=maven-releases::default::http://C:8081/repository/maven-releases/</span><br></pre></td></tr></table></figure>
<h3 id="2-2、搭建Nexus"><a href="#2-2、搭建Nexus" class="headerlink" title="2.2、搭建Nexus"></a><strong>2.2、搭建Nexus</strong></h3><p>具体选用Nexus OSS 3.6.0-02开源版本。</p>
<h4 id="2-2-1、A节点"><a href="#2-2-1、A节点" class="headerlink" title="2.2.1、A节点"></a><strong>2.2.1、A节点</strong></h4><p>A节点具体搭建Nexus具体流程如下：</p>
<ol>
<li>修改“bin&#x2F;nexus”执行脚本中的<code>INSTALL4J_JAVA_HOME_OVERRIDE</code>变量，将其值设为1.8以上JDK的路径，执行<code>bin/nexus start</code>开启Nexus服务</li>
<li>开启的Nexus服务默认监听8081端口，通过<code>A:8081</code>进行访问，<code>admin</code>用户的默认密码为<code>admin123</code></li>
<li>Nexus的仓库有3种类型：“hosted，proxy，group”。“hosted”类型的仓库存储私人包；“proxy”类型的仓库代理远端仓库；“group”类型的仓库是组仓库，它管理多个仓库，访问它相当于访问该组下的所有仓库。Nexus默认配置有4个仓库：“maven-public（group类型），maven-releases（hosted类型），maven-snapshots（hosted类型），maven-central（proxy类型）”。“maven-central”默认代理官方Maven仓库（URL地址为：<code>https://repo1.maven.org/maven2/</code>），该代理仓库会缓存所代理的官方Maven仓库中的包，这样虽然会加快包获取速度，但是同时会大大增加硬盘占用大小，<font color='red'>如果不需要可删除该代理仓库</font>；Maven客户端直接使用“maven-public”组仓库即可，配置示例见配置示例1；“Release”版本的包发布到“maven-releases”仓库，配置示例见配置示例2；“Snapshot”版本的包发布到“maven-snapshots”仓库，配置示例见配置示例3</li>
</ol>
<p>配置示例1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">  &lt;id&gt;maven-public&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;Central Repository&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://A:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">  &lt;layout&gt;default&lt;/layout&gt;</span><br><span class="line">  &lt;releases&gt;</span><br><span class="line">    &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">  &lt;/releases&gt;</span><br><span class="line">  &lt;snapshots&gt;</span><br><span class="line">    &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">    &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</span><br><span class="line">  &lt;/snapshots&gt;</span><br><span class="line">&lt;/repository&gt;</span><br></pre></td></tr></table></figure>

<p>配置示例2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># settings.xml</span><br><span class="line"># 仓库的用户名和密码必须在settings.xml文件中配置，id属性作为唯一标识不一定需要是对应的仓库名称</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;maven-releases&lt;/id&gt;</span><br><span class="line">  &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line"># 命令行</span><br><span class="line"># 通过-D选项指定插件需要的系统变量 </span><br><span class="line">mvn deploy -Dmaven.test.skip=true -DaltDeploymentRepository=maven-releases::default::http://A:8081/repository/maven-releases/</span><br><span class="line"></span><br><span class="line">mvn deploy:deploy-file -Dfile=&#123;待上传包路径&#125; -DgroupId=&#123;包上传后的GroupId&#125; -DartifactId=&#123;包上传后的ArtifactId&#125; -Dversion=&#123;包上传后的版本号&#125; -Dpackaging=&#123;包上传后的类型，一般为JAR&#125; -DrepositoryId=maven-releases -Durl=http://A:8081/repository/maven-releases/</span><br></pre></td></tr></table></figure>

<p>配置示例3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># settings.xml</span><br><span class="line"># 仓库的用户名和密码必须在settings.xml文件中配置，id属性作为唯一标识不一定需要是对应的仓库名称</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;maven-snapshots&lt;/id&gt;</span><br><span class="line">  &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line"># 命令行</span><br><span class="line"># 通过-D选项指定插件需要的系统变量 </span><br><span class="line">mvn deploy -Dmaven.test.skip=true -DaltDeploymentRepository=maven-snapshots::default::http://A:8081/repository/maven-snapshots/</span><br><span class="line"></span><br><span class="line">mvn deploy:deploy-file -Dfile=&#123;待上传包路径&#125; -DgroupId=&#123;包上传后的GroupId&#125; -DartifactId=&#123;包上传后的ArtifactId&#125; -Dversion=&#123;包上传后的版本号&#125; -Dpackaging=&#123;包上传后的类型，一般为JAR&#125; -DrepositoryId=maven-snapshots -Durl=http://A:8081/repository/maven-snapshots/</span><br></pre></td></tr></table></figure>

<p>备注：<br>上传到“maven-releases”仓库的JAR包“version”设置中禁止含有“SNAPSHOT”字符串；反之，上传到“maven-snapshots”仓库的JAR包“version”设置中必须含有“SNAPSHOT”字符串</p>
<h4 id="2-2-2、B节点"><a href="#2-2-2、B节点" class="headerlink" title="2.2.2、B节点"></a><strong>2.2.2、B节点</strong></h4><p>B节点具体搭建Nexus具体流程如下：</p>
<ol>
<li>修改“bin&#x2F;nexus”执行脚本中的<code>INSTALL4J_JAVA_HOME_OVERRIDE</code>变量，将其值设为1.8以上JDK的路径</li>
<li>冷拷贝A节点上的Nexus数据目录“sonatype-work”</li>
<li>执行<code>bin/nexus start</code>开启Nexus服务</li>
</ol>
<h4 id="2-2-3、C节点"><a href="#2-2-3、C节点" class="headerlink" title="2.2.3、C节点"></a><strong>2.2.3、C节点</strong></h4><p>C节点具体搭建Nexus具体流程如下：</p>
<ol>
<li>修改“bin&#x2F;nexus”执行脚本中的<code>INSTALL4J_JAVA_HOME_OVERRIDE</code>变量，将其值设为1.8以上JDK的路径</li>
<li>冷拷贝A节点上的Nexus数据目录“sonatype-work”</li>
<li>执行<code>bin/nexus start</code>开启Nexus服务</li>
</ol>
<h3 id="2-3、搭建Nginx"><a href="#2-3、搭建Nginx" class="headerlink" title="2.3、搭建Nginx"></a><strong>2.3、搭建Nginx</strong></h3><p>具体选用Nginx-1.13.8版本，非root用户安装和使用Nginx。<br>参考[2]，搭建Nginx具体流程如下：</p>
<ol>
<li>从<code>https://sourceforge.net/projects/pcre/files/pcre/</code>下载最新的PCRE包，解压</li>
<li>解压Nginx包，进入解压后目录</li>
<li>执行<code>./configure --prefix=&#123;Nginx安装到目录&#125; --with-pcre=&#123;PCRE包路径&#125; --without-http_gzip_module &amp;&amp; make &amp;&amp; make install</code>命令，完成安装</li>
<li>进入安装到目录，配置“conf&#x2F;nginx.conf”文件，需要注意的是，由于是非root用户使用Nginx，监听端口需要大于1024，一个示例配置见Nginx示例配置</li>
<li>进入安装到目录，执行<code>sbin/nginx</code>开启Nginx服务</li>
</ol>
<p>Nginx示例配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    upstream myapp1 &#123;</span><br><span class="line">        #可以解决同一个会话的一系列请求被转发到不同服务器导致cookie获取异常的问题</span><br><span class="line">        ip_hash;</span><br><span class="line"></span><br><span class="line">        server A:8081;</span><br><span class="line">        server B:8081;</span><br><span class="line">        server C:8081;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8081;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            allow 允许IP地址1;</span><br><span class="line">            allow 允许IP地址2;</span><br><span class="line">            allow 允许IP地址3;</span><br><span class="line"></span><br><span class="line">            deny all;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://myapp1;</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
参考文献：
[1]http://www.sonatype.org/nexus/2015/07/10/high-availability-ha-and-continuous-integration-ci-with-nexus-oss
[2]https://gist.github.com/simonw/92481
[3]https://help.sonatype.com/display/NXRM3/Run+Behind+a+Reverse+Proxy
[4]http://nginx.org/en/docs/http/load_balancing.html
[5]https://ketao1989.github.io/2015/08/30/nginx-proxy-configure-and-sduty/
[6]http://www.cnblogs.com/xianyulaodi/p/6547807.html
[7]https://serverfault.com/questions/598202/make-nginx-to-pass-hostname-of-the-upstream-when-reverseproxying
[8]https://trac.nginx.org/nginx/ticket/501
[9]http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header
[10]http://blog.51cto.com/1234567aaa/317802
[11]http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream
[12]https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>文件字符编码不能推定只能否定</title>
    <url>/blog/2018/09/22/%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AE%9A%E5%8F%AA%E8%83%BD%E5%90%A6%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="一、文件字符编码不能推定"><a href="#一、文件字符编码不能推定" class="headerlink" title="一、文件字符编码不能推定"></a><strong>一、文件字符编码不能推定</strong></h2><p>文件字符编码不能推定，原因：以一个极端情形为例进行说明，文件只包含一个<code>A</code>字符，分别以“ASCII”和“GBK”字符编码方案进行编码，得到的字节流皆为单字节<code>0x41</code>，因此，文件字符编码不能被推定。</p>
<h2 id="二、文件字符编码只能否定"><a href="#二、文件字符编码只能否定" class="headerlink" title="二、文件字符编码只能否定"></a><strong>二、文件字符编码只能否定</strong></h2><p>可通过以下方式确定字符编码C不是文件的字符编码：以字符编码C对文件字节流B1进行解码得到临时字符串S，再以字符编码C对S进行编码得到字节流B2，如果B1和B2不一致，那么字符编码C不是文件的字符编码。<br>示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFileNotEncodedWith</span><span class="params">(File file, Charset charset)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] direct = IOUtils.toByteArray(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(direct, charset);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] indirect = ss.getBytes(charset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !Arrays.equals(direct, indirect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1、漏判"><a href="#2-1、漏判" class="headerlink" title="2.1、漏判"></a><strong>2.1、漏判</strong></h3><p>漏判：“不是”被错认为“是”。<br>根据“一、文件字符编码不能推定”可知，漏判是正常现象。</p>
<h3 id="2-2、误判"><a href="#2-2、误判" class="headerlink" title="2.2、误判"></a><strong>2.2、误判</strong></h3><p>误判：“是”被误认为“不是”。<br>一般情形下，误判不可能出现，除非一些很特殊的情形：</p>
<ul>
<li>文件写程序未常规实现</li>
<li>即便对于同一个字符编码，文件写程序和Java判断程序采用的字符码表不尽相同</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>文档生成脚本语言</title>
    <url>/blog/2018/07/05/%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="一、博文HTML"><a href="#一、博文HTML" class="headerlink" title="一、博文HTML"></a><strong>一、博文HTML</strong></h2><p>Markdown。</p>
<h2 id="二、印刷级别PDF"><a href="#二、印刷级别PDF" class="headerlink" title="二、印刷级别PDF"></a><strong>二、印刷级别PDF</strong></h2><p>LaTeX。</p>
<h2 id="三、Slide"><a href="#三、Slide" class="headerlink" title="三、Slide"></a><strong>三、Slide</strong></h2><p>基于LaTeX的Beamer。</p>
<p>备注：<br>较常见的制作Slide的软件有Microsoft PowerPoint，Keynote。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>文档生成</tag>
      </tags>
  </entry>
  <entry>
    <title>方法区</title>
    <url>/blog/2022/01/10/%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<p>本文默认基于64位的JDK 8（其虚拟机实现是HotSpot），除非特别说明。</p>
<h2 id="一、方法区内部数据"><a href="#一、方法区内部数据" class="headerlink" title="一、方法区内部数据"></a><strong>一、方法区内部数据</strong></h2><p>方法区内有：类元数据、运行时常量池、即时编译器编译以后的代码等数据。</p>
<h3 id="1-1、类元数据"><a href="#1-1、类元数据" class="headerlink" title="1.1、类元数据"></a><strong>1.1、类元数据</strong></h3><p>类元数据，存放有：类型信息，访问修饰符，字段信息，方法信息等。</p>
<p>在C&#x2F;C++实现层面，对应的是一个Klass对象。</p>
<h3 id="1-2、运行时常量池"><a href="#1-2、运行时常量池" class="headerlink" title="1.2、运行时常量池"></a><strong>1.2、运行时常量池</strong></h3><p>运行时常量池，其英文名为“Runtime Constant Pool”。</p>
<p>Class字节码文件中有一部分信息是常量池，其英文名为<code>Constant Pool Table</code>，在运行时，它其中的内容会被载入到运行时常量池中。</p>
<h2 id="二、方法区实现"><a href="#二、方法区实现" class="headerlink" title="二、方法区实现"></a><strong>二、方法区实现</strong></h2><p>JDK 6使用“永久代”实现方法区，JDK 8使用“元空间”实现方法区：实现策略升级解决一些已知存在问题，具体原因没有必要深究[3]。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4</a><br>[2]<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html</a><br>[3]<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>方法参数合法性定义</title>
    <url>/blog/2018/09/23/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%90%88%E6%B3%95%E6%80%A7%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>为简化论述，以“A”指代“方法定义者”，“B”指代“方法调用者”。</p>
<p>“方法参数合法性定义”由A完成，定义须被完整准确传达给B，B在调用方法时，如果未遵循已被告知的“方法参数合法性定义”而导致了调用后果，那么责任由B承担；相对的，如果遵循已被告知的“方法参数合法性定义”而导致了调用后果，那么责任由A承担。</p>
<p>即类似于如下情形：商家提供了一个产品，并附带了一个产品使用说明书，用户在使用产品时，如果用户未遵照说明书使用而导致了使用后果，那么责任由用户承担；相对的，如果用户遵照说明书使用而导致了使用后果，那么责任由商家承担</p>
<p><font color='red'>基于上述论述，在方法具体实现中，理论上可以不再对实际传入参数是否合法进行验证，但是进行验证可以增加程序的健壮性。</font></p>
]]></content>
      <categories>
        <category>工程师进阶</category>
      </categories>
  </entry>
  <entry>
    <title>日志记录最佳实践</title>
    <url>/blog/2018/10/11/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一、使用SLF4J日志框架"><a href="#一、使用SLF4J日志框架" class="headerlink" title="一、使用SLF4J日志框架"></a><strong>一、使用SLF4J日志框架</strong></h2><p>使用SLF4J门面日志框架，而不直接使用具体日志框架，比如“Log4j”，“Logback”等。<br>一般最终选取“SLF4J+Log4j”日志框架组合方案。</p>
<h2 id="二、SLF4J日志框架不同日志级别及不同日志级别适于记录日志内容"><a href="#二、SLF4J日志框架不同日志级别及不同日志级别适于记录日志内容" class="headerlink" title="二、SLF4J日志框架不同日志级别及不同日志级别适于记录日志内容"></a><strong>二、SLF4J日志框架不同日志级别及不同日志级别适于记录日志内容</strong></h2><p>SLF4J日志框架的不同日志级别有：TRACE，DEBUG，INFO，WARN，ERROR。<br>排序顺序为：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。</p>
<h3 id="2-1、调试语境"><a href="#2-1、调试语境" class="headerlink" title="2.1、调试语境"></a><strong>2.1、调试语境</strong></h3><p>属于调试语境的日志级别有：TRACE和DEBUG。<br>在正常的程序开发流中，一般不主动记录属于调试语境日志级别的日志，只在需要调试时，才进行记录。</p>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>记录内容描述</th>
</tr>
</thead>
<tbody><tr>
<td>TRACE</td>
<td>比DEBUG粒度更小的调试信息</td>
</tr>
<tr>
<td>DEBUG</td>
<td>调试信息</td>
</tr>
</tbody></table>
<h3 id="2-2、正常语境"><a href="#2-2、正常语境" class="headerlink" title="2.2、正常语境"></a><strong>2.2、正常语境</strong></h3><p>属于正常语境的日志级别有 ：INFO，WARN和ERROR。<br>在正常的程序开发流中，一般主动记录属于正常语境日志级别的日志，即：在正常的程序开发流中，一般只需考虑记录INFO，WARN和ERROR日志级别的日志。</p>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>记录内容描述</th>
</tr>
</thead>
<tbody><tr>
<td>INFO</td>
<td>记录程序运行的状态、动作信息</td>
</tr>
<tr>
<td>WARN</td>
<td>介于INFO和ERROR之间的信息，比如“非必须处理的错误信息”</td>
</tr>
<tr>
<td>ERROR</td>
<td>记录系统逻辑出错、异常或者重要的错误信息</td>
</tr>
</tbody></table>
<br/>
**补充几点：**
- 线上生产环境的日志级别开关阈值为INFO
- 谨慎地记录日志，大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请务必思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？
- 具体日志记录内容不作约定，具体情况具体分析，比如“有些场景需要日志记录的唯一ID，而有些并不需要”
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>时区</title>
    <url>/blog/2018/09/07/%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<p>一个时区体系主要包括两个方面：绝对基准时间和相对参照时间。<br>在介绍之前，首先介绍关于经线的几个概念：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0度经线：又称格林尼治子午线或本初子午线，被定义为经过英国格林尼治天文台的那条经线，“英国格林尼治”的英文名为“Greenwich”</span><br><span class="line">180度经线：0度经线的正对面那条经线</span><br><span class="line">东经和西经：0度经线以东被称为“东经”，0度经线以西被称为“西经”。东经和西经有两个重合点，分别在“0度经线”和“180度经线”处，而并没有“东经0度，西经0度，东经180度，西经180度”</span><br></pre></td></tr></table></figure>
<h2 id="一、绝对基准时间"><a href="#一、绝对基准时间" class="headerlink" title="一、绝对基准时间"></a><strong>一、绝对基准时间</strong></h2><h3 id="1-1、GMT"><a href="#1-1、GMT" class="headerlink" title="1.1、GMT"></a><strong>1.1、GMT</strong></h3><p>GMT：英文全称为“Greenwich Mean Time”，中文名称为“格林尼治平时”。<br>GMT绝对基准时间：以“格林尼治平时”为绝对基准时间，“格林尼治平时”时间的12点为“平太阳横穿格林尼治子午线时的时间”。</p>
<p><strong>缺陷</strong>：<br>由于地球自转影响，“格林尼治平时”时间需要持续进行调校，调校基于天文观测，而天文观测天然不够准确。自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。</p>
<h3 id="1-2、UT"><a href="#1-2、UT" class="headerlink" title="1.2、UT"></a><strong>1.2、UT</strong></h3><p>UT：英文全称为“Universal Time”，中文名称为“世界时”。<br>经过发展，包含有3个体系：UT0，UT1，UT2。</p>
<h4 id="1-2-1、UT0"><a href="#1-2-1、UT0" class="headerlink" title="1.2.1、UT0"></a><strong>1.2.1、UT0</strong></h4><p>UT0即GMT，因此，UT0绝对基准时间为“格林尼治平时”。</p>
<h4 id="1-2-2、UT1"><a href="#1-2-2、UT1" class="headerlink" title="1.2.2、UT1"></a><strong>1.2.2、UT1</strong></h4><p>UT1在UT0的基础上加入了极移改正Δλ，修正地轴摆动的影响。<br>UT1与UT0关系的描述公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UT1绝对基准时间 = UT0绝对基准时间 + Δλ</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3、UT2"><a href="#1-2-3、UT2" class="headerlink" title="1.2.3、UT2"></a><strong>1.2.3、UT2</strong></h4><p>UT2是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正ΔT。<br>UT2与UT1关系的描述公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UT2绝对基准时间 = UT1绝对基准时间 + ΔT</span><br></pre></td></tr></table></figure>
<h3 id="1-3、TAI"><a href="#1-3、TAI" class="headerlink" title="1.3、TAI"></a><strong>1.3、TAI</strong></h3><p>TAI：法文全称为“temps atomique International”，中文名称为“国际原子时”。<br>基于原子能级跃迁时的共振频率非常稳定的物理现象，对“秒”作了重新定义：铯133原子在基态的两个超精细能级结构间零磁场跃迁时，辐射频率的9192631770个周期持续的时间为1秒。<br>基于原子秒运作的时钟称为原子钟。<br>TAI绝对基准时间定义：取“世界时”的1958年1月1日0时0分0秒的瞬间作为“国际原子时”的同年同月同日0时0分0秒，后续则以原子钟进行计时。<br>根据上述定义，TAI绝对基准时间不再基于天文观测，而是基于原子钟，因此计时更加精确。</p>
<h3 id="1-4、UTC"><a href="#1-4、UTC" class="headerlink" title="1.4、UTC"></a><strong>1.4、UTC</strong></h3><p>UTC：英文全称为“Coordinated Universal Time”，中文名称为“协调世界时”。<font color='red'>是目前全世界使用的时间标准</font>。<br>UTC是TAI和UT1的结合，UTC基于TAI，并通过不规则地加入闰秒来抵消地球自转变慢的影响，以保证UTC与UT1相差不超过0.9秒。<br><font color='red'>在民用领域中，GMT等价于UTC</font>。</p>
<h2 id="二、相对参照时间"><a href="#二、相对参照时间" class="headerlink" title="二、相对参照时间"></a><strong>二、相对参照时间</strong></h2><h3 id="2-1、地理时区"><a href="#2-1、地理时区" class="headerlink" title="2.1、地理时区"></a><strong>2.1、地理时区</strong></h3><p>在最开始的GMT时区体系中，地理时区的定义如下（在后续的时区体系中，比如“TAI，UTC”，上述地理时区的定义保留了下来）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于绝对基准时间，从0度经线开始东经每向东偏移15度为一个新时区的中央子午线所在，该新时区以该中央子午线为中心线东西各覆盖7.5度，该新时区相对于西侧紧邻时区增加1个小时；从0度经线西经每向西偏移15度为一个新时区的中央子午线所在，该新时区以该中央子午线为中心线东西各覆盖7.5度，该新时区相对于东侧紧邻时区减少1个小时。180度经线定义为“国际日期变更线”，由西向东越过此线时间增加1天，由东向西越过此线时间减少1天</span><br></pre></td></tr></table></figure>
<h3 id="2-2、实际时区"><a href="#2-2、实际时区" class="headerlink" title="2.2、实际时区"></a><strong>2.2、实际时区</strong></h3><p>实际中，国家或者地区施行实际时区，实际时区的施行完全由国家或者地区自主综合考量决定。<br>比如：</p>
<ul>
<li>整个中国大陆地区施行“UTC+8”时区，而地理时区其实横跨了“UTC+5，UTC+6，UTC+7，UTC+8，UTC+9”五个时区</li>
<li>有些国家和地区基于“节约能源”考虑，不施行全年固定的实际时区，而是：非夏季，施行平时的实际时区；夏季，施行夏令时</li>
</ul>
<p><strong>实际时区别名：</strong></p>
<ul>
<li>同一个实际时区有可能被多个国家或者地区采用，因此一个实际时区可能有多个别名，本文只关注“英文别名”和“IANA别名”，不关注其他形式的别名，比如“中文别名”</li>
<li>“英文别名”和“IANA别名”互相独立，并不是一一对应的</li>
<li>同一个英文别名的缩略可能指代不同的实际时区，比如“CST”可以指代“Central Standard Time(UTC-6)”，也可以指代“China Standard Time(UTC+8)”</li>
</ul>
<p><strong>夏令时：</strong></p>
<ul>
<li>夏令时是对平时所施行实际时区提前1小时，比如平时所施行实际时区为“Eastern Standard Time(EST)，UTC-5”，那么对应的夏令时则为“UTC-4”</li>
<li>中国不施行夏令时。原因如下：1）中国中西部地区施行的都是北京标准时间，相当于全年施行夏令时，因此，在中国，夏令时只对东部地区起作用；2）中国大多数平民都已习惯北京标准时间。施行夏令时对于他们来说难以接受，觉得是多此一举；3）施行夏令时需要每年修改铁路和航班时间表，会造成非常大的麻烦</li>
</ul>
<p>下面列出“UTC+8，UTC-5，UTC-6，UTC-8，UTC+05:30，UTC+6”这几个实际时区的“英文别名”，“IANA别名”和“施行国家或者地区”，所列并不保证是完备的，可能只是部分的。</p>
<h4 id="2-2-1、UTC-8"><a href="#2-2-1、UTC-8" class="headerlink" title="2.2.1、UTC+8"></a><strong>2.2.1、UTC+8</strong></h4><h5 id="2-2-1-1、英文别名"><a href="#2-2-1-1、英文别名" class="headerlink" title="2.2.1.1、英文别名"></a><strong>2.2.1.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>AWST</td>
<td>Australian Western Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>CHOT</td>
<td>Choibalsan Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>CIT</td>
<td>Central Indonesia Time</td>
<td>否</td>
</tr>
<tr>
<td>CST</td>
<td>China Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>HKT</td>
<td>Hong Kong Time</td>
<td>否</td>
</tr>
<tr>
<td>MST</td>
<td>Malaysia Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>MYT</td>
<td>Malaysia Time</td>
<td>否</td>
</tr>
<tr>
<td>PST</td>
<td>Philippine Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>SGT</td>
<td>Singapore Time</td>
<td>否</td>
</tr>
<tr>
<td>ULAT</td>
<td>Ulaanbaatar Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>WST</td>
<td>Western Standard Time</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="2-2-1-2、IANA别名"><a href="#2-2-1-2、IANA别名" class="headerlink" title="2.2.1.2、IANA别名"></a><strong>2.2.1.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>Antarctica&#x2F;Casey</li>
<li>Asia&#x2F;Brunei</li>
<li>Asia&#x2F;Choibalsan</li>
<li>Asia&#x2F;Hong_Kong</li>
<li>Asia&#x2F;Irkutsk</li>
<li>Asia&#x2F;Kuala_Lumpur</li>
<li>Asia&#x2F;Kuching</li>
<li>Asia&#x2F;Macau</li>
<li>Asia&#x2F;Makassar</li>
<li>Asia&#x2F;Manila</li>
<li>Asia&#x2F;Shanghai</li>
<li>Asia&#x2F;Singapore</li>
<li>Asia&#x2F;Taipei</li>
<li>Asia&#x2F;Ulaanbaatar</li>
<li>Australia&#x2F;Perth</li>
<li>Asia&#x2F;Harbin</li>
<li>Asia&#x2F;Chongqing</li>
</ul>
<h5 id="2-2-1-3、施行国家或者地区"><a href="#2-2-1-3、施行国家或者地区" class="headerlink" title="2.2.1.3、施行国家或者地区"></a><strong>2.2.1.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>中国大陆地区</li>
<li>中国香港地区</li>
<li>中国澳门地区</li>
<li>中国台湾地区</li>
<li>蒙古国（全国大部分地区）</li>
<li>新加坡</li>
<li>马来西亚</li>
<li>菲律宾</li>
<li>印尼（中部地区）</li>
<li>文莱</li>
<li>老挝（磨丁市）</li>
</ul>
<h4 id="2-2-2、UTC-5"><a href="#2-2-2、UTC-5" class="headerlink" title="2.2.2、UTC-5"></a><strong>2.2.2、UTC-5</strong></h4><h5 id="2-2-2-1、英文别名"><a href="#2-2-2-1、英文别名" class="headerlink" title="2.2.2.1、英文别名"></a><strong>2.2.2.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>ACT</td>
<td>Acre Time</td>
<td>否</td>
</tr>
<tr>
<td>CDT</td>
<td>Central Daylight Time</td>
<td>是</td>
</tr>
<tr>
<td>COT</td>
<td>Colombia Time</td>
<td>否</td>
</tr>
<tr>
<td>CST</td>
<td>Cuba Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>EASST</td>
<td>Easter Island Summer Time</td>
<td>是</td>
</tr>
<tr>
<td>ECT</td>
<td>Ecuador Time</td>
<td>否</td>
</tr>
<tr>
<td>EST</td>
<td>Eastern Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>PET</td>
<td>Peru Time</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="2-2-2-2、IANA别名"><a href="#2-2-2-2、IANA别名" class="headerlink" title="2.2.2.2、IANA别名"></a><strong>2.2.2.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>America&#x2F;Atikokan	</li>
<li>America&#x2F;Bahia_Banderas</li>
<li>America&#x2F;Bogota	</li>
<li>America&#x2F;Cancun</li>
<li>America&#x2F;Cayman	</li>
<li>America&#x2F;Chicago</li>
<li>America&#x2F;Eirunepe	</li>
<li>America&#x2F;Guayaquil</li>
<li>America&#x2F;Indiana&#x2F;Knox	</li>
<li>America&#x2F;Indiana&#x2F;Tell_City</li>
<li>America&#x2F;Jamaica	</li>
<li>America&#x2F;Lima</li>
<li>America&#x2F;Matamoros	</li>
<li>America&#x2F;Menominee</li>
<li>America&#x2F;Merida	</li>
<li>America&#x2F;Mexico_City</li>
<li>America&#x2F;Monterrey	</li>
<li>America&#x2F;North_Dakota&#x2F;Beulah</li>
<li>America&#x2F;North_Dakota&#x2F;Center	</li>
<li>America&#x2F;North_Dakota&#x2F;New_Salem</li>
<li>America&#x2F;Panama	</li>
<li>America&#x2F;Rainy_River</li>
<li>America&#x2F;Rankin_Inlet	</li>
<li>America&#x2F;Resolute</li>
<li>America&#x2F;Rio_Branco	</li>
<li>America&#x2F;Winnipeg</li>
</ul>
<h5 id="2-2-2-3、施行国家或者地区"><a href="#2-2-2-3、施行国家或者地区" class="headerlink" title="2.2.2.3、施行国家或者地区"></a><strong>2.2.2.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>开曼群岛</li>
<li>哥伦比亚</li>
<li>古巴</li>
<li>海地</li>
<li>牙买加</li>
<li>秘鲁</li>
<li>巴拿马</li>
<li>加拿大安大略省（雷湾以西地区除外，但包括阿蒂科肯）</li>
<li>加拿大魁北克省（北岸和玛德琳岛除外）</li>
<li>加拿大努纳武特地区中东部</li>
<li>美国康涅狄格州</li>
<li>美国特拉华州</li>
<li>美国佐治亚州</li>
<li>美国缅因州</li>
<li>美国马里兰州</li>
<li>美国马萨诸塞州</li>
<li>美国新罕布什尔州</li>
<li>美国新泽西州</li>
<li>美国纽约州</li>
<li>美国北卡罗来纳州</li>
<li>美国俄亥俄州</li>
<li>美国宾夕法尼亚州</li>
</ul>
<h4 id="2-2-3、UTC-6"><a href="#2-2-3、UTC-6" class="headerlink" title="2.2.3、UTC-6"></a><strong>2.2.3、UTC-6</strong></h4><h5 id="2-2-3-1、英文别名"><a href="#2-2-3-1、英文别名" class="headerlink" title="2.2.3.1、英文别名"></a><strong>2.2.3.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>CST</td>
<td>Central Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>EAST</td>
<td>Easter Island Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>GALT</td>
<td>Galapagos Time</td>
<td>否</td>
</tr>
<tr>
<td>MDT</td>
<td>Mountain Daylight Time</td>
<td>是</td>
</tr>
</tbody></table>
<h5 id="2-2-3-2、IANA别名"><a href="#2-2-3-2、IANA别名" class="headerlink" title="2.2.3.2、IANA别名"></a><strong>2.2.3.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>America&#x2F;Belize</li>
<li>America&#x2F;Boise</li>
<li>America&#x2F;Cambridge_Bay</li>
<li>America&#x2F;Chihuahua</li>
<li>America&#x2F;Costa_Rica</li>
<li>America&#x2F;Denver</li>
<li>America&#x2F;Edmonton</li>
<li>America&#x2F;El_Salvador</li>
<li>America&#x2F;Guatemala</li>
<li>America&#x2F;Inuvik</li>
<li>America&#x2F;Managua</li>
<li>America&#x2F;Mazatlan</li>
<li>America&#x2F;Ojinaga</li>
<li>America&#x2F;Regina</li>
<li>America&#x2F;Swift_Current</li>
<li>America&#x2F;Tegucigalpa</li>
<li>America&#x2F;Yellowknife</li>
<li>Pacific&#x2F;Easter</li>
<li>Pacific&#x2F;Galapagos</li>
</ul>
<h5 id="2-2-3-3、施行国家或者地区"><a href="#2-2-3-3、施行国家或者地区" class="headerlink" title="2.2.3.3、施行国家或者地区"></a><strong>2.2.3.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>伯利兹</li>
<li>哥斯达黎加</li>
<li>萨尔瓦多</li>
<li>危地马拉</li>
<li>洪都拉斯</li>
<li>尼加拉瓜</li>
<li>美国阿肯色州</li>
<li>美国伊利诺州</li>
<li>美国爱荷华州</li>
<li>美国堪萨斯州</li>
<li>美国路易斯安那州</li>
<li>美国明尼苏达州</li>
<li>美国密西西比州</li>
<li>美国密苏里州</li>
<li>美国奥克拉荷马州</li>
<li>美国威斯康辛州</li>
</ul>
<h4 id="2-2-4、UTC-8"><a href="#2-2-4、UTC-8" class="headerlink" title="2.2.4、UTC-8"></a><strong>2.2.4、UTC-8</strong></h4><h5 id="2-2-4-1、英文别名"><a href="#2-2-4-1、英文别名" class="headerlink" title="2.2.4.1、英文别名"></a><strong>2.2.4.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>AKDT</td>
<td>Alaska Daylight Time</td>
<td>是</td>
</tr>
<tr>
<td>CIST</td>
<td>Clipperton Island Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>PST</td>
<td>Pacific Standard Time</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="2-2-4-2、IANA别名"><a href="#2-2-4-2、IANA别名" class="headerlink" title="2.2.4.2、IANA别名"></a><strong>2.2.4.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>America&#x2F;Anchorage</li>
<li>America&#x2F;Juneau</li>
<li>America&#x2F;Metlakatla</li>
<li>America&#x2F;Nome</li>
<li>America&#x2F;Sitka</li>
<li>America&#x2F;Yakutat</li>
<li>Pacific&#x2F;Pitcairn</li>
</ul>
<h5 id="2-2-4-3、施行国家或者地区"><a href="#2-2-4-3、施行国家或者地区" class="headerlink" title="2.2.4.3、施行国家或者地区"></a><strong>2.2.4.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>美国加利福尼亚州</li>
<li>美国华盛顿州</li>
<li>美国俄勒冈州（除了大部分位于爱达荷疆界旁的马卢尔县之外）</li>
<li>美国内华达州（除了西温多弗以及积宝镇)</li>
<li>美国爱达荷州（位于萨蒙河以北的北半部）</li>
</ul>
<h4 id="2-2-5、UTC-05-30"><a href="#2-2-5、UTC-05-30" class="headerlink" title="2.2.5、UTC+05:30"></a><strong>2.2.5、UTC+05:30</strong></h4><h5 id="2-2-5-1、英文别名"><a href="#2-2-5-1、英文别名" class="headerlink" title="2.2.5.1、英文别名"></a><strong>2.2.5.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>IST</td>
<td>Indian Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>SLST</td>
<td>Sri Lanka Standard Time</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="2-2-5-2、IANA别名"><a href="#2-2-5-2、IANA别名" class="headerlink" title="2.2.5.2、IANA别名"></a><strong>2.2.5.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>Asia&#x2F;Colombo</li>
<li>Asia&#x2F;Kolkata</li>
</ul>
<h5 id="2-2-5-3、施行国家或者地区"><a href="#2-2-5-3、施行国家或者地区" class="headerlink" title="2.2.5.3、施行国家或者地区"></a><strong>2.2.5.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>印度</li>
<li>斯里兰卡</li>
</ul>
<h4 id="2-2-6、UTC-6"><a href="#2-2-6、UTC-6" class="headerlink" title="2.2.6、UTC+6"></a><strong>2.2.6、UTC+6</strong></h4><h5 id="2-2-6-1、英文别名"><a href="#2-2-6-1、英文别名" class="headerlink" title="2.2.6.1、英文别名"></a><strong>2.2.6.1、英文别名</strong></h5><table>
<thead>
<tr>
<th>英文别名缩略</th>
<th>英文别名全称</th>
<th>是否为夏令时</th>
</tr>
</thead>
<tbody><tr>
<td>BST</td>
<td>Bangladesh Standard Time</td>
<td>否</td>
</tr>
<tr>
<td>BTT</td>
<td>Bhutan Time</td>
<td>否</td>
</tr>
<tr>
<td>IOT</td>
<td>Indian Chagos Time</td>
<td>否</td>
</tr>
<tr>
<td>KGT</td>
<td>Kyrgyzstan time</td>
<td>否</td>
</tr>
<tr>
<td>OMST</td>
<td>Omsk Time</td>
<td>否</td>
</tr>
<tr>
<td>VOST</td>
<td>Vostok Station Time</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="2-2-6-2、IANA别名"><a href="#2-2-6-2、IANA别名" class="headerlink" title="2.2.6.2、IANA别名"></a><strong>2.2.6.2、IANA别名</strong></h5><p>IANA别名列表如下：</p>
<ul>
<li>Antarctica&#x2F;Vostok </li>
<li>Asia&#x2F;Almaty</li>
<li>Asia&#x2F;Bishkek</li>
<li>Asia&#x2F;Dhaka</li>
<li>Asia&#x2F;Omsk</li>
<li>Asia&#x2F;Qyzylorda</li>
<li>Asia&#x2F;Thimphu</li>
<li>Asia&#x2F;Urumqi</li>
<li>Indian&#x2F;Chagos</li>
</ul>
<p>	</p>
<h5 id="2-2-6-3、施行国家或者地区"><a href="#2-2-6-3、施行国家或者地区" class="headerlink" title="2.2.6.3、施行国家或者地区"></a><strong>2.2.6.3、施行国家或者地区</strong></h5><p>施行国家或者地区列表如下：</p>
<ul>
<li>孟加拉国</li>
<li>不丹</li>
<li>英属印度洋领地</li>
<li>哈萨克斯坦（全国大部分地区）</li>
<li>吉尔吉斯斯坦</li>
<li>俄罗斯（鄂木斯克）</li>
</ul>
<br/>
参考文献：
[1]https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%88%9D%E5%AD%90%E5%8D%88%E7%B7%9A
[2]https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%97%A5%E6%9C%9F%E5%8F%98%E6%9B%B4%E7%BA%BF
[3]https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%A8%99%E6%BA%96%E6%99%82%E9%96%93
[4]http://gb.weather.gov.hk/gts/time/basicterms-UTandGMTc.htm
[5]https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C%E6%97%B6
[6]https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%AD%90%E6%97%B6
[7]http://www.ntsc.ac.cn/kxcb/kpcg/shijian/201209/t20120921_3648814.html
[8]https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B%E6%99%82%E5%8D%80
[9]https://24timezones.com/time-zones
[10]https://time.is/zh/Beijing
[11]https://www.zeitverschiebung.net/en/timezone/asia--macau
[12]http://aju.space/2016/06/24/talk-about-time-and-timer.html
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>晕车</title>
    <url>/blog/2016/04/08/%E6%99%95%E8%BD%A6/</url>
    <content><![CDATA[<p>“晕车”是日常生活中常见的现象，往往给当事人带来了很大困扰。</p>
<h2 id="一、晕车原因阐述"><a href="#一、晕车原因阐述" class="headerlink" title="一、晕车原因阐述"></a><strong>一、晕车原因阐述</strong></h2><p>关于“晕车”原因最流行的假说是：当人眼所见到的运动与人的感觉系统（具体是人的“前庭系统”）所感受到的运动不相符时，就会晕车。</p>
<p>“疲乏，异味”等因素能够加剧晕车，但不是晕车的主因。</p>
<h2 id="二、晕车问题解决"><a href="#二、晕车问题解决" class="headerlink" title="二、晕车问题解决"></a><strong>二、晕车问题解决</strong></h2><p>下面这些措施均可用来缓解晕车症状。</p>
<h3 id="2-1、避免“人眼所见到的运动与人的感觉系统所感受到的运动不相符”"><a href="#2-1、避免“人眼所见到的运动与人的感觉系统所感受到的运动不相符”" class="headerlink" title="2.1、避免“人眼所见到的运动与人的感觉系统所感受到的运动不相符”"></a><strong>2.1、避免“人眼所见到的运动与人的感觉系统所感受到的运动不相符”</strong></h3><p>当乘坐交通工具时，避免将人眼停留在交通工具内部的物体上（此时，你人眼所见到的运动是“静止的”，而你的感觉系统所感受到的运动一般是“运动的”，但也要注意，在有些运行得比较稳的交通工具内，你的感觉系统所感受到的运动也有可能是“静止的”，比如动车，高铁，飞机等），而要望向交通工具外部的物体（此时，你人眼所见到的运动是“运动的”，而你的感觉系统所感受到的运动一般也是“运动的”)，这样就能够避免“人眼所见到的运动与人的感觉系统所感受到的运动不相符”。</p>
<p>在坐小汽车时，“坐副驾驶座”比“坐后面两个座位”比较不容易晕车的原因也正是如此。</p>
<h3 id="2-2、闭眼"><a href="#2-2、闭眼" class="headerlink" title="2.2、闭眼"></a><strong>2.2、闭眼</strong></h3><p>闭眼或者睡觉，这排除了“晕车”形成条件中的“人眼所见到的运动”这一因素。</p>
<h3 id="2-3、晕车药"><a href="#2-3、晕车药" class="headerlink" title="2.3、晕车药"></a><strong>2.3、晕车药</strong></h3><p>有些晕车药本质上是镇静类药物，主要是让你的感觉系统不要这么兴奋敏感；有些晕车药能够抑制你产生呕吐和恶心感。</p>
<h3 id="2-4、转移注意力"><a href="#2-4、转移注意力" class="headerlink" title="2.4、转移注意力"></a><strong>2.4、转移注意力</strong></h3><p>聊天，听音乐（有些人对听音乐不感兴趣，可以改成听广播，听戏剧）等，可以转移你的注意力。<br>闻桔子皮，柠檬皮，吃生姜，吃薄荷，闻酒精等都让你接受“强刺激性”刺激，从而转移你的注意力。</p>
<h3 id="2-5、减小对晕车后果的恐惧"><a href="#2-5、减小对晕车后果的恐惧" class="headerlink" title="2.5、减小对晕车后果的恐惧"></a><strong>2.5、减小对晕车后果的恐惧</strong></h3><p>准备好呕吐袋等，减小对晕车后果的恐惧，这样子能够避免自己一直担心晕车的后果，而导致最终不断在想“晕车”这件事。这其实也是“转移注意力”的一种。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zh.wikipedia.org/wiki/%E6%99%95%E5%8A%A8%E7%97%85">https://zh.wikipedia.org/wiki/%E6%99%95%E5%8A%A8%E7%97%85</a><br>[2]<a href="http://www.39world.com/drugs/010I0G3200830713.html">http://www.39world.com/drugs/010I0G3200830713.html</a><br>[3]<a href="http://zh.wikihow.com/%E9%98%B2%E6%AD%A2%E6%99%95%E8%BD%A6">http://zh.wikihow.com/%E9%98%B2%E6%AD%A2%E6%99%95%E8%BD%A6</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/blog/2019/01/06/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>最长递增子序列：英文名为“Longest Increasing Subsequence”，简称“LIS”，就是在序列中找到最长递增子序列，一般常见的有“求解LIS的长度，求解LIS的方案数，打印1个LIS方案”3个细分问题。</p>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a><strong>二、解题思路</strong></h2><h3 id="2-1、求解LIS的长度"><a href="#2-1、求解LIS的长度" class="headerlink" title="2.1、求解LIS的长度"></a><strong>2.1、求解LIS的长度</strong></h3><p>动态规划解决。<br>以<code>sequence</code>指代原序列。<br>定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[len]=sequence[p]，表示最长递增子序列长度为len时，所有len长度最长递增子序列方案中所有第len个元素构成的集合中具有最小值的元素为sequence[p]</span><br></pre></td></tr></table></figure>
<p>构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">dp[len] = sequence[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="comment">// 更新dp，看是否值需要更新成sequence[index]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体策略是：找到最大maxlen，使得dp[maxlen]&lt;sequence[index]，则dp[maxlen+1]=sequence[index]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = len, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[mid] &lt; sequence[index]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[left] = sequence[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; len)</span><br><span class="line">        len = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需更新<code>dp[maxlen+1]</code>为<code>sequence[index]</code>的证明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设n&gt;0，则：</span><br><span class="line">1、dp[maxlen+1+n]不可能更新成sequence[index]，否则dp[maxlen+n]&lt;sequence[index]，跟“找到最大maxlen”矛盾</span><br><span class="line">2、令“dp[maxlen+1]=sequence[index]”对应的最长递增子序列中第“maxlen+1-n”个元素为sequence[m]，则有sequence[m]&lt;sequence[index]，又根据dp定义，有dp[maxlen+1-n]&lt;=sequence[m]，则最终有dp[maxlen+1-n]&lt;sequence[index]，因此dp[maxlen+1-n]不可能更新成sequence[index]</span><br></pre></td></tr></table></figure>
<p>根据上述构造过程，可知算法时间复杂度为<code>O(n*n)</code>。<br>dp具有“有序”性质，证明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">令在dp[len]这个最长递增子序列中第“len-n”个元素为sequence[m]，则有sequence[m]&lt;dp[len]，又根据dp定义，有dp[len-n]&lt;=sequence[m]，则最终有dp[len-n]&lt;dp[len]</span><br></pre></td></tr></table></figure>
<p>根据dp的“有序”性质，上述构造过程中的“找到最大maxlen”步骤显而易见可采用“二分查找法”策略进行优化，从而将算法的时间复杂度优化为<code>O(n*logn)</code>。</p>
<h3 id="2-2、求解LIS的方案数"><a href="#2-2、求解LIS的方案数" class="headerlink" title="2.2、求解LIS的方案数"></a><strong>2.2、求解LIS的方案数</strong></h3><p>定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail[p]=len，表示以sequence[p]为最长递增子序列末尾元素时，该最长递增子序列的长度为len。tail在求解LIS长度时顺带构造</span><br><span class="line">number[p]=num，表示以sequence[p]为最长递增子序列末尾元素时（此时该最长递增子序列的长度为tail[p]），方案数为num</span><br></pre></td></tr></table></figure>
<p>构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">0</span>; preIndex &lt; index; preIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[preIndex] &lt; sequence[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail[preIndex] + <span class="number">1</span> == tail[index]) &#123;</span><br><span class="line">                num += number[preIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sequence[preIndex] == sequence[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail[preIndex] == tail[index]) &#123;</span><br><span class="line">                <span class="comment">//去掉重复方案，比如“3 4 3 4 5”只有1种方案，而不是3种</span></span><br><span class="line">                number[preIndex] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    number[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去掉重复方案逻辑正确性的证明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经过逻辑推理可知，重复方案存在且只存在于同时满足“sequence[preIndex] == sequence[index]”和“tail[preIndex] == tail[index]”两个条件的情形中，因此只需对该种情形进行方案去重处理即可</span><br></pre></td></tr></table></figure>
<h3 id="2-3、打印1个LIS方案"><a href="#2-3、打印1个LIS方案" class="headerlink" title="2.3、打印1个LIS方案"></a><strong>2.3、打印1个LIS方案</strong></h3><p>获取最简单的一个LIS方案方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] oneSolution = <span class="keyword">new</span> <span class="title class_">int</span>[lenOfLIS];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> lenOfLIS; index &gt;= <span class="number">1</span>; index--) &#123;</span><br><span class="line">    oneSolution[index - <span class="number">1</span>] = dp[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oneSolution;</span><br></pre></td></tr></table></figure>
<p>dp的“有序”性质确保了上述方法的正确性。</p>
<h2 id="三、变种"><a href="#三、变种" class="headerlink" title="三、变种"></a><strong>三、变种</strong></h2><p>变种有：</p>
<ul>
<li>最长不递减子序列，英文名为“Longest Non-Decreasing Subsequence”，简称“LNDS”</li>
<li>最长递减子序列，英文名为“Longest Decreasing Subsequence”，简称“LDS”</li>
<li>最长不递增子序列，英文名为“Longest Non-Increasing Subsequence”，简称“LNIS”</li>
</ul>
<p>接下来再探讨LNDS问题解题思路。而LDS和LNIS问题解题思路则分别可由LIS和LNDS问题解题思路简单推得。</p>
<h3 id="3-1、LNDS"><a href="#3-1、LNDS" class="headerlink" title="3.1、LNDS"></a><strong>3.1、LNDS</strong></h3><h4 id="3-1-1、求解LNDS的长度"><a href="#3-1-1、求解LNDS的长度" class="headerlink" title="3.1.1、求解LNDS的长度"></a><strong>3.1.1、求解LNDS的长度</strong></h4><p>这里构造中须将<code>dp[maxlen]&lt;sequence[index]</code>改成<code>dp[maxlen]&lt;=sequence[index]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">dp[len] = sequence[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="comment">// 更新dp，看是否值需要更新成sequence[index]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体策略是：找到最大maxlen，使得dp[maxlen]&lt;=sequence[index]，则dp[maxlen+1]=sequence[index]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = len, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[mid] &lt;= sequence[index]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[left] = sequence[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; len)</span><br><span class="line">        len = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只需更新<code>dp[maxlen+1]</code>为<code>sequence[index]</code>的证明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设n&gt;0，则：</span><br><span class="line">1、dp[maxlen+1+n]不可能更新成sequence[index]，否则dp[maxlen+n]&lt;=sequence[index]，跟“找到最大maxlen”矛盾</span><br><span class="line">2、令“dp[maxlen+1]=sequence[index]”对应的最长不递减子序列中第“maxlen+1-n”个元素为sequence[m]，则有sequence[m]&lt;=sequence[index]，又根据dp定义，有dp[maxlen+1-n]&lt;=sequence[m]，则最终有dp[maxlen+1-n]&lt;=sequence[index]，因此dp[maxlen+1-n]或者不可能更新成sequence[index]（当dp[maxlen+1-n]&lt;sequence[index]），或者没必要更新成sequence[index]（当dp[maxlen+1-n]=sequence[index]）</span><br></pre></td></tr></table></figure>
<p>这里dp仍然具有“有序”性质，证明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">令在dp[len]这个最长不递减子序列中第“len-n”个元素为sequence[m]，则有sequence[m]&lt;=dp[len]，又根据dp定义，有dp[len-n]&lt;=sequence[m]，则最终有dp[len-n]&lt;=dp[len]</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2、求解LNDS的方案数"><a href="#3-1-2、求解LNDS的方案数" class="headerlink" title="3.1.2、求解LNDS的方案数"></a><strong>3.1.2、求解LNDS的方案数</strong></h4><p>这里构造中不再需要考虑“方案重复”情形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">0</span>; preIndex &lt; index; preIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[preIndex] &lt;= sequence[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail[preIndex] + <span class="number">1</span> == tail[index]) &#123;</span><br><span class="line">                num += number[preIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        number[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3、打印1个LNDS方案"><a href="#3-1-3、打印1个LNDS方案" class="headerlink" title="3.1.3、打印1个LNDS方案"></a><strong>3.1.3、打印1个LNDS方案</strong></h4><p>跟LIS一致。</p>
<h2 id="四、完整的源代码"><a href="#四、完整的源代码" class="headerlink" title="四、完整的源代码"></a><strong>四、完整的源代码</strong></h2><p>完整的源代码见<a href="https://github.com/dslztx/assist/blob/master/assist-algorithm/src/main/java/me/dslztx/assist/algorithm/dp/lis/LIS.java">LIS</a>。</p>
<h2 id="五、另外一种解题思路"><a href="#五、另外一种解题思路" class="headerlink" title="五、另外一种解题思路"></a><strong>五、另外一种解题思路</strong></h2><h3 id="5-1、求解LIS的长度"><a href="#5-1、求解LIS的长度" class="headerlink" title="5.1、求解LIS的长度"></a><strong>5.1、求解LIS的长度</strong></h3><p>直接根据tail数组求解。<br>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">()</span> &#123;</span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">totalMax</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">indexA</span> <span class="operator">=</span> <span class="number">0</span>; indexA &lt; length; indexA++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxtmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">indexB</span> <span class="operator">=</span> <span class="number">0</span>; indexB &lt; indexA; indexB++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[indexB] &lt; sequence[indexA]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tail[indexB] + <span class="number">1</span> &gt; maxtmp) &#123;</span><br><span class="line">                    maxtmp = tail[indexB] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail[indexA] = maxtmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxtmp &gt; totalMax) &#123;</span><br><span class="line">            totalMax = maxtmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lenOfLIS = totalMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lenOfLIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述算法的时间复杂度为<code>O(n*n)</code>。</p>
<h3 id="5-2、求解LIS的方案数"><a href="#5-2、求解LIS的方案数" class="headerlink" title="5.2、求解LIS的方案数"></a><strong>5.2、求解LIS的方案数</strong></h3><p>跟“2.2、求解LIS的方案数”一致。</p>
<h3 id="5-3、打印1个LIS方案"><a href="#5-3、打印1个LIS方案" class="headerlink" title="5.3、打印1个LIS方案"></a><strong>5.3、打印1个LIS方案</strong></h3><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] oneSolution = <span class="keyword">new</span> <span class="title class_">int</span>[lenOfLIS];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lenOfLIS;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> length - <span class="number">1</span>; index &gt;= <span class="number">0</span> &amp;&amp; len &gt;= <span class="number">1</span>; index--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail[index] == len) &#123;</span><br><span class="line">        oneSolution[len - <span class="number">1</span>] = sequence[index];</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oneSolution;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>杀死美的熟悉</title>
    <url>/blog/2010/05/15/%E6%9D%80%E6%AD%BB%E7%BE%8E%E7%9A%84%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<p>是谁剥夺了我们对美的赞语，让我们面对美丽只能哽塞无语！</p>
<p>是谁遮掩了我们欣赏美的眼睛，让我们纵使面对美景也只是一个茫然无从的瞎子！</p>
<p>是谁抢占了我们心灵中那一域给美预留的空间，令我们对美的神经从此迟钝麻木！</p>
<hr>
<p>是熟悉！</p>
<hr>
<p>他悄无声息地游走在生活每个角落，窥视着他的猎物！</p>
<p>他不会骤然放箭，而是用一把锋利的匕首慢慢的砍削！</p>
<p>而受伤的我们却全然不知也不想去在意这微不足道的伤痛！</p>
<p>他的罪恶就这样慢慢地发酵！</p>
<p>他躲在黑暗中狰狞地笑着，等待着看我们被他征服后失落窘迫的糗态！</p>
<p>我们越来越怀疑自己的判断力和品位！因为渐渐发现曾经所倾心的东西不过是如此的平凡无奇！</p>
<p>却没有留意脚底那些细微的粉末，这是犯罪的证据，显然愚昧的我们是不会纠缠于此的！</p>
<p>我们开始对曾经的美丽投去鄙夷和不屑的目光！</p>
<p>被抛弃与忘却注定是他们的宿命！</p>
<p>而黑暗中却传来阵阵令人颤栗的欢呼！</p>
<hr>
<p>不要再幻想敌人的仁慈，让我们自己拿起剑勇敢地向这个十恶不赦的敌人刺去！</p>
<p>这剑是我们坚定的信念：曾经的魅力，永远不会逝去，逝去的只是我们的耐心，时时提醒自己不应该放弃自己曾经的梦，即使现在我们已拥有了他或即将拥有他，但是我们应该永远把他放在自己最新的位置上，并时时，把他们从自己的心底拿出来，好好审视，也许我们能获得更多！</p>
<p>我们再也不是熟悉的奴隶！</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>诗</category>
      </categories>
  </entry>
  <entry>
    <title>材料进展之计算机网络</title>
    <url>/blog/2023/04/18/%E6%9D%90%E6%96%99%E8%BF%9B%E5%B1%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>《计算机网络》第8版。谢希仁编著。</p>
<p><del>第1章 概述</del><br><del>第2章 物理层（不包括P63-P70）</del></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>架构绪论</title>
    <url>/blog/2021/02/01/%E6%9E%B6%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="一、架构的含义"><a href="#一、架构的含义" class="headerlink" title="一、架构的含义"></a><strong>一、架构的含义</strong></h2><p>架构的本质是：实现业务目标的有所权衡和取舍的载体。</p>
<p>故：</p>
<ul>
<li>架构的唯一评价标准是<code>是否契合业务目标</code>。比如“谈论‘单体&#x2F;分布式’，‘单点数据库&#x2F;集群数据库’，‘非高可用&#x2F;高可用’等方案选型，需要结合具体业务目标”</li>
<li>架构演进的唯一动力是<code>解决现有架构与“当下或者可预见未来业务目标”的不契合问题</code>。比如“业务需要持续提供服务，当下存在单点故障风险，故进行高可用改造”，“业务发展迅速，请求流量大幅度增加，故进行分布式集群高并发改造”，“业务需要稳定提供服务，避免单点过载，故进行负载均衡改造”</li>
<li>脱离业务目标谈论架构就是耍流氓</li>
</ul>
<p>特别需要注意的是，上述架构并非狭义的“软件系统架构”，而是广义的，还可能且不限于是：</p>
<ul>
<li>公司组织架构。比如“总裁办 -&gt; IT部，行政部，人力资源中心”</li>
<li>政府组织架构。比如“中央人民政府 -&gt; 外交部，司法部，公安部”</li>
<li>电脑体系架构。比如“控制器，运算器，存储设备，输入设备和输出设备”</li>
<li>操作系统内核架构。常见的是“微内核架构”和“宏内核架构”两种架构方案</li>
<li>知识架构</li>
</ul>
<h2 id="二、业务目标"><a href="#二、业务目标" class="headerlink" title="二、业务目标"></a><strong>二、业务目标</strong></h2><p>业务目标是具体情况具体分析，并且不断发展的，但是对于一些常见的、共性的业务目标会有较为成熟的解决方案，特别需要注意的是，解决方案的引入很可能会带来一些新的问题，比如“针对流量增加引入分布式高并发解决方案，可能会带来分布式节点一致性问题”，“针对快速读取热数据引入MySQL-Redis两级数据库解决方案，可能会带来MySQL-Redis数据一致性问题”。</p>
<p><font color='red'>接下来讨论“软件系统”这个业务目标。</font></p>
<h3 id="2-1、架构基本单元进程实现"><a href="#2-1、架构基本单元进程实现" class="headerlink" title="2.1、架构基本单元进程实现"></a><strong>2.1、架构基本单元进程实现</strong></h3><p>解决方案描述：</p>
<ul>
<li>选用语言，比如Java，Go</li>
<li>版本控制，比如Git，SVN</li>
<li>项目管理，比如Maven</li>
<li>单元测试</li>
</ul>
<h3 id="2-2、流量增长应对"><a href="#2-2、流量增长应对" class="headerlink" title="2.2、流量增长应对"></a><strong>2.2、流量增长应对</strong></h3><p>解决方案描述：</p>
<ul>
<li>提高单点请求处理能力</li>
<li>集群化（分布式），可能带来“分布式节点的一致性”问题</li>
</ul>
<h3 id="2-3、数据库负载过大应对"><a href="#2-3、数据库负载过大应对" class="headerlink" title="2.3、数据库负载过大应对"></a><strong>2.3、数据库负载过大应对</strong></h3><p>解决方案描述：</p>
<ul>
<li>读写分离，引入“读写一致性”问题</li>
<li>分库分表</li>
</ul>
<h3 id="2-4、单点故障导致不可用应对"><a href="#2-4、单点故障导致不可用应对" class="headerlink" title="2.4、单点故障导致不可用应对"></a><strong>2.4、单点故障导致不可用应对</strong></h3><p>解决方案描述：</p>
<ul>
<li>高可用改造</li>
</ul>
<h3 id="2-5、流量在集群内节点的分配应对"><a href="#2-5、流量在集群内节点的分配应对" class="headerlink" title="2.5、流量在集群内节点的分配应对"></a><strong>2.5、流量在集群内节点的分配应对</strong></h3><p>解决方案描述：</p>
<ul>
<li>负载均衡</li>
</ul>
<h3 id="2-6、热数据快速访问需求"><a href="#2-6、热数据快速访问需求" class="headerlink" title="2.6、热数据快速访问需求"></a><strong>2.6、热数据快速访问需求</strong></h3><p>解决方案描述：</p>
<ul>
<li>采用MySQL+Redis两级数据库方案，引入“读写一致性”、“缓存穿透”等问题</li>
</ul>
<h3 id="2-7、监控度量需求"><a href="#2-7、监控度量需求" class="headerlink" title="2.7、监控度量需求"></a><strong>2.7、监控度量需求</strong></h3><p>解决方案描述：</p>
<ul>
<li>APM</li>
<li>InfluxDB + Grafana</li>
</ul>
<h3 id="2-8、集中收集日志数据需求"><a href="#2-8、集中收集日志数据需求" class="headerlink" title="2.8、集中收集日志数据需求"></a><strong>2.8、集中收集日志数据需求</strong></h3><p>解决方案描述：</p>
<ul>
<li>ELK</li>
<li>Log4j 2 + Kafka，引入“最多1次&#x2F;至少1次&#x2F;恰好1次”问题</li>
</ul>
<br/>
<br/>

<p>另外还有且不仅限于以下这些业务目标（或者说解决方案对应的业务目标）：</p>
<ul>
<li>微服务化改造</li>
<li>实现熔断降级限流</li>
<li>优雅停服</li>
<li>弹性伸缩</li>
<li>容器化部署</li>
<li>使用K8S管控容器</li>
<li>Service Mesh改造</li>
<li>实现幂等性接口</li>
<li>引入分布式锁</li>
<li>引入分布式事务</li>
<li>引入分布式ID</li>
<li>接入配置中心</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>棋形</title>
    <url>/blog/2023/11/23/%E6%A3%8B%E5%BD%A2/</url>
    <content><![CDATA[<p>棋形，是棋子在棋盘上组合成的各种形状。</p>
<h2 id="一、棋形好坏"><a href="#一、棋形好坏" class="headerlink" title="一、棋形好坏"></a><strong>一、棋形好坏</strong></h2><p>基于“落子尽其用”原则可将棋形分为：好形和坏形。</p>
<p>棋形是“好形&#x2F;坏形”的判断须具体情况具体分析，比如：</p>
<ul>
<li>有N颗黑子，A棋形是“直接连接的N颗黑子”，B棋形是“有尖、小飞、小跳等落子的N颗黑子”。一般情况下，前者是坏形，后者是好形，因为前者黑子相对占据地盘少；而在“该片黑子被白子围攻”情况中，前者是好形，因为前者黑子相对防守更加好</li>
</ul>
<h2 id="二、经典棋形"><a href="#二、经典棋形" class="headerlink" title="二、经典棋形"></a><strong>二、经典棋形</strong></h2><p>经典棋形有：</p>
<ol>
<li>12种基础死活棋形</li>
<li>“乌龟不出头”棋形</li>
<li>“变种板六”棋形</li>
<li>…</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://mp.weixin.qq.com/s/Ee87tmop4fto1IN28Rom-Q">https://mp.weixin.qq.com/s/Ee87tmop4fto1IN28Rom-Q</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式与通配符模式表达式</title>
    <url>/blog/2017/05/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a><strong>一、正则表达式</strong></h2><h3 id="1-1、含义"><a href="#1-1、含义" class="headerlink" title="1.1、含义"></a><strong>1.1、含义</strong></h3><p>用于匹配字符串的表达式。</p>
<h3 id="1-2、实现"><a href="#1-2、实现" class="headerlink" title="1.2、实现"></a><strong>1.2、实现</strong></h3><p>正则表达式具有很多变种，比如：GNU BRE，GNU ERE，POSIX BRE，POSIX ERE，JDK正则表达式，Python正则表达式，Perl正则表达式，PCRE正则表达式等。<br>不同变种支持的语法大同小异，没有必要掌握所有的变种语法，根据几个变种语法触类旁通其他变种语法即可（细节差异可查阅具体文档手册）。<br>不过，正则表达式有一个特殊的变种——通配符模式表达式，接下来进行单独介绍。</p>
<h2 id="二、通配符模式表达式"><a href="#二、通配符模式表达式" class="headerlink" title="二、通配符模式表达式"></a><strong>二、通配符模式表达式</strong></h2><h3 id="2-1、含义"><a href="#2-1、含义" class="headerlink" title="2.1、含义"></a><strong>2.1、含义</strong></h3><p>“通配符模式表达式”是“正则表达式”的变种，它跟“一般正则表达式”最显著的区别是：在“一般正则表达式”中，“*”表示“前面的元素出现0次或者任意多次”，“?”表示“前面的元素出现0次或者1次”；在“通配符模式表达式”中，“*”表示“任意字符串，包括空字符串”，“?”表示“任意单个字符”。<br>通配符模式表达式一般常用于匹配文件路径字符串的场景。</p>
<h3 id="2-2、实现"><a href="#2-2、实现" class="headerlink" title="2.2、实现"></a><strong>2.2、实现</strong></h3><p>跟“一般正则表达式”具有很多变种一样，“通配符模式表达式”也具有很多变种，比如：Linux Shell通配符模式表达式，GNU tar命令通配符模式表达式，GNU find命令通配符模式表达式等。<br>接下来针对上述3个变种进行简要介绍，首先说明当前目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── a.txt</span><br><span class="line">├── b.txt</span><br><span class="line">├── c</span><br><span class="line">└── d</span><br><span class="line">    ├── f.txt</span><br><span class="line">    └── g.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-3、3个变种的简要介绍"><a href="#2-3、3个变种的简要介绍" class="headerlink" title="2.3、3个变种的简要介绍"></a><strong>2.3、3个变种的简要介绍</strong></h3><h4 id="2-3-1、Linux-Shell通配符模式表达式"><a href="#2-3-1、Linux-Shell通配符模式表达式" class="headerlink" title="2.3.1、Linux Shell通配符模式表达式"></a><strong>2.3.1、Linux Shell通配符模式表达式</strong></h4><p>Linux Shell（比如“Bash Shell”）在执行命令之前会对命令字符串进行解析，包括对“通配符模式表达式”的解析（比如<code>rm *.txt</code>命令中的“*.txt”），Linux Shell解析器所支持的“通配符模式表达式”被称为“Linux Shell通配符模式表达式”。<br>接下来是两点说明：<br>1、为防止命令字符串中的“某个表达式”被误认为是“Linux Shell通配符模式表达式”而被误解析，可将该表达式嵌在<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>对之间<br>2、Linux Shell通配符模式表达式中的“*”通配符不包含对“&#x2F;”字符的匹配。比如在当前目录执行<code>rm d*f.txt</code>命令，得到<code>/bin/rm: 无法删除&quot;d*f.txt&quot;: 没有那个文件或目录</code>结果；又比如在当前目录执行<code>rm *.txt</code>命令，只会删除“a.txt”和“b.txt”文件</p>
<h4 id="2-3-2、GNU-tar命令通配符模式表达式"><a href="#2-3-2、GNU-tar命令通配符模式表达式" class="headerlink" title="2.3.2、GNU tar命令通配符模式表达式"></a><strong>2.3.2、GNU tar命令通配符模式表达式</strong></h4><p>GNU tar命令有一个“–exclude&#x3D;PATTERN”选项，其中的“PATTERN”是通配符模式表达式，它由tar命令进行解析，tar命令解析器所支持的“通配符模式表达式”被称为“GNU tar命令通配符模式表达式”。<br>接下来是一点说明：<br>1、GNU tar命令通配符模式表达式中的“*”通配符包含对“&#x2F;”字符的匹配。比如在当前目录执行<code>tar --exclude=&#39;d*f.txt&#39; -czvf a.tar.gz .</code>命令，“d&#x2F;f.txt”文件未被打包；又比如在当前目录执行<code>tar --exclude=&#39;*.txt&#39; -czvf a.tar.gz .</code>命令，则所有的TXT文件都未被打包</p>
<h4 id="2-3-3、GNU-find命令通配符模式表达式"><a href="#2-3-3、GNU-find命令通配符模式表达式" class="headerlink" title="2.3.3、GNU find命令通配符模式表达式"></a><strong>2.3.3、GNU find命令通配符模式表达式</strong></h4><p>GNU find命令有一个“-path PATTERN”选项，其中的“PATTERN”是通配符模式表达式，它由find命令进行解析，find命令解析器所支持的“通配符模式表达式”被称为“GNU find命令通配符模式表达式”。<br>接下来是一点说明：<br>1、GNU find命令通配符模式表达式中的“*”通配符包含对“&#x2F;”字符的匹配。比如在当前目录执行<code>find . -path &#39;./d*&#39;</code>命令，能够找到“d”目录，“d&#x2F;g.txt”和“d&#x2F;f.txt”文件；又比如在当前目录执行<code>find -path &#39;./*.txt&#39;</code>命令，则所有的TXT文件都被找到</p>
<br/>
参考文献：
[1]http://www.regular-expressions.info/posix.html
[2]https://remram44.github.io/regex-cheatsheet/regex.html
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>汇编指令的LOCK指令前缀</title>
    <url>/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>本文介绍汇编指令的<code>LOCK指令前缀</code>，需要注意的是，<code>LOCK指令前缀</code>只是见于常见的汇编指令体系，而并不是存在于所有的汇编指令体系中，即有些汇编指令体系中用等价的设计来获得<code>LOCK指令前缀</code>提供的功能。而且，在具有<code>LOCK指令前缀</code>的汇编指令体系中，并不是所有的汇编指令都能被<code>LOCK指令前缀</code>修饰，不同汇编指令体系下允许被<code>LOCK指令前缀</code>修饰的汇编指令集不尽相同。</p>
<p><code>LOCK指令前缀</code>功能如下：</p>
<ul>
<li>被修饰的汇编指令成为“原子的”</li>
<li>与被修饰的汇编指令一起提供内存屏障效果</li>
</ul>
<br/>

<p><font color='red'>本文接下来以X86指令体系为上下文语境</font>，在X86指令体系中，具有<code>LOCK指令前缀</code>，其内允许使用<code>LOCK指令前缀</code>修饰的汇编指令有：</p>
<blockquote>
<p>ADD,ADC,AND,BTC,BTR,BTS,CMPXCHG,CMPXCH8B,DEC,INC,NEG,NOT,OR,SBB,SUB,XOR,XADD以及XCHG等</p>
</blockquote>
<p>需要注意的是，“XCHG”和“XADD”汇编指令本身是原子指令，但也允许使用<code>LOCK指令前缀</code>进行修饰。</p>
<h2 id="一、被修饰的汇编指令成为“原子的”"><a href="#一、被修饰的汇编指令成为“原子的”" class="headerlink" title="一、被修饰的汇编指令成为“原子的”"></a><strong>一、被修饰的汇编指令成为“原子的”</strong></h2><p>原子操作的本质描述是：当且仅当操作物理或者逻辑不可中断（不可中断：操作所涉内存不可被读取和修改）时，该操作才是原子的。</p>
<br/>

<p>原子汇编指令分为两类：</p>
<ul>
<li>本身是原子指令，比如“XCHG”和“XADD”汇编指令</li>
<li>本身不是原子指令，但是被<code>LOCK指令前缀</code>修饰后成为原子指令，比如<code>LOCK CMPXCHG</code></li>
</ul>
<p>汇编指令被<code>LOCK指令前缀</code>修饰后会成为“原子的”，因为<code>LOCK指令前缀</code>会带来如下效果：</p>
<ol>
<li>被修饰的汇编指令A在执行期间，会在内存总线上声言一个<code>#LOCK</code>信号，该信号导致内存被锁住，此时内存不能再被其他汇编指令存取，直到A执行完成。经过分析可知，A的执行效果与“暂停执行其他所有汇编指令直到A执行完成”等价，因此此时A是原子的</li>
<li>上一个方案锁住内存，期间内存不能被存取，代价非常大，因此，现在一般是采用“缓存锁定”的方案，避免降低内存的存取速度，具体是：<code>在汇编指令A（被LOCK指令前缀修饰的汇编指令）执行期间锁住所涉及到的Cache Line，此时其他CPU核不能存取其内缓存中对应的Cache Line</code>。需要注意的是，有些情形不能使用“缓存锁定”，而只能使用“内存总线锁定”，比如“所涉及操作数据跨越多个Cache Line”，“CPU不支持缓存锁定”等</li>
</ol>
<h2 id="二、与被修饰的汇编指令一起提供内存屏障效果"><a href="#二、与被修饰的汇编指令一起提供内存屏障效果" class="headerlink" title="二、与被修饰的汇编指令一起提供内存屏障效果"></a><strong>二、与被修饰的汇编指令一起提供内存屏障效果</strong></h2><p>内存屏障的作用（内存屏障可具有下述作用，但不一定需要具备下述所有作用）：</p>
<ul>
<li>禁止重排序</li>
<li>刷新缓存到内存</li>
<li>使缓存失效</li>
</ul>
<br/>

<p>内存屏障分为两类：</p>
<ul>
<li>本身是内存屏障，比如“lfence”，“sfence”和“mfence”汇编指令</li>
<li>本身不是内存屏障，但是被<code>LOCK指令前缀</code>修饰，其组合成为一个内存屏障。在X86指令体系中，其中一类内存屏障常使用“<code>LOCK指令前缀</code>加上一个空操作”方式实现，比如<code>lock addl $0x0,(%esp)</code></li>
</ul>
<p>汇编指令被LOCK指令前缀修饰后，一起提供内存屏障效果，因为LOCK指令前缀带来如下效果：</p>
<ul>
<li>将所有写缓冲区中的数据刷新到内存，并将所有涉及到的Cache Line状态置为无效，使得下次只能从内存读取</li>
<li>禁止指令重排序，即“B之前的语句集A禁止被重排序到B之后，B之后的语句集C禁止被重排序到B之前，执行顺序必为<code>A，B，C</code>”，<font color='red'>需要注意的是</font>，上述叙述中的语句集A和C内部是可能存在重排序的</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://blog.csdn.net/qq_30055391/article/details/84892936">https://blog.csdn.net/qq_30055391/article/details/84892936</a><br>[2]<a href="https://blog.csdn.net/muxiqingyang/article/details/6615199">https://blog.csdn.net/muxiqingyang/article/details/6615199</a><br>[3]<a href="https://blog.csdn.net/qq_26222859/article/details/52235930">https://blog.csdn.net/qq_26222859/article/details/52235930</a><br>[4]<a href="https://blog.csdn.net/zacklin/article/details/7445442">https://blog.csdn.net/zacklin/article/details/7445442</a><br>[5]<a href="https://stackoverflow.com/questions/29880015/lock-prefix-vs-mesi-protocol">https://stackoverflow.com/questions/29880015/lock-prefix-vs-mesi-protocol</a><br>[6]<a href="https://www.infoq.cn/article/cache-coherency-primer">https://www.infoq.cn/article/cache-coherency-primer</a><br>[7]<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C">https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C</a><br>[8]<a href="https://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly">https://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>活棋和死棋</title>
    <url>/blog/2023/10/15/%E6%B4%BB%E6%A3%8B%E5%92%8C%E6%AD%BB%E6%A3%8B/</url>
    <content><![CDATA[<h2 id="一、活棋"><a href="#一、活棋" class="headerlink" title="一、活棋"></a><strong>一、活棋</strong></h2><h3 id="1-1、双活"><a href="#1-1、双活" class="headerlink" title="1.1、双活"></a><strong>1.1、双活</strong></h3><p>双活：在这个局部，谁先走谁死，谁也吃不掉谁，最后黑白双方一起存活。如图1和图2所示。</p>
<p>图1</p>
<img src=https://blog.dslztx.top/imgs/20231015-0-1.svg width=30% height=30% />

<p>图2</p>
<img src=https://blog.dslztx.top/imgs/20231015-0-2.svg width=30% height=30% />

<h3 id="1-2、双真眼活棋"><a href="#1-2、双真眼活棋" class="headerlink" title="1.2、双真眼活棋"></a><strong>1.2、双真眼活棋</strong></h3><p>最常见的活棋棋形为：双真眼相连接（包括直接连接 + 间接连接）构成的棋形。</p>
<p>眼可分为3种：</p>
<ul>
<li>角上眼：1只眼角</li>
<li>边上眼：2只眼角</li>
<li>中央眼：4只眼角</li>
</ul>
<p>在继续介绍之前，首先复习关于充分条件、必要条件和逆否命题的相关知识：</p>
<ol>
<li>充分条件和必要条件：<ul>
<li>由A可以推出B（A -&gt; B），由B可以推出A（B -&gt; A），则A是B的充分必要条件（A &lt;-&gt; B）</li>
<li>由A可以推出B（A -&gt; B），由B不可以推出A，则A是B的充分不必要条件</li>
<li>由A不可以推出B，由B可以推出A（B -&gt; A），则A是B的必要不充分条件</li>
<li>由A不可以推出B，由B不可以推出A，则A是B的既不充分也不必要条件</li>
</ul>
</li>
<li>命题<code>A -&gt; B</code>成立，则其逆否命题<code>!B -&gt; !A</code>也成立</li>
</ol>
<h4 id="1-2-1、真眼与假眼定义"><a href="#1-2-1、真眼与假眼定义" class="headerlink" title="1.2.1、真眼与假眼定义"></a><strong>1.2.1、真眼与假眼定义</strong></h4><p>准确本质定义是：</p>
<ol>
<li>假眼 &lt;-&gt; 能局部打吃的眼</li>
<li>互为逆否的结论：不能局部打吃（不能打吃或者只能整体打吃）的眼 &lt;-&gt; 真眼</li>
</ol>
<h4 id="1-2-2、判断方法"><a href="#1-2-2、判断方法" class="headerlink" title="1.2.2、判断方法"></a><strong>1.2.2、判断方法</strong></h4><h5 id="1-2-2-1、眼边连接判断法"><a href="#1-2-2-1、眼边连接判断法" class="headerlink" title="1.2.2.1、眼边连接判断法"></a><strong>1.2.2.1、眼边连接判断法</strong></h5><p>结论：</p>
<ol>
<li>眼边连接（直接连接 + 间接连接） &lt;-&gt; 真眼</li>
<li>互为逆否的结论：假眼 &lt;-&gt; 眼边不连接（直接连接 + 间接连接）</li>
</ol>
<p>第1点的证明：</p>
<ul>
<li>充分性证明，即<code>眼边连接（直接连接 + 间接连接） -&gt; 真眼</code>：各种连接棋形必能进展到不能打吃或者只能整体打吃，得证</li>
<li>必要性证明，即<code>真眼 -&gt; 眼边连接（直接连接 + 间接连接）</code>：真眼（不能打吃或者只能整体打吃）必能推导到各种连接情形，得证</li>
</ul>
<h5 id="1-2-2-2、眼角判断法"><a href="#1-2-2-2、眼角判断法" class="headerlink" title="1.2.2.2、眼角判断法"></a><strong>1.2.2.2、眼角判断法</strong></h5><p>眼边连接判断法计算量过大，故产生一种脱胎于眼边连接判断法（敌方占据眼角是某种程度的分断）的减小计算量的近似判断法——眼角判断法。</p>
<p>其结论为：</p>
<ol>
<li>角上眼（共1只眼角）：<ul>
<li>被敌方占据1只眼角是假眼[<font color='red'>近似</font>]</li>
<li>未被敌方占据1只眼角（1只眼角或为己方所占，或不为双方所占）是真眼[<font color='red'>准确</font>]</li>
</ul>
</li>
<li>边上眼（共2只眼角）：<ul>
<li>被敌方占据&gt;&#x3D;1只眼角是假眼[<font color='red'>近似</font>]</li>
<li>未被敌方占据&gt;&#x3D;1只眼角（2只眼角或为己方所占，或不为双方所占）是真眼[<font color='red'>准确</font>]</li>
</ul>
</li>
<li>中央眼（共4只眼角）：<ul>
<li>被敌方占据&gt;&#x3D;2只眼角是假眼[<font color='red'>近似</font>]</li>
<li>未被敌方占据&gt;&#x3D;2只眼角（至少3只眼角或为己方所占，或不为双方所占）是真眼[<font color='red'>准确</font>]</li>
</ul>
</li>
</ol>
<p>以上判断法解析：</p>
<ol>
<li><code>角上眼被敌方占据1只眼角 / 边上眼被敌方占据&gt;=1只眼角 / 中央眼被敌方占据&gt;=2只眼角</code>是<code>相应眼不连接（直接连接 + 间接连接）</code>的必要不充分条件（如图3、图4和图5中眼A），而<code>不连接（直接连接 + 间接连接） &lt;-&gt; 假眼</code>，故有<code>角上眼被敌方占据1只眼角 / 边上眼被敌方占据&gt;=1只眼角 / 中央眼被敌方占据&gt;=2只眼角</code>是<code>相应眼是假眼</code>的必要不充分条件，即：<ul>
<li><code>角上眼被敌方占据1只眼角 / 边上眼被敌方占据&gt;=1只眼角 / 中央眼被敌方占据&gt;=2只眼角</code> -\-&gt; <code>相应眼是假眼</code>，因此以上判断法中的假眼判断是近似而不准确的</li>
<li><code>相应眼是假眼</code> -&gt; <code>角上眼被敌方占据1只眼角 / 边上眼被敌方占据&gt;=1只眼角 / 中央眼被敌方占据&gt;=2只眼角</code></li>
</ul>
</li>
<li>第1点结论的逆否命题分别为：<ul>
<li><code>相应眼是真眼</code> -\-&gt; <code>角上眼未被敌方占据1只眼角 / 边上眼未被敌方占据&gt;=1只眼角 / 中央眼未被敌方占据&gt;=2只眼角</code></li>
<li><code>角上眼未被敌方占据1只眼角 / 边上眼未被敌方占据&gt;=1只眼角 / 中央眼未被敌方占据&gt;=2只眼角</code> -&gt; <code>相应眼是真眼</code>，因此以上判断法中的真眼判断是准确的</li>
</ul>
</li>
</ol>
<p>图3</p>
<img src=https://blog.dslztx.top/imgs/20231015-0-3.svg width=30% height=30% />

<p>图4</p>
<img src=https://blog.dslztx.top/imgs/20231015-0-4.svg width=30% height=30% />

<p>图5</p>
<img src=https://blog.dslztx.top/imgs/20231015-0-5.svg width=30% height=30% />

<hr>
<p>图6是常被称为“假眼活棋&#x2F;两头蛇活棋&#x2F;盘龙眼活棋”的棋形[1]，称之为“假眼”其实不然，根据以上描述，其本质还是双真眼活棋，只不过别处误将眼角判断法作为了一个准确的判断法，甚至作为了真眼和假眼的定义法。</p>
<p>图6</p>
<p><img src="https://blog.dslztx.top/imgs/20231015-0-6.png"></p>
<h2 id="二、死棋"><a href="#二、死棋" class="headerlink" title="二、死棋"></a><strong>二、死棋</strong></h2><p>死棋包括：</p>
<ol>
<li>已经没有气的棋子</li>
<li>有气，但无法做活的棋子</li>
</ol>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://zh.wikipedia.org/zh/%E5%81%87%E7%9C%BC%E6%B4%BB">https://zh.wikipedia.org/zh/%E5%81%87%E7%9C%BC%E6%B4%BB</a></p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Java虚拟机</title>
    <url>/blog/2021/12/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>第3版。</p>
<h2 id="一、走近Java"><a href="#一、走近Java" class="headerlink" title="一、走近Java"></a><strong>一、走近Java</strong></h2><p><del>第1章 走近Java</del></p>
<h2 id="二、自动内存管理"><a href="#二、自动内存管理" class="headerlink" title="二、自动内存管理"></a><strong>二、自动内存管理</strong></h2><p><del>第2章 Java内存区域与内存溢出异常</del></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>灯具选择</title>
    <url>/blog/2023/02/01/%E7%81%AF%E5%85%B7%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="一、光源"><a href="#一、光源" class="headerlink" title="一、光源"></a><strong>一、光源</strong></h2><p>光源是灯具的核心，故首先介绍光源。根据发光原理，可分为3类：1）白炽现象发光；2）荧光发光；3）LED发光。</p>
<p>关于光的一些介绍，可参见<a href="/blog/2023/01/30/%E5%85%89/" title="光">《光》</a>。</p>
<h3 id="1-1、白炽现象发光"><a href="#1-1、白炽现象发光" class="headerlink" title="1.1、白炽现象发光"></a><strong>1.1、白炽现象发光</strong></h3><p>发光原理：通电加热灯丝到白炽状态，利用热辐射发出可见光。</p>
<p>常见的基于白炽发光的灯具有：</p>
<ul>
<li>白炽灯，就是小时候用的那种时间长了会很烫手、经常呼啦一下烧断了钨丝的灯泡</li>
<li>卤素灯，可以看做是白炽灯的升级版，会在灯泡内注入碘或溴等卤素气体，高温下，升华的钨丝与卤素进行化学作用，冷却后的钨会重新凝固在钨丝上，形成平衡的循环，避免钨丝过早断裂</li>
</ul>
<p>该类灯具特点（基于该类常见灯具的定性描述，即可能存在该类不常见灯具违背以下特点）：</p>
<ol>
<li>能源利用率：能源利用率低，所消耗的电能只有不到10%可转化为光能，其余部分以热能的形式散失</li>
<li>材料寿命：寿命短，1000小时左右</li>
<li>光危害：蓝光含量少，紫外线含量少，红外线含量高</li>
<li>色温：2500-3000K</li>
<li>显色指数：显色指数非常高，在95-100之间</li>
<li>照度：跟“灯具瓦数”和“能源利用率”相关</li>
</ol>
<p><strong>[备注]</strong> 我国从2011年起逐步实行淘汰计划，到2016年10月1日起，禁止销售和进口15瓦及以上普通照明用白炽灯。</p>
<h3 id="1-2、荧光发光"><a href="#1-2、荧光发光" class="headerlink" title="1.2、荧光发光"></a><strong>1.2、荧光发光</strong></h3><p>发光原理：利用低气压的汞蒸气在通电后释放紫外线，从而使荧光粉发出可见光。</p>
<p>常见的基于荧光发光的灯具有：</p>
<ul>
<li>普通荧光灯，比如“小时候常见的长条状的日光灯就属于普通荧光灯的一种”</li>
<li>节能灯（国外简称为CFL灯），全称为“紧凑型三基色电子荧光灯”，是一种紧凑型、自带镇流器的日光灯</li>
</ul>
<p>该类灯具特点（基于该类常见灯具的定性描述，即可能存在该类不常见灯具违背以下特点）：</p>
<ol>
<li>能源利用率：能源利用率低，所消耗的电能只有不到30%可转化为光能，其余部分以热能的形式散失</li>
<li>材料寿命：寿命短，6000小时左右</li>
<li>光危害：蓝光含量多，紫外线含量多，红外线含量少</li>
<li>色温：2700-6400K</li>
<li>显色指数：显色性差异较大，多数不高</li>
<li>照度：跟“灯具瓦数”和“能源利用率”相关</li>
</ol>
<h3 id="1-3、LED发光"><a href="#1-3、LED发光" class="headerlink" title="1.3、LED发光"></a><strong>1.3、LED发光</strong></h3><p>发光二极管，是一种能够将电能转化为可见光的固态的半导体器件，它可以直接把电转化为光。英文名为Light Emitting Diode，简称LED。</p>
<p>该类灯具特点（基于该类常见灯具的定性描述，即可能存在该类不常见灯具违背以下特点）：</p>
<ol>
<li>能源利用率：能源利用率高，所消耗的电能有80%以上可转化为光能，其余部分以热能的形式散失。故常被称为LED节能灯，须注意与“节能灯（CFL灯）”的区分</li>
<li>材料寿命：寿命长，5万-10万小时</li>
<li>光危害：蓝光含量多，紫外线含量少，红外线含量少</li>
<li>色温：范围广</li>
<li>显色指数：范围广</li>
<li>照度：跟“灯具瓦数”和“能源利用率”相关</li>
</ol>
<p><strong>[备注]</strong> 各国大力推广发展LED灯。</p>
<h2 id="二、灯具选择"><a href="#二、灯具选择" class="headerlink" title="二、灯具选择"></a><strong>二、灯具选择</strong></h2><p>灯具选择的核心指标有：能源利用率，材料寿命，显色指数，色温，光危害，照度，无可视频闪；非核心指标有：智能控制，智能互动，更高安全性等。</p>
<p>首先须选择光源，结合上一章节内容，选择LED灯具，因为：LED灯具在可控制调节获得“高显色指数，合适色温，最小光危害，高照度，无可视频闪”的前提下，具有最高的能源利用率和最优的材料寿命表现。</p>
<p>接下来描述不同场景下的LED灯具选择。</p>
<h3 id="2-1、工作学习场景"><a href="#2-1、工作学习场景" class="headerlink" title="2.1、工作学习场景"></a><strong>2.1、工作学习场景</strong></h3><p>对除了“能源利用率”和“材料寿命”之外的核心指标要求如下：</p>
<ul>
<li>色温：4000K左右</li>
<li>显色指数：大于80</li>
<li>光危害：LED天然没有红外线、紫外线危害，控制减少蓝光危害</li>
<li>照度：国AA级[3]</li>
<li>无可视频闪</li>
</ul>
<h3 id="2-2、卧室（不工作学习）场景"><a href="#2-2、卧室（不工作学习）场景" class="headerlink" title="2.2、卧室（不工作学习）场景"></a><strong>2.2、卧室（不工作学习）场景</strong></h3><p>对除了“能源利用率”和“材料寿命”之外的核心指标要求如下：</p>
<ul>
<li>色温：2700-3000K</li>
<li>显色指数：不必要大于80</li>
<li>光危害：LED天然没有红外线、紫外线危害，控制减少蓝光危害</li>
<li>照度：没有太高要求</li>
<li>无可视频闪</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>&#91;1&#93;<a href="https://www.soujianzhu.cn/NormAndRules/NormContent.aspx?id=231#3-2">《室内建筑照明规范》</a><br>[2]<a href="http://www.jiankangguang.com/index.php/cms/show-51.html">http://www.jiankangguang.com/index.php/cms/show-51.html</a><br>[3]GB&#x2F;T 9473-2017《读写作业台灯性能要求》</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/blog/2024/02/06/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="一、物理层"><a href="#一、物理层" class="headerlink" title="一、物理层"></a><strong>一、物理层</strong></h2><p>物理层的目标是确保在计算机网络中繁多的硬件设备、传输媒体和通信手段上能够正确传输数据比特流，并且对数据链路层屏蔽具体的“硬件设备、传输媒体和通信手段”细节。</p>
<p>基于上述目标，物理层的任务有：</p>
<ol>
<li>确定与传输媒体接口有关的一些特性：<ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，平时常见的各种规格的接插件都有严格的标准化的规定</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压范围，阻抗匹配，传输速率，距离限制等</li>
<li>功能特性：指明某条线上出现的某一个电平的电压的意义</li>
<li>过程特性：指明对于不同功能的各种可能事件的出现顺序</li>
</ul>
</li>
<li>数据在计算机内部多采用并行传输方式，而在通信线路上用串行方式，物理层需要负责传输方式的转换</li>
<li>…</li>
</ol>
<p>物理层协议设计完成物理层任务，达成物理层目标。因应“繁多的硬件设备、传输媒体、通信手段，且物理连接方式分为点对点和广播等”，物理层协议众多。</p>
<p><font color='red'>学习物理层协议，重点在于基本概念，避免陷入细节地狱（比如“物理层是否关注信号复用”，“物理层是否关注‘单向通信&#x2F;双向交替通信&#x2F;双向同时通信’通信工作方式”等），我们应把主要精力放在数据链路层、网络层、传输层和应用层。</font></p>
<h2 id="二、信号学简单介绍"><a href="#二、信号学简单介绍" class="headerlink" title="二、信号学简单介绍"></a><strong>二、信号学简单介绍</strong></h2><p>本节对信号学进行简单介绍，详细介绍可参看通信学、信号学相关书籍。</p>
<p>凡是能承载信息的客体都能作为信号，比如：</p>
<ul>
<li>红绿灯</li>
<li>信号枪</li>
<li>手电筒三短、三长、三短</li>
<li>灯光的明暗</li>
<li>口令</li>
<li>电磁波（光也属于电磁波）</li>
</ul>
<p>本文讨论电磁波信号，电磁波波谱如下图所示。</p>
<p><img src="https://blog.dslztx.top/imgs/20230508-0-0.jpeg"></p>
<h3 id="2-1、信号"><a href="#2-1、信号" class="headerlink" title="2.1、信号"></a><strong>2.1、信号</strong></h3><p>信号可分为两类：模拟信号（连续信号）和数字信号（离散信号）。</p>
<p>两类信号的优缺点如下表。</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>模拟信号</td>
<td>1)直观<br/>2)技术易实现</td>
<td>1)保密性差<br/>2)抗噪声干扰能力弱，故只适合短距离传输</td>
</tr>
<tr>
<td>数字信号</td>
<td>1)保密性好<br/>2)抗噪声干扰能力强，故适合长距离传输</td>
<td>1)不直观<br/>2)技术不易实现</td>
</tr>
</tbody></table>
<p>结论：综合来看，数字信号优于模拟信号，现实世界正在进行越来越多的“模拟信号通信 -&gt; 数字信号通信”改造。</p>
<h3 id="2-2、传输媒体"><a href="#2-2、传输媒体" class="headerlink" title="2.2、传输媒体"></a><strong>2.2、传输媒体</strong></h3><table>
<thead>
<tr>
<th>传输媒体</th>
<th>属于导引&#x2F;非导引</th>
<th>支持的信号形式</th>
<th>抗干扰性</th>
<th>衰减性</th>
<th>经济成本</th>
</tr>
</thead>
<tbody><tr>
<td>双绞线</td>
<td>导引</td>
<td>模拟信号、数字信号</td>
<td>次次高</td>
<td>次次高</td>
<td>次次高</td>
</tr>
<tr>
<td>同轴电缆</td>
<td>导引</td>
<td>模拟信号、数字信号</td>
<td>次高</td>
<td>次高</td>
<td>次高</td>
</tr>
<tr>
<td>光纤</td>
<td>导引</td>
<td>模拟信号、数字信号</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>空气（无线传输电磁波）</td>
<td>非导引</td>
<td>模拟信号、数字信号</td>
<td>差</td>
<td>差</td>
<td>低</td>
</tr>
<tr>
<td>二级管电缆（虚拟）</td>
<td>导引</td>
<td>数字信号</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ul>
<li>双绞线，同轴电缆，光纤都有不同规格，抗干扰性、衰减性和经济成本等维度的比较基于一般情况</li>
<li>当前数字信号传输的常用方案：远距离用光纤，中距离用同轴电缆，近距离用双绞线或者空气（比如“5G”，“Wifi”）</li>
</ul>
<h3 id="2-3、信号承载信息"><a href="#2-3、信号承载信息" class="headerlink" title="2.3、信号承载信息"></a><strong>2.3、信号承载信息</strong></h3><p>通过编码，信号（包括“模拟信号”和“数字信号”）可以承载信息。</p>
<p>在继续介绍之前首先介绍带宽的含义：</p>
<ul>
<li>原义：带宽原指频率范围，单位为赫兹（Hz）。以带宽（频率）区分后述扩展义</li>
<li>扩展义：后由于带宽跟数据速率的紧密关系，被借用表示数据速率，单位为比特&#x2F;秒（“bit&#x2F;s”，简写为“b&#x2F;s”或者“bps”）。须知<code>Kbps，Mbps，Gbps</code>中的<code>K，M，G</code>分别表示<code>10^3，10^6，10^9</code>，而不是<code>2^10，2^20，2^30</code>。以带宽（速率）区分上述原义</li>
</ul>
<p>香农定理描述了特定传输媒体上的不失真信息传输速率理论极限值C，具体有公式<code>C = B * log2(1 + S/N)</code>。<br>其中：</p>
<ul>
<li><code>C</code>是极限的不失真信息传输速率，即理论极限不失真带宽（速率），单位为“比特&#x2F;秒（bps）”<br> -<code>B</code>是信道带宽（频率），单位为“赫兹（Hz）”</li>
<li><code>S</code>是平均信号功率，<code>N</code>是平均噪声功率，<code>S/N</code>是信噪比</li>
</ul>
<p>根据以上定理，假定实际不失真信息传输速率为F，即实际不失真带宽（速率），那么我们可以不断追寻合适的编码方案以期将F不断逼近C，虽然实际不可能达到，因为传输过程中信号还要受到其他一些损伤，比如“各种脉冲干扰”。</p>
<h3 id="2-4、信道"><a href="#2-4、信道" class="headerlink" title="2.4、信道"></a><strong>2.4、信道</strong></h3><p>信道是一个逻辑概念，有狭义和广义之分：</p>
<ul>
<li>狭义：跟数据传输方向有关，同一条逻辑通路相反的两个数据传输方向有两条信道</li>
<li>广义：跟数据传输方向无关，同一条逻辑通路相反的两个数据传输方向只有一条信道</li>
</ul>
<p>本博文使用广义概念。</p>
<p>一条传输媒体通道可以复用成N（N&gt;&#x3D;1）个信道：</p>
<ul>
<li>N&#x3D;1，信道最大带宽（速率）&#x3D; 传输媒体最大带宽（速率）</li>
<li>N&gt;1，所有信道的最大带宽（速率）和 &#x3D; 传输媒体最大带宽（速率）</li>
</ul>
<p>常见的复用技术有：</p>
<ul>
<li>频分复用：Frequency Division Multiplexing(FDM)，一个信道固定使用分配到的频带，在通信过程中始终占用这个频带</li>
<li>时分复用：Time Division Multiplexing(TDM)，一个信道固定使用分配到的时间片，在通信过程中始终占用这个时间片</li>
<li>码分复用：Code Division Multiplexing(CDM)，不同信道固定使用不同的码片序列，不同信道使用的码片序列互相正交。相较于“频分复用”和“时分复用”，码分复用方案可获得相对较高的传输媒体最大平均实际带宽（速率），因为占据所有时间片和在任意时刻可以利用所有频带资源，代价是较高的技术落地难度和较大的资源消耗</li>
<li>波分复用：Wavelength Division Multiplexing(WDM)，即光的频分复用</li>
<li>统计时分复用：Static TDM(STDM)，即改进的时分复用。称一般时分复用为同步时分复用，统计时分复用为异步时分复用</li>
</ul>
<h3 id="2-5、信号同步"><a href="#2-5、信号同步" class="headerlink" title="2.5、信号同步"></a><strong>2.5、信号同步</strong></h3><p>要想正确实现信号的传输，可能还需要信号发送端和接收端双方的时钟同步，是否需要时钟同步跟“编码方案”，“复用技术”等因素有关。<br>比如：</p>
<ul>
<li>采用时分复用需要信号发送端和接收端双方的时钟同步</li>
<li>非采用时分复用前提下使用差分曼彻斯特编码，具备自同步能力</li>
<li>CDMA需要同步</li>
</ul>
<p>当下流行的时钟同步方案标准为SDH&#x2F;SONET。</p>
<p><font color='red'>关于是否需要时钟同步和时钟同步方案内容，笔者未作深入了解。</font></p>
<h2 id="三、通信过程总结"><a href="#三、通信过程总结" class="headerlink" title="三、通信过程总结"></a><strong>三、通信过程总结</strong></h2><h3 id="3-1、通信过程"><a href="#3-1、通信过程" class="headerlink" title="3.1、通信过程"></a><strong>3.1、通信过程</strong></h3><p>单次通信过程：<code>发送信号 -&gt; 调制（光猫，ADSL猫等） -&gt; 信道 -&gt; 解调（光猫，ADSL猫等） -&gt; 接收信号</code>。</p>
<p>需要说明的是：</p>
<ol>
<li>调制和解调的含义是广义的：<ul>
<li>调制：对信号进行变换的过程统称为调制，包括“数字信号 -&gt; 模拟信号”，“模拟信号 -&gt; 数字信号”，“低频信号 -&gt; 高频信号”，“高频信号 -&gt; 低频信号”等</li>
<li>解调：对应的调制过程的逆过程</li>
</ul>
</li>
<li>以上信道所指代的信号传输过程中可能包括多个调制&#x2F;解调过程</li>
</ol>
<h3 id="3-2、通信工作方式"><a href="#3-2、通信工作方式" class="headerlink" title="3.2、通信工作方式"></a><strong>3.2、通信工作方式</strong></h3><p>通信工作方式有3种：</p>
<ul>
<li>双向同时通信：通信的双方可以同时发送和接收消息</li>
<li>双向交替通信：通信的双方都可以发送或者接收消息，但不能双方同时发送，当然也不能同时接收</li>
<li>单向通信：单方向通信</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="/blog/2024/02/06/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/" title="网络原理概述">《网络原理概述》</a><br>[2]<a href="https://github.com/jolesen/BOOKS/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89-%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf">https://github.com/jolesen/BOOKS/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89-%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf</a><br>[3]<a href="https://blog.csdn.net/Hedon954/article/details/119361409">https://blog.csdn.net/Hedon954/article/details/119361409</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>生活急救大全</title>
    <url>/blog/2018/06/25/%E7%94%9F%E6%B4%BB%E6%80%A5%E6%95%91%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="一、喉气管异物堵塞"><a href="#一、喉气管异物堵塞" class="headerlink" title="一、喉气管异物堵塞"></a><strong>一、喉气管异物堵塞</strong></h2><p>喉咙，气管异物堵塞，表现为“患者突然呛咳、不能发音、喘鸣、呼吸急促、皮肤发紫，严重者可迅速出现意识丧失，甚至呼吸心跳停止”。<br>推荐采用“海姆立克急救法”，海姆立克急救法是冲击患者腹部及膈肌等软组织，产生向上的压力，压迫两肺下部，从而驱使肺部残留气体形成一股强大气流，而将堵塞住气管、咽喉部的异物排出。</p>
<h3 id="1-1、婴幼儿"><a href="#1-1、婴幼儿" class="headerlink" title="1.1、婴幼儿"></a><strong>1.1、婴幼儿</strong></h3><p><strong>要点描述：</strong><br>0. 救助者将婴儿的身体置于一侧的前臂上，同时手掌将后头颈部固定，头部低于躯干<br>0. 用另一手固定婴儿下颌角，并使婴儿头部轻度后仰，打开气道<br>0. 两前臂将婴儿固定，翻转呈俯卧位<br>0. 用手掌跟向内、向上叩击婴儿背部两肩胛骨中间5次<br>0. 检查口腔，如异物排出，迅速用手取出异物<br>0. 否则，两手及前臂将婴儿翻转为仰卧位<br>0. 快速冲击性按压婴儿两乳头平线中间5次<br>0. 检查口腔，如异物排出，迅速用手取出异物<br>0. 若阻塞物未能排出，重复进行背部叩击和胸部冲击</p>
<p><strong>视频地址：</strong><br>地址1：<a href="https://v.qq.com/x/page/f0664zs73ud.html">https://v.qq.com/x/page/f0664zs73ud.html</a><br>地址2：<a href="https://v.qq.com/x/page/u03488kifrv.html">https://v.qq.com/x/page/u03488kifrv.html</a><br>地址3：<a href="https://v.qq.com/x/page/p0385btxrzc.html">https://v.qq.com/x/page/p0385btxrzc.html</a><br>地址4：<a href="https://v.qq.com/x/page/g01524h7t84.html">https://v.qq.com/x/page/g01524h7t84.html</a></p>
<p><font color='red'>注意：</font><br>千万不要将婴儿双脚抓起倒吊从背部拍打，这样不仅无法排出异物，还可能造成颈椎受伤。</p>
<h3 id="1-2、成人"><a href="#1-2、成人" class="headerlink" title="1.2、成人"></a><strong>1.2、成人</strong></h3><h4 id="1-2-1、他救"><a href="#1-2-1、他救" class="headerlink" title="1.2.1、他救"></a><strong>1.2.1、他救</strong></h4><h5 id="1-2-1-1、他救立位腹部冲击法"><a href="#1-2-1-1、他救立位腹部冲击法" class="headerlink" title="1.2.1.1、他救立位腹部冲击法"></a><strong>1.2.1.1、他救立位腹部冲击法</strong></h5><p><strong>要点描述：</strong><br>0. 救助者站在患者的背后，患者弯腰、头部前倾、张开嘴巴，以利于异物排出<br>0. 救助者一手握空心拳，拳眼顶住患者腹部正中脐上两横指处<br>0. 另一手紧握此拳，快速向内、向上冲击5次<br>0. 检查口腔，如异物排出，迅速用手将其取出</p>
<p><strong>视频地址：</strong><br>地址1：<a href="https://v.qq.com/x/page/p0385btxrzc.html">https://v.qq.com/x/page/p0385btxrzc.html</a><br>地址2：<a href="https://v.qq.com/x/page/b05331488by.html">https://v.qq.com/x/page/b05331488by.html</a><br>地址3：<a href="https://v.qq.com/x/page/n0195yyme6j.html">https://v.qq.com/x/page/n0195yyme6j.html</a><br>地址4：<a href="https://v.qq.com/x/page/o0152vafh9t.html">https://v.qq.com/x/page/o0152vafh9t.html</a></p>
<h5 id="1-2-1-2、他救仰卧腹部冲击法"><a href="#1-2-1-2、他救仰卧腹部冲击法" class="headerlink" title="1.2.1.2、他救仰卧腹部冲击法"></a><strong>1.2.1.2、他救仰卧腹部冲击法</strong></h5><p><strong>要点描述：</strong><br>0. 将患者置于仰卧位，使头后仰，救助者骑跨在患者髋部两侧<br>0. 救助者一只手的掌跟置于患者腹部正中脐上两横指处，不要触及剑突。另一手直接放在第一只手背上，两手掌跟重叠<br>0. 两手合力快速向上、向内有节奏冲击患者的腹部，连续5次，可重复操作若干次<br>0. 检查口腔，如异物排出，迅速用手将其取出</p>
<p><strong>视频地址：</strong><br>地址1：<a href="https://v.qq.com/x/page/p0385btxrzc.html">https://v.qq.com/x/page/p0385btxrzc.html</a></p>
<h4 id="1-2-2、自救"><a href="#1-2-2、自救" class="headerlink" title="1.2.2、自救"></a><strong>1.2.2、自救</strong></h4><p>采用自救腹部冲击法。<br><strong>要点描述：</strong><br>0. 自己的一手握空心拳，拳眼置于腹部正中脐上两横指处<br>0. 另一手紧握此拳，双手同时向内、向上冲击5次，每次冲击动作要明显分开<br>0. 还可选择将上腹部压在坚硬物上，如：桌边、椅背和栏杆处，连续向内、向上冲击5次<br>0. 冲击5次无效，可重复操作若干次，直至异物排出</p>
<p><strong>视频地址：</strong><br>地址1：<a href="https://v.qq.com/x/page/p0385btxrzc.html">https://v.qq.com/x/page/p0385btxrzc.html</a><br>地址2：<a href="https://v.qq.com/x/page/n0195yyme6j.html">https://v.qq.com/x/page/n0195yyme6j.html</a><br>地址3：<a href="https://v.qq.com/x/page/i036683s09w.html">https://v.qq.com/x/page/i036683s09w.html</a><br>地址4：<a href="https://v.qq.com/x/page/g01524h7t84.html">https://v.qq.com/x/page/g01524h7t84.html</a></p>
<h3 id="1-3、2岁以上儿童"><a href="#1-3、2岁以上儿童" class="headerlink" title="1.3、2岁以上儿童"></a><strong>1.3、2岁以上儿童</strong></h3><p>采用腹部立位冲击法，跟“1.2.1.1、他救立位腹部冲击法”中的一样。</p>
<h2 id="二、毒蛇咬伤急救"><a href="#二、毒蛇咬伤急救" class="headerlink" title="二、毒蛇咬伤急救"></a><strong>二、毒蛇咬伤急救</strong></h2><p>毒蛇咬伤后，首先需紧急自救，做到“一辨二结三冲洗”。紧急自救后，应尽快到有能力处理蛇伤的医院接受治疗，但千万不能快速奔逃，避免蛇毒迅速扩散。<br><strong>1、辨</strong><br>“辨”指的是辨认蛇种。毒蛇咬伤常为大而深的牙痕，无毒蛇咬伤则为细小牙痕。若无法辨别，应记住蛇的样子（可以拍照），便于后期医生对症施治。<br><strong>2、结</strong><br>“结”指的是尽快在距离伤口上方约10厘米处进行结扎，以延缓毒素扩散，但需注意每隔20分钟放松结扎，以免肢体因血循环受阻而坏死。<br><strong>3、冲洗</strong><br>“冲洗”指的是在结扎好后，用利器将伤口切开，由周围向伤口反复挤压，尽量逼出毒血，并用清水清洗伤口。</p>
<br/>
参考文献：
[1]https://mooc.guokr.com/note/20648
[2]http://www.xinhuanet.com/2018-06/06/c_1122946742.htm
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>急救</tag>
      </tags>
  </entry>
  <entry>
    <title>疫苗接种</title>
    <url>/blog/2018/05/21/%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/</url>
    <content><![CDATA[<h2 id="一、疫苗分类-1"><a href="#一、疫苗分类-1" class="headerlink" title="一、疫苗分类[1]"></a><strong>一、疫苗分类[1]</strong></h2><p>第一类疫苗，是指政府免费向公民提供，公民应当依照政府的规定受种的疫苗，包括国家免疫规划确定的疫苗，省、自治区、直辖市人民政府在执行国家免疫规划时增加的疫苗，以及县级以上人民政府或者其卫生主管部门组织的应急接种或者群体性预防接种所使用的疫苗。<br>第二类疫苗，是指由公民自费并且自愿受种的其他疫苗。</p>
<h2 id="二、疫苗清单"><a href="#二、疫苗清单" class="headerlink" title="二、疫苗清单"></a><strong>二、疫苗清单</strong></h2><h3 id="2-1、第一类疫苗"><a href="#2-1、第一类疫苗" class="headerlink" title="2.1、第一类疫苗"></a><strong>2.1、第一类疫苗</strong></h3><p>根据2017年4月28日《浙江省扩大国家免疫规划实施方案》[2]。</p>
<table>
<thead>
<tr>
<th>疫苗名称</th>
<th>所属疫苗家族</th>
<th>是否为联合疫苗</th>
<th>疫苗预防疾病</th>
<th>疫苗接种程序</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>重组乙型肝炎疫苗</td>
<td>乙肝疫苗</td>
<td>否</td>
<td>乙型肝炎</td>
<td>共3剂：出生、1月、6月各注射一剂重组乙型肝炎疫苗</td>
<td>出生后24小时内接种第1剂，第1、2剂间隔≥28天</td>
</tr>
<tr>
<td>卡介苗</td>
<td>结核病疫苗</td>
<td>否</td>
<td>结核病</td>
<td>共1剂：出生注射一剂卡介苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>脊髓灰质炎灭活疫苗（IPV）和脊髓灰质炎减毒活疫苗</td>
<td>脊灰疫苗</td>
<td>否</td>
<td>脊髓灰质炎</td>
<td>共4剂：2月注射一剂脊髓灰质炎灭活疫苗，3月、4月、4周岁各口服一剂脊髓灰质炎减毒活疫苗</td>
<td>第1、2剂，第2、3剂间隔≥28天</td>
</tr>
<tr>
<td>吸附无细胞百日咳白喉破伤风联合疫苗（百白破疫苗）</td>
<td>百日破疫苗、白喉疫苗、破伤风疫苗</td>
<td>是</td>
<td>百日咳、白喉、破伤风</td>
<td>共4剂：3月、4月、5月、18-24月各注射一剂吸附无细胞百日咳白喉破伤风联合疫苗</td>
<td>第1、2剂，第2、3剂间隔≥28天</td>
</tr>
<tr>
<td>吸附白喉破伤风联合疫苗（白破疫苗）</td>
<td>白喉疫苗、破伤风疫苗</td>
<td>是</td>
<td>白喉、破伤风</td>
<td>共1剂：6周岁注射一剂吸附白喉破伤风联合疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>A群&#x2F;AC群脑膜炎球菌多糖疫苗</td>
<td>流脑疫苗</td>
<td>否</td>
<td>A群、C群脑膜炎球菌引起的流行性脑脊髓膜炎</td>
<td>共4剂：6、9月各注射一剂A群脑膜炎球菌多糖疫苗，3周岁、6周岁各注射一剂AC群脑膜炎球菌多糖疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>乙型脑炎减毒活疫苗</td>
<td>乙脑疫苗</td>
<td>否</td>
<td>乙型脑炎</td>
<td>共2剂：8月、2周岁各注射一剂乙型脑炎减毒活疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>麻疹（腮腺炎）风疹联合疫苗（麻腮风疫苗）</td>
<td>麻疹疫苗、腮腺炎疫苗、风疹疫苗</td>
<td>是</td>
<td>麻疹、腮腺炎、风疹</td>
<td>共2剂：8月注射一剂麻风疫苗，18-24月注射一剂麻腮风疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>甲型肝炎减毒活疫苗</td>
<td>甲肝疫苗</td>
<td>否</td>
<td>甲型肝炎</td>
<td>共1剂：18月注射一剂甲型肝炎减毒活疫苗</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<h3 id="2-2、第二类疫苗"><a href="#2-2、第二类疫苗" class="headerlink" title="2.2、第二类疫苗"></a><strong>2.2、第二类疫苗</strong></h3><table>
<thead>
<tr>
<th>疫苗名称</th>
<th>所属疫苗家族</th>
<th>是否为联合疫苗</th>
<th>疫苗预防疾病</th>
<th>疫苗接种程序</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>23价肺炎疫苗</td>
<td>肺炎疫苗</td>
<td>否</td>
<td>肺炎球菌性肺炎</td>
<td>共1剂（≥2周岁）</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>A+C群流脑（结合）疫苗</td>
<td>流脑疫苗</td>
<td>否</td>
<td>A群、C群脑膜炎球菌引起的流行性脑脊髓膜炎</td>
<td>共2剂，间隔3月（6月-2周岁）</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>B型流感嗜血杆菌疫苗（Hib）</td>
<td>B型流感嗜血杆菌疫苗</td>
<td>否</td>
<td>B型流感嗜血杆菌感染</td>
<td>共4剂：2月、3月、4月、18月各注射一剂B型流感嗜血杆菌疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>无细胞百白破+IPV+Hib联合疫苗（五联苗）</td>
<td>百日咳疫苗、白喉疫苗、破伤风疫苗、脊灰疫苗、B型流感嗜血杆菌疫苗</td>
<td>是</td>
<td>百日咳、白喉、破伤风、脊髓灰质炎、B型流感嗜血杆菌感染</td>
<td>共4剂：2月、3月、4月、18月各注射一剂五联苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>冻干水痘疫苗</td>
<td>水痘疫苗</td>
<td>否</td>
<td>水痘</td>
<td>共2剂：15月、4周岁各注射一剂冻干水痘疫苗</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>流感裂解疫苗</td>
<td>流行性感冒疫苗</td>
<td>否</td>
<td>流行性感冒</td>
<td>共1剂（≥3周岁）</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>Ev71疫苗（二倍体）</td>
<td>手足口病疫苗</td>
<td>否</td>
<td>Ev71型手足口病</td>
<td>共2剂，间隔1月</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>13价肺炎球菌多糖结合疫苗</td>
<td>肺炎疫苗</td>
<td>否</td>
<td>肺炎球菌性肺炎</td>
<td>共4剂：2月、4月、6月、12-15月各注射一剂13价肺炎球菌多糖结合疫苗</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<h2 id="三、疫苗术语"><a href="#三、疫苗术语" class="headerlink" title="三、疫苗术语"></a><strong>三、疫苗术语</strong></h2><h3 id="3-1、减毒活疫苗和灭活疫苗"><a href="#3-1、减毒活疫苗和灭活疫苗" class="headerlink" title="3.1、减毒活疫苗和灭活疫苗"></a><strong>3.1、减毒活疫苗和灭活疫苗</strong></h3><h4 id="3-1-1、减毒活疫苗"><a href="#3-1-1、减毒活疫苗" class="headerlink" title="3.1.1、减毒活疫苗"></a><strong>3.1.1、减毒活疫苗</strong></h4><p>对病原体进行各种处理，使其毒性减弱，但保留免疫原性。接种减毒活疫苗后，病原体可以在机体内生长繁殖，引发免疫反应，从而获得长期或者终生免疫保护。<br>优点：</p>
<ul>
<li>使获得较广泛的免疫保护</li>
<li>使获得较强的免疫反应</li>
<li>使获得较持久的免疫能力</li>
</ul>
<p>缺点：</p>
<ul>
<li>残余毒力可能引发有些个体的严重的疾病</li>
<li>存在毒力返祖可能</li>
</ul>
<h4 id="3-1-2、灭活疫苗"><a href="#3-1-2、灭活疫苗" class="headerlink" title="3.1.2、灭活疫苗"></a><strong>3.1.2、灭活疫苗</strong></h4><p>对病原体进行培养，然后灭活，仅保留抗原成分。接种灭活疫苗后，病原体未在机体内生长繁殖，直接针对保留的抗原成分引发免疫反应。<br>优点：</p>
<ul>
<li>安全</li>
</ul>
<p>缺点：</p>
<ul>
<li>免疫期短</li>
<li>接种量大</li>
</ul>
<h3 id="3-2、剂型"><a href="#3-2、剂型" class="headerlink" title="3.2、剂型"></a><strong>3.2、剂型</strong></h3><h4 id="3-2-1、预充式"><a href="#3-2-1、预充式" class="headerlink" title="3.2.1、预充式"></a><strong>3.2.1、预充式</strong></h4><p>药液直接被预充入注射器中。</p>
<h4 id="3-2-2、西林瓶"><a href="#3-2-2、西林瓶" class="headerlink" title="3.2.2、西林瓶"></a><strong>3.2.2、西林瓶</strong></h4><p>空注射器从西林瓶中抽取药液。</p>
<h2 id="四、统筹疫苗接种计划"><a href="#四、统筹疫苗接种计划" class="headerlink" title="四、统筹疫苗接种计划"></a><strong>四、统筹疫苗接种计划</strong></h2><table>
<thead>
<tr>
<th>疫苗名称</th>
<th>所属类别</th>
</tr>
</thead>
<tbody><tr>
<td>重组乙型肝炎疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>卡介苗</td>
<td>第一类</td>
</tr>
<tr>
<td>脊髓灰质炎灭活疫苗（IPV）和脊髓灰质炎减毒活疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>百白破疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>白破疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>A群&#x2F;AC群脑膜炎球菌多糖疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>乙型脑炎减毒活疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>麻腮风疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>甲型肝炎减毒活疫苗</td>
<td>第一类</td>
</tr>
<tr>
<td>B型流感嗜血杆菌疫苗</td>
<td>第二类</td>
</tr>
<tr>
<td>冻干水痘疫苗</td>
<td>第二类</td>
</tr>
<tr>
<td>流感裂解疫苗</td>
<td>第二类</td>
</tr>
<tr>
<td>Ev71疫苗（二倍体）</td>
<td>第二类</td>
</tr>
<tr>
<td>13价肺炎球菌多糖结合疫苗</td>
<td>第二类</td>
</tr>
</tbody></table>
<p><strong>备注：</strong><br>1、“五联苗”相对于“百白破疫苗，脊髓灰质炎灭活疫苗，B型流感嗜血杆菌疫苗”的优势主要在于“减少接种次数，降低不良反应概率”，但是缺货，所以放弃<br>2、根据[5]在“23价肺炎疫苗”和“13价肺炎球菌多糖结合疫苗”中选择“13价肺炎球菌多糖结合疫苗”<br>3、“A+C群流脑（结合）疫苗”与“A群&#x2F;AC群脑膜炎球菌多糖疫苗”相比优势不明显，直接选用“A群&#x2F;AC群脑膜炎球菌多糖疫苗”</p>
<br/>
参考文献：
&#91;1&#93;[《疫苗流通和预防接种管理条例》](http://www.gov.cn/zhengce/content/2016-04/25/content_5067597.htm)
[2]http://www.cdc.zj.cn/newsinfo.php?item=6908ntwXSCmnLeXXMywuhgH2MlpKNj485adKBlwHilU
[3]http://www.cqcdc.org/html/content/17/03/1839.shtml
[4]http://sh.eastday.com/m/20171110/u1ai10987241.html
[5]http://www.sohu.com/a/130828247_651397
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>育儿</category>
      </categories>
      <tags>
        <tag>疫苗</tag>
      </tags>
  </entry>
  <entry>
    <title>符号与英文名称对照表</title>
    <url>/blog/2017/06/24/%E7%AC%A6%E5%8F%B7%E4%B8%8E%E8%8B%B1%E6%96%87%E5%90%8D%E7%A7%B0%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>在阅读英文文献，查阅英文资料时，经常需要用到“符号”与“英文名称”的对照关系。故整理维护一份“符号与英文名称对照表”，基于的顺序是：按照美式键盘的布局，从上到下，从左到右。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;</td>
<td>back quote</td>
<td>反引号</td>
</tr>
<tr>
<td>~</td>
<td>tilde</td>
<td>波浪号</td>
</tr>
<tr>
<td>!</td>
<td>exclamation mark</td>
<td>感叹号</td>
</tr>
<tr>
<td>@</td>
<td>at sign</td>
<td><code>at</code>符号</td>
</tr>
<tr>
<td>#</td>
<td>number sign</td>
<td>井号</td>
</tr>
<tr>
<td>$</td>
<td>dollar sign</td>
<td>美元符号</td>
</tr>
<tr>
<td>%</td>
<td>percent sign</td>
<td>百分号</td>
</tr>
<tr>
<td>^</td>
<td>caret</td>
<td>插入符号</td>
</tr>
<tr>
<td>&amp;</td>
<td>ampersand</td>
<td>与符号</td>
</tr>
<tr>
<td>&#42;</td>
<td>asterisk</td>
<td>星号</td>
</tr>
<tr>
<td>()</td>
<td>parenthesis brackets，round brackets</td>
<td>圆括号</td>
</tr>
<tr>
<td>-</td>
<td>hyphen</td>
<td>连字符</td>
</tr>
<tr>
<td>&#95;</td>
<td>underscore</td>
<td>下划线</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>equal sign</td>
<td>等号</td>
</tr>
<tr>
<td>+</td>
<td>plus sign</td>
<td>加号</td>
</tr>
<tr>
<td>[]</td>
<td>square brackets</td>
<td>方括号</td>
</tr>
<tr>
<td>{}</td>
<td>curly brackets，braces</td>
<td>大括号，花括号</td>
</tr>
<tr>
<td>\</td>
<td>backslash</td>
<td>反斜线</td>
</tr>
<tr>
<td>&#124;</td>
<td>vertical bar</td>
<td>竖线</td>
</tr>
<tr>
<td>;</td>
<td>semicolon</td>
<td>分号</td>
</tr>
<tr>
<td>:</td>
<td>colon</td>
<td>冒号</td>
</tr>
<tr>
<td>‘</td>
<td>single quotation marks</td>
<td>单引号</td>
</tr>
<tr>
<td>“</td>
<td>double quotation marks</td>
<td>双引号</td>
</tr>
<tr>
<td>,</td>
<td>comma</td>
<td>逗号</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>angle brackets</td>
<td>尖括号</td>
</tr>
<tr>
<td>.</td>
<td>period，full stop</td>
<td>句点</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>slash</td>
<td>正斜线</td>
</tr>
<tr>
<td>?</td>
<td>question mark</td>
<td>问号</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>终端模拟器中执行命令出现乱码问题解决</title>
    <url>/blog/2016/06/07/%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>Xshell跟Gnome Terminal相比，两者都是终端模拟器（在Xshell中也可以执行简单的内置命令，如“cd”，“ls”等），地位相同。</p>
<h2 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a><strong>二、原理分析</strong></h2><p>涉及到乱码，那么需要了解编码解码过程。在终端模拟器中执行命令，通信过程示意图如图1所示。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20160607-0-1.png"></p>
<p>在以上通信过程中，在“命令执行单元”处发生了一系列的编码解码过程，在“终端模拟器”处也发生了一系列的编码解码过程，此外，我们常常创建SSH连接，从而建立一个远端Shell会话，在该情景中，通信过程示意图如图2所示，由图2可知，在该情景中，跟原来的通信过程相比，只不过“命令执行单元”处与“终端模拟器”处之间的通信数据经过SSH安全通道而已，一般并不影响整体的编码解码过程。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20160607-0-2.png"></p>
<p>“命令执行单元”处执行命令过程中会发生一系列的编码解码过程，不同命令具有不同实现，因而不同命令执行过程中发生的编码解码过程也不尽相同（以下这些链接中的内容可作为该结论的证据：<a href="http://blog.csdn.net/haoyyy/article/details/21027641">《使用vi和less查看文本出现中文乱码，使用cat正常》</a>，<a href="http://www.it610.com/article/3602944.htm">《查看日志文件more正常，用less查看出现乱码》</a>)。另外，很多命令在执行过程中会去读取locale系列环境变量（比如“LANG”，“LANGUAGE”，“LC_ALL”，“LC_CTYPE”等）的配置值用于编码解码过程。<br>比如“uniq”命令会去使用“LC_COLLATE”等环境变量的配置值，“grep”命令会去使用“LC_ALL”等环境变量的配置值，“vim”命令会去使用“LC_CTYPE”等环境变量的配置值。</p>
<p>“终端模拟器”处执行命令过程中也会发生一系列的编码解码过程，主要有3方面内容：</p>
<ul>
<li>配置终端模拟器使用的编码方案，对于Gnome Terminal，在图3所示位置进行配置，对于Xshell，在图4所示位置进行配置，对于Xftp，在图5所示位置进行配置</li>
<li>执行命令时，使用终端模拟器配置的编码方案，对原命令字符串进行编码，将得到的字节流传递给“命令执行单元”</li>
<li>展现命令执行结果时，获取字节流形式的命令执行结果，使用终端模拟器配置的编码方案，对其进行解码，得到字符串形式的命令执行结果</li>
</ul>
<p>图3</p>
<p><img src="https://blog.dslztx.top/imgs/20160607-0-3.png"></p>
<p>图4</p>
<p><img src="https://blog.dslztx.top/imgs/20160607-0-4.png"></p>
<p>图5</p>
<p><img src="https://blog.dslztx.top/imgs/20160607-0-5.png"></p>
<h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a><strong>三、实验</strong></h2><h3 id="3-1、ls命令"><a href="#3-1、ls命令" class="headerlink" title="3.1、ls命令"></a><strong>3.1、ls命令</strong></h3><h4 id="3-1-1、实验1"><a href="#3-1-1、实验1" class="headerlink" title="3.1.1、实验1"></a><strong>3.1.1、实验1</strong></h4><p>现有一个名为“你好吗.txt”的文件，相应于该文件名的存储内容存储的是使用“UTF-8”编码方案编码得到的字节流。<br>设置不同的locale系列环境变量配置值和终端模拟器编码方案，得到不同的“ls命令”执行结果，具体如表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值</th>
<th>终端模拟器（实验了Gnome Terminal和Xshell）编码方案</th>
<th>ls命令执行结果截图</th>
</tr>
</thead>
<tbody><tr>
<td><font color='red'>zh_CN.utf8</font></td>
<td><font color='red'>UTF-8</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-6.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-7.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.utf8</td>
<td>GBK</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-8.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.gbk</td>
<td>GBK</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-9.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h4 id="3-1-2、实验2"><a href="#3-1-2、实验2" class="headerlink" title="3.1.2、实验2"></a><strong>3.1.2、实验2</strong></h4><p>现有一个名为“你好吗.txt”的文件，相应于该文件名的存储内容存储的是使用“GBK”编码方案编码得到的字节流。<br>设置不同的locale系列环境变量配置值和终端模拟器编码方案，得到不同的“ls命令”执行结果，具体如表2。</p>
<p>表2</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值</th>
<th>终端模拟器（实验了Gnome Terminal和Xshell）编码方案</th>
<th>ls命令执行结果截图</th>
</tr>
</thead>
<tbody><tr>
<td>zh_CN.utf8</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-10.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-11.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.utf8</td>
<td>GBK</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-12.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td><font color='red'>zh_CN.gbk</font></td>
<td><font color='red'>GBK</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-13.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h3 id="3-2、vim命令"><a href="#3-2、vim命令" class="headerlink" title="3.2、vim命令"></a><strong>3.2、vim命令</strong></h3><h4 id="3-2-1、实验1"><a href="#3-2-1、实验1" class="headerlink" title="3.2.1、实验1"></a><strong>3.2.1、实验1</strong></h4><p>现有一个名为“a.txt”的文件，存储有内容“你好吗？”，使用的编码格式为“UTF-8”。<br>设置不同的locale系列环境变量配置值和终端模拟器编码方案，得到不同的“vim a.txt”执行结果，具体如表3。</p>
<p>表3</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值（跟“3.1、ls命令”一样，也是将locale系列中的所有环境变量的配置值设为同一个值）</th>
<th>终端模拟器（实验了Gnome Terminal和Xshell）编码方案</th>
<th>“vim a.txt”命令执行结果截图</th>
<th>VIM环境中执行“:e ++enc&#x3D;utf8”结果截图</th>
</tr>
</thead>
<tbody><tr>
<td><font color='red'>zh_CN.utf8</font></td>
<td><font color='red'>UTF-8</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-14.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-15.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-16.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-17.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.utf8</td>
<td>GBK</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-18.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-19.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td><font color='red'>zh_CN.gbk</font></td>
<td><font color='red'>GBK</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-20.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-21.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h4 id="3-2-2、实验2"><a href="#3-2-2、实验2" class="headerlink" title="3.2.2、实验2"></a><strong>3.2.2、实验2</strong></h4><p>现有一个名为“a.txt”的文件，存储有内容“你好吗？”，使用的编码格式为“GBK”。<br>设置不同的locale系列环境变量配置值和终端模拟器编码方案，得到不同的“vim a.txt”执行结果，具体如表4。</p>
<p>表4</p>
<table>
<thead>
<tr>
<th>locale系列环境变量配置值（跟“3.1、ls命令”一样，也是将locale系列中的所有环境变量的配置值设为同一个值）</th>
<th>终端模拟器（实验了Gnome Terminal和Xshell）编码方案</th>
<th>“vim a.txt”命令执行结果截图</th>
<th>VIM环境中执行“:e ++enc&#x3D;gbk”结果截图</th>
</tr>
</thead>
<tbody><tr>
<td><font color='red'>zh_CN.utf8</font></td>
<td><font color='red'>UTF-8</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-22.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-23.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.gbk</td>
<td>UTF-8</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-24.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-25.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td>zh_CN.utf8</td>
<td>GBK</td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-26.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-27.png" alt="这里写图片描述"></td>
</tr>
<tr>
<td><font color='red'>zh_CN.gbk</font></td>
<td><font color='red'>GBK</font></td>
<td><img src="https://blog.dslztx.top/imgs/20160607-0-28.png" alt="这里写图片描述"></td>
<td><img src="http://107.182.16.103/imgs/20160607-0-29.png" alt="这里写图片描述"></td>
</tr>
</tbody></table>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="4-1、locale系列环境变量"><a href="#4-1、locale系列环境变量" class="headerlink" title="4.1、locale系列环境变量"></a><strong>4.1、locale系列环境变量</strong></h3><p>在以上实验中，locale系列中的所有环境变量的配置值都被设为“zh_CN.gbk”或者“zh_CN.utf8”，其实“ls命令实现”或者“vim命令实现”只需要读取locale系列中特定的部分的环境变量的配置值即可，locale系列中其他的环境变量的配置值并不会影响“ls命令”或者“vim命令”的运行。只不过我们并不知道上述提及的“locale系列中特定的部分的环境变量”是哪些，故而为了简单起见，将locale系列中的所有环境变量的配置值都设为“zh_CN.gbk”或者“zh_CN.utf8”。</p>
<h3 id="4-2、推测vim命令读取文件内容发生的主要的编码解码过程"><a href="#4-2、推测vim命令读取文件内容发生的主要的编码解码过程" class="headerlink" title="4.2、推测vim命令读取文件内容发生的主要的编码解码过程"></a><strong>4.2、推测vim命令读取文件内容发生的主要的编码解码过程</strong></h3><p>由“3.2、vim命令”中的实验可推知，使用vim命令读取文件内容中发生的主要的编码解码过程如下：读取文件内容的字节流，使用locale系列环境变量指定的编码方案（也可以通过“:e ++enc&#x3D;?”命令自己指定要使用的编码方案)对字节流进行解码得到文件内容的字符流，再使用locale系列环境变量指定的编码方案对获得的字符流进行编码得到字节流，将前述编码得到的字节流传递给终端模拟器。<br>因而，只要locale系列环境变量指定的编码方案跟终端模拟器使用的编码方案一致，那么直接可以得到文件内容的非乱码展现或者通过“:e ++enc&#x3D;?”命令得到文件内容的非乱码展现。</p>
<h3 id="4-3、实验中用到的两个脚本"><a href="#4-3、实验中用到的两个脚本" class="headerlink" title="4.3、实验中用到的两个脚本"></a><strong>4.3、实验中用到的两个脚本</strong></h3><p>脚本1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">cd /home/dsl/tmp/shell</span><br><span class="line"></span><br><span class="line">export LC_ALL=$1</span><br><span class="line">export LANG=$1</span><br><span class="line">export LANGUAGE=$1</span><br><span class="line"></span><br><span class="line">locale</span><br><span class="line"></span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>脚本2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">cd /home/dsl/tmp/shell</span><br><span class="line"></span><br><span class="line">export LC_ALL=$1</span><br><span class="line">export LANG=$1</span><br><span class="line">export LANGUAGE=$1</span><br><span class="line"></span><br><span class="line">locale</span><br><span class="line"></span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line">echo &quot;---------&quot;</span><br><span class="line"></span><br><span class="line">vim a.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>编码解码核心论述</title>
    <url>/blog/2018/09/07/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%A0%B8%E5%BF%83%E8%AE%BA%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a><strong>一、核心概念</strong></h2><h3 id="1-1、编码"><a href="#1-1、编码" class="headerlink" title="1.1、编码"></a><strong>1.1、编码</strong></h3><p>编码：将信息从一种形式转换成另外一种形式。</p>
<h3 id="1-2、解码"><a href="#1-2、解码" class="headerlink" title="1.2、解码"></a><strong>1.2、解码</strong></h3><p>解码：编码的逆过程。</p>
<h2 id="二、常见应用场景"><a href="#二、常见应用场景" class="headerlink" title="二、常见应用场景"></a><strong>二、常见应用场景</strong></h2><p>编码解码在生活中具有广泛的应用，常见的应用场景介绍见表1。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>应用场景</th>
<th>专有名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符&lt;-&gt;字节流</td>
<td>字符编码</td>
<td>用于字符的存储，传输，展现。常见的具体字符编码方案有：ASCII，GBK，UTF-8，…</td>
</tr>
<tr>
<td>图像信号&lt;-&gt;字节流</td>
<td>图像编码</td>
<td>用于图像信号的存储，传输，展现</td>
</tr>
<tr>
<td>声音信号&lt;-&gt;字节流</td>
<td>声音编码</td>
<td>用于声音信号的存储，传输，展现</td>
</tr>
<tr>
<td>其他形式数据&lt;-&gt;JSON数据</td>
<td>无</td>
<td>JSON是一种良好的交互数据格式</td>
</tr>
<tr>
<td>其他形式数据&lt;-&gt;XML数据</td>
<td>无</td>
<td>XML是一种良好的交互数据格式</td>
</tr>
<tr>
<td>Java字符串字面量原字符串&lt;-&gt;Java字符串字面量转义字符串</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>模拟信号&lt;-&gt;01信号</td>
<td>&#x2F;</td>
<td>一个具体编码方案举例：&gt;&#x3D;5伏特输出1；&lt;5伏特输出0</td>
</tr>
<tr>
<td>压缩前数据&lt;-&gt;压缩后数据</td>
<td>压缩编码</td>
<td>用于压缩数据，减小数据量，降低空间占用，加快数据传输。常见的具体压缩编码方案有：LZMA编码，RLE编码，Huffman编码，…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>网络原理概述</title>
    <url>/blog/2024/02/06/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、计算机网络定义"><a href="#一、计算机网络定义" class="headerlink" title="一、计算机网络定义"></a><strong>一、计算机网络定义</strong></h2><p>计算机网络：通过传输媒体和中间各种类型网络设备（包括“网卡”，“路由器”，“交换机”等）连接起来的计算机集合。</p>
<p>两点释疑：</p>
<ol>
<li>以上计算机网络定义跟计算机节点之间的地理距离完全无关，两个计算机节点地理距离即便只有1CM，只要通过传输媒体和中间各种类型网络设备连接起来就构成了计算机网络</li>
<li>两个计算机通过USB、PCI、HDMI等接口连接，而不是通过网络设备，那么就不构成计算机网络</li>
</ol>
<h2 id="二、组建计算机网络的关键——协议"><a href="#二、组建计算机网络的关键——协议" class="headerlink" title="二、组建计算机网络的关键——协议"></a><strong>二、组建计算机网络的关键——协议</strong></h2><p>组建计算机网络，必须定义和实现计算机节点之间的网络协议。<br>网络协议自诞生之日起就蓬勃发展，但是不兼容的网络协议导致不同的计算机网络难以互连，针对此问题，ISO和因特网标准化组织给出了两种标准化协议模型：OSI模型和TCP&#x2F;IP模型。</p>
<h3 id="2-1、协议模型"><a href="#2-1、协议模型" class="headerlink" title="2.1、协议模型"></a><strong>2.1、协议模型</strong></h3><p>对协议模型作几点说明：</p>
<ul>
<li>对网络协议模型进行分层，只允许相邻层传递数据，分解问题空间，降低设计和实现难度，层协议具备更好的独立性和灵活性</li>
<li>属于同层的网络协议可能地位不同，比如“在运输层中，TCP&#x2F;UDP是核心协议，QUIC协议基于UDP协议”，“在网络协议中，IP协议是核心协议，IGMP&#x2F;ICMP协议是基于IP协议的辅助协议，ARP&#x2F;RARP协议是不基于IP协议的辅助协议”</li>
<li>一些网络协议能够被精确映射到网络协议分层，另外一些网络协议不能被精确映射到网络协议分层是客观的，因为存在特殊需求的网络协议实现其功能并不能被某个网络协议分层的定义所100%覆盖，<font color='red'>故不要花费过多精力追求将所有网络协议精确映射到网络协议分层</font>。比如：“ICMP&#x2F;IGMP基于IP在IP之上，但未到运输层，一般仍算为网络层”，“ARP&#x2F;RARP不基于IP，但一般仍算为网络层”</li>
</ul>
<h3 id="2-2、OSI模型-VS-TCP-IP模型"><a href="#2-2、OSI模型-VS-TCP-IP模型" class="headerlink" title="2.2、OSI模型 VS TCP&#x2F;IP模型"></a><strong>2.2、OSI模型 VS TCP&#x2F;IP模型</strong></h3><h4 id="2-2-1、OSI模型"><a href="#2-2-1、OSI模型" class="headerlink" title="2.2.1、OSI模型"></a><strong>2.2.1、OSI模型</strong></h4><p>OSI模型：</p>
<ol>
<li>发展：具体分为7层，从下到上依次为<code>物理层，数据链路层，网络层，运输层，会话层，表示层，应用层</code>。对每层只给出了层功能定义，没有直接限定协议，以充分兼容已有协议</li>
<li>优点（跟TCP&#x2F;IP模型比较）：<ul>
<li>层次划分相较细致，概念相较清晰，比如“划分了数据链路层和物理层”</li>
<li>协议兼容性相较强，比如“网络层的核心协议可以是非IP协议”，“运输层的核心协议可以是既非TCP协议又非UDP协议”</li>
</ul>
</li>
<li>缺点（跟TCP&#x2F;IP模型比较）：<ul>
<li>实现相较复杂，比如“有‘表示层’和‘会话层’两个层属协议”，“需要考虑各种可能的网络层和运输层协议”</li>
</ul>
</li>
<li>现状：已成为历史</li>
</ol>
<h4 id="2-2-2、TCP-IP模型"><a href="#2-2-2、TCP-IP模型" class="headerlink" title="2.2.2、TCP&#x2F;IP模型"></a><strong>2.2.2、TCP&#x2F;IP模型</strong></h4><p>TCP&#x2F;IP模型（原始是四层）：</p>
<ol>
<li>发展：基于已存在的TCP、UDP和IP三个协议，参考OSI模型，提出TCP&#x2F;IP模型。具体分为4层，从下到上依次为<code>网络接口层，网际层，运输层，应用层</code>：<ul>
<li>网络接口层不限定具体协议</li>
<li>网际层限定核心协议为IP协议</li>
<li>运输层限定核心协议为TCP或者UDP协议</li>
<li>应用层不限定具体协议，但是所基于的运输层核心协议必为TCP或者UDP协议</li>
</ul>
</li>
<li>优点（跟OSI模型比较）：<ul>
<li>实现相较简单</li>
</ul>
</li>
<li>缺点（跟OSI模型比较）：<ul>
<li>层次划分相较不细致，比如“网络接口层不划分数据链路层和物理层”</li>
<li>协议兼容性相较弱，比如“网际层的核心协议就是IP协议”，“运输层的核心协议就是TCP协议或者UDP协议”，“应用层协议必须基于TCP或者UDP协议”</li>
</ul>
</li>
<li>现状：事实标准。虽然在组建网络时，可以用不兼容TCP&#x2F;IP模型的其他协议（可以是已存在的，甚至可以是新设计和实现的），但是完全没有必要</li>
</ol>
<hr>
<p>虽然TCP&#x2F;IP四层模型是事实标准，但是在实际应用中发现仍然有“物理层”和“数据链路层”分层必要，故实际一般使用“TCP&#x2F;IP五层模型（后续叙述如无特别说明都基于该五层模型）”，从下到上依次为<code>物理层，数据链路层，网络层，运输层，应用层</code>。</p>
<p>五层模型与层属协议示例见下表。</p>
<table>
<thead>
<tr>
<th>TCP&#x2F;IP五层模型</th>
<th>层属协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP，FTP，SMTP，POP3，TELNET，DNS</td>
</tr>
<tr>
<td>运输层</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP，ICMP，IGMP，ARP，RARP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>PPP，Ethernet</td>
</tr>
<tr>
<td>物理层</td>
<td>光纤，电缆，无线信道</td>
</tr>
</tbody></table>
<h2 id="三、组建计算机网络的性能指标"><a href="#三、组建计算机网络的性能指标" class="headerlink" title="三、组建计算机网络的性能指标"></a><strong>三、组建计算机网络的性能指标</strong></h2><h3 id="3-1、带宽"><a href="#3-1、带宽" class="headerlink" title="3.1、带宽"></a><strong>3.1、带宽</strong></h3><p>在继续介绍之前首先介绍带宽的含义：</p>
<ul>
<li>原义：带宽原指频率范围，单位为赫兹（Hz）。以带宽（频率）区分后述扩展义</li>
<li>扩展义：后由于带宽跟数据速率的紧密关系，被借用表示数据速率，单位为比特&#x2F;秒（“bit&#x2F;s”，简写为“b&#x2F;s”或者“bps”）。须知<code>Kbps，Mbps，Gbps</code>中的<code>K，M，G</code>分别表示<code>10^3，10^6，10^9</code>，而不是<code>2^10，2^20，2^30</code>。以带宽（速率）区分上述原义</li>
</ul>
<h4 id="3-1-1、网卡带宽"><a href="#3-1-1、网卡带宽" class="headerlink" title="3.1.1、网卡带宽"></a><strong>3.1.1、网卡带宽</strong></h4><p>表示网卡的数据处理速率，单位为“bps”。<br>日常所说的“百兆网卡”，“千兆网卡”，“万兆网卡”，表示网卡的最大数据处理速率分别为“100Mbps”，“1000Mbps”和“10000Mbps&#x3D;10Gbps”。</p>
<h4 id="3-1-2、信道带宽"><a href="#3-1-2、信道带宽" class="headerlink" title="3.1.2、信道带宽"></a><strong>3.1.2、信道带宽</strong></h4><p>香农定理描述了特定传输媒体上的不失真信息传输速率理论极限值C，具体有公式<code>C = B * log2(1 + S/N)</code>。<br>其中：</p>
<ul>
<li><code>C</code>是极限的不失真信息传输速率，即理论极限不失真带宽（速率），单位为“比特&#x2F;秒（bps）”</li>
<li><code>B</code>是信道带宽（频率），单位为“赫兹（Hz）”</li>
<li><code>S</code>是平均信号功率，<code>N</code>是平均噪声功率，<code>S/N</code>是信噪比</li>
</ul>
<p>根据以上定理，假定实际不失真信息传输速率为F，即实际不失真带宽（速率），那么我们可以不断追寻合适的编码方案以期将F不断逼近C，虽然实际不可能达到，因为传输过程中信号还要受到其他一些损伤，比如“各种脉冲干扰”。</p>
<h3 id="3-2、时延"><a href="#3-2、时延" class="headerlink" title="3.2、时延"></a><strong>3.2、时延</strong></h3><p>结合笔者理解，跟[1]中定义不完全一致。</p>
<h4 id="3-2-1、单趟时延"><a href="#3-2-1、单趟时延" class="headerlink" title="3.2.1、单趟时延"></a><strong>3.2.1、单趟时延</strong></h4><p>单趟时延 &#x3D; 发送时延 + 传播时延 + 处理时延  + 接收时延 + 排队时延。</p>
<p>各个时延介绍如下：</p>
<ul>
<li>发送时延：发送节点在发送数据时使数据块从节点进入到信道所需要的时间，也就是从数据块的第一个比特开始发送算起，到最后一个比特发送完所需的时间，有公式<code>发送时延 = 数据块长度/网卡带宽</code></li>
<li>传播时延：信号在信道中传播一定的距离所需要的时间，有公式<code>传播时延 = 信道长度/信号在信道上的传播速率</code>，即跟数据块大小无关</li>
<li>处理时延：数据在交换节点（比如“路由器”）进行收、转换、发等处理所需要的时间</li>
<li>接收时延：接收节点从信道接收数据块的第一个比特开始到完成接收该数据块最后一个比特所需要的时间，有公式<code>接收时延 = 数据块长度/网卡带宽</code></li>
<li>排队时延：整个单趟过程中各环节排队所需要时间的总和，比如“在交换节点的排队所需要时间”，“在接收节点的排队所需要时间”</li>
</ul>
<h4 id="3-2-2、往返时延"><a href="#3-2-2、往返时延" class="headerlink" title="3.2.2、往返时延"></a><strong>3.2.2、往返时延</strong></h4><p>往返时延（RTT）是重要的性能指标，从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认）。</p>
<p>往返时延 &#x3D; 发送单趟时延 + 接收方处理时延 + 接收单趟时延。</p>
<p>各个时延介绍如下：</p>
<ul>
<li>发送单趟时延：参见“3.2.1、单趟时延”</li>
<li>接收方处理时延：接收方接收到数据块后进行处理所需要的时间</li>
<li>接收单趟时延：参见“3.2.1、单趟时延”</li>
</ul>
<h2 id="四、计算机网络分类"><a href="#四、计算机网络分类" class="headerlink" title="四、计算机网络分类"></a><strong>四、计算机网络分类</strong></h2><p>可基于多种角度对计算机网络进行分类，<font color='red'>但也切忌耗费过多精力强求分类</font>。</p>
<h3 id="4-1、基于作用范围"><a href="#4-1、基于作用范围" class="headerlink" title="4.1、基于作用范围"></a><strong>4.1、基于作用范围</strong></h3><p>基于作用范围可将计算机网络分为：局域网，广域网，城域网。</p>
<p>说明如下：</p>
<ul>
<li>局域网：Local Area Network(LAN)，作用范围通常为几米到几十公里，例如一个家庭、一个企业就是最基础的局域网</li>
<li>广域网：Wide Area Network(WAN)，作用范围通常为几十公里到几千公里</li>
<li>城域网：Metropolitan Area Network(MAN) ，作用范围在局域网与广域网之间</li>
</ul>
<p>基于作用范围的分类没有太大意义，因为距离阈值人为定义，不一定能准确对照到实际，比如“有些大的局域网覆盖范围有几百公里”，“有些小城市的城域网覆盖范围只有几公里”。</p>
<h3 id="4-2、基于网络核心部分是否允许公共接入"><a href="#4-2、基于网络核心部分是否允许公共接入" class="headerlink" title="4.2、基于网络核心部分是否允许公共接入"></a><strong>4.2、基于网络<code>核心部分</code>是否允许公共接入</strong></h3><p>基于网络<code>核心部分</code>是否允许公共接入可将网络分为：公用网和专用网。</p>
<p>两点说明：</p>
<ol>
<li>计算机网络由<code>核心部分</code>和<code>边缘部分</code>构成：1）前者是网络骨干，不包括主机，为后者提供连通交换服务；2）后者包括所有主机，使用前者提供的服务进行相互通信</li>
<li>公共接入的含义是具体的，比如“全球网络视角下，因特网<code>核心部分</code>接入是公共接入，俄罗斯国家网<code>核心部分</code>接入不是公共接入；全俄罗斯网络视角下，俄罗斯国家网<code>核心部分</code>接入是公共接入”。<font color='red'>后续如无特别说明，在全球网络视角下讨论是否为公共接入</font></li>
</ol>
<p>举例说明：</p>
<ul>
<li>因特网<code>核心部分</code>允许公共接入，故其是公用网</li>
<li>如果有一个网络X，其用户是全球网络用户（现实中除了因特网之外不存在其他全球性网络），即<code>核心部分</code>允许公共接入，故其也是公用网</li>
<li>俄罗斯国家网<code>核心部分</code>不允许公共接入，故其是专用网</li>
<li>中国人民解放军军网<code>核心部分</code>不允许公共接入，故其是专用网</li>
<li>某个家庭内部网络<code>核心部分</code>不允许公共接入，故其是专用网</li>
</ul>
<h3 id="4-3、基于是否为全球网络"><a href="#4-3、基于是否为全球网络" class="headerlink" title="4.3、基于是否为全球网络"></a><strong>4.3、基于是否为全球网络</strong></h3><p>基于是否为全球网络可将计算机网络分为：全球网和局域网。这里的局域网是广义的，“4.1、基于作用范围”小节中的局域网是狭义的。</p>
<p>举例说明:</p>
<ul>
<li>因特网是全球网</li>
<li>如果有一个网络X，其用户是全球网络用户（现实中除了因特网之外不存在其他全球性网络），那么其也是全球网</li>
<li>俄罗斯国家网是广义局域网</li>
<li>中国人民解放军军网是广义局域网</li>
<li>某个家庭内部网络是广义局域网</li>
</ul>
<h3 id="4-4、基于是否为子网"><a href="#4-4、基于是否为子网" class="headerlink" title="4.4、基于是否为子网"></a><strong>4.4、基于是否为子网</strong></h3><p>基于是否为子网可将计算机网络分为：子网和整体网。<font color='red'>须知子网的定义是具体的</font>。</p>
<p>举例说明：</p>
<ul>
<li>俄罗斯国家网：从自身视角是整体网；接入因特网后，从因特网视角是子网</li>
<li>因特网：整体网</li>
<li>企业网：从自身视角是整体网；接入因特网后，从因特网视角是子网</li>
</ul>
<h2 id="五、现实中的计算机网络介绍"><a href="#五、现实中的计算机网络介绍" class="headerlink" title="五、现实中的计算机网络介绍"></a><strong>五、现实中的计算机网络介绍</strong></h2><p>现实中存在各种形形色色的计算机网络，介绍常见的几种。</p>
<table>
<thead>
<tr>
<th>计算机网络</th>
<th>含义</th>
<th>基于作用范围</th>
<th>基于网络<code>核心部分</code>是否允许公共接入</th>
<th>基于是否为全球网络</th>
<th>基于是否为子网</th>
</tr>
</thead>
<tbody><tr>
<td>因特网（常称互联网）</td>
<td>英文名为“Internet”，全球最大的计算机网络</td>
<td>广域网</td>
<td>公用网</td>
<td>全球网</td>
<td>整体网</td>
</tr>
<tr>
<td>中国人民解放军军网</td>
<td>解放军专用网络</td>
<td>广域网</td>
<td>专用网</td>
<td>广义局域网</td>
<td>自身视角是整体网，接入因特网后是子网</td>
</tr>
<tr>
<td>俄罗斯国家网</td>
<td>俄罗斯国家专用网络</td>
<td>广域网</td>
<td>专用网</td>
<td>广义局域网</td>
<td>自身视角是整体网，接入因特网后是子网</td>
</tr>
<tr>
<td>学校网</td>
<td>学校专用网络</td>
<td>一般是局域网</td>
<td>专用网</td>
<td>广义局域网</td>
<td>自身视角是整体网，接入因特网后是子网</td>
</tr>
<tr>
<td>企业网</td>
<td>企业专用网络</td>
<td>一般是局域网</td>
<td>专用网</td>
<td>广义局域网</td>
<td>自身视角是整体网，接入因特网后是子网</td>
</tr>
<tr>
<td>家庭网</td>
<td>家庭专用网络</td>
<td>一般是局域网</td>
<td>专用网</td>
<td>广义局域网</td>
<td>自身视角是整体网，接入因特网后是子网</td>
</tr>
</tbody></table>
<p><strong>[备注]</strong> “Internet”表示因特网&#x2F;互联网，“internet”表示计算机网络&#x2F;互连网。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]《计算机网络》（第8版）<br>[2]<a href="https://blog.csdn.net/guoweimelon/article/details/50857130">https://blog.csdn.net/guoweimelon/article/details/50857130</a><br>[3]<a href="https://blog.csdn.net/weixin_39647186/article/details/112309210">https://blog.csdn.net/weixin_39647186/article/details/112309210</a><br>[4]<a href="https://blog.csdn.net/Erice_s/article/details/123099350">https://blog.csdn.net/Erice_s/article/details/123099350</a></p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>网络抓包过滤表达式</title>
    <url>/blog/2016/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、表达式构成"><a href="#一、表达式构成" class="headerlink" title="一、表达式构成##"></a><strong>一、表达式构成</strong>##</h2><p>表达式共有7种基本元素。基本元素之间可以用<code>not and or</code>这3种符号相连，这3种符号中，<code>not</code>符号的优先级最高，<code>and</code>和<code>or</code>符号的优先级相同。<br>另外：按照语法表达式的要求，表达式中有很多地方可以省略，但是为了表达式的可读性，禁止省略比较好。</p>
<h3 id="1-1、第一类基本元素"><a href="#1-1、第一类基本元素" class="headerlink" title="1.1、第一类基本元素###"></a><strong>1.1、第一类基本元素</strong>###</h3><p>基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proto(常见的取值有：tcp,udp;未指定，默认取为跟‘type’相应的所有合法值) dir(常见的取值有：src,dst,src or dst,src and dst;未指定，默认值为‘src or dst’) type(可取值有：host,net,port,portrange;未指定，默认值为‘host’) id(名字或者数字)</span><br></pre></td></tr></table></figure>
<p>基本含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proto字段用于限定协议;</span><br><span class="line">dir字段用于指定过滤条件是应用到源地址还是目标地址，或者是两者。</span><br><span class="line">type字段用于指定过滤条件是应用到&quot;host,net,port,portrange&quot;之中的哪种类型</span><br><span class="line">id字段一般为地址，端口号，端口号范围</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#抓取使用tcp协议，源主机地址为192.168.1.1的包</span><br><span class="line">tcp src host 192.168.1.1</span><br><span class="line"></span><br><span class="line">#抓取使用udp协议，源主机或者目标主机地址端口为8886的包</span><br><span class="line">udp src or dst port 8886</span><br><span class="line"></span><br><span class="line">#抓取使用tcp协议，源主机和目标主机网络地址都为192.168.1.0的包</span><br><span class="line">tcp src and dst net 192.168.1.0</span><br><span class="line"></span><br><span class="line">#抓取使用tcp协议，目标主机端口地址范围为6000-6008的包</span><br><span class="line">tcp dst portrange 6000-6008</span><br></pre></td></tr></table></figure>
<h3 id="1-2、第二类基本元素"><a href="#1-2、第二类基本元素" class="headerlink" title="1.2、第二类基本元素###"></a><strong>1.2、第二类基本元素</strong>###</h3><p>关键词为<code>proto</code>，基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proto protocol</span><br></pre></td></tr></table></figure>
<p>基本含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用protocol协议的IPv4或者IPv6包符合条件</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#抓取使用tcp协议的IPv4或者IPv6包</span><br><span class="line">proto tcp</span><br></pre></td></tr></table></figure>
<h3 id="1-3、第三类基本元素"><a href="#1-3、第三类基本元素" class="headerlink" title="1.3、第三类基本元素###"></a><strong>1.3、第三类基本元素</strong>###</h3><p>关键词为<code>gateway</code>，基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gateway host</span><br></pre></td></tr></table></figure>
<p>基本含义：抓取使用host作为网关的包。不常用。</p>
<h3 id="1-4、第四类基本元素"><a href="#1-4、第四类基本元素" class="headerlink" title="1.4、第四类基本元素###"></a><strong>1.4、第四类基本元素</strong>###</h3><p>关键词为<code>broadcast</code>，基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">broadcast</span><br></pre></td></tr></table></figure>
<p>基本含义：抓取Ethernet广播包。不常用。</p>
<h3 id="1-5、第五类基本元素"><a href="#1-5、第五类基本元素" class="headerlink" title="1.5、第五类基本元素###"></a><strong>1.5、第五类基本元素</strong>###</h3><p>关键词为<code>less</code>，基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less length</span><br></pre></td></tr></table></figure>
<p>基本含义：抓取长度小于等于length的包。不常用。</p>
<h3 id="1-6、第六类基本元素"><a href="#1-6、第六类基本元素" class="headerlink" title="1.6、第六类基本元素###"></a><strong>1.6、第六类基本元素</strong>###</h3><p>关键词为<code>greater</code>，基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greater length</span><br></pre></td></tr></table></figure>
<p>基本含义：抓取长度大于等于length的包。不常用。</p>
<h3 id="1-7、第七类基本元素"><a href="#1-7、第七类基本元素" class="headerlink" title="1.7、第七类基本元素###"></a><strong>1.7、第七类基本元素</strong>###</h3><p>基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr(由“数值常量，运算操作符[+,-,*,/,&amp;,|,&lt;&lt;,&gt;&gt;],长度操作符[关键词为&#x27;len&#x27;],访问器[即&#x27;[]&#x27;]”组成) relop（可取值有：&gt;,&lt;,&gt;=,&lt;=,=,!=） expr(由“数值常量，运算操作符[+,-,*,/,&amp;,|,&lt;&lt;,&gt;&gt;],长度操作符[关键词为&#x27;len&#x27;],访问器[即&#x27;[]&#x27;]”组成)</span><br></pre></td></tr></table></figure>
<p>基本含义：抓取使得关系表达式满足的包。不常用。</p>
<h2 id="二、表达式应用举例"><a href="#二、表达式应用举例" class="headerlink" title="二、表达式应用举例##"></a><strong>二、表达式应用举例</strong>##</h2><h3 id="2-1、监听本机Mysql数据库绑定的3306端口"><a href="#2-1、监听本机Mysql数据库绑定的3306端口" class="headerlink" title="2.1、监听本机Mysql数据库绑定的3306端口###"></a><strong>2.1、监听本机Mysql数据库绑定的3306端口</strong>###</h3><p>欲监听本机，需要使用相应的网卡，在笔者机器上，是“lo”这个网卡。<br>具体命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i lo &#x27;tcp src or dst port 3306&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、监听与www-baidu-com的通信"><a href="#2-2、监听与www-baidu-com的通信" class="headerlink" title="2.2、监听与www.baidu.com的通信###"></a><strong>2.2、监听与<a href="http://www.baidu.com的通信/">www.baidu.com的通信</a></strong>###</h3><p>欲监听互联网主机，需要使用相应的网卡，在笔者机器上，是“eth0”这个网卡。<br>具体命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i eth0 &#x27;ip src or dst host www.baidu.com&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2-3、监听tcp通信"><a href="#2-3、监听tcp通信" class="headerlink" title="2.3、监听tcp通信###"></a><strong>2.3、监听tcp通信</strong>###</h3><p>欲监听与互联网主机的tcp通信，使用“eth0”这个网卡;欲监听与本机的tcp通信，使用“lo”这个网卡。<br>具体命令分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#tcp是关键词，必须被转义</span><br><span class="line">sudo tcpdump -i eth0 &#x27;proto \tcp&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#tcp是关键词，必须被转义</span><br><span class="line">sudo tcpdump -i lo &#x27;proto \tcp&#x27;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]man 7 pcap-filter</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>职称</title>
    <url>/blog/2018/08/04/%E8%81%8C%E7%A7%B0/</url>
    <content><![CDATA[<h2 id="一、职称基本概念"><a href="#一、职称基本概念" class="headerlink" title="一、职称基本概念"></a><strong>一、职称基本概念</strong></h2><p>职称是专业技术人才学术技术水平和专业能力的主要标志。</p>
<h2 id="二、职称系列"><a href="#二、职称系列" class="headerlink" title="二、职称系列"></a><strong>二、职称系列</strong></h2><p>当下有“工程、卫生、农业、经济、会计、统计、翻译、新闻出版广电、艺术、教师、科学研究”等领域的职称系列；一个领域下面有不同专业，比如“工程”领域下面有“机电制造、信息技术、能源与原材料、轻纺、石化”等专业；专业下面又可以有子专业，比如“信息技术”专业下面可以有“应用电子、信息安全、系统集成、软件技术”等子专业。</p>
<h2 id="三、职称级别"><a href="#三、职称级别" class="headerlink" title="三、职称级别"></a><strong>三、职称级别</strong></h2><p>各职称系列均设置“初级”、“中级”、“高级”职称级别，其中“高级职称”分为“正高级”和“副高级”，“初级职称”分为“助理级”和“员级”，可根据需要仅设置“助理级”。<br>部分系列介绍如下表。</p>
<table><thead><tr><th rowspan=2>系列</th><th colspan=2>高级</th><th rowspan=2>中级</th><th rowspan=2>初级</th></tr><tr><th>正高级</th><th>副高级</th></tr></thead><tbody><tr><td>高等学校教师</td><td>教授</td><td>副教授</td><td>讲师</td><td>助理讲师</td></tr><tr><td>自然科学研究人员</td><td>研究员</td><td>副研究员</td><td>助理研究员</td><td>研究实习员</td></tr><tr><td>工程技术人员</td><td>正高级工程师</td><td>高级工程师</td><td>工程师</td><td>助理工程师</td></tr><tr><td rowspan=4>卫生技术人员</td><td>主任医师</td><td>副主任医师</td><td>主管（主治）医师</td><td>医师</td></tr><tr><td>主任药师</td><td>副主任药师</td><td>主管药师</td><td>药师</td></tr><tr><td>主任护师</td><td>副主任护师</td><td>主管护师</td><td>护师</td></tr><tr><td>主任技师</td><td>副主任技师</td><td>主管技师</td><td>技师</td></tr><tr><td>经济专业人员</td><td>正高级经济师</td><td>高级经济师</td><td>经济师</td><td>助理经济师</td></tr><tr><td>会计专业人员</td><td>正高级会计师</td><td>高级会计师</td><td>会计师</td><td>助理会计师</td></tr><tr><td>审计专业人员</td><td>正高级审计师</td><td>高级审计师</td><td>审计师</td><td>助理审计师</td></tr></tbody></table>

<h2 id="四、获取职称"><a href="#四、获取职称" class="headerlink" title="四、获取职称"></a><strong>四、获取职称</strong></h2><p>获取职称主要有“考试”和“评审”两种途径。</p>
<h2 id="五、职称与职位"><a href="#五、职称与职位" class="headerlink" title="五、职称与职位"></a><strong>五、职称与职位</strong></h2><p>“职称获取”与“职位聘用”相分离，即“低职称高职位”或者“高职称低职位”都是可能的。<br>比如获得“高级工程师职称”的A可能被聘用为“低级Java服务端开发工程师职位”，获得“助理工程师职称”的B可能被聘用为“高级Java服务端开发工程师职位”。<br>比如获得“教授职称”的A可能被好大学聘用为“副教授职位”，获得“副教授职称”的B可能被差大学聘用为“教授职位”。</p>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h2><h3 id="6-1、获取“信息技术”专业职称"><a href="#6-1、获取“信息技术”专业职称" class="headerlink" title="6.1、获取“信息技术”专业职称"></a><strong>6.1、获取“信息技术”专业职称</strong></h3><p>获取“信息技术”专业职称主要有两种途径：考试和评审。</p>
<h4 id="6-1-1、考试"><a href="#6-1-1、考试" class="headerlink" title="6.1.1、考试"></a><strong>6.1.1、考试</strong></h4><p>“软考”是考试途径的其中一种，不过，通过“软考”获取到的职称很多地方都不认可。</p>
<h4 id="6-1-2、评审"><a href="#6-1-2、评审" class="headerlink" title="6.1.2、评审"></a><strong>6.1.2、评审</strong></h4><p>“评审”是最权威最受认可的途径。</p>
<p><strong>备注：</strong><br>根据“评审”途径说明可知，“软考”证书是通过“评审”的一个加分项，由此也可知，“评审”的确比“软考”更加权威。</p>
<br/>
参考文献：
[1]http://www.gov.cn/zhengce/2017-01/08/content_5157911.htm#1
[2]https://zhuanlan.zhihu.com/p/33559628
[3]http://www.sohu.com/a/203641491_698856
[4]http://www.cpta.com.cn/n1/2017/0119/c360341-29036066.html
[5]http://hr.zju.edu.cn/cn/redir.php?catalog_id=87663&object_id=87688
[6]http://tieba.baidu.com/p/708995995?traceid=
[7]http://www.cnitpm.com/pm/26754.html
[8]https://www.zhihu.com/question/24882864
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>职称</tag>
      </tags>
  </entry>
  <entry>
    <title>聪明人与一般人的思维方式差异[转]</title>
    <url>/blog/2016/07/05/%E8%81%AA%E6%98%8E%E4%BA%BA%E4%B8%8E%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82-%E8%BD%AC/</url>
    <content><![CDATA[<p>在北大被虐了三年，有三点感触尤深。思考了很久那些“聪明”到底触动到我的是什么，以下说的可能很抽象（而且都跟理工科有关），但都是亲身感受。</p>
<h2 id="一、聪明的人对“难”更钝感"><a href="#一、聪明的人对“难”更钝感" class="headerlink" title="一、聪明的人对“难”更钝感"></a><strong>一、聪明的人对“难”更钝感</strong></h2><p>聪明的人对“难”更钝感，这意味着他们可以更轻松地面对陡峭的学习曲线。打个比方，如果把学习曲线看作一道陡坡，对于他们来说可以减掉30度的倾角，虽然走得未必快，但是很轻松。<br>比如说同样没有编程基础，我会觉得rainmeter编程太麻烦而放弃，但同学L就觉得简单，花了一晚上搞定。虽然之后我花了一晚上也可以搞出来一个桌面，但是我深刻地认识到我和他对“难”的认识是不一样的。同样的过程适用于ps，matlab，c，fortran，latex等等，还有asymptotic method，laser diagnose等等。<br>哪怕和聪明人花掉一样的时间可以学到同样的东西，但是对我而言，这些东西难，对他们而言，不难。而且往往是他们可以花更少的时间学得更多更透彻。我想究其根本，<font color='red'>在于他们实在太习惯这种程度的学习曲线，身经百战（这是后天锻炼出来的）</font>。被虐到后来，看到很多东西很麻烦很想放弃，想到身边的同学如果看到这些应该会觉得很简单吧，咬咬牙也就学下来了，虽然学得真是非常辛酸。</p>
<h2 id="二、能够更长时间保持清晰的思维，专注地思考"><a href="#二、能够更长时间保持清晰的思维，专注地思考" class="headerlink" title="二、能够更长时间保持清晰的思维，专注地思考"></a><strong>二、能够更长时间保持清晰的思维，专注地思考</strong></h2><p>聪明的人可以更长时间地保持清晰的思维，专注地思考。在一件事情逻辑链很长的时候，我往往要断掉很多次，复习很多次，才能把这条线贯通，但是有的人就可以抽丝剥茧，慢条斯理地一步步把逻辑搞清楚，直接推理出结果。<br>举个例子，一道数学证明题，我知道条件和结论，要写证明过程。然后我开始想从条件出发，可能用到定理A，那么那我还需要证明B，然后C，然后D，然后有点难，先缓缓。接着从结论倒推，我应该用到了定理E，但是还需要证明F，然后……然后就断了。我已经搞不清楚我在证什么了，我头脑已经乱掉了，内存不足，前面的忘记了；主频不够，后面的推不动了。然后一遍遍复习推理的过程，熟悉了之前的步骤，才能继续往下。但是这些问题对于一些人就很轻松，第一次看到题，就可以很轻松地讲给你听。<font color='red'>头脑很清楚，条理分明，逻辑有力，无法反驳</font>。我曾细问过很多次他们中间思考的过程，最后的感触就是聪明的人只需要最基本的一条引理就可以脚踏逻辑凌空而起，而我需要一条实在的梯子。这一点不仅是在面对难题的时候，生活很多细节也可见端倪，类似的例子见《理想国》。</p>
<h2 id="三、善于抓住最本质的东西"><a href="#三、善于抓住最本质的东西" class="headerlink" title="三、善于抓住最本质的东西"></a><strong>三、善于抓住最本质的东西</strong></h2><p>聪明的人善于抓住最本质的东西。物理的运动学对他们而言只是说了一件事情就是：f&#x3D;ma，剩下的只是数学；对流，传导，辐射说到底就是类似“不平则鸣”的一件事情，方程记不得了，按常识推推也就推出来了；流体力学最后就是搓出来的涡；一阶的偏微分方程就是流线等等。不背公式，不背推论，常识加数学，就构成了他们的整个物理学框架。<br>最后的状态就是，他们稳稳站在常识之上，靠着强大的吸收能力和清晰的逻辑，一骑绝尘，直至肉眼不可见。</p>
<br/>
原文地址：http://www.360doc.com/content/16/0302/08/30725314_538721799.shtml

]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>螺纹</title>
    <url>/blog/2018/09/22/%E8%9E%BA%E7%BA%B9/</url>
    <content><![CDATA[<h2 id="一、螺纹概念"><a href="#一、螺纹概念" class="headerlink" title="一、螺纹概念"></a><strong>一、螺纹概念</strong></h2><p>螺纹：见于“螺栓、螺钉、螺柱、螺杆、螺母、水管接口”等器件上面的旋转纹路。</p>
<h2 id="二、螺纹分类"><a href="#二、螺纹分类" class="headerlink" title="二、螺纹分类"></a><strong>二、螺纹分类</strong></h2><p>根据螺纹旋入的方向分为：左旋螺纹和右旋螺纹。</p>
<h3 id="2-1、左旋螺纹"><a href="#2-1、左旋螺纹" class="headerlink" title="2.1、左旋螺纹"></a><strong>2.1、左旋螺纹</strong></h3><p>逆时针旋转时旋入。</p>
<h3 id="2-2、右旋螺纹"><a href="#2-2、右旋螺纹" class="headerlink" title="2.2、右旋螺纹"></a><strong>2.2、右旋螺纹</strong></h3><p>顺时针旋转时旋入。<br>标准规范：一般器件采用“右旋螺纹”，除了一些特殊器件采用“左旋螺纹”。<font color='red'>因此，生活中绝大多数情况下，顺时针旋转螺纹器件可以达到“拧紧，关紧”等效果。</font></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>解耦神器——队列</title>
    <url>/blog/2018/07/11/%E8%A7%A3%E8%80%A6%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是解耦神器。</p>
<h2 id="一、狭义队列"><a href="#一、狭义队列" class="headerlink" title="一、狭义队列"></a><strong>一、狭义队列</strong></h2><p>狭义队列：跟“栈”相对应的数据结构，具有“先进先出”的特点，比如<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>，<code>ConcurrentLinkedQueue</code>等。</p>
<h2 id="二、广义队列"><a href="#二、广义队列" class="headerlink" title="二、广义队列"></a><strong>二、广义队列</strong></h2><p>广义队列：提供存取数据接口的构件，比如<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>，<code>ConcurrentLinkedQueue</code>，<code>Disruptor</code>，<code>Mysql</code>，<code>Redis</code>，<code>Kafka</code>，<code>ActiveMQ</code>，<code>RabbitMQ</code>等。</p>
<h3 id="2-1、进程内队列"><a href="#2-1、进程内队列" class="headerlink" title="2.1、进程内队列"></a><strong>2.1、进程内队列</strong></h3><p><code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>，<code>ConcurrentLinkedQueue</code>，<code>Disruptor</code>等。</p>
<h3 id="2-2、进程间队列"><a href="#2-2、进程间队列" class="headerlink" title="2.2、进程间队列"></a><strong>2.2、进程间队列</strong></h3><p><code>Mysql</code>，<code>Redis</code>，<code>Kafka</code>，<code>ActiveMQ</code>，<code>RabbitMQ</code>等。</p>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>解耦</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计数器异步打印重置之线程安全</title>
    <url>/blog/2020/07/28/%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BC%82%E6%AD%A5%E6%89%93%E5%8D%B0%E9%87%8D%E7%BD%AE%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>本文探讨计数器异步打印重置场景中的线程安全。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterAsyncPrintAndResetExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        stat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">AtomicInteger</span> <span class="variable">oldCounter</span> <span class="operator">=</span> counter;    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">                counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">                System.out.println(oldCounter.get());  <span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程持续调用，模拟“来一个请求调用一次的场景”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object query)</span> &#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中存在线程安全问题：</p>
<ul>
<li>情形1：在&#x2F;&#x2F;3处打印时，由于“狭义可见性”问题，存在“一些工作线程执行时，counter变量指向旧计数器实例”的可能，此时打印的计数器计数值是偏少的</li>
<li>情形2：存在“&#x2F;&#x2F;2和&#x2F;&#x2F;3重排序”可能，此时&#x2F;&#x2F;3处打印时，工作线程仍然在使用旧计数器实例进行计数，此时打印的计数器计数值是偏少的</li>
</ul>
<p>针对以上问题，经过分析可以发现：给counter变量加上<code>volatile</code>修饰符，可以解决“情形1”的线程安全问题，因为“根据volatile变量的读写语义，&#x2F;&#x2F;2执行完之后，所有线程的counter变量指向新的AtomicInteger实例对象，如果此时假定&#x2F;&#x2F;2和&#x2F;&#x2F;3不存在重排序，那么就不存在线程安全问题”；而对于“情形2”的线程安全问题则于事无补。因此，为了彻底解决上述线程安全问题，只能通过加锁来解决，根据“正常计数多，打印重置计数少”的特点，显然适合使用读写锁。<br>改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterAsyncPrintAndResetExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        stat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                rwLock.writeLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">AtomicInteger</span> <span class="variable">oldCounter</span> <span class="operator">=</span> counter;    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">                    counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(oldCounter.get());  <span class="comment">//3</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    rwLock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程持续调用，模拟“来一个请求调用一次的场景”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object query)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counter.incrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/blog/2019/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a><strong>一、绪论</strong></h2><p>特别需要注意的是，计算机组成知识绝大多数是“特例性质”的，而不是“通用性质”的，不过基于“日常，概念入门，抓住主要矛盾，触类旁通”的角度来看，“特例性质”的计算机组成知识已经足够。<br>什么是“特例性质”的知识？只在特定背景下才成立的知识。计算机组成千变万化，它可以具有不同的硬件架构（比如“CPU有冯诺依曼架构和哈佛架构之分”），不同的部件组合，不同的连接设施，不同的指令集等。因此，很多知识只在特定的“计算机组成”背景下才成立，比如“很多处理器相关的知识是在X86处理器下才成立的”，“<code>LOCK前缀指令</code>不是在所有计算机上都存在的”。</p>
<h2 id="二、计算机组成"><a href="#二、计算机组成" class="headerlink" title="二、计算机组成"></a><strong>二、计算机组成</strong></h2><p>计算机由5部分构成：控制器，运算器，存储设备，输入设备和输出设备。<br>而现代CPU包含了“控制器”和“运算器”，因此“控制器”和“运算器”归在一起介绍；另外有些设备既是输入设备，也是输出设备，因此“输入设备”和“输出设备”也归在一起介绍。</p>
<h2 id="三、字长"><a href="#三、字长" class="headerlink" title="三、字长"></a><strong>三、字长</strong></h2><p>对于“字长”，类似于“总线”，只需要知道这个概念的大致含义，深究并不会带来太大价值。</p>
<p>常见的“字长”分类是：机器字长，指令字长，存储字长。</p>
<p>机器字长：CPU内运算器在一个时钟周期内最多能运算的二进制位数。<br>指令字长：一个指令字包含的二进制位数。<br>存储字长：一个存储单元包含的二进制位数。</p>
<h2 id="四、32位和64位"><a href="#四、32位和64位" class="headerlink" title="四、32位和64位"></a><strong>四、32位和64位</strong></h2><p>在计算机范畴中，常听到32位和64位的概念，那么它们是什么含义呢？其实只有明确了32位和64位所修饰的名词，才能确定具体含义。常被修饰的名词有：CPU，操作系统和计算机整体架构。</p>
<h3 id="4-1、CPU"><a href="#4-1、CPU" class="headerlink" title="4.1、CPU"></a><strong>4.1、CPU</strong></h3><p>32位：<code>CPU内通用寄存器位宽</code>，<code>可寻址内存范围</code>，<code>机器字长</code>都为32位。<br>64位：<code>CPU内通用寄存器位宽</code>，<code>可寻址内存范围</code>，<code>机器字长</code>都为64位，可能兼容32位，也可能不兼容32位。</p>
<h3 id="4-2、操作系统"><a href="#4-2、操作系统" class="headerlink" title="4.2、操作系统"></a><strong>4.2、操作系统</strong></h3><p>32位操作系统支持32位CPU；64位操作系统支持64位CPU，可能兼容32位CPU，也可能不兼容32位CPU。</p>
<h3 id="4-3、一个计算机整体的架构是32位还是64位"><a href="#4-3、一个计算机整体的架构是32位还是64位" class="headerlink" title="4.3、一个计算机整体的架构是32位还是64位"></a><strong>4.3、一个计算机整体的架构是32位还是64位</strong></h3><p>一个计算机整体的架构是32位还是64位主要由CPU决定：</p>
<ul>
<li>当是32位CPU时，其他硬件组件（比如内存，总线等）和软件（操作系统，应用程序）都只能支持32位，因此该计算机整体的架构是32位的</li>
<li>当是64位CPU时，当该CPU兼容32位且其他硬件组件（比如内存，总线等）和软件（操作系统，应用程序）都仍只支持32位，该计算机整体的架构是32位的；当其他硬件组件（比如内存，总线等）和软件（操作系统，应用程序）都支持64位，该计算机整体的架构是64位的</li>
</ul>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://baike.baidu.com/item/64%E4%BD%8D%E5%A4%84%E7%90%86%E5%99%A8">https://baike.baidu.com/item/64%E4%BD%8D%E5%A4%84%E7%90%86%E5%99%A8</a><br>[2]<a href="https://baike.baidu.com/item/64%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">https://baike.baidu.com/item/64%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</a><br>[3]<a href="https://www.zhihu.com/question/20536161">https://www.zhihu.com/question/20536161</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>访问无线局域网内主机连接异常问题</title>
    <url>/blog/2017/08/26/%E8%AE%BF%E9%97%AE%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>以下主机（A，B，C）都运行Ubuntu 16.04。</p>
<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>无线局域网内两台主机A和B，A通过SSH连接到B，发现操作卡顿，说明A和B之间的无线局域网连接存在异常。<br>在A上<code>PING</code>B，发现“time”值时高时低，再次证明A和B之间的无线局域网连接存在异常。</p>
<h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a><strong>二、原因分析</strong></h2><p>在同一个无线局域网内存在另外一台主机C，A通过SSH连接到C，操作不卡顿，在A上<code>PING</code>C，“time”值也处于稳定的低值，以上证明A和B之间的无线局域网连接异常现象问题出在主机B。<br>通过查阅资料[1][2]，发现应该是Ubuntu 16.04的无线网卡省电模块的bug所致，查看主机B上“&#x2F;etc&#x2F;NetworkManager&#x2F;conf.d&#x2F;default-wifi-powersave-on.conf”配置文件的“wifi.powersave”属性值，发现果然是会导致问题的值“3”，而在主机C上，该属性值为不会导致问题的值“2”。</p>
<h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a><strong>三、解决方案</strong></h2><p>将主机B上“&#x2F;etc&#x2F;NetworkManager&#x2F;conf.d&#x2F;default-wifi-powersave-on.conf”配置文件的“wifi.powersave”属性值改为“2”。</p>
<br/>
参考文献：
[1]https://askubuntu.com/questions/858265/extremely-high-ping-to-local-router-over-wifi
[2]https://git.launchpad.net/~network-manager/network-manager/+git/ubuntu/commit/?id=9f40397c

]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>跨操作系统解压压缩文件或者解打包打包文件后内部文件名乱码问题</title>
    <url>/blog/2016/06/26/%E8%B7%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%8E%8B%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E8%A7%A3%E6%89%93%E5%8C%85%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E5%90%8E%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a><strong>一、问题描述</strong></h2><p>在Ubuntu（默认使用“UTF-8”编码方案）下制作ZIP压缩文件，“tar.gz”压缩文件或者“tar”打包文件，待加入文件的文件名中包含有中文字符，然后在Windows（默认使用“GBK”编码方案）下解压&#x2F;解打包前述得到的ZIP压缩文件，“tar.gz”压缩文件或者“tar”打包文件，最后发现本应正常显示的包含有中文字符的文件名显示乱码。<br>比如Ubuntu下有一个“a”目录文件，其下有一个名为“你好吗.txt”的文件，目录结构如图1所示。</p>
<p>图1<br><img src="https://blog.dslztx.top/imgs/20160626-1-1.png" alt="这里写图片描述"></p>
<p>执行<code>tar -czvf a.tar.gz a</code>命令，得到一个名为“a.tar.gz”的压缩文件，将其复制到Windows下，使用WinRAR软件进行解压，出现如图2所示的显示结果，即文件名显示乱码。</p>
<p>图2<br><img src="https://blog.dslztx.top/imgs/20160626-1-2.png" alt="这里写图片描述"></p>
<p>执行<code>tar -cvf a.tar a</code>命令，得到一个名为“a.tar”的打包文件，将其复制到Windows下，使用WinRAR软件进行解打包，出现如图3所示的显示结果，即文件名显示乱码。</p>
<p>图3<br><img src="https://blog.dslztx.top/imgs/20160626-1-2.png" alt="这里写图片描述"></p>
<h2 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a><strong>二、原理分析</strong></h2><p>制作压缩文件&#x2F;打包文件时，编码“加入文件文件名”所使用的编码方案并未被记录，因而后续解压&#x2F;解打包时，当解码文件名时所使用的编码方案不一致时，就会产生乱码。</p>
<h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a><strong>三、解决方案</strong></h2><p>RAR压缩文件格式或者7Z压缩文件格式会记录压缩文件时编码“加入文件文件名”所使用的编码方案，因此为了避免跨操作系统解压压缩文件&#x2F;解打包打包文件时可能产生的乱码问题，尽可能使用RAR压缩文件格式或者7Z压缩文件格式。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><p>最新的ZIP文件创建工具在创建ZIP文件时，会记录编码“加入文件文件名”所使用的编码方案。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>输入输出设备</title>
    <url>/blog/2019/06/04/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="一、输入设备"><a href="#一、输入设备" class="headerlink" title="一、输入设备"></a><strong>一、输入设备</strong></h2><ul>
<li>鼠标</li>
<li>键盘</li>
<li>…</li>
</ul>
<h2 id="二、输出设备"><a href="#二、输出设备" class="headerlink" title="二、输出设备"></a><strong>二、输出设备</strong></h2><ul>
<li>显示器</li>
<li>…</li>
</ul>
<h2 id="三、输入和输出设备一体"><a href="#三、输入和输出设备一体" class="headerlink" title="三、输入和输出设备一体"></a><strong>三、输入和输出设备一体</strong></h2><ul>
<li>触摸屏</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>进程用户身份</title>
    <url>/blog/2017/06/12/%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD/</url>
    <content><![CDATA[<p>本文所指“进程”是指在Linux操作系统下运行的进程。需要注意的是，执行“ls，cd，vim”等命令，都会创建运行进程。</p>
<h2 id="一、进程用户身份的概念"><a href="#一、进程用户身份的概念" class="headerlink" title="一、进程用户身份的概念"></a><strong>一、进程用户身份的概念</strong></h2><h3 id="1-1、进程用户身份——用户"><a href="#1-1、进程用户身份——用户" class="headerlink" title="1.1、进程用户身份——用户"></a><strong>1.1、进程用户身份——用户</strong></h3><p>分为“进程创建用户”和“进程有效用户”。</p>
<h4 id="1-1-1、进程创建用户"><a href="#1-1-1、进程创建用户" class="headerlink" title="1.1.1、进程创建用户"></a><strong>1.1.1、进程创建用户</strong></h4><p>指代创建进程的用户。一般来讲，该值在被初始赋值（值为“创建进程的用户”）之后不可被改变。</p>
<h4 id="1-1-2、进程有效用户"><a href="#1-1-2、进程有效用户" class="headerlink" title="1.1.2、进程有效用户"></a><strong>1.1.2、进程有效用户</strong></h4><p>指代代表进程与外界通信的用户。一般来讲，该值在被初始赋值（值为“创建进程的用户”）之后仍可被改变。该值常见的赋值模型有3种。<br><strong>1、保持不变</strong><br>在被初始赋值后保持不变。即“进程有效用户”跟“进程创建用户”一致。<br>比如当前用户为“dsl”，执行<code>top</code>命令，假定得到的进程ID为“13377”，再执行<code>/bin/ps -o euser -p 13377</code>命令，可得如下结果，从而得知进程有效用户一直为“dsl”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EUSER</span><br><span class="line">dsl</span><br></pre></td></tr></table></figure>
<p><strong>2、改变一次</strong><br>在被初始赋值后改变一次。比如有一个可执行文件，它设置了SUID特殊权限，执行该可执行文件创建运行一个进程，该进程有效用户“在被初始赋值后，改变一次被赋值为该可执行文件的拥有者”。<br>比如有以下C源代码文件（文件名为“geteuid.c”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    //geteuid()方法能够得到进程有效用户的UID</span><br><span class="line">    printf(&quot;euser uid is:%d\n&quot;, geteuid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gcc -o geteuid geteuid.c</code>命令，编译得到一个二进制文件“geteuid”，将该二进制文件的拥有者设为“root”，权限配置为“4777”。当前用户为“dsl”，执行<code>./geteuid</code>命令，得到的打印结果如下，“0”UID对应的用户名为“root”，从而得知进程有效用户为“root”（进程有效用户变化路径：“dsl”——“root”）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">euser uid is:0</span><br></pre></td></tr></table></figure>
<p><strong>3、改变一次，恢复到初始值</strong><br>在被初始赋值后改变一次，最后再恢复到初始值。比如有一个可执行文件，它设置了SUID特殊权限，执行该可执行文件创建运行一个进程，该进程有效用户“在被初始赋值后，改变一次被赋值为该可执行文件的拥有者，最后再改变被恢复到初始值”。<br>“&#x2F;bin&#x2F;ping”命令的拥有者为“root”，权限配置信息为“4755”，执行<code>ping www.google.com</code>命令，假定得到的进程ID为“15216”，再执行<code>/bin/ps -o euser -p 15216</code>命令，可得如下结果，从而得知进程有效用户为“dsl”（进程有效用户变化路径：“dsl”——“root”——“dsl”）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EUSER</span><br><span class="line">dsl</span><br></pre></td></tr></table></figure>
<p>上述内容参考以下引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping needs root so it can open a socket in raw mode. That&#x27;s literally the first thing it does when it starts up:</span><br><span class="line">icmp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line">socket_errno = errno;</span><br><span class="line">That&#x27;s the only thing it needs root for, so like many programs, it immediately drops its privilege level back to your normal user account.</span><br></pre></td></tr></table></figure>
<h3 id="1-2、进程用户身份——用户组"><a href="#1-2、进程用户身份——用户组" class="headerlink" title="1.2、进程用户身份——用户组"></a><strong>1.2、进程用户身份——用户组</strong></h3><p>分为“进程创建用户组”和“进程有效用户组”。</p>
<h4 id="1-2-1、进程创建用户组"><a href="#1-2-1、进程创建用户组" class="headerlink" title="1.2.1、进程创建用户组"></a><strong>1.2.1、进程创建用户组</strong></h4><p><font color='red'>指代创建进程用户的对应用户组。</font>一般来讲，该值在被初始赋值（值为“创建进程的用户对应的用户组”）之后不可被改变。</p>
<h4 id="1-2-2、进程有效用户组"><a href="#1-2-2、进程有效用户组" class="headerlink" title="1.2.2、进程有效用户组"></a><strong>1.2.2、进程有效用户组</strong></h4><p>指代代表进程与外界通信的用户组。一般来讲，该值在被初始赋值（值为“创建进程的用户对应的用户组”）之后仍可被改变。该值常见的赋值模型有3种。<br><strong>1、保持不变</strong><br>在被初始赋值后保持不变。即“进程有效用户组”跟“进程创建用户组”一致。<br><strong>2、改变一次</strong><br>在被初始赋值后改变一次。比如有一个可执行文件，它设置了SGID特殊权限，执行该可执行文件创建运行一个进程，该进程有效用户组“在被初始赋值后，改变一次被赋值为该可执行文件的组拥有者”。<br>比如有以下C源代码文件（文件名为“getegid.c”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    //getegid()方法能够得到进程有效用户组的GID</span><br><span class="line">    printf(&quot;egroup gid is:%d\n&quot;, getegid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gcc -o getegid getegid.c</code>命令，编译得到一个二进制文件“getegid”，将该二进制文件的组拥有者设为“root”，权限配置为“2777”。当前用户为“dsl”（对应的用户组为“dsl”），执行<code>./getegid</code>命令，得到的打印结果如下，“0”GID对应的用户组为“root”，从而得知进程有效用户组为“root”（进程有效用户组变化路径：“dsl”——“root”）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egroup gid is:0</span><br></pre></td></tr></table></figure>
<p><strong>3、改变一次，恢复到初始值</strong><br>在被初始赋值后改变一次，最后再恢复到初始值。比如有一个可执行文件，它设置了SGID特殊权限，执行该可执行文件创建运行一个进程，该进程有效用户组“在被初始赋值后，改变一次被赋值为该可执行文件的组拥有者，最后再改变被恢复到初始值”。</p>
<h2 id="二、进程用户身份的意义"><a href="#二、进程用户身份的意义" class="headerlink" title="二、进程用户身份的意义"></a><strong>二、进程用户身份的意义</strong></h2><p>在Linux操作系统中，进程用户身份非常重要，尤其是在进程通信中用于代表本进程的“&lt;进程有效用户，进程有效用户组&gt;”，比如在判定一个进程是否拥有对文件的“读取，修改，执行”权限时，使用的进程用户身份就是“&lt;进程有效用户，进程有效用户组&gt;”。</p>
<br/>
参考文献：
[1]http://www.lst.de/~okir/blackhats/node23.html
[2]http://www.makelinux.net/alp/083
[3]http://en.wikipedia.org/wiki/User_identifier
[4]http://stackoverflow.com/questions/8499296/realuid-saved-uid-effective-uid-whats-going-on
[5]http://stackoverflow.com/questions/205070/whats-the-deal-with-all-the-different-uids-a-process-can-have
[6]http://unix.stackexchange.com/questions/51874/root-owned-program-with-setuid-bit-on
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>连接与分断</title>
    <url>/blog/2023/10/15/%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%86%E6%96%AD/</url>
    <content><![CDATA[<h2 id="一、连接"><a href="#一、连接" class="headerlink" title="一、连接"></a><strong>一、连接</strong></h2><p>狭义的连接：即“直接连接”。<br>广义的连接：包括“直接连接”和“间接连接”。</p>
<h3 id="1-1、直接连接"><a href="#1-1、直接连接" class="headerlink" title="1.1、直接连接"></a><strong>1.1、直接连接</strong></h3><p>把自己的棋子连在一起，又叫“连”或“粘”。</p>
<h3 id="1-2、间接连接"><a href="#1-2、间接连接" class="headerlink" title="1.2、间接连接"></a><strong>1.2、间接连接</strong></h3><p>间接连接是：当下未直接连接，但是最终必然可以进展到直接连接的棋形。</p>
<p>间接连接包括：</p>
<ul>
<li>虎口连接</li>
<li>小尖连接</li>
<li>双连接</li>
<li>提子连接</li>
</ul>
<h2 id="二、分断"><a href="#二、分断" class="headerlink" title="二、分断"></a><strong>二、分断</strong></h2><p>围棋中，把对方棋形分割成两块的棋，称为“分断”，又叫“切断”，简称“断”。分断的点被称为“断点”。</p>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
  </entry>
  <entry>
    <title>配置基于SSH的本地Git Server</title>
    <url>/blog/2022/02/10/%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8ESSH%E7%9A%84%E6%9C%AC%E5%9C%B0Git-Server/</url>
    <content><![CDATA[<h2 id="一、配置SSH登录本机"><a href="#一、配置SSH登录本机" class="headerlink" title="一、配置SSH登录本机"></a><strong>一、配置SSH登录本机</strong></h2><p><strong>1、服务端</strong></p>
<ol>
<li>执行<code>sudo apt-get install openssh-server</code>命令安装openssh-server，然后就会默认自动开启sshd服务，监听端口为22</li>
<li>执行如下命令，将公钥写入<code>authorized_keys</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /home/dslztx/.ssh/keys/id_rsa.pub /home/dslztx/.ssh/authorized_keys</span><br><span class="line">chmod 0600 /home/dslztx/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p><strong>2、客户端</strong><br>在<code>/home/dslztx/.ssh/config</code>文件中增加以下配置，然后就可以通过<code>ssh localhost</code>命令以dslztx用户登录本机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host localhost</span><br><span class="line">    HostName 127.0.0.1</span><br><span class="line">    User dslztx</span><br><span class="line">    IdentityFile ~/.ssh/keys/id_rsa</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure>

<h2 id="二、配置Git-Server"><a href="#二、配置Git-Server" class="headerlink" title="二、配置Git Server"></a><strong>二、配置Git Server</strong></h2><p>执行<code>git init --bare sample.git</code>命令创建一个空仓库（这里是“sample.git”），仓库一般以<code>.git</code>为后缀名。</p>
<p>假如在目录“&#x2F;home&#x2F;dslztx”下执行以上命令，则该仓库的服务器地址（本机访问）为<code>dslztx@localhost:/home/dslztx/sample.git</code>。</p>
<h2 id="三、配置Git-Client"><a href="#三、配置Git-Client" class="headerlink" title="三、配置Git Client"></a><strong>三、配置Git Client</strong></h2><p>在本机上，可通过<code>git clone dslztx@localhost:/home/dslztx/sample.git</code>克隆上述仓库。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664</a><br>[2]<a href="https://jingyan.baidu.com/article/e8cdb32b8acb5f77042bad47.html">https://jingyan.baidu.com/article/e8cdb32b8acb5f77042bad47.html</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>金融风险和防范</title>
    <url>/blog/2016/04/03/%E9%87%91%E8%9E%8D%E9%A3%8E%E9%99%A9%E5%92%8C%E9%98%B2%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、金融风险"><a href="#一、金融风险" class="headerlink" title="一、金融风险"></a><strong>一、金融风险</strong></h2><h3 id="1-1、银行卡被复制"><a href="#1-1、银行卡被复制" class="headerlink" title="1.1、银行卡被复制"></a><strong>1.1、银行卡被复制</strong></h3><p>在一些特制的POS机上刷卡，使得你的银行卡能够被完全复制。一旦不法分子再通过某种途径获取得到你的银行卡密码，就能够通过ATM等途径转移你银行卡内的钱。</p>
<h3 id="1-2、手机号作为支付宝帐号的手机被他人获取"><a href="#1-2、手机号作为支付宝帐号的手机被他人获取" class="headerlink" title="1.2、手机号作为支付宝帐号的手机被他人获取"></a><strong>1.2、手机号作为支付宝帐号的手机被他人获取</strong></h3><p>手机号作为支付宝帐号的手机被他人获取，而且未设置手机开机密码，那么获取该手机的人就能够取得对该手机的完全控制权，使得可以通过短信修改支付宝登录和支付密码。</p>
<p>此时，不法分子有两种途径可以盗取你的钱财：</p>
<ol>
<li>使用花呗，借呗等服务，进行信用支付，最后这笔钱还是得由你来负责归还</li>
<li>获取得到你的银行卡信息，获取途径包括：1）原先支付宝绑定的银行卡；2）如果银行卡一同丢失，直接可以获得银行卡信息；3）如果身份证一同丢失，那么可以去银行查询你名下的银行卡信息；4）通过社会工程获知你的银行卡信息。然后根据获取得到的银行卡信息，使用支付宝快捷支付，转移钱财</li>
</ol>
<h3 id="1-3、丢失身份证"><a href="#1-3、丢失身份证" class="headerlink" title="1.3、丢失身份证"></a><strong>1.3、丢失身份证</strong></h3><p>不法分子可以使用你的丢失身份证创建你名下的另外一个支付宝账户，通过这个支付宝账户可以使用花呗，借呗等服务进行信用支付。</p>
<h2 id="二、如何防范"><a href="#二、如何防范" class="headerlink" title="二、如何防范"></a><strong>二、如何防范</strong></h2><h3 id="2-1、及时挂失"><a href="#2-1、及时挂失" class="headerlink" title="2.1、及时挂失"></a><strong>2.1、及时挂失</strong></h3><p>手机丢失，立即向通信运营商挂失SIM卡，立即向支付宝客服（95188）申请锁住相关联的支付宝帐号。</p>
<h3 id="2-2、关闭花呗，借呗等信用支付服务"><a href="#2-2、关闭花呗，借呗等信用支付服务" class="headerlink" title="2.2、关闭花呗，借呗等信用支付服务"></a><strong>2.2、关闭花呗，借呗等信用支付服务</strong></h3><p>可以向支付宝申请永久关闭借呗服务，花呗服务现在还不可被永久关闭。</p>
<h3 id="2-3、申请一张专门用来“储蓄”的银行卡"><a href="#2-3、申请一张专门用来“储蓄”的银行卡" class="headerlink" title="2.3、申请一张专门用来“储蓄”的银行卡"></a><strong>2.3、申请一张专门用来“储蓄”的银行卡</strong></h3><p>申请一张专门用来“储蓄”的银行卡，该张银行卡的使用特点如下：<br>1）不刷任何POS机<br>2）支付宝不绑定该张银行卡<br>3）不随身携带该张银行卡，以防一同丢失<br>4）资金流入：使用ATM机，从另外一张银行卡转账到该张银行卡；资金流出：使用ATM机，从该张银行卡转账到另外一张银行卡，然后把主要的财富存放到该张“储蓄”银行卡上，该张银行卡内的钱相对来说比较安全，那么此时即便其他银行卡账户和支付宝花呗借呗账户的钱都被盗取，损失也不会很大！</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>键盘流思考</title>
    <url>/blog/2018/05/30/%E9%94%AE%E7%9B%98%E6%B5%81%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>为什么要“键盘流”，原因如下：</p>
<ul>
<li>显得极客范</li>
<li>相对“鼠标流”，“键盘流”更加高效</li>
<li>“键盘流”操作有的放矢，不似“鼠标流”操作很多时候漫无章法。故而，“键盘流”会在潜移默化中强化自己“有的放矢”的思维习惯</li>
<li>“键盘流”相对于“鼠标流”，更让思路具有连惯性</li>
</ul>
<p>另外，“键盘流”不是意味完全放弃“鼠标流”，针对有些情形，只有“鼠标流”才能完成任务或者“鼠标流”完成任务更加高效；不同应用程序具有自己的快捷键体系，想要所有快捷键体系都类Vim风格是不现实的。</p>
<p><font color='red'>综上，“键盘流”的准确内涵是：“键盘流”为主，“鼠标流”为辅，“键盘流”风格多样。</font></p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>键盘流</category>
      </categories>
  </entry>
  <entry>
    <title>阿里巴巴Java开发手册</title>
    <url>/blog/2018/10/01/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>01、<del>编程规约</del><br>02、<del>异常日志</del><br>03、<del>单元测试</del><br>04、<del>安全规约</del><br>05、<del>MySQL数据库</del><br>06、<del>工程结构</del><br>07、<del>设计规约</del></p>
<p>附1、<del>版本历史</del><br>附2、<del>专有名词解释</del></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>风</title>
    <url>/blog/2010/07/15/%E9%A3%8E/</url>
    <content><![CDATA[<p>风，轻盈的仙女，爱抚受伤的大地！<br><br/></p>
<hr>
<p>春，见到了你，羞红了粉黛的脸蛋，娇羞欲滴，招徕无际的青春和活力！</p>
<hr>
<p>夏，碰见了你，顿时神清气爽，恣意享受湖静莲曳的淡宁！一片寂静中，生命的乐章开始酝酿！废墟中跳出了沉稳的深绿，走来了活泼的浅绿！</p>
<hr>
<p>秋，撞见了你，岁月的渣渍，时间侵蚀的痕迹，生命没落的证据，一切的一切，尽被你柔弱的坚强所驱，只剩下一快洁净的画布，等待着勾勒出新的生命传奇！</p>
<hr>
<p>冬，是那传说中的恶魔，他绑架了你！<br>裹胁着善良的你去摧毁你所倾注心血的事业！残忍地迫使你用那双纤细的手去伤害那可怜无助的生灵！<br>他们是你曾经的朋友，他们在瑟瑟发抖，他们诅咒着无情的你，但却没人发现你的泪水，没有人意识到你的内心正飘荡在一片汪洋之中，独自忍受着孤独和委屈的煎熬！<br>当你发现你双手尽是殷红的血渍！你开始感到罪恶正在把你侵蚀！<br>你想反抗，你想逃离地狱！<br>但，善良也许是另一种形式的懦弱！你摆脱不了万恶的魔鬼！命运的无情好像注定你要屈服于冬的淫威！</p>
<p>但，他最终踉跄地逃了！躲进了他的巢穴，因为他感受到了即将到来的光明！<br>黑暗战胜光明恒是一个不能被证明的定理！而相反，却是一个无须证明的公理！</p>
<p>但是世上没有了欢声笑语，有的只是一片可怕的死寂与无尽的荒凉！</p>
<p>生命蜕变成了一种虚幻的奢求！而终于你自由了！你被呼唤回到你那久违的天府乐园，轮回的使命你已完成！<br>而你却决定留下来！不敢相信那样一个娇弱能让目视者顿生怜爱的身躯却燃烧着这样一颗毅然决然的火热的心！</p>
<p>你走上了寻找春天的路！<br>期待着用你的美丽和善良帮助人世找回早已生殊的安宁与活力！</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>诗</category>
      </categories>
  </entry>
  <entry>
    <title>高速缓存一致性</title>
    <url>/blog/2019/06/09/%E9%AB%98%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、高速缓存一致性"><a href="#一、高速缓存一致性" class="headerlink" title="一、高速缓存一致性"></a><strong>一、高速缓存一致性</strong></h2><p>在多CPU&#x2F;CPU核环境中，存在不同CPU&#x2F;CPU核内高速缓存数据不一致问题，为解决该问题，引入高速缓存一致性协议，MESI协议是众多高速缓存一致性协议中应用较为广泛的一种，<font color='red'>接下来就基于MESI协议进行叙述</font>，需要注意的是，MESI协议的不同具体实现可能是存在差异的。</p>
<p>在MESI协议中，同一主存数据块在不同CPU&#x2F;CPU核内高速缓存上对应的Cache Line的状态修改是互相联动的，这免不了引入同步等待阻塞过程，降低了性能，比如“同一主存数据块在CPU&#x2F;CPU核aC，bC，cC内高速缓存上对应的Cache Line分别为aA，bA，cA，状态都为<code>S</code>”场景：</p>
<ul>
<li>aC修改aA，发送RW操作信号（失效信号）到内存总线，bC和cC收到该RW操作信号，将bA和cA的状态置为<code>I</code>，并发送ACK信号到内存总线，aC在收到bC和cC的两个ACK信号后，才继续将aA的状态置为<code>M</code>，否则同步等待阻塞</li>
</ul>
<p>针对上述问题，引入“写缓冲器”和“失效队列”，化同步为异步，优化性能。针对上述场景，现在的过程如下：</p>
<ul>
<li>aC修改aA，并不直接修改aA，而是将修改存入“写缓冲器”，发送RW操作信号（失效信号）到内存总线，此时aC完成该修改操作，继续做其他事情。bC和cC收到该RW操作信号，并不直接将bA和cA的状态置为<code>I</code>，而是将该失效信号存入“失效队列”，并在存入“失效队列”成功后发送ACK信号到内存总线（异步地从“失效队列”取出失效信号，将对应的Cache Line状态置为<code>I</code>），aC在收到bC和cC的两个ACK信号后，才取出“写缓冲器”的修改写入aA，并将aA的状态置为<code>M</code></li>
</ul>
<br/>

<p>上述<code>高速缓存-写缓冲器-失效队列</code>+<code>MESI协议</code>机制，仍然会导致“狭义可见性”问题：</p>
<ul>
<li>在原始纯粹的多CPU&#x2F;CPU核（内部包含“高速缓存”）机制中，存在“狭义可见性”问题</li>
<li>在引入MESI协议后，由于不能实时保持同步，故不能避免“狭义可见性”问题</li>
<li>在引入“写缓冲器”和“失效队列”机制后，他们会额外造成“狭义可见性”问题。比如“bC收到RW操作信号，将该失效信号存入“失效队列”，紧接着读取该Cache Line，该Cache Line的状态仍为<code>S</code>，故而不会重新加载，最终读取到旧值”，“cC收到RW操作信号，将该失效信号存入“失效队列”，然后取出该失效信号并生效，即将Cache Line的状态置为<code>I</code>，紧接着读取该Cache Line，由于该Cache Line的状态为<code>I</code>，重新加载，但是此时aC对aA的修改仍然存放在“写缓冲器”，状态也为<code>S</code>，故最终读取到旧值”</li>
</ul>
<h2 id="二、扩展"><a href="#二、扩展" class="headerlink" title="二、扩展"></a><strong>二、扩展</strong></h2><h3 id="2-1、与“可见性”的关系"><a href="#2-1、与“可见性”的关系" class="headerlink" title="2.1、与“可见性”的关系"></a><strong>2.1、与“可见性”的关系</strong></h3><p>如上所述，上述<code>高速缓存-写缓冲器-失效队列</code>+<code>MESI协议</code>机制，“狭义可见性”问题不可避免，只能通过添加合适的内存屏障加以解决。</p>
<h3 id="2-2、与“原子性”的关系"><a href="#2-2、与“原子性”的关系" class="headerlink" title="2.2、与“原子性”的关系"></a><strong>2.2、与“原子性”的关系</strong></h3><p><font color='red'>MESI协议，只能用来保证多CPU&#x2F;CPU核内的高速缓存一致性，并不能帮助使得汇编指令是原子的</font>。比如“现有CPU核A和B，执行相同的‘自增1’汇编指令C，可分别以AC和BC代指，C所涉及的变量V在Cache Line D上，可分别以AD&#x2F;AV和BD&#x2F;BV代指，假定AV和BV的初始值为0，并发执行AC和BC，由于AD和BD并未被缓存锁定（也没有内存总线锁的锁定，在X86指令架构中，<code>LOCK指令前缀</code>会发出<code>#LOCK</code>信号，即“内存总线锁信号”），因此AC和BC获取得到的AV和BV的值可能都为0，此时AC和BC的执行结果都为1，最终变量V在内存中的值为1，这与AC和BC原子化执行的效果不等价，在整个过程中，MESI协议正常工作但是并没有帮助使得AC和BC的执行是原子的，否则AC和BC的执行结果应该是1&#x2F;2或者2&#x2F;1”。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]<a href="https://blog.csdn.net/qq_30055391/article/details/84892936">https://blog.csdn.net/qq_30055391/article/details/84892936</a><br>[2]<a href="https://stackoverflow.com/questions/29880015/lock-prefix-vs-mesi-protocol">https://stackoverflow.com/questions/29880015/lock-prefix-vs-mesi-protocol</a><br>[3]<a href="https://zhuanlan.zhihu.com/p/146374416">https://zhuanlan.zhihu.com/p/146374416</a><br>[4]<a href="https://juejin.im/post/6844903927654121486">https://juejin.im/post/6844903927654121486</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>高速缓存</title>
    <url>/blog/2019/06/07/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>高速缓存，英文名为“CPU Cache”，下面可简称缓存&#x2F;Cache。</p>
<h2 id="一、为什么要使用高速缓存"><a href="#一、为什么要使用高速缓存" class="headerlink" title="一、为什么要使用高速缓存"></a><strong>一、为什么要使用高速缓存</strong></h2><p>使用高速缓存基于的理由有两点：</p>
<ul>
<li>局部性原理，包括“时间局部性”和“空间局部性”。空间局部性：假如当前正在访问地址A，那么接下来访问A的邻近地址的可能性非常大；时间局部性：在一段时间内，被访问过的地址可能会被多次访问</li>
<li>一方面，高速缓存的存取速度大于主存的存取速度，利用高速缓存，可以提升CPU存取数据的效率；另外一方面，高速缓存的成本大于主存，用高速缓存完全替代主存是不经济的。因此，基于“时间局部性”原理，可使用高速缓存缓存正在存取的主存数据，一旦后续命中缓存，CPU可直接存取高速缓存，获得存取速度的提升；又基于“空间局部性”原理，使用高速缓存缓存主存数据时，不要只缓存1个字节，而是要缓存一定数量的字节，这就是Cache Line机制产生的原因</li>
</ul>
<h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a><strong>二、分类</strong></h2><p>一般分为：L1高速缓存，L2高速缓存，L3高速缓存。<br>一般情况下，L1高速缓存和L2高速缓存属于“CPU核”私有，L3高速缓存属于“多CPU核”共享。</p>
<h2 id="三、缓存行"><a href="#三、缓存行" class="headerlink" title="三、缓存行"></a><strong>三、缓存行</strong></h2><p>Cache Line：缓存行，如上所述，使用高速缓存缓存主存数据时需要缓存一定数量的字节，这就是一个Cache Line。一般情况下，一个Cache Line有32或者64个字节。<br>使用高速缓存缓存主存的数据，既然高速缓存以Cache Line为基本单元，那么主存中就得有相应的基本单元——数据块。一个数据块与一个Cache Line对应，它们的字节数相等，加载一个数据块的数据到一个Cache Line。</p>
<h2 id="四、高速缓存Cache-Line与主存数据块的映射"><a href="#四、高速缓存Cache-Line与主存数据块的映射" class="headerlink" title="四、高速缓存Cache Line与主存数据块的映射"></a><strong>四、高速缓存Cache Line与主存数据块的映射</strong></h2><p>假设高速缓存共有<code>s+e</code>位地址：其中<code>s</code>表示共有<code>2^s=S</code>个组；<code>e</code>表示每组共有<code>2^e=E</code>个Cache Line。<br>每个Cache Line有<code>1+t</code>个数据位和<code>2^b=B</code>个字节：<code>1</code>个标记位，表示是否有效，“有效”则Cache Line命中，“无效”则Cache Line未命中，等价于“未加载”；<code>t</code>个标记位，其含义在后面介绍；然后一个Cache Line共有<code>2^b=B</code>个字节。<br>主存共有<code>m</code>位地址，以数据块作为基本单元，一个数据块跟一个Cache Line对应故同样有<code>2^b=B</code>个字节，那么就有<code>2^(m-b)</code>个数据块。</p>
<p>高速缓存Cache Line与主存数据块的映射方法描述如下：首先通过取模运算，将主存中的一个数据块映射到高速缓存中的某一个特定组，然后该数据块被允许可映射到该组内的任一个Cache Line。<br>取模运算具体为<code>2^(m-b) mod 2^s</code>，经过分析可知，要想建立Cache Line与数据块的一一映射关系，还需要保存主存地址的<code>m-b-s</code>位信息，上述提到的标记位<code>t</code>就是用来保存这个信息的，因此，<font color='red'>t&#x3D;m-b-s</font>。<br>示意图如图1。</p>
<p>图1</p>
<p><img src="https://blog.dslztx.top/imgs/20190607-0-0.png"></p>
<h3 id="4-1、组相联映射"><a href="#4-1、组相联映射" class="headerlink" title="4.1、组相联映射"></a><strong>4.1、组相联映射</strong></h3><p><code>s</code>和<code>e</code>都不为0。是“直接映射”和“全相联映射”的折衷方案。</p>
<h3 id="4-2、直接映射"><a href="#4-2、直接映射" class="headerlink" title="4.2、直接映射"></a><strong>4.2、直接映射</strong></h3><p><code>s</code>不为0，<code>e</code>为0，即每组只有一个Cache Line。<br><strong>优点</strong>：最简单的映射方式，实现硬件简单，成本低，地址映射变换速度快（因为在找到组后，不需要再比较Cache Line），而且由于每组只有一个Cache Line，无需替换算法而是直接替换。<br><strong>缺点</strong>：Cache Line冲突率高，也即高速缓存利用率低，高速缓存命中率低。</p>
<h3 id="4-3、全相联映射"><a href="#4-3、全相联映射" class="headerlink" title="4.3、全相联映射"></a><strong>4.3、全相联映射</strong></h3><p><code>s</code>为0，即只有1个组，<code>e</code>不为0。<br><strong>优点</strong>：高速缓存利用率高，高速缓存命中率高。<br><strong>缺点</strong>：当判断一个主存地址是否被命中时，需要遍历每一个Cache Line，代价非常高。</p>
<h2 id="五、具体运转机制"><a href="#五、具体运转机制" class="headerlink" title="五、具体运转机制"></a><strong>五、具体运转机制</strong></h2><h3 id="5-1、读策略"><a href="#5-1、读策略" class="headerlink" title="5.1、读策略"></a><strong>5.1、读策略</strong></h3><p>当CPU需要从主存中读取数据时，如果在高速缓存中存在相应数据块数据（即缓存命中），那么直接从高速缓存中读取数据；如果不存在（即缓存不命中），那么先将主存中的相应数据块载入高速缓存，然后再从高速缓存中读取数据。</p>
<h3 id="5-2、写策略-2"><a href="#5-2、写策略-2" class="headerlink" title="5.2、写策略[2]"></a><strong>5.2、写策略<sup>[2]</sup></strong></h3><p>主要有两种：Write Back（写回）和Write Through（写通）。<br>总的示意图如图2。</p>
<p>图2</p>
<p><img src="https://blog.dslztx.top/imgs/20190607-0-1.png"></p>
<h4 id="5-2-1、Write-Back"><a href="#5-2-1、Write-Back" class="headerlink" title="5.2.1、Write Back"></a><strong>5.2.1、Write Back</strong></h4><p>分为两种情形：Cache写命中和Cache写未命中。示意图如图2中b。<br><strong>1、Cache写命中</strong><br>当CPU对Cache写命中时，只修改Cache Line的内容而不立即写入主存，只当该Cache Line被替换出去时才写回主存。<br>这种策略使得Cache在CPU与主存之间，不仅起到了读缓存作用，也起到了写缓存作用，在读和写的过程中都减少了对主存的访问次数。<br>不过为支持这种机制，Cache Line必须再额外配置一个修改标记位，以表征该Cache Line是否被修改过。当某个Cache Line需要被替换出去的时候，根据修改标记位决定是否需要写回主存。</p>
<p><strong>2、Cache写未命中</strong><br>当CPU对Cache写未命中时，首先将相应的主存数据块加载到Cache Line（基于“后续对该Cache Line进行存取的可能性很大”的假设），然后跟“Cache写命中”一样，只修改Cache Line的内容而不立即写入主存，只当该Cache Line被替换出去时才写回主存。<br>为什么不在加载主存数据块到Cache Line的过程中顺便将修改写回主存的原因是：加载主存数据块到Cache Line的过程中很有可能需要替换出去一个Cache Line，而该Cache Line又很有可能需要写回主存，这需要竞争总线，为降低该操作的时延而“在加载主存数据块到Cache Line的过程中不顺便将修改写回主存避免竞争总线”。</p>
<h4 id="5-2-2、Write-Through"><a href="#5-2-2、Write-Through" class="headerlink" title="5.2.2、Write Through"></a><strong>5.2.2、Write Through</strong></h4><p>分为两种情形：Cache写命中和Cache写未命中。示意图如图2中a（当Cache写未命中时，采取WTNWA策略）。<br><strong>1、Cache写命中</strong><br>当CPU对Cache写命中时，同时写主存和Cache，因此主存和Cache总是保持同步，这种机制实现简单。但是由于每次写都要写主存，导致总线工作繁忙，降低主存的存取速度。<br>比如，在一个一段程序频繁修改一个局部变量的场景中，局部变量并不会被共享，因此，每次修改都直接写主存是白白占用了总线时间。</p>
<p><strong>2、Cache写未命中</strong><br>当CPU对Cache写未命中时，直接向主存写入，对于此时是否将修改过的主存数据块加载到Cache Line，存在两种选择：1）加载，称为“Write–Through–with–Write–Allocate”，简称为“WTWA”；2）不加载，称为“Write-Through–with-NO-Write–Allocate”，简称为“WTNWA”。<br>方案一操作复杂，但是缓存命中率高；方案二操作简单，但是缓存命中率低。</p>
<h3 id="5-3、替换策略"><a href="#5-3、替换策略" class="headerlink" title="5.3、替换策略"></a><strong>5.3、替换策略</strong></h3><p>当加载一个主存数据块到Cache时，根据映射策略选择一个标的Cache Line：当映射策略为“直接映射”时，标的Cache Line只有一个，无需任何替换算法；除此之外，标的Cache组内所有Cache Line都可成为标的Cache Line，如果存在空Cache Line，那么无需替换，直接加载到该空Cache Line，否则，需要替换算法进行替换。</p>
<p>理想的替换算法应该是：替换时保留最近将要使用的Cache Line，这样才能获得很高的缓存命中率。</p>
<p>目前，使用较多的替换算法有：随机（RANDOM）替换、先入先出（FIFO）替换和近期最少使用（LRU）替换。</p>
<p><strong>备注：</strong></p>
<ul>
<li>所有替换算法都由硬件电路实现，这样才能获得最佳性能</li>
</ul>
<h4 id="5-3-1、随机（RANDOM）替换算法"><a href="#5-3-1、随机（RANDOM）替换算法" class="headerlink" title="5.3.1、随机（RANDOM）替换算法"></a><strong>5.3.1、随机（RANDOM）替换算法</strong></h4><p>随机选择缓存组内的Cache Line进行替换。优点：实现简单，系统开销小；缺点：不是理想替换算法。</p>
<h4 id="5-3-2、先入先出（FIFO）替换算法"><a href="#5-3-2、先入先出（FIFO）替换算法" class="headerlink" title="5.3.2、先入先出（FIFO）替换算法"></a><strong>5.3.2、先入先出（FIFO）替换算法</strong></h4><p>根据先入先出策略选择缓存组内的Cache Line进行替换，需要额外保存先入先出信息。优点：实现简单，系统开销小；缺点：不是理想替换算法。</p>
<h4 id="5-3-3、近期最少使用（LRU）替换算法"><a href="#5-3-3、近期最少使用（LRU）替换算法" class="headerlink" title="5.3.3、近期最少使用（LRU）替换算法"></a><strong>5.3.3、近期最少使用（LRU）替换算法</strong></h4><p>根据近期最少使用策略选择缓存组内的Cache Line进行替换，需要额外随时记录Cache Line的使用情况，以便确定哪个Cache Line是近期最少使用的。优点：最接近于理想替换算法；缺点：实现复杂，系统开销大。</p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]CSAPP：《Computer Systems: A Programmer’s Perspective》<br>[2]<a href="http://www.ssdfans.com/blog/2018/07/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAcache%E5%86%99%E7%AD%96%E7%95%A5/">http://www.ssdfans.com/blog/2018/07/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAcache%E5%86%99%E7%AD%96%E7%95%A5/</a><br>[3]<a href="https://blog.csdn.net/hs794502825/article/details/37937949">https://blog.csdn.net/hs794502825/article/details/37937949</a><br>[4]<a href="https://blog.csdn.net/dongyanxia1000/article/details/53392315">https://blog.csdn.net/dongyanxia1000/article/details/53392315</a><br>[5]<a href="https://blog.csdn.net/dark5669/article/details/53895744">https://blog.csdn.net/dark5669/article/details/53895744</a><br>[6]<a href="https://blog.csdn.net/Move_now/article/details/68488996">https://blog.csdn.net/Move_now/article/details/68488996</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>鸟哥的Linux私房菜-基础学习篇</title>
    <url>/blog/2017/09/02/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    <content><![CDATA[<h2 id="第一部分-Linux的规则与安装"><a href="#第一部分-Linux的规则与安装" class="headerlink" title="第一部分 Linux的规则与安装"></a><strong>第一部分 Linux的规则与安装</strong></h2><p>0、计算机概论<br>1、Linux是什么<br>2、Linux如何学习<br>3、主机规划与磁盘分区<br>4、安装CentOS 5.x与多重引导小技巧<br>5、首次登录与在线求助man page</p>
<h2 id="第二部分-Linux文件、目录与磁盘格式"><a href="#第二部分-Linux文件、目录与磁盘格式" class="headerlink" title="第二部分 Linux文件、目录与磁盘格式"></a><strong>第二部分 Linux文件、目录与磁盘格式</strong></h2><p>6、Linux的文件权限与目录配置<br>7、Linux文件与目录管理<br>8、Linux磁盘与文件系统管理<br>9、文件与文件系统的压缩与打包</p>
<h2 id="第三部分-学习shell与shell-script"><a href="#第三部分-学习shell与shell-script" class="headerlink" title="第三部分 学习shell与shell script"></a><strong>第三部分 学习shell与shell script</strong></h2><p>10、vim程序编辑器<br>11、认识与学习bash<br>12、正则表达式与文件格式化处理<br>13、学习shell script</p>
<h2 id="第四部分-Linux使用者管理"><a href="#第四部分-Linux使用者管理" class="headerlink" title="第四部分 Linux使用者管理"></a><strong>第四部分 Linux使用者管理</strong></h2><p>14、Linux帐号管理与ACL权限设置<br>15、磁盘配额（Quota）与高级文件系统管理<br>16、例行性工作（crontab）<br>17、程序管理与SELinux初探<br>18、认识系统服务（daemons）<br>19、认识与分析日志文件</p>
<h2 id="第五部分-Linux系统管理员"><a href="#第五部分-Linux系统管理员" class="headerlink" title="第五部分 Linux系统管理员"></a><strong>第五部分 Linux系统管理员</strong></h2><p>20、启动流程、模块管理与Loader<br>21、系统设置工具（网络与打印机）与硬件检测<br>22、软件安装：源码与Tarball<br>23、软件安装：RPM、SRPM与YUM功能<br>24、X Window设置介绍<br>25、Linux备份策略<br>26、Linux内核编译与管理</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
</search>
